// -*- C++ -*-
//
// ${ModelName}${classname}.cc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.

#include "${ModelName}.h"
#include "ThePEG/Helicity/Vertex/${spindirectory}/${lorentztag}Vertex.h"
#include "ThePEG/StandardModel/StandardModelBase.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"

namespace {
  const Complex ii = Complex(0,1);
}

namespace Herwig 
{
  using namespace ThePEG;
  using namespace ThePEG::Helicity;
  using ThePEG::Constants::pi;

  class ${ModelName}${classname}: public ${lorentztag}Vertex {
  public:
    ${ModelName}${classname}();
    virtual void setCoupling(Energy2${couplingptrs});
    ${paramdecl}
    /** @name Functions used by the persistent I/O system. */
    //@{
    /**
     * Function used to write out object persistently.
     * @param os the persistent output stream written to.
     */
    void persistentOutput(PersistentOStream & os) const;
    
    /**
     * Function used to read in object persistently.
     * @param is the persistent input stream read from.
     * @param version the version number of the object when written.
     */
    void persistentInput(PersistentIStream & is, int version);
    //@}
  
  public:
    static void Init();
    /**
     * Pointer to the model object.
     */
    tcSMPtr _theModel;



  protected:
    virtual IBPtr clone() const { return new_ptr(*this); }
    virtual IBPtr fullclone() const { return new_ptr(*this); }
    virtual void doinit();
    virtual void getParams(Energy2${q2});

  
  private:
    ${ModelName}${classname} & operator=(const ${ModelName}${classname} &);
    Complex leftval, rightval, normval;


  };
}

namespace Herwig {
using namespace ThePEG;

// Static variable needed for the type description system in ThePEG.
  DescribeClass<${ModelName}${classname},Helicity::${lorentztag}Vertex>
  describeHerwig${ModelName}${classname}("Herwig::${ModelName}${classname}", 
					 "${ModelName}.so");


void ${ModelName}${classname}::Init() {
  static ClassDocumentation<${ModelName}${classname}> documentation
    ("The ${ModelName}${classname} class is the implementation of"
     "the coupling of the Z boson to the Standard Model fermions");
}

  void ${ModelName}${classname}::setCoupling(Energy2 q2${couplingptrs}) {
    getParams(q2);
  // first the overall normalisati
    ${norm} // cout << ${normdebug} << endl;
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ${left} // cout << ${leftdebug} << endl;
    ${right} // cout << ${rightdebug} << endl;
  // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

${ModelName}${classname}::${ModelName}${classname}() {
  ${addToPlist}
  ${addToPlist2}
}

void ${ModelName}${classname}::persistentOutput(PersistentOStream & os) const {
  os << _theModel << $ostream;
}

void ${ModelName}${classname}::persistentInput(PersistentIStream & is, int) {
  is >> _theModel >> $istream;
}

void ${ModelName}${classname}::doinit() {


   _theModel = generator()->standardModel();
   tcHw${ModelName}Ptr hw${ModelName}_ptr =dynamic_ptr_cast<tcHw${ModelName}Ptr>(_theModel);
   
  Energy2 q2 = 8100.*GeV*GeV;
    getParams(q2);

   ${parameters}
   ${setCouplings}
   orderInGem(${qedorder});
   orderInGs(${qcdorder});
   ${lorentztag}Vertex::doinit();
}

void ${ModelName}${classname}::getParams(Energy2 q2) {

   _theModel = generator()->standardModel();
   tcHw${ModelName}Ptr hw${ModelName}_ptr =dynamic_ptr_cast<tcHw${ModelName}Ptr>(_theModel);
   
   if(hw${ModelName}_ptr) { 
     ${paramvertexcalc}
   }
}


}
