#! /usr/bin/env python
import os, sys, pprint, argparse
from string import Template, strip

from ufo2peg import *

# set up the option parser for command line input 
parser = argparse.ArgumentParser(
    description='Create Herwig++ model files from Feynrules UFO input.'
)
parser.add_argument(
    'ufodir', 
    metavar='UFO_directory', 
    help='the UFO model directory'
)
parser.add_argument(
    '-v', '--verbose', 
    action="store_true", 
    help="print verbose output"
)
parser.add_argument(
    '-n','--name', 
    default="FRModel", 
    help="set custom nametag for the model"
)

args = parser.parse_args()

modeldir = args.ufodir.rstrip('/')
modelpath, module = os.path.split(modeldir)
if modelpath:
    sys.path.append(os.path.abspath(modelpath))

FR = __import__(module)


##################################################
##################################################
##################################################

# get the Model name from the arguments
modelname = args.name
libname = modelname + '.so'

# copy the Makefile-FR to current directory,
# replace with the modelname for compilation
with open('../Makefile-FR','r') as orig:
    with open('Makefile','w') as dest:
        dest.write(orig.read().replace("FeynrulesModel.so", libname))


# define arrays and variables     
#allplist = ""
parmdecls = []
parmgetters = []
parmconstr = []

paramstoreplace_ = []
paramstoreplace_expressions_ = []

# get external parameters for printing
parmsubs = dict( [ (p.name, float(p.value)) 
                   for p in FR.all_parameters 
                   if p.nature == 'external' ] ) 

# evaluate python cmath
def evaluate(x):
    import cmath
    return eval(x, 
                {'cmath':cmath,
                 'complexconjugate':FR.function_library.complexconjugate}, 
                parmsubs)


## get internal params into arrays
internal = ( p for p in FR.all_parameters 
             if p.nature == 'internal' )

#paramstoreplaceEW_ = []
#paramstoreplaceEW_expressions_ = []

# calculate internal parameters
for p in internal:
    parmsubs.update( { p.name : evaluate(p.value) } )
#    if 'aS' in p.value and p.name != 'aS':
#        paramstoreplace_.append(p.name)
#        paramstoreplace_expressions_.append(p.value)
#    if 'aEWM1' in p.value and p.name != 'aEWM1':
#        paramstoreplaceEW_.append(p.name)
#        paramstoreplaceEW_expressions_.append(p.value)

        
    
# more arrays used for substitution in templates 
paramsforstream = []
parmmodelconstr = []

# loop over parameters and fill in template stuff according to internal/external and complex/real
# WARNING: Complex external parameter input not tested!
if args.verbose:
    print 'verbose mode on: printing all parameters'
    print '-'*60
    paramsstuff = ('name', 'expression', 'default value', 'nature')
    pprint.pprint(paramsstuff)



interfacedecl_T = Template(
"""
static Parameter<${modelname}, ${type}> interface${pname}
  ("${pname}",
   "The interface for parameter ${pname}",
   &${modelname}::${pname}_, ${value}, 0, 0,
   false, false, Interface::nolimits);
"""
)

interfaceDecls = []

for p in FR.all_parameters:
    value = parmsubs[p.name]

    if p.nature == 'external':
        interfaceDecls.append( 
            interfacedecl_T.substitute(modelname=modelname,
                                       pname=p.name,
                                       value=value,
                                       type=typemap(p.type)) 
        )

    if p.type == 'real':
        assert( value.imag < 1.0e-16 )
        value = value.real
        if p.nature == 'external':
            parmconstr.append('%s_(%s)' % (p.name, value))
            parmmodelconstr.append('set %s:%s %s' % (modelname, p.name, value))
    elif p.type == 'complex':
        value = complex(value)
        if p.nature == 'external':
            parmconstr.append('%s_(%s,%s)' % (p.name, value.real, value.imag))
            parmmodelconstr.append('set %s:%s (%s,%s)' % (modelname, p.name, value.real, value.imag))
    else:
        raise Exception('Unknown data type "%s".' % p.type)
    parmsubs[p.name] = value


    if p.nature == 'external':
        parmdecls.append('  %s %s_;' % (typemap(p.type), p.name))
        parmgetters.append('  %s %s() const { return %s_; }' % (typemap(p.type),p.name, p.name))
        paramsforstream.append('%s_' % p.name)
        expression, symbols = 'return %s_' % p.name, None
    else:
        expression, symbols = py2cpp(p.value)
        text = add_brackets(expression, symbols)
        parmgetters.append('  %s %s() const { return %s; }' % (typemap(p.type),p.name, text))

    print 'NAME  |',p.name
    print 'VALUE |',p.value
    print 'TEXT  |','%s = %s;' % (p.name,expression)
    print 'SYMS  |',symbols
    print '-'*60

### special treatment
#    if p.name == 'aS':
#        expression = '0.25 * sqr(strongCoupling(q2)) / Constants::pi'
#    elif p.name == 'aEWM1':
#        expression = '4.0 * Constants::pi / sqr(electroMagneticCoupling(q2))'
#    elif p.name == 'Gf':
#        expression = 'generator()->standardModel()->fermiConstant() * GeV2'
#    elif p.name == 'MZ':
#        expression = 'getParticleData(ThePEG::ParticleID::Z0)->mass() / GeV'


    if args.verbose:
        pprint.pprint((p.name,p.value, value, p.nature))

parmtextsubs = { 'parmgetters' : '\n'.join(parmgetters),
                 'parmdecls' : '\n'.join(parmdecls),
                 'parmconstr' : ': ' + ','.join(parmconstr),
                 'getters' : '',
                 'decls' : '',
                 'addVertex' : '',
                 'ostream' : '<< '.join(paramsforstream),
                 'istream' : '>> '.join(paramsforstream),
                 'refs' : '',
                 'parmextinter': ''.join(interfaceDecls),
                 'ModelName': modelname
                 }

print '-'*60

# write the files from templates according to the above subs
MODEL_H  = getTemplate('Model.h')
MODEL_CC = getTemplate('Model.cc')
MODEL_HWIN = getTemplate('LHC-FR.in')
writeFile( modelname + '.h',          MODEL_H.substitute(parmtextsubs) )
writeFile( modelname +'.cc',          MODEL_CC.substitute(parmtextsubs) )
writeFile( 'LHC-' + modelname +'.in', MODEL_HWIN.substitute(parmtextsubs) )


##################################################
##################################################
##################################################


# get vertex template
VERTEX = getTemplate('Vertex.cc')

def produce_vertex_file(subs):
    newname = modelname + subs['classname'] + '.cc'
    writeFile( newname, VERTEX.substitute(subs) )

if args.verbose:
    print 'verbose mode on: printing all vertices'
    print '-'*60
    labels = ('vertex', 'particles', 'Lorentz', 'C_L', 'C_R', 'norm')
    pprint.pprint(labels)


for vertex in FR.all_vertices:

    #print vertex.name
    #print map(str,vertex.particles)
    #print '---------------'
#    vertex.include = 1

    ### Spin structure
    unique = CheckUnique()
    for l in vertex.lorentz:
        lorentztag = get_lorentztag(l.spins)
        unique( lorentztag )
    
    ### Particle ids #### sort order? ####
    plistarray = [','.join([ str(p.pdg_code) for p in vertex.particles ])]
    
    ### Colour structure
    if vertex.color == '1': qcdord = '0'
    else:              qcdord = ''

    ### classname
    classname = 'V_%03d' % int(vertex.name[2:])

    ### parse couplings
    unique_qcd = CheckUnique()
    unique_qed = CheckUnique()
    
    coup_left  = []
    coup_right = []
    coup_norm = []
 
    for (colour_idx,lorentz_idx),C in vertex.couplings.iteritems():
        qed = C.order.get('QED',0)
        qcd = C.order.get('QCD',0)
        # WARNING: FIX FOR CASES WHEN BOTH ARE ZERO
        # Is there a better way to treat this?
        if qed == 0 and qcd == 0:
            qed = 1
        unique_qcd( qcd )
        unique_qed( qed )
        L = vertex.lorentz[lorentz_idx]

        if lorentztag in ['FFS','FFV']:
            #print 'PRINTING LORENTZ STRUCTURE'
            #print L.structure
            for lor in map(strip, L.structure.split('+')):
                breakdown = lor.split('*')
                prefactor='1'
                #print 'breakdown', breakdown, 'length', len(breakdown)
                if len(breakdown) == 3:
                    prefactor = breakdown[0]
                    breakdown = breakdown[1:]
                if len(breakdown) == 2:
#                    assert(breakdown[0][:5] == 'Gamma')
                    if breakdown[1][:5] == 'ProjM':
                        #print 'LEFT HANDED'
                        coup_left.append(prefactor+' * '+C.value)
                    elif breakdown[1][:5] == 'ProjP':
                        #print 'RIGHT HANDED'
                        coup_right.append(prefactor+' * '+C.value)
                    else:
                        coup_left.append(C.value)
                        coup_right.append(C.value)
                if len(breakdown) == 1:
                    if breakdown[0][:5] == 'ProjM':
                        #print 'LEFT HANDED'
                        coup_left.append(prefactor+' * '+C.value)
                    elif breakdown[0][:5] == 'ProjP':
                        #print 'RIGHT HANDED'
                        coup_right.append(prefactor+' * '+C.value)
                    else:
                        coup_left.append(C.value)
                        coup_right.append(C.value)
        else:
            coup_norm.append(C.value)
                
            
        #print 'Colour  :',vertex.color[colour_idx]
        #print 'Lorentz %s:'%L.name, L.spins, L.structure
        #print 'Coupling %s:'%C.name, C.value, '\nQED=%s'%qed, 'QCD=%s'%qcd
        #print '---------------'


    leftcontent = ' + '.join(coup_left) if len(coup_left)!=0 else '0j'
    rightcontent = ' + '.join(coup_right) if len(coup_right)!=0 else '0j'
    normcontent = ' + '.join(coup_norm) if len(coup_norm)!=0 else '1.'

#    #print 'Left:',leftcontent
#    #print 'Right:',rightcontent
#    #print 'Norm:',normcontent
#    #print '---------------'


#    ### do we need left/right?
    symbols = set()
    if 'FF' in lorentztag:
#        leftcalc = aStoStrongCoup(py2cpp(leftcontent)[0], paramstoreplace_, paramstoreplace_expressions_)
#        rightcalc = aStoStrongCoup(py2cpp(rightcontent)[0], paramstoreplace_, paramstoreplace_expressions_)
        leftcalc, sym = py2cpp(leftcontent)
        symbols |= sym
        rightcalc, sym = py2cpp(rightcontent)
        symbols |= sym
        left = 'left(' + leftcalc + ');'
        right = 'right(' + rightcalc + ');'
    else:
        left = ''
        right = ''
        leftcalc = ''
        rightcalc = ''
        

#    normcalc = aStoStrongCoup(py2cpp(normcontent)[0], paramstoreplace_, paramstoreplace_expressions_)
    normcalc, sym = py2cpp(normcontent)
    symbols |= sym
    norm = 'norm(' + normcalc + ');'

    # define unkown symbols from the model
    symboldefs = [ def_from_model(FR,s) for s in symbols ]
        
    ### assemble dictionary and fill template
    subs = { 'lorentztag' : lorentztag,                   # ok
             'classname'  : classname,            # ok
             'symbolrefs' : '\n    '.join(symboldefs),
             'left'       : left,                 # doesn't always exist in base
             'right'      : right,                 # doesn't always exist in base 
             'norm'      : norm,                 # needs norm, too

             #################### need survey which different setter methods exist in base classes

             'addToPlist' : '\n'.join([ 'addToList(%s);'%s for s in plistarray]),
             'parameters' : '',
             'setCouplings' : '',
             'qedorder'   : qed,
             'qcdorder' : qcd,
             'couplingptrs' : ',tcPDPtr'*len(vertex.particles),
             'spindirectory' : spindirectory(lorentztag),
             'ModelName' : modelname,
             }             # ok

    if args.verbose:
        print '-'*60
        pprint.pprint(( classname, plistarray, leftcalc, rightcalc, normcalc ))
        
        

    produce_vertex_file(subs)
#    if  L.spins[0] != -1 and L.spins[1] != -1 and L.spins[2] != -1 and plistarray[0] not in allplist and plistarray[1] not in allplist:
#        produce_vertex_file(subs)
#        allplist += plistarray[0]
#        allplist += plistarray[1]
#    elif  L.spins[0] != -1 and L.spins[1] != -1 and L.spins[2] != -1 and selfconjugate:
#        produce_vertex_file(subs)
#        allplist += plistarray[0]
#    else:
#        #print 'VERTEX ALREADY INCLUDED'
#        vertex.include = 0
        
        #print '============================================================'

print '='*60

##################################################
##################################################
##################################################

vertexline = Template("""\
create $classname $name
insert ${ModelName}:ExtraVertices 0 $name
""")


def get_vertices():
    vlist = ['library %s\n' % libname]
    for v in FR.all_vertices:
        for l in v.lorentz:
            lorentztag = get_lorentztag(l.spins)
            #print lorentztag
        if 'U' not in lorentztag: # and v.include == 1:
            vlist.append( vertexline.substitute(
                { 'classname' : 'Herwig::%sV_%03d' % (modelname, int(v.name[2:])),
                  'name' : '/Herwig/%s/%s' % (modelname,v.name), 
                  'ModelName' : modelname } ) )
    return ''.join(vlist)


modelfilesubs = { 'plist' : thepeg_particles(FR,parmsubs),
                  'vlist' : get_vertices(),
                  'setcouplings': '\n'.join(parmmodelconstr),
                  'ModelName': modelname
                  }

#print thepeg_particles()

MODELINFILE = getTemplate('FR.model')

writeFile( modelname +'.model', MODELINFILE.substitute(modelfilesubs) )

print 'finished generating model:\t', modelname
print 'model directory:\t\t', args.ufodir
print 'generated:\t\t\t', len(FR.all_vertices), 'vertices'
print '='*60
print 'library:\t\t\t', libname
print 'input file:\t\t\t', 'LHC-' + modelname +'.in'
print 'model file:\t\t\t', modelname +'.model'
print '='*60
print """To complete the installation, compile by typing "make", 
copy the generated .so file, into the Herwig++ lib directory
and the .model and .in files in the directory that you wish to run in.
"""
print 'DONE!'
print '='*60

