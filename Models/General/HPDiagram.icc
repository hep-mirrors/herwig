// -*- C++ -*-
//
// HPDiagram.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined, non-templated member
// functions of the HPDiagram struct.
//
namespace Herwig {
using namespace ThePEG;

inline HPDiagram::HPDiagram() 
  : incoming(make_pair(0, 0)), outgoing(make_pair(0, 0)),
    ordered(make_pair(true,true)), channelType(UNDEFINED),
    colourFlow(0), ids(4, 0) {}

inline HPDiagram::HPDiagram(IDPair a, IDPair b) 
  : incoming(a), outgoing(b), ordered(make_pair(true,true)), 
    channelType(UNDEFINED), colourFlow(0), ids(4, 0){
  ids[0] = incoming.first;
  ids[1] = incoming.second;
  ids[2] = outgoing.first;
  ids[3] = outgoing.second;
}


inline bool operator==(const HPDiagram & x, const HPDiagram & y) {
  if( x.channelType != y.channelType ) return false;
  if( x.incoming == y.incoming && x.outgoing == y.outgoing &&
      x.ordered == y.ordered ) {
    if( !y.intermediate && !x.intermediate ) return true;
    if( abs(y.intermediate->id()) == abs(x.intermediate->id()) )
      return true;
  }
  //diagram is also the same if the outgoing particles are
  //swapped and the ordering is opposite
  else if( x.incoming == y.incoming &&
	   x.outgoing.first != x.outgoing.second &&
	   y.outgoing.first != y.outgoing.second &&
	   x.outgoing.first == y.outgoing.second && 
	   x.outgoing.second == y.outgoing.first &&
	   x.channelType == y.channelType) {
    if(x.channelType==HPDiagram::fourPoint) return true;
    if(x.channelType==HPDiagram::tChannel&&
       x.ordered.second != y.ordered.second) {
      if( abs(y.intermediate->id()) == abs(x.intermediate->id()) )
	return true;
    }
    if(x.channelType==HPDiagram::sChannel) {
      if( y.intermediate->id() == x.intermediate->id() )
	return true;
    }
  }
  return false;
}

inline bool HPDiagram::sameProcess(const HPDiagram & x) const {
  return ( x.incoming == incoming && x.outgoing == outgoing );
}

inline bool operator<(const HPDiagram & x, const HPDiagram & y) {
  for( size_t i = 0; i < 4; ++i ) {
    if( x.ids[i] < y.ids[i] )
      return true;
    else if( x.ids[i] > y.ids[i] )
      return false;
  }
  return false;
}

inline ostream & operator<<(ostream & os, const HPDiagram & diag) {
  os << diag.incoming.first << " " << diag.incoming.second << " -> ";
  if(diag.intermediate)
    os << diag.intermediate->id() << " -> ";
  os << diag.outgoing.first << " " << diag.outgoing.second
     << "  channel: " << diag.channelType << "  ";
  if(diag.channelType == HPDiagram::tChannel)
    os << "ordering " << diag.ordered.first << " " 
       << diag.ordered.second << "  ";
  for(size_t cf = 0; cf < diag.colourFlow.size(); ++cf) 
    os << "(" << diag.colourFlow[cf].first << "," 
       <<diag.colourFlow[cf].second << ")";
  os << '\n';
  return os;
}

inline PersistentOStream & operator<<(PersistentOStream & os, 
				      const HPDiagram & x) {
  os << x.incoming << x.outgoing << x.ordered << x.intermediate
     << x.vertices << x.channelType << x.colourFlow << x.ids;
  return os;
}

inline PersistentIStream & operator>>(PersistentIStream & is, 
				      HPDiagram & x) {
  int chan = -1;
  is >> x.incoming >> x.outgoing >> x.ordered >> x.intermediate
     >> x.vertices >> chan >> x.colourFlow >> x.ids;
  x.channelType = HPDiagram::Channel(chan);
  return is;
}

}
