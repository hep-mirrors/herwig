// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the StandardModel class.
//
namespace Herwig {
using namespace ThePEG;

typedef Ptr<Herwig::RunningMassBase>::pointer runPtr;
typedef Ptr<Herwig::RunningMassBase>::transient_pointer trunPtr;

inline StandardModel::StandardModel() {}

inline StandardModel::StandardModel(const StandardModel & x)
  : StandardModelBase(x) 
  ,_theFFZVertex(x._theFFZVertex)
  ,_theFFPVertex(x._theFFPVertex) ,_theFFGVertex(x._theFFGVertex)
  ,_theFFWVertex(x._theFFWVertex) ,_theFFHVertex(x._theFFHVertex)
  ,_theWWHVertex(x._theWWHVertex) 
  ,_theGGGVertex(x._theGGGVertex) 
  ,_theWWWVertex(x._theWWWVertex) , _theGGGGVertex(x._theGGGGVertex) 
  ,_theWWWWVertex(x._theWWWWVertex),_vertexlist(x._vertexlist)
  ,_theRunningMass(x._theRunningMass) { }

inline IBPtr StandardModel::clone() const {
  return new_ptr(*this);
}

inline IBPtr StandardModel::fullclone() const {
  return new_ptr(*this);
}

inline void StandardModel::doupdate() throw(UpdateException) {
  StandardModelBase::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void StandardModel::doinit() throw(InitException) {
  //_theRunningMass->init();
  StandardModelBase::doinit();
}

inline void StandardModel::dofinish() {
  StandardModelBase::dofinish();
}

inline void StandardModel::doinitrun() {
  StandardModelBase::doinitrun();
}

inline void StandardModel::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  StandardModelBase::rebind(trans);
}

inline IVector StandardModel::getReferences() {
  IVector ret = StandardModelBase::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// Standard Model couplings
inline double StandardModel::lnu() const 
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(vnu()+anu());}
inline double StandardModel::le()  const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(ve()+ae());}
inline double StandardModel::lu()  const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(vu()+au());}
inline double StandardModel::ld()  const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(vd()+ad());}
inline double StandardModel::rnu() const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(vnu()-anu());}
inline double StandardModel::re()  const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(ve()-ae());}
inline double StandardModel::ru()  const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(vu()-au());}
inline double StandardModel::rd()  const
{return 0.25/sqrt(sin2ThetaW()*(1.-sin2ThetaW()))*(vd()-ad());}

// vertices	

inline tFFVVertexPtr  StandardModel::vertexFFZ() const {return _theFFZVertex;}
inline tFFVVertexPtr  StandardModel::vertexFFP() const {return _theFFPVertex;}
inline tFFVVertexPtr  StandardModel::vertexFFG() const {return _theFFGVertex;}
inline tFFVVertexPtr  StandardModel::vertexFFW() const {return _theFFWVertex;}
inline tVVVVertexPtr  StandardModel::vertexGGG() const {return _theGGGVertex;}
inline tVVVVertexPtr  StandardModel::vertexWWW() const {return _theWWWVertex;}
inline tFFSVertexPtr  StandardModel::vertexFFH() const {return _theFFHVertex;}
inline tVVSVertexPtr  StandardModel::vertexWWH() const {return _theWWHVertex;}
inline tVVVVVertexPtr StandardModel::vertexWWWW() const {return _theWWWWVertex;}
inline tVVVVVertexPtr StandardModel::vertexGGGG() const {return _theGGGGVertex;}


inline trunPtr StandardModel::massPtr() const {
  return _theRunningMass;}

// Return the running mass for a given scale and particle type 
inline double StandardModel::mass(Energy2 scale,tcPDPtr part) const
{return _theRunningMass->value(scale,part);}

// Total number of vertices
inline unsigned int StandardModel::numberOfVertices() const 
{return _vertexlist.size();}

inline tVertexBasePtr StandardModel::vertex(unsigned int ix)
{return _vertexlist[ix];}

inline void StandardModel::addVertex(VertexBasePtr in)
{_vertexlist.push_back(in);}

}
