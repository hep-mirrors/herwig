// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the YFSFormFactors class.
//

namespace Herwig {
 
inline double YFSFormFactors::Zij(const long double & eta,
				  const long double & yi,const long double & yj)
{return 2.*ReLi2((yj-yi)/(eta-yi))+0.5*sqr(log(abs((eta-yi)/(eta-yj))));}

inline double YFSFormFactors::Xijkl(const long double & eta,
				    const long double & yi,const long double & yj,
				    const long double & yk,const long double & yl)
{return log(abs((eta-yi)*(eta-yj)/(eta-yk)/(eta-yl)));}

inline double YFSFormFactors::A4single(const double & beta,const double & ombeta)
{
  if(beta>0.01){return log(ombeta/(1.+beta))/beta;}
  else         {return -2.-2./3.*sqr(beta)*(1+0.6*sqr(beta));}
}

inline InvEnergy2 YFSFormFactors::A4IFRestZero(const Energy  & m0   ,const Energy & m1)
{
  Energy2 mdiff(m0*m0-m1*m1);
  return -2./mdiff*(sqr(log(m0/m1))+ReLi2(mdiff/sqr(m0)));
}

inline InvEnergy2 YFSFormFactors::A4IFZero(const double  & beta0,const double & beta1,
					   const Energy  & en0  ,const Energy & en1  ,
					   const Energy  & m0   ,const Energy & m1)
{
  long double  Delta(en0-en1),mu2((m0-m1)*(m0+m1));
  long double z[2]={beta1*en1/Delta,beta0*en0/Delta-1.};
  long double y[3],xi[3];
  y[0]=en1/Delta;
  y[1]=y[0]-0.5*mu2/sqr(Delta);
  y[2]=-y[0]+2.*m1*m1/mu2;
  for(unsigned int ix=0;ix<3;++ix){xi[ix]=(z[0]-y[ix])/(z[1]-y[ix]);}
  long double U[2];
  for(unsigned int ix=0;ix<2;++ix)
    {U[ix] = 0.5*sqr(log(abs((z[ix]-y[0])*(z[ix]-y[1])/(z[ix]-y[2]))))
	+log(abs(z[ix]-y[0]))*log(abs(z[ix]-y[0])/sqr(z[ix]-y[1]))
	+2.*ReLi2((y[1]-y[0])/(z[ix]-y[0]))
	+2.*ReLi2((y[2]-y[1])/(z[ix]-y[1]));}
  return 1./mu2*(log(2.*sqr(Delta)/mu2)*log(abs(xi[1]*xi[2]/xi[0]))+U[1]-U[0]);
}

inline InvEnergy2 YFSFormFactors::A4IFRest(const Energy & m0   ,const Energy & m1, 
					   const double & beta1,const double & ombeta1,
					   const Energy & E1)
{
  Energy Mfact[4]={m0-E1*ombeta1         ,m0-E1*(1.+beta1),
		   m0*E1*(1.+beta1)-m1*m1,m0*E1*ombeta1-m1*m1};
  Energy2 qprod(m0*E1*beta1);
  return 0.5/qprod*(+log(abs(Mfact[0]/Mfact[1]))*log(E1*(1.+beta1)/m0)
		    -2.*log(abs(2.*beta1*E1*Mfact[0]/m0/m1))*log(E1*(1.+beta1)/m1)
		    +2.*ReLi2(E1/m0*ombeta1)-2.*ReLi2(E1/m0*(1.+beta1))
		    +ReLi2(-0.5*Mfact[1]/beta1/E1)-ReLi2( 0.5*Mfact[0]/beta1/E1)
		    +ReLi2( 0.5*Mfact[2]/qprod   )-ReLi2(-0.5*Mfact[3]/qprod));
}

inline InvEnergy2 YFSFormFactors::A4IFFull(const double  & beta0,const double & beta1,
					   const Energy  & en0  ,const Energy & en1  ,
					   const Energy  & m0   ,const Energy & m1   ,
					   const Energy2 & t)
{
  long double  Delta(en0-en1),Omega(en0+en1),delta(m0-m1),omega(m0+m1),
    T(sqrt(sqr(Delta)-t)),V(Delta+T);
  long double kappa(sqrt((sqr(omega)-t)*(sqr(delta)-t)));
  long double y[4]={-0.5/T*(T+Omega-(omega*delta+kappa)*V/t),
		    -0.5/T*(T+Omega-(omega*delta-kappa)*V/t),
		    -0.5/T*(T-Omega+(omega*delta+kappa)/V),
		    -0.5/T*(T-Omega+(omega*delta-kappa)/V)};
  long double z[2]={beta1*en1/T,beta0*en0/T-1.};
  double Y[2],lfact(log(abs(V*V/t)));
  for(unsigned int ix=0;ix<2;++ix)
    {Y[ix] = lfact*Xijkl(z[ix],y[0],y[3],y[1],y[2])
	+Zij(z[ix],y[0],y[3])+Zij(z[ix],y[1],y[0])
	+Zij(z[ix],y[2],y[1])-Zij(z[ix],y[2],y[3])
	+0.5*Xijkl(z[ix],y[0],y[1],y[2],y[3])*Xijkl(z[ix],y[1],y[2],y[0],y[3]);}
  return (Y[1]-Y[0])/kappa;
}

InvEnergy2 YFSFormFactors::A4IF(const double  & beta0   ,const double  & ombeta0 ,
				const double  & beta1   ,const double  & ombeta1 ,
				const Energy  & en0  ,const Energy & en1  ,
				const Energy  & m0   ,const Energy & m1   ,
				const Energy2 & t)
{
  // this is the general function so pick the special case
  if(t>_tcut)
    {
      // rest frame of decaying particle t!=0
      if(abs(en0-m0)<_ecut){return A4IFRest(m0,m1,beta1,ombeta1,en1);}
      // rest frame of decay product t!=0
      else if(abs(en1-m1)<_ecut){return A4IFRest(m1,m0,beta0,ombeta0,en0);}
      // general frame t!=0
      else
	{return A4IFFull(beta0,beta1,en0,en1,m0,m1,t);}
    }
  else
    {
      // rest frame of decaying particle t=0
      if(abs(en0-m0)<_ecut){return A4IFRestZero(m0,m1);}
      // rest frame of decay products t=0
      else if(abs(en1-m1)<_ecut){return A4IFRestZero(m1,m0);}
      // general frame t=0
      else{return A4IFZero(beta0,beta1,en0,en1,m0,m1);}
    }
}

inline double YFSFormFactors::A4FFFull(const Energy  & inen1,const Energy & inen2,
				       const double  & beta1,const double & beta2,
				       const Energy  & inm1 ,const Energy & inm2,
				       const Energy2 & s)
{
  Energy en1(inen1),en2(inen2),m1(inm1),m2(inm2);
  // order the particles so en1>en2
  if(inen1*beta1<inen2*beta2)
    {
      en1=inen2;
      en2=inen1;
      m1=inm2;
      m2=inm1;
    }
  long double Delta(en1-en2);
  long double Omega(en1+en2),delta(m1-m2),omega(m1+m2);
  long double Q2(s-2.*(m1*m1+m2*m2));
  long double root(sqrt(Delta*Delta+Q2));
  long double eta[2]={sqrt((en2-m2)*(en2+m2)),sqrt((en1-m1)*(en1+m1))+root};
  if(0.5*(s-m1*m1-m2*m2)>en1*en2){eta[0]=-eta[0];}
  long double root2(sqrt((Q2+omega*omega)*(Q2+delta*delta)));
  double Y[2];
  // various limits
  long double y[4];
  y[0]=0.5*(root-Omega+(omega*delta+root2)/(root+Delta));
  y[1]=y[0]-root2/(root+Delta);
  y[2]=0.5*(root+Omega+(omega*delta+root2)/(root-Delta));
  y[3]=y[2]-root2/(root-Delta);
  // the Y function at both limits
  for(unsigned int ix=0;ix<2;++ix)
    {Y[ix]=Zij(eta[ix],y[0],y[3])+Zij(eta[ix],y[1],y[0])
	+Zij(eta[ix],y[2],y[1])-Zij(eta[ix],y[2],y[3])
	+0.5*Xijkl(eta[ix],y[0],y[1],y[2],y[3])*Xijkl(eta[ix],y[1],y[2],y[0],y[3]);}
  // the answer
  // the Z function at both limits
  double output(0.);
  if(abs(Delta)>_ecut)
    {output=log(abs((root-Delta)/(root+Delta)))*(+Xijkl(eta[1],y[0],y[3],y[1],y[2])
						 -Xijkl(eta[0],y[0],y[3],y[1],y[2]));}
  output=1./root2*(output+Y[1]-Y[0]);
  return output;
}

inline double YFSFormFactors::BtildeIF(const double  & beta0   ,const double  & ombeta0 ,
				       const double  & beta1   ,const double  & ombeta1 ,
				       const Energy  & en0     ,const Energy  & en1     ,
				       const Energy  & m0      ,const Energy  & m1      ,
				       const Energy2 & t       ,const double  & charge  ,
				       const Energy  & emin    ,
				       const bool    & includegamma,
				       const Energy  & mgamma)
{
  // coefficient of the divergent piece
  Energy2 mprod(m0*m1),nu(0.5*(m0*m0+m1*m1-t));
  double Anu;
  if(nu-mprod>1e-12*GeV2)
    {
      Energy2 lambda(sqrt((nu-mprod)*(nu+mprod)));
      Anu=nu/lambda*log((lambda+nu)/mprod);
    }
  else
    {Anu=1.;}
  // finite piece
  double rfinite(-0.5*A4single(beta0,ombeta0)-0.5*A4single(beta1,ombeta1)
		 +nu*A4IF(beta0,ombeta0,beta1,ombeta1,en0,en1,m0,m1,t));
  // return the answer
  double output; 
  if(includegamma){output=-_alpha*charge/pi*((Anu-1.)*2.*log(2.*emin/mgamma)+rfinite);}
  else            {output=-_alpha*charge/pi*((Anu-1.)*2.*log(2.*emin       )+rfinite);}
  return output;
}

inline double YFSFormFactors::BtildeFF(const double  & beta1  ,const double  & ombeta1 ,
				       const double  & beta2  ,const double  & ombeta2 ,
				       const Energy  & en1    ,const Energy  & en2     ,
				       const Energy  & m1     ,const Energy  & m2      , 
				       const Energy2 & s      ,const double  & charge  ,
				       const Energy  & emin   ,
				       const bool    & includegamma,
				       const Energy  & mgamma)
{
  // masses etc
  Energy2 m12(m1*m1),m22(m2*m2),mu(0.5*(s-m12-m22)),mprod(m1*m2);
  // parameters
  double ratio(m1*m2/mu),rho(sqrt((1.-ratio)*(1.+ratio)));
  Energy2 prod(mu*(1.+rho));
  // finite piece
  double rfinite(-0.5*A4single(beta1,ombeta1)-0.5*A4single(beta2,ombeta2)
		 +mu*A4FFFull(en1,en2,beta1,beta2,m1,m2,s));
  double Anu(log(prod/mprod)/rho);
  // return the answer
  double output; 
  if(includegamma){output=-_alpha*charge/pi*((Anu-1.)*2.*log(2.*emin/mgamma)+rfinite);}
  else            {output=-_alpha*charge/pi*((Anu-1.)*2.*log(2.*emin       )+rfinite);}
  return output;
}

inline double YFSFormFactors::ReBIF(const Energy  & m0      ,const Energy  & m1      , 
				    const Energy2 & t       ,const double  & charge  ,
				    const bool    & includegamma,const Energy  & mgamma)
{
  // mass squared for speed
  Energy2 m02(m0*m0),m12(m1*m1),nu(0.5*(m02+m12-t)),mprod(m0*m1);
  double Anu,vfinite;
  double output;
  // t>0
  if(t>_tcut)
    {
      // parameters
      Energy2 lambda(sqrt((nu-mprod)*(nu+mprod)));
      double eta(0.5*m12*t/lambda/(lambda+nu-m12)),zeta((lambda+nu)*eta/m12);
      // simple A functions for virtual piece
      InvEnergy2 A;
      if(lambda>1e-6*GeV2){A=(log((lambda+nu)/mprod)/lambda);}
      else{A=1./mprod;}
      double A1((m02-m12)/t*log(m0/m1)-2.*sqr(lambda)/t*A-2.);
      double A3(A*log(2.*lambda/mprod)
		+1./lambda*
		(+0.25*(log((lambda+nu)/m02)+2.*log((lambda-nu+m02)/t  ))*
		 log((lambda+nu)/m02)
		 +0.25*(log((lambda+nu)/m12)-2.*log((lambda+nu-m12)/m12))*
		 log((lambda+nu)/m12)
		 +0.5*(log(eta)*log(1.+eta)-log(zeta)*log(1.+zeta))
		 +ReLi2(-eta)-ReLi2(-zeta)));
      Anu=nu*A;
      vfinite=0.5*A1-nu*A3;
    }
  // t==0
  else
    {
      // virtual part of the dipole
      Anu = (m02+m12)/(m02-m12)*log(m0/m1);
      vfinite=0.5*(Anu-1.);
    }
  if(includegamma){output=-_alpha*charge/pi*((Anu-1.)*log(sqr(mgamma)/mprod)+vfinite);}
  else            {output=-_alpha*charge/pi*((Anu-1.)*log(1.         /mprod)+vfinite);}
  return output;
}


inline double YFSFormFactors::ReBFF(const Energy & m1,const Energy & m2,
				    const Energy2 & s,const double  & charge  ,
				    const bool    & includegamma,const Energy  & mgamma)
{
  // masses etc
  Energy2 m12(m1*m1),m22(m2*m2),mu(0.5*(s-m12-m22)),mprod(m1*m2);
  // parameters
  double ratio(m1*m2/mu),rho(sqrt((1.-ratio)*(1.+ratio)));
  Energy2 prod(mu*(1.+rho));
  // the finite piece
  double vfinite(mu*rho/s*log(prod/mprod)+0.5*(m12-m22)/s*log(m1/m2)
		 +1./rho*(pi*pi-0.5*log(prod/m12)*log(prod/m22)
			  -0.5*sqr(log((m12+prod)/(m22+prod)))
			  -ReLi2(2.*mu*rho/(m12+prod))
			  -ReLi2(2.*mu*rho/(m22+prod)))-1.);
  // the cut-off piece
  double Anu(log(prod/mprod)/rho),output;
  if(includegamma){output=-_alpha*charge/pi*((Anu-1.)*log(sqr(mgamma)/mprod)+vfinite);}
  else            {output=-_alpha*charge/pi*((Anu-1.)*log(1.         /mprod)+vfinite);}
  return output;
}

inline double YFSFormFactors::YFSIF(const double  & beta0   ,const double  & ombeta0 ,
				    const double  & beta1   ,const double  & ombeta1 ,
				    const Energy  & en0     ,const Energy  & en1     ,
				    const Energy  & m0      ,const Energy  & m1      , 
				    const Energy2 & t       ,const double  & charge  ,
				    const Energy  & emin)
{return BtildeIF(beta0,ombeta0,beta1,ombeta1,en0,en1,m0,m1,t,charge,emin,false)
    +ReBIF(m0,m1,t,charge,false);}

inline double YFSFormFactors::YFSFF(const double  & beta1   ,const double  & ombeta1 ,
				    const double  & beta2   ,const double  & ombeta2 ,
				    const Energy  & en1     ,const Energy  & en2     ,
				    const Energy  & m1      ,const Energy  & m2      , 
				    const Energy2 & s       ,const double  & charge  ,
				    const Energy  & emin)
{return BtildeFF(beta1,ombeta1,beta2,ombeta2,en1,en2,m1,m2,s,charge,emin,false)
    +ReBFF(m1,m2,s,charge,false);}

inline double YFSFormFactors::
exponentialYFSIF(const double  & beta0,const double  & ombeta0 ,
		 const double  & beta1,const double  & ombeta1 ,
		 const Energy  & en0  ,const Energy  & en1     ,
		 const Energy  & m0   ,const Energy  & m1      , 
		 const Energy2 & t    ,const double  & charge  ,
		 const Energy  & emin)
{return exp(YFSIF(beta0,ombeta0,beta1,ombeta1,en0,en1,m0,m1,t,charge,emin));}

inline double YFSFormFactors::
exponentialYFSFF(const double  & beta1,const double  & ombeta1 ,
		 const double  & beta2,const double  & ombeta2 ,
		 const Energy  & en1  ,const Energy  & en2     ,
		 const Energy  & m1   ,const Energy  & m2      , 
		 const Energy2 & s    ,const double  & charge  ,
		 const Energy  & emin)
{return exp(YFSFF(beta1,ombeta1,beta2,ombeta2,en1,en2,m1,m2,s,charge,emin));}



inline double YFSFormFactors::nbarFF(const double & beta1, const double & ombeta1,
				     const double & beta2, const double & ombeta2,
				     const double & charge,
				     const Energy & Emax , const Energy & Emin,
				     const bool massterms)
{
  if(!massterms)
    {return -_alpha/pi*charge*
	((1.+beta1*beta2)/(beta1+beta2)*(+log((1.+beta1)/ombeta1)
					 +log((1.+beta2)/ombeta2)))*log(Emax/Emin);}
  else
    {return -_alpha/pi*charge*
	((1.+beta1*beta2)/(beta1+beta2)*(+log((1.+beta1)/ombeta1)
					 +log((1.+beta2)/ombeta2))-2.)*log(Emax/Emin);}
}

inline double YFSFormFactors::nbarIF(const double & beta, const double & ombeta,
				     const double & charge,
				     const Energy & Emax , const Energy & Emin,
				     const bool massterms)
{
  if(!massterms)
    {return -_alpha/pi*charge/beta* log((1.+beta)/ombeta)    *log(Emax/Emin);}
  else
    {return -_alpha/pi*charge/beta*(log((1.+beta)/ombeta)-2.)*log(Emax/Emin);}
}
}
