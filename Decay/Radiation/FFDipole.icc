// -*- C++ -*-
//
// FFDipole.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the FFDipole class.
//

namespace Herwig {

inline FFDipole::FFDipole() :
  _emin(1.e-6*MeV), _eminrest(100*MeV), _eminlab(100*MeV), _emax(),
  _multiplicity(), _nphotonmax(20), _m(3), _charge(), _qdrf(2),
  _qnewdrf(2), _qprf(2), _qnewprf(2), _qlab(2), _qnewlab(2), _dipolewgt(),
  _yfswgt(), _jacobianwgt(), _mewgt(), _maxwgt(5.0), _mode(1), _maxtry(500),
  _energyopt(1), _betaopt(1), _dipoleopt()
{}

inline IBPtr FFDipole::clone() const {
  return new_ptr(*this);
}

inline IBPtr FFDipole::fullclone() const {
  return new_ptr(*this);
}

// poisson
inline int FFDipole::poisson(double average)
{
  int n(0),n_factorial(1);
  double x(UseRandom::rnd()*exp(average)),sum(1.);
  while (x>=sum)
    {
      ++n;
      n_factorial *= n;   
      sum += pow(average,n)/n_factorial;
    };
  return n;
}

inline double FFDipole::exactDipoleWeight(double beta1, double ombeta1,
					  double beta2, double ombeta2,
					  unsigned int iphot)
{
  double opbc,ombc;
  // if cos is greater than zero use result accurate as cos->1
  if(_cosphot[iphot]>0)
    {
      opbc=1.+beta2*_cosphot[iphot];
      ombc=ombeta1+beta1*sqr(_sinphot[iphot])/(1.+_cosphot[iphot]);
    }
  // if cos is less    than zero use result accurate as cos->-1
  else
    {
      opbc=ombeta2+beta2*sqr(_sinphot[iphot])/(1.-_cosphot[iphot]);
      ombc=1.-beta1*_cosphot[iphot];
    }
  return 0.5/(opbc*ombc)*(1.+beta1*beta2
			  -0.5*ombeta1*(1.+beta1)*opbc/ombc		 
			  -0.5*ombeta2*(1.+beta2)*ombc/opbc);
}

inline double FFDipole::jacobianWeight()
{
  Energy pcm1=Kinematics::pstarTwoBodyDecay(_m[0],_m[1],_m[2]);
  Energy m12 =sqrt((_qnewdrf[0]+_qnewdrf[1]).m2())            ;
  Energy pcm2=Kinematics::pstarTwoBodyDecay(m12,_m[1],_m[2])  ;
  double betaprobeta = pcm2*_m[0]/pcm1/m12   ;
  double spros       = sqr(m12/_m[0])        ;
  double deltafn     = m12/(m12+_bigLdrf.e());
  return betaprobeta*spros*deltafn           ;
}


}
