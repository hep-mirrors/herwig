// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the GeneralDipole class.
//

namespace Herwig {
using Math::ReLi2;

inline GeneralDipole::GeneralDipole() {
  // maximum weight
  _maxwgt = 5.0;
  // minimum photon energy
  _emin    = 1.e-6*MeV;
  // real minimum energies in lab and rest frame
  _eminlab  = 100*MeV;
  _eminrest = 100*MeV;
  // maximum number of tries
  _maxtry=500;
  // option for the energy cut-off
  _energyopt=1;
  // option for beta factors
  _betaopt = 1;
  // default mode
  _mode = 1;
  // control over the number of photons
  _nphotonmax=20;
}

inline GeneralDipole::GeneralDipole(const GeneralDipole & x)
  : Interfaced(x),_emin(x._emin),_eminrest(x._eminrest),
    _eminlab(x._eminlab),_maxwgt(x._maxwgt),
    _maxtry(x._maxtry),_nphotonmax(x._nphotonmax),_mode(x._mode),
    _energyopt(x._energyopt),_betaopt(x._betaopt)
 {}

inline IBPtr GeneralDipole::clone() const {
  return new_ptr(*this);
}

inline IBPtr GeneralDipole::fullclone() const {
  return new_ptr(*this);
}

// crude average multiplicity
inline double GeneralDipole::nbar(unsigned int i,unsigned int j)
{
  if(_zij[i][j]>0){return 0.;}
  if(i==0)
    {return YFSFormFactors::nbarIF(_beta[j],_ombeta[j],_zij[i][j]/9.,_emax,_emin);}
  else if(j==0)
    {return YFSFormFactors::nbarIF(_beta[i],_ombeta[i],_zij[i][j]/9.,_emax,_emin);}
  else
    {
      // easiest to do the calculation in terms of the values in rest frame
      // of the dipole
      Energy2 s((_qdrf[i]+_qdrf[j]).m2());
      Energy md(sqrt(s)),ei(0.5*(s+_m2[i]-_m2[j])/md),ej(0.5*(s-_m2[i]+_m2[j])/md);
      // calculate beta
      double betai(sqrt((ei+_m[i])*(ei-_m[i]))/ei);
      double betaj(sqrt((ej+_m[j])*(ej-_m[j]))/ej);
      // calculate 1-beta to avoid numerical problems
      double ombetai(sqr(_m[i]/ei)/(1.+betai));
      double ombetaj(sqr(_m[j]/ej)/(1.+betaj));
      return YFSFormFactors::nbarFF(betai,ombetai,betaj,ombetaj,_zij[i][j]/9.,_emax,_emin);
    }
}

// poisson
inline int GeneralDipole::poisson(double average)
{
  int n(0),n_factorial(1);
  double x(UseRandom::rnd()*exp(average)),sum(1.);
  while (x>=sum)
    {
      ++n;
      n_factorial *= n;   
      sum += pow(average,n)/n_factorial;
    };
  return n;
}

inline void GeneralDipole::reweightDipole()
{
  // reweight the dipoles
  double wgt,denom1,denom2,cosspect;
  unsigned int ie,is;
  for(unsigned int ix=0;ix<_multiplicity;++ix)
    {
      if(!_photcut[ix])
	{
	  ie = _photonemit[ix];
	  is = _photonspect[ix];
	  // first factor
	  denom1   = _ombetanew[ie]+_betanew[ie]*sqr(_sinphot[ix])/(1.+_cosphot[ix]);
	  // angle to the spectator
	  cosspect = (_qnewdrf[is].vect()).cosTheta(_ldrf[ix].vect());
	  // second factor
	  denom2   = (1.-_betanew[is]*cosspect);
	  wgt = 
	    2.*(1.-_betanew[ie]*_betanew[is]*_cosij[ie][is])/denom1/denom2
	    -_ombetanew[ie]*(1.+_betanew[ie])/sqr(denom1)
	    -_ombetanew[is]*(1.+_betanew[is])/sqr(denom2);
	  _dipolewgt*=wgt;
	}
    }
}

inline double GeneralDipole::jacobianWeight()
{
  // rescaling factor
  double output(pow(_rescalingfactor,3*_nprod-3));
  // mass term
  output *=sqr(_roots/_m[0]);
  // boost term
  output /=(1.+_bigLdrf.e()/_roots);
  // energy rescaling
  Energy mratio[2]={0.,0.};
  for(unsigned int ix=1;ix<=_nprod;++ix)
    {
      mratio[0]+=_m2[ix]/_qdrf[ix].e();
      mratio[1]+=_m2[ix]/_qnewdrf[ix].e();
      output   *=_qdrf[ix].e()/_qnewdrf[ix].e();
    }
  // ratios of energies of all the particles
  output *= (_m[0]-mratio[0])/(_roots-mratio[1]);
  // return the answer
  return output;
}

inline double GeneralDipole::dipoleWeight(unsigned int ix, unsigned int iy,
					  unsigned int iphot)
{
  unsigned int ie(_photonemit[iphot]),is(_photonspect[iphot]);
  double wtemp,denom1,denom2,cosemit,cosspect;
  if((ix==ie&&iy==is)||(iy==ie&&ix==is))
    {
      // first factor
      denom1   = _ombetanew[ie]+_betanew[ie]*sqr(_sinphot[iphot])/
	(1.+_cosphot[iphot]);
      // angle to the spectator
      cosspect = (_qnewdrf[is].vect()).cosTheta(_ldrf[iphot].vect());
      // second factor
      denom2   = (1.-_betanew[is]*cosspect);
      // total weight
      wtemp =-_zij[ix][iy]/9.*(2.*(1.-_betanew[ie]*_betanew[is]*_cosij[ie][is])
			       /denom1/denom2
			       -_ombetanew[ie]*(1.+_betanew[ie])/sqr(denom1)
			       -_ombetanew[is]*(1.+_betanew[is])/sqr(denom2));
    }
  // use accurate result if photon emitted from this dipole
  // otherwise use the general result
  else
    {
      // get the angles
      cosemit  = (_qnewdrf[ix].vect()).cosTheta(_ldrf[iphot].vect());
      cosspect = (_qnewdrf[iy].vect()).cosTheta(_ldrf[iphot].vect());
      // denominators
      denom1   = (1.-_betanew[ix]*cosemit );
      denom2   = (1.-_betanew[iy]*cosspect);
      // total weight
      wtemp =-_zij[ix][iy]/9.*(2.*(1.-_betanew[ix]*_betanew[iy]*_cosij[ix][iy])
			       /denom1/denom2
			       -_ombetanew[ix]*(1.+_betanew[ix])/sqr(denom1)
			       -_ombetanew[iy]*(1.+_betanew[iy])/sqr(denom2));
    }
  return wtemp;
}
 
}
