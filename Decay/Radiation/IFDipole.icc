// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the IFDipole class.
//

namespace Herwig {

inline IFDipole::IFDipole() 
{
  // minimum photon energy
  _emin = 1.*MeV;
  // option for the energy cut-off
  _energyopt=1;
  // option for beta factors
  _betaopt = 1;
  // maximum weight
  _maxwgt = 3.0;
  // default mode
  _mode = 1;
  // maximum number of tries
  _maxtry=500;
  // control over the number of photons
  _nphotonmax=20;
}

inline IFDipole::IFDipole(const IFDipole & x)
  : Interfaced(x), _alpha(x._alpha), _emin(x._emin),
    _emax(x._emax),
    _nphotonmax(x._nphotonmax),_maxwgt(x._maxwgt),_mode(x._mode),
    _maxtry(x._maxtry),_energyopt(x._energyopt),_betaopt(x._betaopt) {}

inline IBPtr IFDipole::clone() const {
  return new_ptr(*this);
}

inline IBPtr IFDipole::fullclone() const {
  return new_ptr(*this);
}

inline void IFDipole::doupdate() throw(UpdateException) {
  Interfaced::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void IFDipole::doinit() throw(InitException) {
  Interfaced::doinit();
  // get the value fo alpha from the Standard Model object
  _alpha=generator()->standardModel()->alphaEM();
}

inline void IFDipole::dofinish() {
  Interfaced::dofinish();
}

inline void IFDipole::doinitrun() {
  Interfaced::doinitrun();
}

inline void IFDipole::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  Interfaced::rebind(trans);
}

inline IVector IFDipole::getReferences() {
  IVector ret = Interfaced::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// crude average multiplicity
  inline double IFDipole::nbar(double beta1,double ombeta1)
{
  return  _alpha/pi*_chrg1*_chrg2
          /beta1
          *log((1.+beta1)/ombeta1)
          *log(_emax/_emin);
}

// poisson
inline int IFDipole::poisson(double average)
{
  int n(0),n_factorial(1);
  double x(UseRandom::rnd()*exp(average)),sum(1.);
  while (x>=sum)
    {
      ++n;
      n_factorial *= n;   
      sum += pow(average,n)/n_factorial;
    };
  return n;
}

inline double IFDipole::exactDipoleWeight(double beta1, double ombeta1,
					  unsigned int iphot)
{
  double ombc  ;
  // if cos is greater than zero use result accurate as cos->1
  if(_cosphot[iphot]>0.0)
    { ombc=ombeta1+beta1*sqr(_sinphot[iphot])/(1.+_cosphot[iphot]); }
  // if cos is less    than zero use result accurate as cos->-1
  else
    { ombc=1.-beta1*_cosphot[iphot]; }
  return 1.0*sqr(beta1*_sinphot[iphot]/ombc);
}

// crude YFS form factor - MAY need changing?
inline double IFDipole::crudeYFSFormFactor(double b,double omb)
{
  double Y =-_alpha/pi*_chrg1*_chrg2
           / b
           * log((1.+b)/omb)
           * log(_m[0]/(2.*_emin));
  return exp(Y);
}

}
