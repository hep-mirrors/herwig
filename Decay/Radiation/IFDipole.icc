// -*- C++ -*-
//
// IFDipole.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the IFDipole class.
//

namespace Herwig {

inline IFDipole::IFDipole() :
  _alpha(), _emin(1.0*MeV), _emax(), _multiplicity(), _nphotonmax(20),
  _map(2,0), _m(3), _chrg1(), _chrg2(), _qprf(2), _qnewprf(2),
  _lprf(), _bigLprf(), _qlab(2), _qnewlab(2), _llab(), _bigLlab(),
  _dipolewgt(), _yfswgt(), _jacobianwgt(), _mewgt(), _maxwgt(2.0),
  _mode(1), _maxtry(500), _energyopt(1), _betaopt(1), _dipoleopt()
{}

inline IBPtr IFDipole::clone() const {
  return new_ptr(*this);
}

inline IBPtr IFDipole::fullclone() const {
  return new_ptr(*this);
}

inline void IFDipole::doinit() throw(InitException) {
  Interfaced::doinit();
  // get the value fo alpha from the Standard Model object
  _alpha=generator()->standardModel()->alphaEM();
}

// crude average multiplicity
  inline double IFDipole::nbar(double beta1,double ombeta1)
{
  return  _alpha/pi*_chrg1*_chrg2
          /beta1
          *log((1.+beta1)/ombeta1)
          *log(_emax/_emin);
}

// poisson
inline int IFDipole::poisson(double average)
{
  int n(0),n_factorial(1);
  double x(UseRandom::rnd()*exp(average)),sum(1.);
  while (x>=sum)
    {
      ++n;
      n_factorial *= n;   
      sum += pow(average,n)/n_factorial;
    };
  return n;
}

inline double IFDipole::exactDipoleWeight(double beta1, double ombeta1,
					  unsigned int iphot)
{
  double ombc  ;
  // if cos is greater than zero use result accurate as cos->1
  if(_cosphot[iphot]>0.0)
    { ombc=ombeta1+beta1*sqr(_sinphot[iphot])/(1.+_cosphot[iphot]); }
  // if cos is less    than zero use result accurate as cos->-1
  else
    { ombc=1.-beta1*_cosphot[iphot]; }
  return 1.0*sqr(beta1*_sinphot[iphot]/ombc);
}

// crude YFS form factor - MAY need changing?
inline double IFDipole::crudeYFSFormFactor(double b,double omb)
{
  double Y =-_alpha/pi*_chrg1*_chrg2
           / b
           * log((1.+b)/omb)
           * log(_m[0]/(2.*_emin));
  return exp(Y);
}

}
