// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DecayPhaseSpaceChannel class.
//
// Author: Peter Richardson
// 

namespace Herwig {
using namespace ThePEG;

// clone method
inline IBPtr DecayPhaseSpaceChannel::clone() const {
  return new_ptr(*this);
}
  
// full clone method
inline IBPtr DecayPhaseSpaceChannel::fullclone() const {
  return new_ptr(*this);
}

// generate the mass of an intermediate
inline Energy DecayPhaseSpaceChannel::generateMass(int ires,Energy lower,Energy upper)
{
  Energy mass=0;
  if(lower>upper) throw DecayPhaseSpaceError() << "DecayPhaseSpaceChannel::generateMass"
					       << " not allowed";
  if((lower-upper)/(lower+upper)>1e-10) {
    lower +=1e-10*(lower+upper);
    upper -=1e-10*(lower+upper);
  }
  else 
    return 0.5*(lower+upper);
  // use a Breit-Wigner
  if(_jactype[ires]==0) {
    double rhomin = atan((lower*lower-_intmass2[ires])/_intmwidth[ires]);
    double rhomax = atan((upper*upper-_intmass2[ires])/_intmwidth[ires])-rhomin;
    double rho = rhomin+rhomax*UseRandom::rnd();
    mass = sqrt(_intmass2[ires]+_intmwidth[ires]*tan(rho));
  }
  // use a power-law
  else if(_jactype[ires]==1) {
    double rhomin = pow(lower*lower,_intpower[ires]+1.);
    double rhomax = pow(upper*upper,_intpower[ires]+1.)-rhomin;
    double rho = rhomin+rhomax*UseRandom::rnd();
    mass = pow(rho,0.5/(_intpower[ires]+1.));
  }
  else if(_jactype[ires]==2) {
    mass = _intmass[ires];
  } 
  else {
    throw DecayPhaseSpaceError() << "Unknown type of Jacobian in " 
				  << "DecayPhaseSpaceChannel::generateMass";
  }
  if(mass<lower)      mass=lower+1e-10*(lower+upper);
  else if(mass>upper) mass=upper-1e-10*(lower+upper);
  return mass;
}
 
// return the weight for a given resonance
inline InvEnergy2 DecayPhaseSpaceChannel::massWeight(int ires, Energy moff,
						     Energy lower,Energy upper)
{
  double wgt=0.;
  if(lower>upper) {
    throw DecayPhaseSpaceError() << "DecayPhaseSpaceChannel::massWeight not allowed" 
				 << ires << "   " << _intpart[ires]->id() << "   " 
				 << moff;
  } 
  // use a Breit-Wigner 
  if(_jactype[ires]==0) { 
    double rhomin = atan((lower*lower-_intmass2[ires])/_intmwidth[ires]); 
    double rhomax = atan((upper*upper-_intmass2[ires])/_intmwidth[ires])-rhomin;
    Energy2 moff2=moff*moff-_intmass2[ires];
    wgt = _intmwidth[ires]/rhomax/(moff2*moff2+_intmwidth[ires]*_intmwidth[ires]);
  } 
  // power law
  else if(_jactype[ires]==1) {
    double rhomin = pow(lower*lower,_intpower[ires]+1.);
    double rhomax = pow(upper*upper,_intpower[ires]+1.)-rhomin;
    wgt = (_intpower[ires]+1.)/rhomax*pow(moff*moff,_intpower[ires]);
  }
  else if(_jactype[ires]==2) {
    wgt = 1./pi/_intmwidth[ires];
  } 
  else {
    throw DecayPhaseSpaceError() << "Unknown type of Jacobian in " 
				 << "DecayPhaseSpaceChannel::massWeight";
  } 
  return wgt;
}

// add a new intermediate particle
inline void DecayPhaseSpaceChannel::addIntermediate(PDPtr part,int jac,double power,
						    int dau1,int dau2)
{
  _intpart.push_back(part);
  _jactype.push_back(jac);
  _intpower.push_back(power);
  _intdau1.push_back(dau1); 
  _intdau2.push_back(dau2);
}

// reset the mass and width of an intermediate particle
inline void DecayPhaseSpaceChannel::resetIntermediate(tcPDPtr part,Energy mass,
						      Energy width)
{
  int idin=part->id();
  for(unsigned int ix=0;ix<_intpart.size();++ix) {
    if(_intpart[ix] && _intpart[ix]->id()==idin) {
      _intmass[ix] =mass;_intwidth[ix]=width;
      _intmass2[ix]=mass*mass;_intmwidth[ix]=mass*width;
    }
  }
}

inline void DecayPhaseSpaceChannel::resetDaughter(int oldp,int newp)
{
  for(unsigned int ix=0;ix<_intdau1.size();++ix) {
    if(_intdau1[ix]==oldp) {
      _intdau1[ix]=newp;
    }
  }
  for(unsigned int ix=0;ix<_intdau2.size();++ix) {
    if(_intdau2[ix]==oldp) {
      _intdau2[ix]=newp;
    }
  }
}
}
