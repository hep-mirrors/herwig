// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DecayPhaseSpaceChannel class.
//
// Author: Peter Richardson
// 

namespace Herwig {
using namespace ThePEG;

// clone method
inline IBPtr DecayPhaseSpaceChannel::clone() const {
  return new_ptr(*this);
}
  
// full clone method
inline IBPtr DecayPhaseSpaceChannel::fullclone() const {
  return new_ptr(*this);
}

// generate the mass of an intermediate
inline Energy DecayPhaseSpaceChannel::generateMass(int ires,Energy lower,Energy upper) {
  Energy mass=0;
  if(lower>upper) throw DecayPhaseSpaceError() << "DecayPhaseSpaceChannel::generateMass"
					       << " not allowed" 
					       << Exception::eventerror;
  if(abs(lower-upper)/(lower+upper)>1e-10) {
    lower +=1e-10*(lower+upper);
    upper -=1e-10*(lower+upper);
  }
  else 
    return 0.5*(lower+upper);
  // use a Breit-Wigner
  if(_jactype[ires]==0) {
    double rhomin = atan((lower*lower-_intmass2[ires])/_intmwidth[ires]);
    double rhomax = atan((upper*upper-_intmass2[ires])/_intmwidth[ires])-rhomin;
    double rho = rhomin+rhomax*UseRandom::rnd();
    mass = sqrt(_intmass2[ires]+_intmwidth[ires]*tan(rho));
  }
  // use a power-law
  else if(_jactype[ires]==1) {
    double rhomin = pow(lower*lower,_intpower[ires]+1.);
    double rhomax = pow(upper*upper,_intpower[ires]+1.)-rhomin;
    double rho = rhomin+rhomax*UseRandom::rnd();
    mass = pow(rho,0.5/(_intpower[ires]+1.));
  }
  else if(_jactype[ires]==2) {
    mass = _intmass[ires];
  } 
  else {
    throw DecayPhaseSpaceError() << "Unknown type of Jacobian in " 
				 << "DecayPhaseSpaceChannel::generateMass" 
				 << Exception::eventerror;
  }
  if(mass<lower)      mass=lower+1e-10*(lower+upper);
  else if(mass>upper) mass=upper-1e-10*(lower+upper);
  return mass;
}
 
// return the weight for a given resonance
inline InvEnergy2 DecayPhaseSpaceChannel::massWeight(int ires, Energy moff,
						     Energy lower,Energy upper) {
  double wgt=0.;
  if(lower>upper) {
    throw DecayPhaseSpaceError() << "DecayPhaseSpaceChannel::massWeight not allowed" 
				 << ires << "   " << _intpart[ires]->id() << "   " 
				 << moff << Exception::eventerror;
  } 
  // use a Breit-Wigner 
  if(_jactype[ires]==0) { 
    double rhomin = atan((lower*lower-_intmass2[ires])/_intmwidth[ires]); 
    double rhomax = atan((upper*upper-_intmass2[ires])/_intmwidth[ires])-rhomin;
    Energy2 moff2=moff*moff-_intmass2[ires];
    wgt = _intmwidth[ires]/rhomax/(moff2*moff2+_intmwidth[ires]*_intmwidth[ires]);
  } 
  // power law
  else if(_jactype[ires]==1) {
    double rhomin = pow(lower*lower,_intpower[ires]+1.);
    double rhomax = pow(upper*upper,_intpower[ires]+1.)-rhomin;
    wgt = (_intpower[ires]+1.)/rhomax*pow(moff*moff,_intpower[ires]);
  }
  else if(_jactype[ires]==2) {
    wgt = 1./pi/_intmwidth[ires];
  } 
  else {
    throw DecayPhaseSpaceError() << "Unknown type of Jacobian in " 
				 << "DecayPhaseSpaceChannel::massWeight"
				 << Exception::eventerror;
  } 
  return wgt;
}

// add a new intermediate particle
inline void DecayPhaseSpaceChannel::addIntermediate(PDPtr part,int jac,double power,
						    int dau1,int dau2) {
  _intpart.push_back(part);
  _jactype.push_back(jac);
  _intpower.push_back(power);
  _intdau1.push_back(dau1); 
  _intdau2.push_back(dau2);
}

// reset the mass and width of an intermediate particle
inline void DecayPhaseSpaceChannel::resetIntermediate(tcPDPtr part,Energy mass,
						      Energy width) {
  int idin=part->id();
  for(unsigned int ix=0;ix<_intpart.size();++ix) {
    if(_intpart[ix] && _intpart[ix]->id()==idin) {
      _intmass[ix] =mass;_intwidth[ix]=width;
      _intmass2[ix]=mass*mass;_intmwidth[ix]=mass*width;
    }
  }
}

inline void DecayPhaseSpaceChannel::resetDaughter(int oldp,int newp) {
  for(unsigned int ix=0;ix<_intdau1.size();++ix) {
    if(_intdau1[ix]==oldp) {
      _intdau1[ix]=newp;
    }
  }
  for(unsigned int ix=0;ix<_intdau2.size();++ix) {
    if(_intdau2[ix]==oldp) {
      _intdau2[ix]=newp;
    }
  }
}
 
inline void DecayPhaseSpaceChannel::twoBodyDecay(const Lorentz5Momentum & p,                    
						 const Energy m1, const Energy m2,
						 Lorentz5Momentum & p1,
						 Lorentz5Momentum & p2 ) {
  static double eps=1e-6;
  double ctheta,phi;
  Kinematics::generateAngles(ctheta,phi);
  Vector3 unitDir1=Kinematics::unitDirection(ctheta,phi);
  Momentum3 pstarVector = unitDir1;
  Energy min=p.m();
  if ( min >= m1 + m2  &&  m1 >= 0.0  &&  m2 >= 0.0  ) {
    pstarVector *= Kinematics::pstarTwoBodyDecay(min,m1,m2);
  }
  else if( m1 >= 0.0  &&  m2 >= 0.0 &&(m1+m2-min)/(min+m1+m2)<eps) {
    pstarVector *=0.;
  }
  else {
    throw DecayPhaseSpaceError() << "Two body decay cannot proceed "
				 << "p = " << p / GeV 
				 << " p.m() = " << min / GeV
				 << " -> " << m1/GeV 
				 << ' ' << m2/GeV << Exception::eventerror;
  }
  p1 = Lorentz5Momentum(m1, pstarVector);
  p2 = Lorentz5Momentum(m2,-pstarVector);
  // boost from CM to LAB
  Vector3 bv=p.boostVector();
  p1.boost( bv );   
  p2.boost( bv );
}

}
