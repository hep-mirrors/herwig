// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DecayPhaseSpaceChannel class.
//
// Author: Peter Richardson
// 

namespace Herwig {
using namespace ThePEG;

// default constructor
inline DecayPhaseSpaceChannel::DecayPhaseSpaceChannel()  {}
  
inline DecayPhaseSpaceChannel::DecayPhaseSpaceChannel(const DecayPhaseSpaceChannel & x)
  : Interfaced(x) , _mode(x._mode),
    _intpart(x._intpart), _jactype(x._jactype), _intmass(x._intmass),
    _intwidth(x._intwidth), _intmass2(x._intmass2), _intmwidth(x._intmwidth),
    _intpower(x._intpower), _intdau1(x._intdau1), 
    _intdau2(x._intdau2), _intext(x._intext)
  {}
  
// clone method
inline IBPtr DecayPhaseSpaceChannel::clone() const {
  return new_ptr(*this);
}
  
// full clone method
inline IBPtr DecayPhaseSpaceChannel::fullclone() const {
  return new_ptr(*this);
}

// update method  
inline void DecayPhaseSpaceChannel::doupdate() throw(UpdateException) {
  Interfaced::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
  //  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
  //  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
  //  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
  //  touch()
  // Touch if anything has changed.
}
 
// do finish method 
inline void DecayPhaseSpaceChannel::dofinish() {
  Interfaced::dofinish();
}
  
// initrun method
inline void DecayPhaseSpaceChannel::doinitrun() {
  Interfaced::doinitrun();
}
  
// rebonid method  
inline void DecayPhaseSpaceChannel::rebind(const TranslationMap & trans)
  throw(RebindException) {
  //_mode = trans.translate(_mode);
  Interfaced::rebind(trans);
}
  
// get references method  
inline IVector DecayPhaseSpaceChannel::getReferences() {
  IVector ret = Interfaced::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// generate the mass of an intermediate
inline Energy DecayPhaseSpaceChannel::generateMass(int ires,Energy lower,Energy upper)
{
  Energy mass=0;
  if(lower>upper)
    {throw DecayPhaseSpaceError() << "DecayPhaseSpaceChannel::generateMass not allowed";}
  // use a Breit-Wigner
  if(_jactype[ires]==0)
    {
      double rhomin = atan((lower*lower-_intmass2[ires])/_intmwidth[ires]);
      double rhomax = atan((upper*upper-_intmass2[ires])/_intmwidth[ires])-rhomin;
      double rho = rhomin+rhomax*CurrentGenerator::current().rnd();
      mass = sqrt(_intmass2[ires]+_intmwidth[ires]*tan(rho));
    }
  // use a power-law
  else if(_jactype[ires]==1)
    {
      double rhomin = pow(lower*lower,_intpower[ires]+1.);
      double rhomax = pow(upper*upper,_intpower[ires]+1.)-rhomin;
      double rho = rhomin+rhomax*CurrentGenerator::current().rnd();
      mass = pow(rho,0.5/(_intpower[ires]+1.));
    }
  else if(_jactype[ires]==2)
    {mass = _intmass[ires];}
  else
    {throw DecayPhaseSpaceError() << "Unknown type of Jacobian in " 
				  << "DecayPhaseSpaceChannel::generateMass";}
  return mass;
}
 
// return the weight for a given resonance
inline InvEnergy2 DecayPhaseSpaceChannel::massWeight(int ires, Energy moff,
						     Energy lower,Energy upper)
{
  double wgt=0.;
  if(lower>upper) 
    {throw DecayPhaseSpaceError() << "DecayPhaseSpaceChannel::massWeight not allowed" 
				  << ires << "   " << _intpart[ires]->id() << "   " 
				  << moff;} 
  // use a Breit-Wigner 
  if(_jactype[ires]==0) 
    { 
      double rhomin = atan((lower*lower-_intmass2[ires])/_intmwidth[ires]); 
      double rhomax = atan((upper*upper-_intmass2[ires])/_intmwidth[ires])-rhomin;
      Energy2 moff2=moff*moff-_intmass2[ires];
      wgt = _intmwidth[ires]/rhomax/(moff2*moff2+_intmwidth[ires]*_intmwidth[ires]);
    } 
  // power law
  else if(_jactype[ires]==1)
    {
      double rhomin = pow(lower*lower,_intpower[ires]+1.);
      double rhomax = pow(upper*upper,_intpower[ires]+1.)-rhomin;
      wgt = (_intpower[ires]+1.)/rhomax*pow(moff*moff,_intpower[ires]);
    }
  else if(_jactype[ires]==2)
    {
      wgt = 1./pi/_intmwidth[ires];
    }
  else 
    {throw DecayPhaseSpaceError() << "Unknown type of Jacobian in " 
				  << "DecayPhaseSpaceChannel::massWeight";} 
  return wgt;
}

// add a new intermediate particle
inline void DecayPhaseSpaceChannel::addIntermediate(PDPtr part,int jac,double power,
						    int dau1,int dau2)
{
  _intpart.push_back(part);
  _jactype.push_back(jac);
  _intpower.push_back(power);
  _intdau1.push_back(dau1); 
  _intdau2.push_back(dau2);
}

// reset the mass and width of an intermediate particle
inline void DecayPhaseSpaceChannel::resetIntermediate(tcPDPtr part,Energy mass,
						      Energy width)
{
  int idin=part->id();
  for(unsigned int ix=0;ix<_intpart.size();++ix)
    {if(_intpart[ix] && _intpart[ix]->id()==idin)
	{_intmass[ix] =mass;_intwidth[ix]=width;
	  _intmass2[ix]=mass*mass;_intmwidth[ix]=mass*width;}}
}

inline void DecayPhaseSpaceChannel::resetDaughter(int oldp,int newp)
{
  for(unsigned int ix=0;ix<_intdau1.size();++ix)
    {if(_intdau1[ix]==oldp){_intdau1[ix]=newp;}}
  for(unsigned int ix=0;ix<_intdau2.size();++ix)
    {if(_intdau2[ix]==oldp){_intdau2[ix]=newp;}}
}
}
