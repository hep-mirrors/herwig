// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Tau2MesonDecayer class.
//
//  Author: Peter Richardson
//

namespace Herwig {

using namespace ThePEG;

inline Tau2MesonDecayer::Tau2MesonDecayer() 
{
  // the weights of the different resonances in the matrix elements
  _piwgt.push_back(1.0);_piwgt.push_back(-0.167);_piwgt.push_back(0.05);
  _kwgt.push_back(1.0);_kwgt.push_back(-0.038);_kwgt.push_back(0.00);
  // models to use
  _pimodel = 0;_Kmodel=0;
  // parameter for the masses (use the parameters freom the CLEO fit 
  // rather than the PDG masses etc)
  _rhoparameters=true;
  _rhomasses.push_back(774.6*MeV);_rhomasses.push_back(1408*MeV);
  _rhomasses.push_back(1700*MeV);
  _rhowidths.push_back(149*MeV);_rhowidths.push_back(502*MeV);
  _rhowidths.push_back(235*MeV);
  _Kstarparameters=true;
  _Kstarmasses.push_back(0.89159*GeV);_Kstarmasses.push_back(1.700*GeV);
  _Kstarwidths.push_back(0.0498 *GeV);_Kstarwidths.push_back(0.235*GeV);
  // the channels for the different
  // pion modes 
  _pichannels.push_back(true) ; _pichannels.push_back(false);
  _pichannels.push_back(true) ; _pichannels.push_back(false);
  _pichannels.push_back(true) ; _pichannels.push_back(false);
  _pichannels.push_back(false); _pichannels.push_back(false);
  _pichannels.push_back(false); _pichannels.push_back(false);
  _pichannels.push_back(false); _pichannels.push_back(false); 
  _piwgts.push_back(0.659355); _piwgts.push_back(0.000000);
  _piwgts.push_back(0.250411); _piwgts.push_back(0.000000);
  _piwgts.push_back(0.090234); _piwgts.push_back(0.000000);
  _piwgts.push_back(0.000000); _piwgts.push_back(0.000000);
  _piwgts.push_back(0.000000); _piwgts.push_back(0.000000);
  _piwgts.push_back(0.000000); _piwgts.push_back(0.000000);
  // K0 channels
  _K0channels.push_back(false); _K0channels.push_back(false);
  _K0channels.push_back(false); _K0channels.push_back(false);
  _K0channels.push_back(false); _K0channels.push_back(false);
  _K0channels.push_back(false); _K0channels.push_back(true); 
  _K0channels.push_back(false); _K0channels.push_back(true); 
  _K0channels.push_back(false); _K0channels.push_back(true); 
  _K0wgts.push_back(0.000000); _K0wgts.push_back(0.000000);
  _K0wgts.push_back(0.000000); _K0wgts.push_back(0.000000);
  _K0wgts.push_back(0.000000); _K0wgts.push_back(0.000000);
  _K0wgts.push_back(0.000000); _K0wgts.push_back(0.654200);
  _K0wgts.push_back(0.000000); _K0wgts.push_back(0.144858);
  _K0wgts.push_back(0.000000); _K0wgts.push_back(0.200942);
  // Kplus channels
  _Kpluschannels.push_back(false); _Kpluschannels.push_back(false);
  _Kpluschannels.push_back(false); _Kpluschannels.push_back(false);
  _Kpluschannels.push_back(false); _Kpluschannels.push_back(false);
  _Kpluschannels.push_back(true) ; _Kpluschannels.push_back(false); 
  _Kpluschannels.push_back(true) ; _Kpluschannels.push_back(false); 
  _Kpluschannels.push_back(true) ; _Kpluschannels.push_back(false);
  _Kpluswgts.push_back(0.000000); _Kpluswgts.push_back(0.000000);
  _Kpluswgts.push_back(0.000000); _Kpluswgts.push_back(0.000000);
  _Kpluswgts.push_back(0.000000); _Kpluswgts.push_back(0.000000);
  _Kpluswgts.push_back(0.657559); _Kpluswgts.push_back(0.000000); 
  _Kpluswgts.push_back(0.143210); _Kpluswgts.push_back(0.000000); 
  _Kpluswgts.push_back(0.199231); _Kpluswgts.push_back(0.000000);
  // KK channels
  _KKchannels.push_back(false); _KKchannels.push_back(true);
  _KKchannels.push_back(false); _KKchannels.push_back(true);
  _KKchannels.push_back(false); _KKchannels.push_back(true);
  _KKchannels.push_back(false); _KKchannels.push_back(false); 
  _KKchannels.push_back(false); _KKchannels.push_back(false); 
  _KKchannels.push_back(false); _KKchannels.push_back(false);
  _KKwgts.push_back(0.000000); _KKwgts.push_back(0.439488);
  _KKwgts.push_back(0.000000); _KKwgts.push_back(0.413532);
  _KKwgts.push_back(0.000000); _KKwgts.push_back(0.146980);
  _KKwgts.push_back(0.000000); _KKwgts.push_back(0.000000); 
  _KKwgts.push_back(0.000000); _KKwgts.push_back(0.000000); 
  _KKwgts.push_back(0.000000); _KKwgts.push_back(0.000000);
  // maximum weights
  _pimax   =2.07242e-09;
  _K0max   =7.13254e-11;
  _Kplusmax=3.70648e-11;
  _KKmax   =1.90668e-11;
}
  
inline Tau2MesonDecayer::Tau2MesonDecayer(const Tau2MesonDecayer & x)
  : TauDecayerBase(x),_piwgt(x._piwgt), _kwgt(x._kwgt),
    _pimodel(x._pimodel), _Kmodel(x._Kmodel),
    _pichannels(x._pichannels), _K0channels(x._K0channels), 
    _Kpluschannels(x._Kpluschannels),_KKchannels(x._KKchannels),
    _piwgts(x._piwgts),_K0wgts(x._K0wgts),
    _Kpluswgts(x._Kpluswgts),_KKwgts(x._KKwgts),
    _pimax(x._pimax),_K0max(x._K0max),_Kplusmax(x._Kplusmax),_KKmax(x._KKmax),
    _rhoparameters(x._rhoparameters), _rhomasses(x._rhomasses),
    _rhowidths(x._rhowidths), _Kstarparameters(x._Kstarparameters),
    _Kstarmasses(x._Kstarmasses),_Kstarwidths(x._Kstarwidths), _mass(x._mass),
    _width(x._width), _mass2(x._mass2), _massw(x._massw), _massa(x._massa),
    _massb(x._massb), _mom(x._mom), _dhdq2(x._dhdq2), _hm2(x._hm2), _dparam(x._dparam)
{}

inline IBPtr Tau2MesonDecayer::clone() const {
  return new_ptr(*this);
}

inline IBPtr Tau2MesonDecayer::fullclone() const {
  return new_ptr(*this);
}

inline void Tau2MesonDecayer::doupdate() throw(UpdateException) {
  TauDecayerBase::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
  //  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
  //  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
  //  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
  //  touch()
  // Touch if anything has changed.
}
  
inline void Tau2MesonDecayer::doinit() throw(InitException) {
  TauDecayerBase::doinit();
  // set up for the integration channels
  // set the external particles for pion mode
  tPDPtr tau = getParticleData(ParticleID::tauminus);
  PDVector extpart;
  extpart.push_back(tau);
  extpart.push_back(getParticleData(ParticleID::nu_tau));
  extpart.push_back(getParticleData(ParticleID::piminus));
  extpart.push_back(getParticleData(ParticleID::pi0));
  // set the external particles for the charged kaon mode
  PDVector extparta;
  extparta.push_back(tau);
  extparta.push_back(getParticleData(ParticleID::nu_tau));
  extparta.push_back(getParticleData(ParticleID::Kminus));
  extparta.push_back(getParticleData(ParticleID::pi0));
  //set the external particles for the neutral kaon mode
  PDVector extpartb;
  extpartb.push_back(tau);
  extpartb.push_back(getParticleData(ParticleID::nu_tau));
  extpartb.push_back(getParticleData(ParticleID::Kbar0));
  extpartb.push_back(getParticleData(ParticleID::piminus));
  // set the external particles for the two kaon mode
  PDVector extpartc;
  extpartc.push_back(tau);
  extpartc.push_back(getParticleData(ParticleID::nu_tau));
  extpartc.push_back(getParticleData(ParticleID::Kminus));
  extpartc.push_back(getParticleData(ParticleID::K0));
  tPDPtr res[6]={getParticleData(-213),getParticleData(-100213),getParticleData(-30213),
		 getParticleData(-323),getParticleData(-100323),getParticleData(-30323)};
  for(unsigned int ix=0;ix<6;++ix)
    {
      // enter the parameters
      if(res[ix])
	{
	  if(ix<3)
	    {
	      // set up integration channels for rho -> pi pi and rho -> K K
	      Ptr<Herwig::DecayPhaseSpaceChannel>::pointer
		newchannela= new_ptr(DecayPhaseSpaceChannel());
	      Ptr<Herwig::DecayPhaseSpaceChannel>::pointer
		newchannelb = new_ptr(DecayPhaseSpaceChannel());
	      newchannela->addIntermediate(tau    ,0,0.0,-1,1);
	      newchannelb->addIntermediate(tau    ,0,0.0,-1,1);
	      newchannela->addIntermediate(res[ix],0,0.0,2,3);
	      newchannelb->addIntermediate(res[ix],0,0.0,2,3);
	      newchannela->setExternal(extpart);
	      newchannela->init();
	      addChannel(newchannela);
	      newchannelb->setExternal(extpartc);
	      newchannelb->init();
	      addChannel(newchannelb);
	      }
	    else
	      {
		// set up integration channels for K* -> K pi
		Ptr<Herwig::DecayPhaseSpaceChannel>::pointer
		  newchannela = new_ptr(DecayPhaseSpaceChannel());
		Ptr<Herwig::DecayPhaseSpaceChannel>::pointer
		  newchannelb = new_ptr(DecayPhaseSpaceChannel());
		newchannela->addIntermediate(tau    ,0,0.0,-1,1);
		newchannelb->addIntermediate(tau    ,0,0.0,-1,1);
		newchannela->addIntermediate(res[ix],0,0.0,2,3);
		newchannelb->addIntermediate(res[ix],0,0.0,2,3);
		newchannela->setExternal(extparta);
		newchannela->init();
		addChannel(newchannela);
		newchannelb->setExternal(extpartb);
		newchannelb->init();
		addChannel(newchannelb);
	      }
	  }
      }
    // set the channels etc
    setMode(0,_pimax,_pichannels,_piwgts);
    setMode(1,_K0max,_K0channels,_K0wgts);
    setMode(2,_Kplusmax,_Kpluschannels,_Kpluswgts);
    setMode(3,_KKmax,_KKchannels,_KKwgts);
    // reset the masses in the form-factors and intergrators if needed
    // first the rho resonaces
    if(_rhoparameters)
      {
	for(unsigned int ix=0;ix<3;++ix)
	  {
	    if(ix<_rhomasses.size())
	      {
		for(unsigned int iy=0;iy<numberChannels();++iy)
		  {resetIntermediate(iy,res[ix],_rhomasses[ix],_rhowidths[ix]);}
	      }
	    else
	      {
		_rhomasses.push_back(res[ix]->mass() );
		_rhowidths.push_back(res[ix]->width());
	      }
	  }
      }
    else
      {
	for(unsigned int ix=0;ix<3;++ix)
	  {
	    if(ix<_rhomasses.size())
	      {
		_rhomasses[ix]=res[ix]->mass();
		_rhowidths[ix]=res[ix]->width();
	      }
	    else
	      {
		_rhomasses.push_back(res[ix]->mass() );
		_rhowidths.push_back(res[ix]->width());
	      }
	  }
      }
    // then the Kstar resonances
    if(_Kstarparameters)
      {
	for(unsigned int ix=0;ix<3;++ix)
	  {
	    if(ix<_Kstarmasses.size())
	      {
		for(unsigned int iy=0;iy<numberChannels();++iy)
		  {resetIntermediate(iy,res[ix+3],_Kstarmasses[ix],_Kstarwidths[ix]);}
	      }
	    else
	      {
		_Kstarmasses.push_back(res[ix+3]->mass());
		_Kstarwidths.push_back(res[ix+3]->width());
	      }
	  }
      }
    else
      {
	for(unsigned int ix=0;ix<3;++ix)
	  {
	    if(ix<_Kstarmasses.size())
	      {
		_Kstarmasses[ix]=res[ix+3]->mass();
		_Kstarwidths[ix]=res[ix+3]->width();
	      }
	    else
	      {
		_Kstarmasses.push_back(res[ix+3]->mass());
		_Kstarwidths.push_back(res[ix+3]->width());
	      }
	  }
      }
    // set up for the Breit Wigners
    Energy mpi0    = getParticleData(ParticleID::pi0)->mass();
    Energy mpiplus = getParticleData(ParticleID::piplus)->mass();
    Energy mk0     = getParticleData(ParticleID::K0)->mass();
    // rho resonances
    for(unsigned int ix=0;ix<3;++ix)
      {
	_mass.push_back(_rhomasses[ix]);
	_width.push_back(_rhowidths[ix]);
	_mass2.push_back(_mass[ix]*_mass[ix]);
	_massw.push_back(_mass[ix]*_width[ix]);
	_massa.push_back(mpi0);
	_massb.push_back(mpiplus);
	_mom.push_back(pcm(ix,_mass[ix]));
	_hm2.push_back(GSModelhFunction(ix,_mass[ix]));
	_dparam.push_back(GSModelDParameter(ix));
	_dhdq2.push_back(GSModeldhdq2Parameter(ix));
      }
    // Kstar resonances
    for(unsigned int ix=0;ix<3;++ix)
      {
	_mass.push_back(_Kstarmasses[ix]);
	_width.push_back(_Kstarwidths[ix]);
	_mass2.push_back(_mass[ix+3]*_mass[ix+3]);
	_massw.push_back(_mass[ix+3]*_width[ix+3]);
	_massa.push_back(mk0);
	_massb.push_back(mpiplus);
	_mom.push_back(pcm(ix+3,_mass[ix+3]));
	_hm2.push_back(GSModelhFunction(ix+3,_mass[ix+3]));
	_dparam.push_back(GSModelDParameter(ix+3));
	_dhdq2.push_back(GSModeldhdq2Parameter(ix+3));
      }
}

  inline void Tau2MesonDecayer::dofinish() {
    TauDecayerBase::dofinish();
  }
  
  inline void Tau2MesonDecayer::doinitrun() {
    TauDecayerBase::doinitrun();
    // now initialise the multichannel integration
    PDVector particles;
    particles.push_back(getParticleData(ParticleID::tauminus));
    particles.push_back(getParticleData(ParticleID::nu_tau));
    // initialise the pi+/- pi0 channel
    particles.push_back(getParticleData(ParticleID::piminus));
    particles.push_back(getParticleData(ParticleID::pi0));
    cout << "testing initialisation of the first mode" << endl;
    initializePhaseSpace(0,particles);
    cout << "testing got back" << endl;
    // initialize the K0 pi- channel
    particles[2] = getParticleData(ParticleID::Kbar0);
    particles[3] = getParticleData(ParticleID::piminus);
    initializePhaseSpace(1,particles);
    // initialise the K- pi0 channel
    particles[2] = getParticleData(ParticleID::Kminus);
    particles[3] = getParticleData(ParticleID::pi0);
    initializePhaseSpace(2,particles);
    // initialize the K- K0 channel
    particles[2] = getParticleData(ParticleID::Kminus);
    particles[3] = getParticleData(ParticleID::K0);
    initializePhaseSpace(3,particles);
  }
  
  inline void Tau2MesonDecayer::rebind(const TranslationMap & trans)
    throw(RebindException) {
    // dummy = trans.translate(dummy);
    TauDecayerBase::rebind(trans);
  }
  
  inline IVector Tau2MesonDecayer::getReferences() {
    IVector ret = TauDecayerBase::getReferences();
    // ret.push_back(dummy);
    return ret;
  }

// the decay momentum
inline Energy Tau2MesonDecayer::pcm(const unsigned int ix,const  Energy q) const 
{
  Energy2 q2=q*q;
  Energy output;
  if(q>_massa[ix]+_massb[ix])
    {
      output =  0.5/q*sqrt((q2-(_massa[ix]+_massb[ix])*(_massa[ix]+_massb[ix]))*
			   (q2-(_massa[ix]-_massb[ix])*(_massa[ix]-_massb[ix])));
    }
  else{output=0;}
  return output;
}

// the h function in the GS model
inline double Tau2MesonDecayer::GSModelhFunction(const unsigned int ix,
					       const Energy q)const 
{
  Energy pq=pcm(ix,q);
  return _width[ix]*_mass2[ix]/(_mom[ix]*_mom[ix]*_mom[ix])
    *2.*pq/pi/q*log((q+2.*pq)/(_massa[ix]+_massb[ix]));
}
  
// the dh/dq2 in the GS model for the propagator
inline double Tau2MesonDecayer::GSModeldhdq2Parameter(const unsigned int ix) const 
{
  Energy mpi=0.5*(_massa[ix]+_massb[ix]);
  return _width[ix]/pi/_mom[ix]/_mom[ix]/_mom[ix]*
    (mpi*mpi/_mass[ix]/_mom[ix]*log(0.5*(_mass[ix]+2.*_mom[ix])/mpi)+0.5);
  }

// the D parameter of the GS model
inline double Tau2MesonDecayer::GSModelDParameter(const unsigned int ix) const 
{
  Energy mpi=0.5*(_massa[ix]+_massb[ix]);
  return 3.*mpi*mpi/pi/_mom[ix]/_mom[ix]*log(0.5*(_mass[ix]+2.*_mom[ix])/mpi)
    +0.5*_mass[ix]/pi/_mom[ix]-mpi*mpi*_mass[ix]/pi/_mom[ix]/_mom[ix]/_mom[ix];
}

// calculate the p-wave Breit Wigner
  // imodel is the model 0= normal running width, 1= GS model
  // itype 0=rho+-, 1=K*+-
Complex Tau2MesonDecayer::BreitWigner(Energy2 q2, unsigned int imodel,
				      unsigned int itype, unsigned int ires) const 
{
  // workout the index of the resonace
  unsigned int iy = 3*itype+ires;
  // off shell mass
  Energy q=sqrt(q2);
  // and the running width
  Energy pq=pcm(iy,q);
  double ratio=pq/_mom[iy];ratio=ratio*ratio*ratio;
  Energy gamrun = _width[iy]*_mass[iy]*ratio/q;
  // work out the denominator
  complex<Energy2> denom;
  Complex numer;
  Complex ii(0.,1.);
  if(imodel==0)
    {
      denom=q2-_mass2[iy]+ii*_mass[iy]*gamrun;
      numer=-_mass2[iy];
    }
  else if(imodel==1)
    {
      denom=q2-_mass2[iy]+ii*_mass[iy]*gamrun
	-( pq*pq*(GSModelhFunction(iy,q)-_hm2[iy])
	   -_mom[iy]*_mom[iy]*(q2-_mass2[iy])*_dhdq2[iy]);
      numer=-(_mass2[iy]+_dparam[iy]*_mass[iy]*_width[iy]);
    }
  else
    {
      cerr << "Unknown model in Tau2MesonDecayer::BreitWigner" << endl;
      return 0.;
    }
  // return the answer
  return numer/denom;
}




}
