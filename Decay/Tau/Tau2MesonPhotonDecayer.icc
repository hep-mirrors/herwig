// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Tau2MesonPhoton class.
//
//  Author: Peter Richardson
//

namespace Herwig {

using namespace ThePEG;

inline Tau2MesonPhotonDecayer::Tau2MesonPhotonDecayer() 
{
  // parameters for the integration
  for(unsigned int ix=0;ix<3;++ix){_on.push_back(true);}
  _weights.push_back(0.192018);_weights.push_back(0.265351);_weights.push_back(0.542631);
  _maxwgt=1.49478e-11;
  _resweights.push_back(1.0);_resweights.push_back(-0.1);_resweights.push_back(0.0);
  // parameters of the rho resonaces
  _rhoparameters=true;
  _rhomasses.push_back(0.773*GeV);_rhomasses.push_back(1.70*GeV);
  _rhowidths.push_back(0.145*GeV);_rhowidths.push_back(0.26*GeV);
  // parameters fo the omega resonance
  _omegaparameters=true;
  _omegamass=782*MeV;_omegawidth=8.5*MeV;
  // couplings
  _grho   = 0.11238947*GeV2;
  _grhoomegapi = 12.924/GeV;
}
  
inline Tau2MesonPhotonDecayer::Tau2MesonPhotonDecayer(const Tau2MesonPhotonDecayer & x)
  : TauDecayerBase(x), _grho(x._grho), _grhoomegapi(x._grhoomegapi),
    _resweights(x._resweights),
    _on(x._on), _weights(x._weights), _maxwgt(x._maxwgt),
    _rhoparameters(x._rhoparameters),
    _rhomasses(x._rhomasses),_rhowidths(x._rhowidths),
    _omegaparameters(x._omegaparameters),
    _omegamass(x. _omegamass),_omegawidth(x._omegawidth)
{}


inline IBPtr Tau2MesonPhotonDecayer::clone() const {
  return new_ptr(*this);
}

inline IBPtr Tau2MesonPhotonDecayer::fullclone() const {
  return new_ptr(*this);
}

inline void Tau2MesonPhotonDecayer::doupdate() throw(UpdateException) {
  TauDecayerBase::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
  //  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
  //  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
  //  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
  //  touch()
  // Touch if anything has changed.
}

inline void Tau2MesonPhotonDecayer::doinit() throw(InitException) {
  TauDecayerBase::doinit();
  // set up the integration channels
  // set the external particles
  PDVector extpart;
  extpart.push_back(getParticleData(ParticleID::tauminus));
  extpart.push_back(getParticleData(ParticleID::nu_tau));
  extpart.push_back(getParticleData(ParticleID::piminus));
  extpart.push_back(getParticleData(ParticleID::pi0));
  extpart.push_back(getParticleData(ParticleID::gamma));
  tPDPtr omega=getParticleData(ParticleID::omega);
  tPDPtr temp;
  for(unsigned int ix=0;ix<3;++ix)
    {
      if(ix==0)
	{temp = getParticleData(-213);}
      else if(ix==1)
	{temp = getParticleData(-100213);}
      else if(ix==2)
	{temp = getParticleData(-30213);}
      if(temp)
	{
	  Ptr<Herwig::DecayPhaseSpaceChannel>::pointer
	    newchannel= new_ptr(DecayPhaseSpaceChannel());
	  newchannel->addIntermediate(getParticleData(ParticleID::tauminus),
				      0,0.0,-1,1);
	  newchannel->addIntermediate(temp,0,0.0,-2,2);
	  newchannel->addIntermediate(omega,0,0.0,3,4);
	  newchannel->setExternal(extpart);
	  newchannel->init();
	  addChannel(newchannel);
	}
    }
  cout << "testing setting the rho massesA" << _rhomasses.size() << endl;
  // set up the rho masses and widths
  for(unsigned int ix=0;ix<3;++ix)
    {
      if(ix==0){temp = getParticleData(-213);}
      else if(ix==1){temp = getParticleData(-100213);}
      else if(ix==2){temp = getParticleData(-30213);}
      // if using local values
      if(_rhoparameters&&ix<_rhomasses.size())
	{
	  for(unsigned int iy=0;iy<numberChannels();++iy)
	    {resetIntermediate(iy,temp,_rhomasses[ix],_rhowidths[ix]);}
	}
      else if(ix<_rhomasses.size())
	{
	  _rhomasses[ix]=temp->mass();
	  _rhowidths[ix]=temp->width();
	}
      else
	{
	  cout << "testing adding" << ix << endl;
	  _rhomasses.push_back(temp->mass());
	  _rhowidths.push_back(temp->width());
	}
    }
  cout << "testing setting the rho masses" << _rhomasses.size() << endl;
  // set up the omega masses and widths
  if(_omegaparameters)
    {
      for(unsigned int iy=0;iy<numberChannels();++iy)
	{resetIntermediate(iy,omega,_omegamass,_omegawidth);}
    }
  else
    {
      _omegamass  = omega->mass();
      _omegawidth = omega->width();
    }
  // set up the integration
  setMode(0,_maxwgt,_on,_weights);
}

inline void Tau2MesonPhotonDecayer::dofinish() {
  TauDecayerBase::dofinish();
}

inline void Tau2MesonPhotonDecayer::doinitrun() {
  TauDecayerBase::doinitrun();
  // now initialise the multichannel integration
  PDVector particles;
  particles.push_back(getParticleData(ParticleID::tauminus));
  particles.push_back(getParticleData(ParticleID::nu_tau));
  particles.push_back(getParticleData(ParticleID::piminus));
  particles.push_back(getParticleData(ParticleID::pi0));
  particles.push_back(getParticleData(ParticleID::gamma));
  initializePhaseSpace(0,particles);
}

inline void Tau2MesonPhotonDecayer::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  TauDecayerBase::rebind(trans);
}

inline IVector Tau2MesonPhotonDecayer::getReferences() {
  IVector ret = TauDecayerBase::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// calculate the F function at a given scale (0 is charged rho and 1 is neutral rho) 
inline complex<double> Tau2MesonPhotonDecayer::FFunction(Energy2 q2,int iext) const
{
  Complex output=0;
  if(iext<0)
    {for(unsigned int ix=0, N=_resweights.size(); ix<N && ix <3;++ix)
	{output-=_resweights[ix]*BreitWigner(q2,ix);}}
  else
    {
      unsigned int temp=iext;
      if(temp<_resweights.size()&&iext <3)
	  {output=_resweights[iext]*BreitWigner(q2,iext);}
    }
  output*=_grho*_grhoomegapi*sqrt(2.);
  return output;
  }

// fixed width Breit wigner
inline Complex Tau2MesonPhotonDecayer::BreitWigner(Energy2 q2,unsigned int ires) const
{
  static const Complex ii(0.,1.);
  Complex denom;
  if(ires<_rhomasses.size())
    {denom = q2-_rhomasses[ires]*_rhomasses[ires]+ii*_rhomasses[ires]*_rhowidths[ires];}
  else if(ires==10)
    {denom = q2-_omegamass*_omegamass+ii*_omegamass*_omegawidth;}
  else
    {
      cerr << "Unknown resonace in Tau2MesonPhotonDecayer::BreitWigner" << ires << endl;
      return 0.;
    }
  return 1./denom;
}

}
