// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the KaonThreeMesonCurrent class.
//

namespace Herwig {

inline IBPtr KaonThreeMesonCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr KaonThreeMesonCurrent::fullclone() const {
  return new_ptr(*this);
}

inline Complex KaonThreeMesonCurrent::OmegaPhiBreitWigner(Energy q2,
							  unsigned int ires) const {
  Energy2 m2,mg;
  if(ires==0) {
    m2=sqr(_omegamass);
    mg=_omegamass*_omegawidth;
  }
  else {
    m2=sqr(_phimass);
    mg=_phimass*_phiwidth;
  }
  return (-m2+Complex(0.,1.)*mg)/(q2-m2+Complex(0.,1.)*mg);
}
 
inline Complex KaonThreeMesonCurrent::Tomega(Energy q2, int ires) const{
  double denom=(1.+_epsomega);
  Complex num(0.);
  if(ires<0) num=OmegaPhiBreitWigner(q2,0)+_epsomega*OmegaPhiBreitWigner(q2,1);
  else if(ires==0) num=OmegaPhiBreitWigner(q2,0);
  else             num=OmegaPhiBreitWigner(q2,1);
  return num/denom;
}

inline Complex KaonThreeMesonCurrent::K1BreitWigner(Energy2 q2,
						    unsigned int ires) const {
  if(ires>=_k1mass.size()) return 0.;
  Energy2 m2=sqr(_k1mass[ires]),mg=_k1mass[ires]*_k1width[ires];
  return (-m2+Complex(0.,1.)*mg)/(q2-m2+Complex(0.,1.)*mg);
}

inline Complex KaonThreeMesonCurrent::TK1(Energy2 q2,
					  unsigned int iopt,int ires) const {
  Complex denom(0),num(0.);
  if(iopt==0) {
    for(unsigned int ix=0;ix<_k1wgta.size();++ix) denom+=_k1wgta[ix];
    if(ires==-1) {
      for(unsigned int ix=0;ix<_k1wgta.size();++ix) 
	num+=_k1wgta[ix]*K1BreitWigner(q2,ix);
    }
    else {	
      num+=_k1wgta[ires]*K1BreitWigner(q2,ires);
    }
  }
  else if(iopt==1) {
    for(unsigned int ix=0;ix<_k1wgtb.size();++ix) denom+=_k1wgtb[ix];
    if(ires==-1) {
      for(unsigned int ix=0;ix<_k1wgtb.size();++ix) 
	num+=_k1wgtb[ix]*K1BreitWigner(q2,ix);
    }
    else {	
      num+=_k1wgtb[ires]*K1BreitWigner(q2,ires);
    }
  }
  else {
    return 0.;
  }
  return num/denom;
}

inline Complex KaonThreeMesonCurrent::BWrho1(Energy2 q2, unsigned int ires) const {
  if(ires>=_rho1mass.size()) return 0.;
  Energy mass  = _rho1mass [ires];
  Energy width = _rho1width[ires];
  Energy q=sqrt(q2);
  Energy pcm0 = Kinematics::pstarTwoBodyDecay(mass,_mpi,_mpi);
  Energy pcm  = q<=2.*_mpi ? 0.*GeV : Kinematics::pstarTwoBodyDecay(q,_mpi,_mpi);
  double ratio(pcm/pcm0);ratio*=ratio*ratio;
  Energy2 gam(width*mass*ratio/q);
  return sqr(mass)/(sqr(mass)-q2-Complex(0.,1.)*mass*gam);
}

inline Complex KaonThreeMesonCurrent::BWrho2(Energy2 q2, unsigned int ires) const {
  if(ires>=_rho2mass.size()) return 0.;
  Energy mass  = _rho2mass [ires];
  Energy width = _rho2width[ires];
  Energy q=sqrt(q2);
  Energy pcm0 = Kinematics::pstarTwoBodyDecay(mass,_mpi,_mpi);
  Energy pcm  = q<=2.*_mpi ? 0.*GeV : Kinematics::pstarTwoBodyDecay(q,_mpi,_mpi);
  double ratio(pcm/pcm0);ratio*=ratio*ratio;
  Energy2 gam(width*mass*ratio/q);
  return sqr(mass)/(sqr(mass)-q2-Complex(0.,1.)*mass*gam);
}

inline Complex KaonThreeMesonCurrent::BWKstar1(Energy2 q2, unsigned int ires) const {
  if(ires>=_kstar1mass.size()) return 0.;
  Energy mass  = _kstar1mass [ires];
  Energy width = _kstar1width[ires];
  Energy q=sqrt(q2);
  Energy pcm0 = Kinematics::pstarTwoBodyDecay(mass,_mK,_mpi);
  Energy pcm  = q<=_mpi+_mK ? 0.*GeV : Kinematics::pstarTwoBodyDecay(q,_mK,_mpi);
  double ratio(pcm/pcm0);ratio*=ratio*ratio;
  Energy2 gam(width*mass*ratio/q);
  return sqr(mass)/(sqr(mass)-q2-Complex(0.,1.)*mass*gam);
}

inline Complex KaonThreeMesonCurrent::BWKstar2(Energy2 q2, unsigned int ires) const {
  if(ires>=_kstar2mass.size()) return 0.;
  Energy mass  = _kstar2mass [ires];
  Energy width = _kstar2width[ires];
  Energy q=sqrt(q2);
  Energy pcm0 = Kinematics::pstarTwoBodyDecay(mass,_mK,_mpi);
  Energy pcm  = q<=_mpi+_mK ? 0.*GeV : Kinematics::pstarTwoBodyDecay(q,_mK,_mpi);
  double ratio(pcm/pcm0);ratio*=ratio*ratio;
  Energy2 gam(width*mass*ratio/q);
  return sqr(mass)/(sqr(mass)-q2-Complex(0.,1.)*mass*gam);
}

inline Energy KaonThreeMesonCurrent::a1Width(Energy2 q2) const {
  Energy output;
  if(!_a1opt) output = _a1mass*_a1width*g(q2)/g(_a1mass*_a1mass)/sqrt(q2);
  else        output=(*_a1runinter)(q2);
  return output;
}

inline Complex  KaonThreeMesonCurrent::a1BreitWigner(Energy2 q2) const {
  Complex ii(0.,1.);
  Energy2 m2(_a1mass*_a1mass);
  Energy  q(sqrt(q2));
  return m2/(m2-q2-ii*q*a1Width(q2));
}

inline double KaonThreeMesonCurrent::g(Energy2 q2) const {
  double output;
  if(q2<9.*_mpi*_mpi) {
    output=0.;
  }
  else if(q2<sqr(_rho1mass[0]+_mpi)) {
    double diff=(q2-9.*_mpi*_mpi)/GeV2;
    
    output=4.1*sqr(diff)*diff*(1.-3.3*diff+5.8*sqr(diff));
  }
  else {
    double ratio = q2/GeV2;
    output = ratio*(1.623+10.38/ratio-9.32/sqr(ratio)+0.65/(ratio*sqr(ratio)));
  }
  return output;
}

// matrix element for the running a_1 width
inline double KaonThreeMesonCurrent::
threeBodyMatrixElement(const int,  const Energy2 q2,
		       const Energy2 s3, const Energy2 s2, 
		       const Energy2 s1, const Energy, 
		       const Energy, const Energy) const {
  Energy2 mpi2(sqr(_mpi));
  Complex propb(Trho1(s1,-1)),propa(Trho1(s2,-1)); 
  // the matrix element
  double output(0.); 
  // first resonance
  output+= ((s1-4.*mpi2)+0.25*(s3-s2)*(s3-s2)/q2)*real(propb*conj(propb)); 
  // second resonance
  output+= ((s2-4.*mpi2)+0.25*(s3-s1)*(s3-s1)/q2)*real(propa*conj(propa)); 
  // the interference term 
  output+= (0.5*q2-s3-0.5*mpi2+0.25*(s3-s2)*(s3-s1)/q2)*real(propa*conj(propb)+
							     propb*conj(propa)); 
  return output;
}

inline Complex KaonThreeMesonCurrent::Trho1(Energy2 q2,int ires) const {
  Complex output(0.);
  double norm(0.);
  for(unsigned int ix=0,N=_rho1wgts.size();ix<N;++ix) norm+=_rho1wgts[ix];
  if(ires<0) {
    for(unsigned int ix=0,N=_rho1wgts.size();ix<N;++ix) {
      output+=_rho1wgts[ix]*BWrho1(q2,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_rho1wgts.size()) output=_rho1wgts[temp]*BWrho1(q2,temp);
  }
  return output/norm;
}

inline Complex KaonThreeMesonCurrent::Trho2(Energy2 q2,int ires) const {
  Complex output(0.);
  double norm(0.);
  for(unsigned int ix=0,N=_rho2wgts.size();ix<N;++ix) norm+=_rho2wgts[ix];
  if(ires<0) {
    for(unsigned int ix=0,N=_rho2wgts.size();ix<N;++ix) {
      output+=_rho2wgts[ix]*BWrho2(q2,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_rho2wgts.size()) output=_rho2wgts[temp]*BWrho2(q2,temp);
  }
  return output/norm;
}

inline Complex KaonThreeMesonCurrent::TKstar1(Energy2 q2,int ires) const {
  Complex output(0.);
  double norm(0.);
  for(unsigned int ix=0,N=_kstar1wgts.size();ix<N;++ix) norm+=_kstar1wgts[ix];
  if(ires<0) {
    for(unsigned int ix=0,N=_kstar1wgts.size();ix<N;++ix) {
      output+=_kstar1wgts[ix]*BWKstar1(q2,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_kstar1wgts.size()) output=_kstar1wgts[temp]*BWKstar1(q2,temp);
  }
  return output/norm;
}

inline Complex KaonThreeMesonCurrent::TKstar2(Energy2 q2,int ires) const {
  Complex output(0.);
  double norm(0.);
  for(unsigned int ix=0,N=_kstar2wgts.size();ix<N;++ix) norm+=_kstar2wgts[ix];
  if(ires<0) {
    for(unsigned int ix=0,N=_kstar2wgts.size();ix<N;++ix) {
      output+=_kstar2wgts[ix]*BWKstar2(q2,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_kstar2wgts.size()) output=_kstar2wgts[temp]*BWKstar2(q2,temp);
  }
  return output/norm;
}

inline void KaonThreeMesonCurrent::doinitrun() {
  // set up the running a_1 width
  inita1Width(0);
  ThreeMesonCurrentBase::doinitrun();
}

inline Complex KaonThreeMesonCurrent:: TOmegaKStar(Energy2 si, Energy2 sj,
						   int ires) const {
  Complex output;
  if(ires<0)         output = _omegaKstarwgt*TKstar1(si,-1)+Tomega(sj,-1);
  else if(ires%2==0) output = _omegaKstarwgt*TKstar1(si,ires/2);
  else if(ires%2==1) output = Tomega(sj,ires/2);
  output /=(1.+_omegaKstarwgt);
  return output;
}

inline void KaonThreeMesonCurrent::doupdate() throw(UpdateException) {
  ThreeMesonCurrentBase::doupdate();
  // update running width if needed
  if ( !touched() ) return;
  if(_maxmass!=_maxcalc) inita1Width(-1);
}

}
