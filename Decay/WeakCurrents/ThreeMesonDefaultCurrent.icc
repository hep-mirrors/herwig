// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ThreeMesonDefaultCurrent class.
//

namespace Herwig {
using namespace ThePEG;

inline IBPtr ThreeMesonDefaultCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr ThreeMesonDefaultCurrent::fullclone() const {
  return new_ptr(*this);
}

inline void ThreeMesonDefaultCurrent::doinitrun() {
  // set up the running a_1 width
  inita1width(0);
  ThreeMesonCurrentBase::doinitrun();
}

// functions to return the Breit-Wigners
inline Complex ThreeMesonDefaultCurrent::BrhoF123(Energy2 q2,int ires) const {
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_rhoF123wgts.size()));ix<N;++ix)
    {norm+=_rhoF123wgts[ix];}
  if(ires<0) {
    for(unsigned int ix=0,N=min(3,int(_rhoF123wgts.size()));ix<N;++ix)
      output+=_rhoF123wgts[ix]*rhoKBreitWigner(q2,0,ix);
  }
  else {
    unsigned int temp(ires);
    if(temp<_rhoF123wgts.size()&&temp<3)
      output=_rhoF123wgts[temp]*rhoKBreitWigner(q2,0,temp);
    else
      output=0.;
  }
  return output/norm;
}

inline Complex ThreeMesonDefaultCurrent::BrhoF5(Energy2 q2,int ires) const {
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_rhoF5wgts.size()));ix<N;++ix)
    {norm+=_rhoF5wgts[ix];}
  if(ires<0)
    {for(unsigned int ix=0,N=min(3,int(_rhoF5wgts.size()));ix<N;++ix)
	{output+=_rhoF5wgts[ix]*rhoKBreitWigner(q2,1,ix);}}
  else
    {
      unsigned int temp(ires);
      if(temp<_rhoF5wgts.size()&&temp<3)
	{output=_rhoF5wgts[temp]*rhoKBreitWigner(q2,1,temp);}
    }
  return output/norm;
}

inline Complex ThreeMesonDefaultCurrent::BKstarF123(Energy2 q2,int ires) const
{
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_KstarF123wgts.size()));ix<N;++ix)
    {norm+=_KstarF123wgts[ix];}
  if(ires<0)
    {for(unsigned int ix=0,N=min(3,int(_KstarF123wgts.size()));ix<N;++ix)
	{output+=_KstarF123wgts[ix]*rhoKBreitWigner(q2,2,ix);}}
  else
    {
      unsigned int temp(ires);
      if(temp<_KstarF123wgts.size()&&temp<3)
	{output=_KstarF123wgts[temp]*rhoKBreitWigner(q2,2,temp);}
    }
  return output/norm;
}
inline Complex ThreeMesonDefaultCurrent::BKstarF5(Energy2 q2,int ires) const
{
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_KstarF5wgts.size()));ix<N;++ix)
    {norm+=_KstarF5wgts[ix];}
  if(ires<0)
    {for(unsigned int ix=0,N=min(3,int(_KstarF5wgts.size()));ix<N;++ix)
	{output+=_KstarF5wgts[ix]*rhoKBreitWigner(q2,3,ix);}}
  else
    {
      unsigned int temp(ires);
      if(temp<_KstarF5wgts.size()&&temp<3)
	{output=_KstarF5wgts[ires]*rhoKBreitWigner(q2,3,temp);}
    }
  return output/norm;
}

// matrix element for the running a_1 width
inline double ThreeMesonDefaultCurrent::
threeBodyMatrixElement(const int,  const Energy2 q2,
		       const Energy2 s3, const Energy2 s2, 
		       const Energy2 s1, const Energy, 
		       const Energy, const Energy) const {
  Energy2 mpi2(getParticleData(ParticleID::piplus)->mass());mpi2*=mpi2; 
  Complex propb(BrhoF123(s1,-1)),propa(BrhoF123(s2,-1)); 
  // the matrix element
  double output(0.); 
  // first resonance
  output+= ((s1-4.*mpi2)+0.25*(s3-s2)*(s3-s2)/q2)*real(propb*conj(propb)); 
  // second resonance
  output+= ((s2-4.*mpi2)+0.25*(s3-s1)*(s3-s1)/q2)*real(propa*conj(propa)); 
  // the interference term 
  output+= (0.5*q2-s3-0.5*mpi2+0.25*(s3-s2)*(s3-s1)/q2)*real(propa*conj(propb)+
							     propb*conj(propa)); 
  return output;
}

// running width of the a_1
inline Energy ThreeMesonDefaultCurrent::a1width(Energy2 q2) const {
  return (*_a1runinter)(q2);
}

// a_1 Breit Wigner
inline Complex  ThreeMesonDefaultCurrent::a1BreitWigner(Energy2 q2) const {
  Complex ii(0.,1.);
  Energy2 m2(_a1mass*_a1mass);
  Energy  q(sqrt(q2));
  return m2/(m2-q2-ii*q*a1width(q2));
}

// K_1 Breit Wigner
inline Complex  ThreeMesonDefaultCurrent::K1BreitWigner(Energy2 q2) const {
  Energy m2(_K1mass*_K1mass);
  Complex ii(0.,1.);
  complex<Energy2> fact(m2-ii*_K1mass*_K1width);
  return fact/(fact-q2);
}

// mixed Breit Wigner
inline Complex ThreeMesonDefaultCurrent::FKrho(Energy2 si, Energy2 sj,int ires) const {
  Complex output;
  if(ires<0){output = _rhoKstarwgt*BKstarF123(si,-1)+BrhoF123(sj,-1);}
  else if(ires%2==0){output= _rhoKstarwgt*BKstarF123(si,ires/2);}
  else if(ires%2==1){output=BrhoF123(sj,ires/2);}
  output /=(1.+_rhoKstarwgt);
  return output;
}

inline Complex ThreeMesonDefaultCurrent::rhoKBreitWigner(Energy2 q2,unsigned int itype,
							 unsigned int ires) const {
  Energy q(sqrt(q2)),mass,width,mout[2];
  // get the mass and width of the requested resonance
  if(itype==0){mass=_rhoF123masses[ires];width=_rhoF123widths[ires];}
  else if(itype==1){mass=_rhoF5masses[ires];width=_rhoF5widths[ires];}
  else if(itype==2){mass=_KstarF123masses[ires];width=_KstarF123widths[ires];}
  else if(itype==3){mass=_KstarF5masses[ires];width=_KstarF5widths[ires];}
  else{return 0.;}
  // calculate the momenta for the running widths
  if(itype<=1){mout[0]=_mpi;mout[1]=_mpi;}
  else{mout[0]=_mK;mout[1]=_mpi;}
  Energy pcm0(Kinematics::pstarTwoBodyDecay(mass,mout[0],mout[1])),pcm(0.);
  if(mout[0]+mout[1]<q){pcm=Kinematics::pstarTwoBodyDecay(q,mout[0],mout[1]);}
  double ratio(pcm/pcm0);ratio*=ratio*ratio;
  Energy gamrun(width*mass*ratio/q);
  Complex ii(0.,1.);
  complex<Energy2> denom(q2-mass*mass+ii*mass*gamrun),numer(-mass*mass);
  return numer/denom;
}
}
