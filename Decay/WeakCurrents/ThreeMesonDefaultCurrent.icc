// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ThreeMesonDefaultCurrent class.
//

namespace Herwig {
using namespace ThePEG;

inline IBPtr ThreeMesonDefaultCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr ThreeMesonDefaultCurrent::fullclone() const {
  return new_ptr(*this);
}

inline void ThreeMesonDefaultCurrent::doinitrun() {
  // set up the running a_1 width
  inita1Width(0);
  ThreeMesonCurrentBase::doinitrun();
}

inline void ThreeMesonDefaultCurrent::doupdate() throw(UpdateException) {
  ThreeMesonCurrentBase::doupdate();
  // update running width if needed
  if ( !touched() ) return;
  if(_maxmass!=_maxcalc) inita1Width(-1);
}

// functions to return the Breit-Wigners
inline Complex ThreeMesonDefaultCurrent::BrhoF123(Energy2 q2,int ires) const {
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_rhoF123wgts.size()));ix<N;++ix) {
    norm+=_rhoF123wgts[ix];
  }
  if(ires<0) {
    for(unsigned int ix=0,N=min(3,int(_rhoF123wgts.size()));ix<N;++ix) {
      output+=_rhoF123wgts[ix]*rhoKBreitWigner(q2,0,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_rhoF123wgts.size()&&temp<3)
      output=_rhoF123wgts[temp]*rhoKBreitWigner(q2,0,temp);
    else
      output=0.;
  }
  return output/norm;
}

inline Complex ThreeMesonDefaultCurrent::BrhoF5(Energy2 q2,int ires) const {
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_rhoF5wgts.size()));ix<N;++ix) {
    norm+=_rhoF5wgts[ix];
  }
  if(ires<0) {
    for(unsigned int ix=0,N=min(3,int(_rhoF5wgts.size()));ix<N;++ix) {
      output+=_rhoF5wgts[ix]*rhoKBreitWigner(q2,1,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_rhoF5wgts.size()&&temp<3) {
      output=_rhoF5wgts[temp]*rhoKBreitWigner(q2,1,temp);
    }
  }
  return output/norm;
}

inline Complex ThreeMesonDefaultCurrent::BKstarF123(Energy2 q2,int ires) const {
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_kstarF123wgts.size()));ix<N;++ix) {
    norm+=_kstarF123wgts[ix];
  }
  if(ires<0) {
    for(unsigned int ix=0,N=min(3,int(_kstarF123wgts.size()));ix<N;++ix) {
      output+=_kstarF123wgts[ix]*rhoKBreitWigner(q2,2,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_kstarF123wgts.size()&&temp<3) {
      output=_kstarF123wgts[temp]*rhoKBreitWigner(q2,2,temp);
    }
  }
  return output/norm;
}
  
inline Complex ThreeMesonDefaultCurrent::BKstarF5(Energy2 q2,int ires) const {
  Complex output(0.),norm(0.);
  for(unsigned int ix=0,N=min(3,int(_kstarF5wgts.size()));ix<N;++ix) {
    norm+=_kstarF5wgts[ix];
  }
  if(ires<0) {
    for(unsigned int ix=0,N=min(3,int(_kstarF5wgts.size()));ix<N;++ix) {
      output+=_kstarF5wgts[ix]*rhoKBreitWigner(q2,3,ix);
    }
  }
  else {
    unsigned int temp(ires);
    if(temp<_kstarF5wgts.size()&&temp<3) {
      output=_kstarF5wgts[ires]*rhoKBreitWigner(q2,3,temp);
    }
  }
  return output/norm;
}

// matrix element for the running a_1 width
inline double ThreeMesonDefaultCurrent::
threeBodyMatrixElement(const int,  const Energy2 q2,
		       const Energy2 s3, const Energy2 s2, 
		       const Energy2 s1, const Energy, 
		       const Energy, const Energy) const {
  Energy2 mpi2(sqr(_mpi));
  Complex propb(BrhoF123(s1,-1)),propa(BrhoF123(s2,-1)); 
  // the matrix element
  Energy2 output(0.*MeV2); 
  // first resonance
  output += ((s1-4.*mpi2) + 0.25*(s3-s2)*(s3-s2)/q2) * real(propb*conj(propb)); 
  // second resonance
  output += ((s2-4.*mpi2) + 0.25*(s3-s1)*(s3-s1)/q2) * real(propa*conj(propa)); 
  // the interference term 
  output += (0.5*q2-s3-0.5*mpi2+0.25*(s3-s2)*(s3-s1)/q2)*real(propa*conj(propb)+
							     propb*conj(propa)); 
  return output/sqr(_rhoF123masses[0]);
}

inline double ThreeMesonDefaultCurrent::g(Energy2 q2) const {
  double output;
  if(q2 < 9.*sqr(_mpi)) {
    output=0.;
  }
  else if(q2 < sqr(_rhoF123masses[0]+_mpi)) {
    double diff = (q2-9.*sqr(_mpi))/GeV2;
    
    output = 4.1*sqr(diff)*diff*(1.-3.3*diff+5.8*sqr(diff));
  }
  else {
    double ratio = q2/GeV2;
    output = ratio*(1.623+10.38/ratio-9.32/sqr(ratio)+0.65/(ratio*sqr(ratio)));
  }
  return output;
}

inline double ThreeMesonDefaultCurrent::g(Energy2 q2) const {
  double output;
  if(q2<9.*_mpi*_mpi) {
    output=0.;
  }
  else if(q2<sqr(_rhoF123masses[0]+_mpi)) {
    double diff=(q2-9.*_mpi*_mpi)/GeV2;
    
    output=4.1*sqr(diff)*diff*(1.-3.3*diff+5.8*sqr(diff));
  }
  else {
    double ratio = q2/GeV2;
    output = ratio*(1.623+10.38/ratio-9.32/sqr(ratio)+0.65/(ratio*sqr(ratio)));
  }
  return output;
}

// running width of the a_1
inline Energy ThreeMesonDefaultCurrent::a1Width(Energy2 q2) const {
  Energy output;
  if(!_a1opt) output = _a1mass*_a1width*g(q2)/g(sqr(_a1mass))/sqrt(q2);
  else        output = (*_a1runinter)(q2);
  return output;
}

// a_1 Breit Wigner
inline Complex  ThreeMesonDefaultCurrent::a1BreitWigner(Energy2 q2) const {
  Complex ii(0.,1.);
  Energy2 m2(_a1mass*_a1mass);
  Energy  q(sqrt(q2));
  return m2/(m2-q2-ii*q*a1Width(q2));
}

// K_1 Breit Wigner
inline Complex  ThreeMesonDefaultCurrent::K1BreitWigner(Energy2 q2) const {
  Energy2 m2 = sqr(_k1mass);
  Complex ii(0.,1.);
  complex<Energy2> fact(m2 - ii*_k1mass*_k1width);
  return fact/(fact-q2);
}

// mixed Breit Wigner
inline Complex ThreeMesonDefaultCurrent::FKrho(Energy2 si, Energy2 sj,int ires) const {
  Complex output;
  if(ires<0){output = _rhoKstarwgt*BKstarF123(si,-1)+BrhoF123(sj,-1);}
  else if(ires%2==0){output= _rhoKstarwgt*BKstarF123(si,ires/2);}
  else if(ires%2==1){output=BrhoF123(sj,ires/2);}
  output /=(1.+_rhoKstarwgt);
  return output;
}

inline Complex ThreeMesonDefaultCurrent::rhoKBreitWigner(Energy2 q2,unsigned int itype,
							 unsigned int ires) const {
  Energy q(sqrt(q2)),mass,width,mout[2]={_mpi,_mpi};
  // get the mass and width of the requested resonance
  if(itype==0) {
    mass=_rhoF123masses[ires];
    width=_rhoF123widths[ires];
  }
  else if(itype==1) {
    mass=_rhoF5masses[ires];
    width=_rhoF5widths[ires];
  }
  else if(itype==2) {
    mass=_kstarF123masses[ires];
    width=_kstarF123widths[ires];
  }
  else if(itype==3) {
    mass=_kstarF5masses[ires];
    width=_kstarF5widths[ires];
  }
  else {
    return 0.;
  }
  // calculate the momenta for the running widths
  if(itype>1) mout[0]=_mK;
  Energy pcm0(Kinematics::pstarTwoBodyDecay(mass,mout[0],mout[1]));
  Energy pcm(0.*MeV);
  if(mout[0]+mout[1]<q){pcm=Kinematics::pstarTwoBodyDecay(q,mout[0],mout[1]);}
  double ratio = Math::Pow<3>(pcm/pcm0);
  ratio*=ratio*ratio;
  Energy gamrun(width*mass*ratio/q);
  Complex ii(0.,1.);
  complex<Energy2> denom(q2-mass*mass+ii*mass*gamrun), numer(-mass*mass);
  return numer/denom;
}
}
