// -*- C++ -*-
//
// FivePionCurrent.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the FivePionCurrent class.
//

namespace Herwig {

inline IBPtr FivePionCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr FivePionCurrent::fullclone() const {
  return new_ptr(*this);
}
  
inline Complex FivePionCurrent::rhoBreitWigner(Energy2 scale) const {
  Energy2 m2=sqr(_rhomass);
  return m2/(m2-scale-Complex(0.,1.)*_rhomass*_rhowidth);
}

inline Complex FivePionCurrent::a1BreitWigner(Energy2 scale) const {
  Energy2 m2=sqr(_a1mass);
  return m2/(m2-scale-Complex(0.,1.)*_a1mass*_a1width);
}

inline Complex FivePionCurrent::omegaBreitWigner(Energy2 scale) const {
  Energy2 m2=sqr(_omegamass);
  return m2/(m2-scale-Complex(0.,1.)*_omegamass*_omegawidth);
}

inline Complex FivePionCurrent::sigmaBreitWigner(Energy2 scale) const {
  Energy2 m2=sqr(_sigmamass);
  return m2/(m2-scale-Complex(0.,1.)*_sigmamass*_sigmawidth);
}

inline LorentzVector<complex<InvEnergy2> > 
FivePionCurrent::rhoOmegaCurrent(unsigned int iopt,const Lorentz5Momentum & Q,
				 const Lorentz5Momentum & q1,
				 const Lorentz5Momentum & q2,
				 const Lorentz5Momentum & q3,
				 const Lorentz5Momentum & q4,
				 const Lorentz5Momentum & q5) const {
  // prefactor
  complex<InvEnergy7> pre(_preomega*a1BreitWigner(Q.m2())*omegaBreitWigner((q1+q2+q3).m2())*
			  rhoBreitWigner((q4+q5).m2()));
  // omega piece
  Complex omega(-1.);
  if(_rhoomega) {
    if(iopt==1)      omega=rhoBreitWigner((q2+q3).m2());
    else if(iopt==2) omega=rhoBreitWigner((q1+q3).m2());
    else if(iopt==3) omega=rhoBreitWigner((q1+q2).m2());
    else            
      omega=rhoBreitWigner((q2+q3).m2())+rhoBreitWigner((q1+q3).m2())+
	rhoBreitWigner((q1+q2).m2());
  }
  LorentzVector<complex<Energy3> > omegacurrent(Helicity::epsilon(q1,q2,q3));
  LorentzVector<complex<InvEnergy2> > output =
    pre * omega * Helicity::epsilon(q4-q5,omegacurrent,Q);
  return output;
}
  
inline LorentzVector<complex<InvEnergy2> > 
FivePionCurrent::a1SigmaCurrent(unsigned int iopt,const Lorentz5Momentum & Q,
				const Lorentz5Momentum & q1,const Lorentz5Momentum & q2,
				const Lorentz5Momentum & q3,const Lorentz5Momentum & q4,
				const Lorentz5Momentum & q5) const {
  Lorentz5Momentum pa1(q1+q2+q3);pa1.rescaleMass();
  Energy2 ma12(pa1.m2());
  complex<InvEnergy3> pre(_presigma*a1BreitWigner(Q.m2())*a1BreitWigner(ma12)*
	      sigmaBreitWigner((q4+q5).m2()));
  Energy2 pdot[2]={q2*(q1-q3),q1*(q2-q3)};
  LorentzPolarizationVectorE rho[2] = {(pdot[0]/ma12*pa1-q1+q3)*rhoBreitWigner((q1+q3).m2()),
				      (pdot[1]/ma12*pa1-q2+q3)*rhoBreitWigner((q2+q3).m2())};
  LorentzPolarizationVectorE total;
  if(iopt==1)      total = rho[0];
  else if(iopt==2) total = rho[1];
  else             total = rho[0]+rho[1];
  Complex qdot = total * Q / Q.m2();
  LorentzPolarizationVectorE cq(Q);
  cq = cq * qdot;
  cq -= total;
  return pre * cq;
}
}
