// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the TwoMesonRhoKStarCurrent class.
//
//  Author: Peter Richardson
//

namespace Herwig {
using namespace ThePEG;

inline TwoMesonRhoKStarCurrent::TwoMesonRhoKStarCurrent() 
{
  // set up for the modes in the base class
  addDecayMode(2,-1);
  addDecayMode(2,-3);
  addDecayMode(2,-3);
  addDecayMode(2,-1);
  addDecayMode(2,-3);
  // the weights of the different resonances in the matrix elements
  _piwgt.push_back(1.0);_piwgt.push_back(-0.167);_piwgt.push_back(0.05);
  _kwgt.push_back(1.0);_kwgt.push_back(-0.038);_kwgt.push_back(0.00);
  // models to use
  _pimodel = 0;_Kmodel=0;
  // parameter for the masses (use the parameters freom the CLEO fit 
  // rather than the PDG masses etc)
  _rhoparameters=true;
  _rhomasses.push_back(774.6*MeV);_rhomasses.push_back(1408*MeV);
  _rhomasses.push_back(1700*MeV);
  _rhowidths.push_back(149*MeV);_rhowidths.push_back(502*MeV);
  _rhowidths.push_back(235*MeV);
  _Kstarparameters=true;
  _Kstarmasses.push_back(0.89159*GeV);_Kstarmasses.push_back(1.700*GeV);
  _Kstarwidths.push_back(0.0498 *GeV);_Kstarwidths.push_back(0.235*GeV);
}

inline TwoMesonRhoKStarCurrent::TwoMesonRhoKStarCurrent(const TwoMesonRhoKStarCurrent & x)
  : WeakDecayCurrent(x), _piwgt(x._piwgt),_kwgt(x._kwgt),_pimodel(x._pimodel), 
    _Kmodel(x._Kmodel),_rhoparameters(x._rhoparameters), _rhomasses(x._rhomasses),
    _rhowidths(x._rhowidths), _Kstarparameters(x._Kstarparameters),
    _Kstarmasses(x._Kstarmasses),_Kstarwidths(x._Kstarwidths), _mass(x._mass),
    _width(x._width), _mass2(x._mass2), _massw(x._massw), _massa(x._massa),
    _massb(x._massb), _mom(x._mom), _dhdq2(x._dhdq2), _hm2(x._hm2), _dparam(x._dparam) {}

inline IBPtr TwoMesonRhoKStarCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr TwoMesonRhoKStarCurrent::fullclone() const {
  return new_ptr(*this);
}

inline void TwoMesonRhoKStarCurrent::doupdate() throw(UpdateException) {
  WeakDecayCurrent::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void TwoMesonRhoKStarCurrent::dofinish() {
  WeakDecayCurrent::dofinish();
}

inline void TwoMesonRhoKStarCurrent::doinitrun() {
  WeakDecayCurrent::doinitrun();  
}

inline void TwoMesonRhoKStarCurrent::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  WeakDecayCurrent::rebind(trans);
}

inline IVector TwoMesonRhoKStarCurrent::getReferences() {
  IVector ret = WeakDecayCurrent::getReferences();
  // ret.push_back(dummy);
  return ret;
}


// the h function in the GS model
inline double TwoMesonRhoKStarCurrent::GSModelhFunction(const unsigned int ix,
					       const Energy q)const 
{
  Energy pq=pcm(ix,q);
  return _width[ix]*_mass2[ix]/(_mom[ix]*_mom[ix]*_mom[ix])
    *2.*pq/pi/q*log((q+2.*pq)/(_massa[ix]+_massb[ix]));
}

// the dh/dq2 in the GS model for the propagator
inline double TwoMesonRhoKStarCurrent::GSModeldhdq2Parameter(const unsigned int ix) const 
{
  Energy mpi=0.5*(_massa[ix]+_massb[ix]);
  return _width[ix]/pi/_mom[ix]/_mom[ix]/_mom[ix]*
    (mpi*mpi/_mass[ix]/_mom[ix]*log(0.5*(_mass[ix]+2.*_mom[ix])/mpi)+0.5);
}

// the D parameter of the GS model
inline double TwoMesonRhoKStarCurrent::GSModelDParameter(const unsigned int ix) const 
{
  Energy mpi=0.5*(_massa[ix]+_massb[ix]);
  return 3.*mpi*mpi/pi/_mom[ix]/_mom[ix]*log(0.5*(_mass[ix]+2.*_mom[ix])/mpi)
    +0.5*_mass[ix]/pi/_mom[ix]-mpi*mpi*_mass[ix]/pi/_mom[ix]/_mom[ix]/_mom[ix];
}


// the decay momentum
inline Energy TwoMesonRhoKStarCurrent::pcm(const unsigned int ix,const  Energy q) const 
{
  Energy2 q2=q*q;
  Energy output;
  if(q>_massa[ix]+_massb[ix])
    {
      output =  0.5/q*sqrt((q2-(_massa[ix]+_massb[ix])*(_massa[ix]+_massb[ix]))*
			   (q2-(_massa[ix]-_massb[ix])*(_massa[ix]-_massb[ix])));
    }
  else{output=0;}
  return output;
}

// calculate the p-wave Breit Wigner
  // imodel is the model 0= normal running width, 1= GS model
  // itype 0=rho+-, 1=K*+-
Complex TwoMesonRhoKStarCurrent::BreitWigner(Energy2 q2, unsigned int imodel,
					     unsigned int itype,
					     unsigned int ires) const 
{
  // workout the index of the resonace
  unsigned int iy = 3*itype+ires;
  // off shell mass
  Energy q=sqrt(q2);
  // and the running width
  Energy pq=pcm(iy,q);
  double ratio=pq/_mom[iy];ratio=ratio*ratio*ratio;
  Energy gamrun = _width[iy]*_mass[iy]*ratio/q;
  // work out the denominator
  complex<Energy2> denom;
  Complex numer;
  Complex ii(0.,1.);
  if(imodel==0)
    {
      denom=q2-_mass2[iy]+ii*_mass[iy]*gamrun;
      numer=-_mass2[iy];
    }
  else if(imodel==1)
    {
      denom=q2-_mass2[iy]+ii*_mass[iy]*gamrun
	-( pq*pq*(GSModelhFunction(iy,q)-_hm2[iy])
	   -_mom[iy]*_mom[iy]*(q2-_mass2[iy])*_dhdq2[iy]);
      numer=-(_mass2[iy]+_dparam[iy]*_mass[iy]*_width[iy]);
    }
  else
    {
      cerr << "Unknown model in TwoMesonRhoKStarCurrent::BreitWigner" << endl;
      return 0.;
    }
  // return the answer
  return numer/denom;
}

}

