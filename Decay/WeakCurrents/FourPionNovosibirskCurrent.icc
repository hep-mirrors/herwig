// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the FourPionNovosibirskCurrent class.
//
//  Author:  Peter Richardson
//

namespace Herwig {
using namespace ThePEG;
using namespace ThePEG::Helicity;

inline IBPtr FourPionNovosibirskCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr FourPionNovosibirskCurrent::fullclone() const {
  return new_ptr(*this);
}

// matrix element for the running a_1 width
inline double FourPionNovosibirskCurrent::
threeBodyMatrixElement(const int iopt, const Energy2 q2,
		       const Energy2 s3, const Energy2 s2, 
		       const Energy2 s1, const Energy,
		       const Energy, const Energy) const {
  unsigned int ix;
  // construct the momenta of the decay products
  Energy p1[5],p2[5],p3[5];
  Energy2 p1sq, p2sq, p3sq;
  Energy q(sqrt(q2));
  if(iopt==0) {
    p1[0] = 0.5*(q2+_mpi02-s1)/q; p1sq=p1[0]*p1[0]; p1[4]=sqrt(p1sq-_mpi02);
    p2[0] = 0.5*(q2+_mpic2-s2)/q; p2sq=p2[0]*p2[0]; p2[4]=sqrt(p2sq-_mpic2);
    p3[0] = 0.5*(q2+_mpic2-s3)/q; p3sq=p3[0]*p3[0]; p3[4]=sqrt(p3sq-_mpic2);
  }
  else {
    p1[0] = 0.5*(q2+_mpi02-s1)/q; p1sq=p1[0]*p1[0]; p1[4]=sqrt(p1sq-_mpi02);
    p2[0] = 0.5*(q2+_mpi02-s2)/q; p2sq=p2[0]*p2[0]; p2[4]=sqrt(p2sq-_mpi02);
    p3[0] = 0.5*(q2+_mpi02-s3)/q; p3sq=p3[0]*p3[0]; p3[4]=sqrt(p3sq-_mpi02);
  }
  // take momentum of 1 parallel to z axis
  p1[1]=0.*MeV;p1[2]=0.*MeV;p1[3]=p1[4];
  // construct 2 
  double cos2(0.5*(sqr(p1[4])+sqr(p2[4])-sqr(p3[4]))/p1[4]/p2[4]);
  p2[1] = p2[4]*sqrt(1.-sqr(cos2)); p2[2]=0.*MeV; p2[3]=-p2[4]*cos2;
  // construct 3
  double cos3(0.5*(sqr(p1[4])-sqr(p2[4])+sqr(p3[4]))/p1[4]/p3[4]);
  p3[1] =-p3[4]*sqrt(1.-sqr(cos3)); p3[2]=0.*MeV; p3[3]=-p3[4]*cos3;
  // pi+pi-pi0 term
  complex<Energy4> output(0.*sqr(MeV2));
  if(iopt==0) {
    // values for the different Breit-Wigner terms
    Complex rho1(2.365*rhoBreitWigner(s2)),
      rho2(2.365*rhoBreitWigner(s3)),
      sig1(sigmaBreitWigner(s1,1));
    // compute the vector
    complex<Energy2> term;
    for(ix=1;ix<4;++ix) { 
      term = (p1[0]*p2[ix]-p2[0]*p1[ix])*rho2+(p1[0]*p3[ix]-p3[0]*p1[ix])*rho1
	+_zsigma*q*p1[ix]*sig1;
      output+=term*conj(term);
    }
  }
  // pi0pi0pi0 term
  else if(iopt==1) {
    // values for the different Breit-Wigner terms
    Complex sig1(sigmaBreitWigner(s1,0)),
      sig2(sigmaBreitWigner(s2,0)),
      sig3(sigmaBreitWigner(s3,0));
    // compute the vector
    complex<Energy2> term;
    for(ix=1;ix<4;++ix) {
      term = _zsigma * q * (p1[ix]*sig1 + p2[ix]*sig2 + p3[ix]*sig3);
      output += term*conj(term);
    }
    output/=6.;
  }
  output *= a1FormFactor(q2);
  return output.real() / pow<4,1>(_rhomass);
}

// form-factor for the a_1 vertex
inline double FourPionNovosibirskCurrent::a1FormFactor(Energy2 q2) const {
  return sqr((1.+_a1massolam2)/(1.+q2*_onedlam2));   
}
  
// running width of the a_1
inline Energy FourPionNovosibirskCurrent::a1width(Energy2 q2) const {
  return (*_a1runinter)(q2);
}
  
// a_1 Breit Wigner
inline Complex FourPionNovosibirskCurrent::a1BreitWigner(Energy2 q2) const {
  Complex ii(0.,1.);
  Energy2 m2 = sqr(_a1mass);
  Energy q = sqrt(q2);
  return (m2/complex<Energy2>(q2 - m2 + ii*q*a1width(q2)));
}

// current t_1 from hep-ph/0201149
inline LorentzVector<complex<Energy5> >
FourPionNovosibirskCurrent::t1(Lorentz5Momentum & q1,Lorentz5Momentum & q2,
			       Lorentz5Momentum & q3,Lorentz5Momentum & q4) const {
  // momentum of the whole sysytem
  Lorentz5Momentum Q(q1+q2+q3+q4);Q.rescaleMass();
  // compute the virtuality of the a_1
  Lorentz5Momentum a1(q2+q3+q4);a1.rescaleMass();
  // compute the virtuality of the  rho
  Lorentz5Momentum rho(q3+q4);rho.rescaleMass();
  // compute the prefactor    
  Complex pre(-a1FormFactor(a1.mass2())*a1BreitWigner(a1.mass2())*
	      rhoBreitWigner(rho.mass2()));
  // dot products we need
  Energy2 QdQmq1(Q*a1);
  complex<Energy4> consta(QdQmq1*(a1*q3)), constb(QdQmq1*(a1*q4)),
    constc(((Q*q4)*(q1*q3)-(Q*q3)*(q1*q4)));
  // compute the current
  return pre*(consta*q4-constb*q3+constc*a1);
}

// current t_2 from hep-ph/0201149
inline LorentzVector<complex<Energy5> >
FourPionNovosibirskCurrent::t2(Lorentz5Momentum & q1, Lorentz5Momentum & q2,
			       Lorentz5Momentum & q3, Lorentz5Momentum & q4,
			       unsigned int iopt) const {
  // momentum of the whole system
  Lorentz5Momentum Q(q1+q2+q3+q4);Q.rescaleMass();
  // compute the virtuality of the a_1
  Lorentz5Momentum a1(q2+q3+q4);a1.rescaleMass();
  // compute the virtuality of the  sigma
  Lorentz5Momentum sigma(q3+q4);sigma.rescaleMass();
  // compute the prefactor
  Complex pre(_zsigma*a1FormFactor(a1.mass2())
  	      *a1BreitWigner(a1.mass2())*
  	      sigmaBreitWigner(sigma.mass2(),iopt));
  // dot products we need
  complex<Energy4> consta((Q*a1)*a1.mass2()),constb((Q*q2)*a1.mass2());
  // compute the current
  return pre*(consta*q2-constb*a1);
}

// current t_3 from hep-ph/0201149
inline LorentzVector<complex<Energy5> >
FourPionNovosibirskCurrent::t3(Lorentz5Momentum & q1,Lorentz5Momentum & q2,
			       Lorentz5Momentum & q3,Lorentz5Momentum & q4) const {
  // momentum of the whole sysytem
  Lorentz5Momentum Q(q1+q2+q3+q4);Q.rescaleMass();
  // compute the virtuality of the omega
  Lorentz5Momentum omega(q2+q3+q4);omega.rescaleMass();
  // compute the virtuality of the  rho
  Lorentz5Momentum rho(q3+q4);rho.rescaleMass();
  // compute the prefactor
  Complex pre(omegaBreitWigner(omega.mass2())*rhoBreitWigner(rho.mass2()));
  // dot products we need
  complex<Energy4> consta((Q*q3)*(q1*q4)-(Q*q4)*(q1*q3)),constb(-(Q*q2)*(q1*q4)+(q1*q2)*(Q*q4)),
    constc((Q*q2)*(q1*q3)-(q1*q2)*(Q*q3));
  // compute the current
  return pre*(consta*q2+constb*q3+constc*q4);
}

// the G functions of hep-ph/0201149
inline InvEnergy6 FourPionNovosibirskCurrent::gFunction(Energy2 Q2, int ichan) const {
  InvEnergy6 output;
  Energy Q(sqrt(Q2));
  InvEnergy4 invmrho4 = 1/sqr(sqr(_rhomass));
  // the one charged pion G function
  if(ichan==0) {
    output = (*_Fonec)(Q) * _aonec * (*_Fsigma)(Q2) * sqrt(_bonec*Q/GeV-_conec) *
      invmrho4/Q;
  }
  // the three charged pion G function
  else if(ichan==1) {
    output = (*_Fthreec)(Q)*_athreec*sqrt(_bthreec*Q/GeV-_cthreec)*invmrho4/Q; 
  }
  // the omega G function
  else if(ichan==2) {
    output = (*_Fomega)(Q)*_aomega*sqrt(_bomega*Q/GeV-_comega)*invmrho4/Q;
  }
  else {
    throw Exception() << "Invalid function in FourPionNovosibirskCurrent::gFunction" 
		      << Exception::abortnow;
  }
  return output;
}

// breit wigner for the omega  
inline Complex FourPionNovosibirskCurrent::omegaBreitWigner(Energy2 Q2) const {
  Energy Q(sqrt(Q2));
  // calcluate the running width
  double diff((Q-_omegamass)/GeV),temp(diff);
  double gomega(1.);
  Complex ii(0.,1.);
  if(Q<=1.*GeV) {
    for(unsigned int ix=0;ix<6;++ix) {
      gomega +=temp*_omegaparam[ix];
      temp*=diff;
    }
  }
  else {
    gomega=_omegaparam[6]+Q/GeV*(_omegaparam[7]+Q/GeV*_omegaparam[8]
				 +Q2/GeV2*_omegaparam[9]);
  }
  if(gomega<0.){gomega=0.;}
  Energy2 numer=_omegamass*_omegamass;
  complex<Energy2> denom=Q2-_omegamass*_omegamass+ii*_omegamass*_omegawidth*gomega;
  return numer/denom;
}

// breit-wigner for the sigma meson
inline Complex FourPionNovosibirskCurrent::
sigmaBreitWigner(Energy2 q2,unsigned int iopt) const {
  Energy q(sqrt(q2));
  Energy pcm = iopt==0 ? 
    Kinematics::pstarTwoBodyDecay(q,_mpi0,_mpi0) :
    Kinematics::pstarTwoBodyDecay(q,_mpic,_mpic);
  if(pcm<0.*MeV) pcm=0.*MeV;
  Energy  width(_sigmawidth*pcm/_psigma[iopt]);
  Energy2 msigma2 = sqr(_sigmamass);
  return msigma2/(q2-msigma2+Complex(0.,1.)*msigma2*width/q);
}

// the h function in the rho propagator
inline Energy2 FourPionNovosibirskCurrent::hFunction(const Energy q)const {
  using Constants::pi;
  static const Energy2 eps(0.01*MeV2);
  Energy2 q2(q*q);
  double root(sqrt(1.-4.*_mpic2/q2));

  Energy2 output;
  if(q2>4*_mpic2)  output=root*log((1.+root)/(1.-root))*(q2-4*_mpic2)/pi;
  else if(q2>eps) output=0.*MeV2;
  else            output=-8.*_mpic2/pi;
  return output;
}

// the dh/dq2 rho the propagator
inline double FourPionNovosibirskCurrent::dhdq2Parameter() const {
  Energy2 mrho2(_rhomass*_rhomass);
  double root(sqrt(1.-4.*_mpic2/mrho2));
  return root/Constants::pi*(root+(1.+2*_mpic2/mrho2)*log((1+root)/(1-root)));
}
  
// the numerator for the rho propagator
inline Energy2 FourPionNovosibirskCurrent::DParameter() const {
  Energy2 grhom(8.*_prho*_prho*_prho/_rhomass);
  return _rhomass*_rhomass+_rhowidth*_rhomass*
    (hFunction(0.*MeV)-_hm2+_rhomass*_rhomass*_dhdq2m2)/grhom;
}

// the rho Breit-Wigner
inline Complex FourPionNovosibirskCurrent::rhoBreitWigner(Energy2 q2) const {
  Energy q(sqrt(q2));
  Energy2 grhom(8.*_prho*_prho*_prho/_rhomass);
  complex<Energy2> denom;
  Complex ii(0.,1.);
  if(q2<4.*_mpic2) {
    denom=q2-_rhomass*_rhomass
      -_rhowidth*_rhomass*(hFunction(q)-_hm2-(q2-_rhomass*_rhomass)*_dhdq2m2)/grhom;
  }
  else {
    Energy pcm(2.*Kinematics::pstarTwoBodyDecay(q,_mpic,_mpic));
    Energy2 grho(pcm*pcm*pcm/q);
    denom=q2-_rhomass*_rhomass
      -_rhowidth*_rhomass*(hFunction(q)-_hm2-(q2-_rhomass*_rhomass)*_dhdq2m2)/grhom
      +ii*_rhomass*_rhowidth*grho/grhom;
  }
  return _rhoD/denom;
}

inline void FourPionNovosibirskCurrent::doupdate() throw(UpdateException) {
  WeakDecayCurrent::doupdate();
  // update running width if needed
  if ( !touched() ) return;
  if(_maxmass!=_maxcalc) inita1width(-1);
}

}
