// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the FourPionNovosibirskCurrent class.
//
//  Author:  Peter Richardson
//

namespace Herwig {
using namespace ThePEG;
using namespace ThePEG::Helicity;

inline FourPionNovosibirskCurrent::FourPionNovosibirskCurrent(const FourPionNovosibirskCurrent & x)
  : WeakDecayCurrent(x), _Fomega(x._Fomega), _Fthreec(x._Fthreec), _Fonec(x._Fonec),
    _Fsigma(x._Fsigma),
    _mpi(x._mpi),_rhomass(x._rhomass), _a1mass(x._a1mass), _omegamass(x._omegamass),
    _sigmamass(x._sigmamass), _rhowidth(x._rhowidth), _a1width(x._a1width),
    _omegawidth(x._omegawidth), _sigmawidth(x._sigmawidth), _intmass(x._intmass),
    _intwidth(x._intwidth),_zsigma(x._zsigma), _zmag(x._zmag), _zphase(x._zphase),
    _lambda2(x._lambda2), _onedlam2(x._onedlam2), _a1massolam2(x._a1massolam2),
    _psigma(x._psigma),_mpi2(x._mpi2),_hm2(x._hm2),_rhoD(x._rhoD),_prho(x._prho),
    _dhdq2m2(x._dhdq2m2),_aomega(x._aomega),_athreec(x._athreec),_aonec(x._aonec),
    _bomega(x._bomega),_bthreec(x._bthreec),_bonec(x._bonec),_comega(x._comega),
    _cthreec(x._cthreec),_conec(x._conec),_omegaparam(x._omegaparam),
    _initializea1(x._initializea1),_localparameters(x._localparameters), 
    _a1runwidth(x._a1runwidth), _a1runq2(x._a1runq2),_a1runinter(x._a1runinter) {}

inline IBPtr FourPionNovosibirskCurrent::clone() const {
  return new_ptr(*this);
}

inline IBPtr FourPionNovosibirskCurrent::fullclone() const {
  return new_ptr(*this);
}

inline void FourPionNovosibirskCurrent::doinit() throw(InitException) {
  WeakDecayCurrent::doinit();
  if(!_localparameters)
    {
      _rhomass    = getParticleData(ParticleID::rhominus)->mass();
      _rhowidth   = getParticleData(ParticleID::rhominus)->width();
      _omegamass  = getParticleData(ParticleID::omega)->mass();
      _omegawidth = getParticleData(ParticleID::omega)->width();
      _sigmamass  = getParticleData(9000221)->mass();
      _sigmawidth = getParticleData(9000221)->width();
      _a1mass    = getParticleData(ParticleID::a_1minus)->mass();
      _a1width   = getParticleData(ParticleID::a_1minus)->width();
    }
  // calculate the constants for the a_1 form factor
  _onedlam2 = 1./_lambda2;
  _a1massolam2 = _a1mass*_a1mass*_onedlam2;
  // parameter for the sigma breit-wigner
  //_mpi=getParticleData(ParticleID::piplus)->mass();
  _psigma=Kinematics::pstarTwoBodyDecay(_sigmamass,_mpi,_mpi);
  // parameters for the rho breit wigner
  _mpi2=_mpi*_mpi;
  _prho=Kinematics::pstarTwoBodyDecay(_rhomass,_mpi,_mpi);
  _hm2 = hFunction(_rhomass);
  _dhdq2m2=dhdq2Parameter();
  _rhoD=DParameter();
  // convert the magnitude and phase of z into a phase
  _zsigma = _zmag*(cos(_zphase)+Complex(0.,1.)*sin(_zphase));
  // initialize the a_1 width
  if(_initializea1){inita1width(-1);}
}

inline void FourPionNovosibirskCurrent::doinitrun() {
  // set up the running a_1 width
  inita1width(0);
  WeakDecayCurrent::doinitrun();
}

// matrix element for the running a_1 width
inline double FourPionNovosibirskCurrent::a1MatrixElement(Energy2 q2, Energy2 s3,
							  Energy2 s2, Energy2 s1,
							  Energy,Energy,Energy)
{
  unsigned int ix;
  // construct the momenta of the decay products
  Energy p1[6],p2[6],p3[6];
  Energy q(sqrt(q2));
  p1[0] = 0.5*(q2+_mpi2-s1)/q; p1[5]=p1[0]*p1[0]; p1[4]=sqrt(p1[5]-_mpi2);
  p2[0] = 0.5*(q2+_mpi2-s2)/q; p2[5]=p2[0]*p2[0]; p2[4]=sqrt(p2[5]-_mpi2);
  p3[0] = 0.5*(q2+_mpi2-s3)/q; p3[5]=p3[0]*p3[0]; p3[4]=sqrt(p3[5]-_mpi2);
  // take momentum of 1 parallel to z axis
  p1[1]=0.;p1[2]=0.;p1[3]=p1[4];
  // construct 2 
  double cos2(0.5*(p1[5]+p2[5]-p3[5]-_mpi2)/p1[4]/p2[4]);
  p2[1] = p2[4]*sqrt(1.-cos2*cos2); p2[2]=0.; p2[3]=-p2[4]*cos2;
  // construct 3
  double cos3(0.5*(p1[5]-p2[5]+p3[5]-_mpi2)/p1[4]/p3[4]);
  p3[1] =-p3[4]*sqrt(1.-cos3*cos3); p3[2]=0.; p3[3]=-p3[4]*cos3; 
  // values for the different Breit-Wigner terms
  Complex rho1(1.1*rhoBreitWigner(s2)/_rhoD),
    rho2(1.1*rhoBreitWigner(s3)/_rhoD),
    sig1(sigmaBreitWigner(s1)/pow(_sigmamass,2)),
    sig2(sigmaBreitWigner(s2)/pow(_sigmamass,2)),
    sig3(sigmaBreitWigner(s3)/pow(_sigmamass,2));
  // compute the vector
  Complex vect1[4],vect2[4];
  for(ix=1;ix<4;++ix)
    {
      // pi+pi-pi0 term
      vect1[ix] = (p1[0]*p2[ix]-p2[0]*p1[ix])*rho2+(p1[0]*p3[ix]-p3[0]*p1[ix])*rho1
	+_zsigma*q*p1[ix]*sig1;
      // pi0pi0pi0 term
      vect2[ix] = _zsigma*q*(p1[ix]*sig1+p2[ix]*sig2+p3[ix]*sig3);
    }
  double pre(1./6.);
  Complex output(0.);
  for(ix=1;ix<4;++ix){output+=vect1[ix]*conj(vect1[ix])+pre*vect2[ix]*conj(vect2[ix]);}
  output*=a1FormFactor(q2);
  return output.real();
}

// initialisation of the a_1 running width 
inline void FourPionNovosibirskCurrent::inita1width(int iopt)
{
  if(iopt==-1)
    {
      double total;
      // parameters for the table of values
      Energy mtau(getParticleData(ParticleID::tauplus)->mass());
      Energy mtau2(mtau*mtau);
      Energy2 step(mtau*mtau/200.);
      // function to be integrated to give the matrix element
      Genfun::AbsFunction *inme = new FourPionDefaultMatrixElement(this);
      // integrator to perform the integral
      // weights for the integration channels
      vector<double> inweights;
      inweights.push_back(0.3);inweights.push_back(0.3);inweights.push_back(0.3);
      // types of integration channels
      vector<int> intype;
      intype.push_back(2);intype.push_back(3);intype.push_back(1);
      // masses for the integration channels
      vector<double> inmass(2,_rhomass);inmass.push_back(_sigmamass);
      // widths for the integration channels
      vector<double> inwidth(2,_rhowidth);inwidth.push_back(_sigmawidth);
      ThreeBodyIntegrator *widthgen = new ThreeBodyIntegrator(inweights,intype,
							      inmass,inwidth,
							      inme,_mpi,_mpi,_mpi); 
      // nornmalisation constant to give physical width if on shell
      double a1const(_a1width/(widthgen->width(_a1mass*_a1mass)));
      // loop to give the values
      Energy moff2(0.);
      _a1runwidth.resize(0);_a1runq2.resize(0);
      for(;moff2<=mtau2;moff2+=step)
	{
	  total=widthgen->width(moff2);
	  cout << "testing the g function " 
	       << moff2/GeV2 << " " 
	       << sqrt(moff2)*total/GeV2 << "  " 
	       << a1const*sqrt(moff2)*total/GeV2 << "    "
	       << total*sqrt(moff2)/_a1mass*a1const << endl;
	  total*=a1const;
	  _a1runwidth.push_back(total);
	  _a1runq2.push_back(moff2);
	}
      delete inme; delete widthgen;
      cout << "Energy2 a1q2in[200]={";
      for(unsigned int ix=0;ix<200;++ix)
	{cout << _a1runq2[ix] << ",";}
      cout << endl;
      cout << "Energy a1widthin[200]={";
      for(unsigned int ix=0;ix<200;++ix)
	{cout << _a1runwidth[ix] << ",";}
      cout << endl;
    }
  // set up the interpolator
  else if(iopt==0)
    {_a1runinter = new Interpolator(_a1runwidth,_a1runq2,3);}
}

// form-factor for the a_1 vertex
inline double FourPionNovosibirskCurrent::a1FormFactor(Energy2 q2) const
{
  double temp((1.+_a1massolam2)/(1.+q2*_onedlam2));   
  return temp*temp;
}
  
// running width of the a_1
inline Energy FourPionNovosibirskCurrent::a1width(Energy2 q2) const
{return (*_a1runinter)(q2);}

// a_1 Breit Wigner
inline Complex FourPionNovosibirskCurrent::a1BreitWigner(Energy2 q2) const
{
  Complex ii(0.,1.);
  Energy2 m2(_a1mass*_a1mass); Energy q(sqrt(q2));
  return m2/(q2-m2+ii*q*a1width(q2));
}

// current t_1 from hep-ph/0201149
inline LorentzPolarizationVector FourPionNovosibirskCurrent::t1(Lorentz5Momentum & q1,
								Lorentz5Momentum & q2,
								Lorentz5Momentum & q3,
								Lorentz5Momentum & q4) const 
{
  // momentum of the whole sysytem
  Lorentz5Momentum Q(q1+q2+q3+q4);Q.rescaleMass();
  // compute the virtuality of the a_1
  Lorentz5Momentum a1(q2+q3+q4);a1.rescaleMass();
  // compute the virtuality of the  rho
  Lorentz5Momentum rho(q3+q4);rho.rescaleMass();
  // compute the prefactor    
  Complex pre(-a1FormFactor(a1.mass2())*a1BreitWigner(a1.mass2())*
	      rhoBreitWigner(rho.mass2()));
  // dot products we need
  Energy2 QdQmq1(Q*a1);
  Complex consta(QdQmq1*(a1*q3)),constb(QdQmq1*(a1*q4)),
    constc(((Q*q4)*(q1*q3)-(Q*q3)*(q1*q4)));
  // compute the current
  return pre*(consta*q4-constb*q3+constc*a1);
}

// current t_2 from hep-ph/0201149
inline LorentzPolarizationVector FourPionNovosibirskCurrent::t2(Lorentz5Momentum & q1,
								Lorentz5Momentum & q2,
								Lorentz5Momentum & q3,
								Lorentz5Momentum & q4) const
{
  // momentum of the whole sysytem
  Lorentz5Momentum Q(q1+q2+q3+q4);Q.rescaleMass();
  // compute the virtuality of the a_1
  Lorentz5Momentum a1(q2+q3+q4);a1.rescaleMass();
  // compute the virtuality of the  sigma
  Lorentz5Momentum sigma(q3+q4);sigma.rescaleMass();
  // compute the prefactor
  Complex pre(_zsigma*a1FormFactor(a1.mass2())*a1BreitWigner(a1.mass2())*
	      sigmaBreitWigner(sigma.mass2()));
  // dot products we need
  Complex consta((Q*a1)*a1.mass2()),constb((Q*q2)*a1.mass2());
  // compute the current
  return pre*(consta*q2-constb*a1);
}

// current t_3 from hep-ph/0201149
inline LorentzPolarizationVector FourPionNovosibirskCurrent::t3(Lorentz5Momentum & q1,
								Lorentz5Momentum & q2,
								Lorentz5Momentum & q3,
								Lorentz5Momentum & q4) const
{
  // momentum of the whole sysytem
  Lorentz5Momentum Q(q1+q2+q3+q4);Q.rescaleMass();
  // compute the virtuality of the omega
  Lorentz5Momentum omega(q2+q3+q4);omega.rescaleMass();
  // compute the virtuality of the  rho
  Lorentz5Momentum rho(q3+q4);rho.rescaleMass();
  // compute the prefactor
  Complex pre(omegaBreitWigner(omega.mass2())*rhoBreitWigner(rho.mass2()));
  // dot products we need
  Complex consta((Q*q3)*(q1*q4)-(Q*q4)*(q1*q3)),constb(-(Q*q2)*(q1*q4)+(q1*q2)*(Q*q4)),
    constc((Q*q2)*(q1*q3)-(q1*q2)*(Q*q3));
  // compute the current
  return pre*(consta*q2+constb*q3+constc*q4);
}

// the G functions of hep-ph/0201149
inline double FourPionNovosibirskCurrent::gFunction(Energy2 Q2, int ichan) const
{
  double output;
  Energy Q(sqrt(Q2));
  double invmrho4(1./(_rhomass*_rhomass*_rhomass*_rhomass));
  // the one charged pion G function
  if(ichan==0)
    {output = (*_Fonec)(Q)*_aonec*(*_Fsigma)(Q2)*sqrt((_bonec*Q-_conec)/GeV)*
       invmrho4/Q;}
  // the three charged pion G function
  else if(ichan==1)
    {output = (*_Fthreec)(Q)*_athreec*sqrt((_bthreec*Q-_cthreec)/GeV)*invmrho4/Q;}
  // the omega G function
  else if(ichan==2)
    {output = (*_Fomega)(Q)*_aomega*sqrt((_bomega*Q-_comega)/GeV)*invmrho4/Q;}
  else
    {throw Exception() << "Invalid function in FourPionNovosibirskCurrent::gFunction" 
		       << Exception::abortnow;}
  return output;
}

// breit wigner for the omega  
inline Complex FourPionNovosibirskCurrent::omegaBreitWigner(Energy2 Q2) const
{
  Energy Q(sqrt(Q2));
  // calcluate the running width
  double diff((Q-_omegamass)/GeV),temp(diff);
  double gomega(1.);
  Complex ii(0.,1.);
  if(Q<=1.*GeV) 
    {for(unsigned int ix=0;ix<6;++ix){gomega +=temp*_omegaparam[ix];temp*=diff;}}
  else
    {gomega=_omegaparam[6]+Q/GeV*(_omegaparam[7]+Q/GeV*_omegaparam[8]
				  +Q2/GeV2*_omegaparam[9]);}
  if(gomega<0.){gomega=0.;}
  Energy2 numer=_omegamass*_omegamass;
  complex<Energy2> denom=Q2-_omegamass*_omegamass+ii*_omegamass*_omegawidth*gomega;
  return numer/denom;
}

// breit-wigner for the sigma meson
inline Complex FourPionNovosibirskCurrent::sigmaBreitWigner(Energy2 q2) const
{
  Energy q(sqrt(q2)),
    width(_sigmawidth*Kinematics::pstarTwoBodyDecay(q,_mpi,_mpi)/_psigma);
  Energy2 msigma2(_sigmamass*_sigmamass);
  Complex ii(0.,1.),denom;
  if(q>2.*_mpi){denom= q2-msigma2+ii*msigma2*width/q;}
  else{denom= q2-msigma2;}
  return msigma2/denom;
}

// the h function in the rho propagator
inline Energy2 FourPionNovosibirskCurrent::hFunction(const Energy q)const 
{
  double output;
  static const Energy2 eps(0.01);
  Energy q2(q*q);
  double root(sqrt(1.-4.*_mpi2/q2));
  if(q2>4*_mpi2)
    {output=root*log((1.+root)/(1.-root))*(q2-4*_mpi2)/pi;}
  else if(q2>eps)
    {output=0.;}
  else
    {output=-8.*_mpi2/pi;}
  return output;
}

// the dh/dq2 rho the propagator
inline double FourPionNovosibirskCurrent::dhdq2Parameter() const
{
  Energy2 mrho2(_rhomass*_rhomass);
  double root(sqrt(1.-4.*_mpi2/mrho2));
  return root/pi*(root+(1.+2*_mpi2/mrho2)*log((1+root)/(1-root)));
}
  
// the numerator for the rho propagator
inline Energy2 FourPionNovosibirskCurrent::DParameter() const 
{
  double grhom(8.*_prho*_prho*_prho/_rhomass);
  return _rhomass*_rhomass+_rhowidth*_rhomass*
    (hFunction(0.)-_hm2+_rhomass*_rhomass*_dhdq2m2)/grhom;
}

// the rho Breit-Wigner
inline Complex FourPionNovosibirskCurrent::rhoBreitWigner(Energy2 q2) const
{
  Energy q(sqrt(q2));
  double grhom(8.*_prho*_prho*_prho/_rhomass);
  complex<Energy2> denom;
  Complex ii(0.,1.);
  if(q2<4.*_mpi2)
    {
      denom=q2-_rhomass*_rhomass
      	-_rhowidth*_rhomass*(hFunction(q)-_hm2-(q2-_rhomass*_rhomass)*_dhdq2m2)/grhom;
    }
  else
    {
      Energy pcm(2.*Kinematics::pstarTwoBodyDecay(q,_mpi,_mpi));
      double grho(pcm*pcm*pcm/q);
      denom=q2-_rhomass*_rhomass
	-_rhowidth*_rhomass*(hFunction(q)-_hm2-(q2-_rhomass*_rhomass)*_dhdq2m2)/grhom
	+ii*_rhomass*_rhowidth*grho/grhom;
    }
  return _rhoD/denom;
}
}
