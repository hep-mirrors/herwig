// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DtoKPiPiE791 class.
//

namespace Herwig {

inline IBPtr DtoKPiPiE791::clone() const {
  return new_ptr(*this);
}

inline IBPtr DtoKPiPiE791::fullclone() const {
  return new_ptr(*this);
}

inline void DtoKPiPiE791::decayAngle(const Lorentz5Momentum & pparent,
				      const Lorentz5Momentum & pres,
				      const Lorentz5Momentum & p1,
				      double & cost, Energy2 & ac) const{
  Energy2 dot   = pparent*p1;
  Energy2 mREp  = pres*pparent;
  Energy2 mRE1  = pres*p1;
  Energy2 mp2   = pparent.mass2();
  Energy2 mres2 = pres.mass2();
  Energy2 m12   = p1.mass2();
  // magnitudes
  ac = sqrt((mREp*mREp-mres2*mp2)*(mRE1*mRE1-mres2*m12))/mres2; 
  // angle
  cost=(dot*mres2-mREp*mRE1)/ac/mres2;
}
  
inline Complex DtoKPiPiE791::amplitude(int ispin, Energy mD, 
				       Energy mA , Energy mB , Energy mC ,
				       Energy mAB, double cost, Energy2 ac,
				       Energy mres, Energy wres) const {
  // compute the production momenta
  Energy pDR  = Kinematics::CMMomentum(mD,mres,mC);
  Energy pDAB = Kinematics::CMMomentum(mD,mAB ,mC);
  // and the decay momenta
  Energy pAB = Kinematics::CMMomentum(mAB ,mA,mB);
  Energy pR  = Kinematics::CMMomentum(mres,mA,mB);
  double Fd(1.),Fr(1.),Fr0(1.),s(1.),Fd0(1.);
  switch(ispin) {
  case 0:
    // default values of parameters are correct unless using exponential
    // form-factor
    if(_imodel>1) {
      InvEnergy rD(_rD0B),rres(_rresB);
      if(_imodel==3) {
	rD   = _rD0C;
	rres = _rresC; 
      }
      Fd  = exp(-sqr(pDAB*rD  )/12.);
      Fr  = exp(-sqr( pAB*rres)/12.);
      Fr0 = exp(-sqr( pR *rres)/12.);
    }
    break;
  case 1:
    Fr  = 1./sqrt(1.+sqr(_rresA*pAB ));
    Fr0 = 1./sqrt(1.+sqr(_rresA*pR  ));
    Fd  = 1./sqrt(1.+sqr(_rD0A *pDAB));
    Fd0 = 1./sqrt(1.+sqr(_rD0A *pDR ));
    s =-2.*ac/GeV2*cost;
    break;
  case 2:
    Fr  = 1./sqrt(9.+3.*sqr(_rresA*pAB )+Math::powi(_rresA*pAB ,4));
    Fr0 = 1./sqrt(9.+3.*sqr(_rresA*pR  )+Math::powi(_rresA*pR  ,4));
    Fd  = 1./sqrt(9.+3.*sqr(_rD0A *pDAB)+Math::powi(_rD0A *pDAB,4));
    Fd0 = 1./sqrt(9.+3.*sqr(_rD0A *pDR )+Math::powi(_rD0A *pDR ,4));
    s = 4./3.*sqr(ac/GeV2)*(3.*sqr(cost)-1.);
    break;
  default:
    throw Exception() << "D0toK0PiPiE791::amplitude spin is too high ispin = " 
		      << ispin << Exception::runerror;
  }
  // calculate the width term
  Energy2 mwid=wres*Math::powi(pAB/pR,2*ispin+1)*sqr(Fr*mres/Fr0)/mAB;
  complex<Energy2> bw = sqr(mres)-sqr(mAB)-complex<Energy2>(0.*MeV2,mwid);
  return s*Fr*Fd*GeV2/bw;
}

}
