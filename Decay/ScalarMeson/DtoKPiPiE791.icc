// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DtoKPiPiE791 class.
//

namespace Herwig {

inline IBPtr DtoKPiPiE791::clone() const {
  return new_ptr(*this);
}

inline IBPtr DtoKPiPiE791::fullclone() const {
  return new_ptr(*this);
}

inline double DtoKPiPiE791::decayAngle(const Lorentz5Momentum & pparent,
				       const Lorentz5Momentum & pres,
				       const Lorentz5Momentum & p1) const{
  Energy2 dot   = pparent*p1;
  Energy2 mREp  = pres*pparent;
  Energy2 mRE1  = pres*p1;
  Energy2 mp2   = pparent.mass2();
  Energy2 mres2 = pres.mass2();
  Energy2 m12   = p1.mass2();
  cerr << "testing " 
       << sqrt((mREp*mREp-mres2*mp2)/mres2) << " " 
       << sqrt((mRE1*mRE1-mres2*m12)/mres2) << "\n";
  double cost=(dot*mres2-mREp*mRE1)/sqrt((mREp*mREp-mres2*mp2)*(mRE1*mRE1-mres2*m12));
  return cost;
}

inline Complex  DtoKPiPiE791::amplitude(int ispin, Energy mD, Energy mA,
					Energy mB, Energy mC, Energy mAB, double ctheta,
					Energy p2, Energy p3, Energy mres, 
					Energy wres) const {
  // compute the production momenta
  Energy pDR  = Kinematics::CMMomentum(mD,mres,mC);
  Energy pDAB = Kinematics::CMMomentum(mD,mAB ,mC);
  // and the decay momenta
  Energy pAB = Kinematics::CMMomentum(mAB ,mA,mB);
  Energy pR  = Kinematics::CMMomentum(mres,mA,mB);
  double Fd(1.),FR(1.),FAB(1.),FdR(1.),s(1.);
  switch(ispin) {
  case 0:
    // default values of parameters are correct unless using exponential
    // form-factor
    if(_imodel>1) {
      InvEnergy rD(_rD0B),rres(_rresB);
      if(_imodel==3) {
	rD   = _rD0C;
	rres = _rresC; 
      }
      Fd  = exp(-sqr(pDAB*rD  )/12.);
      FAB = exp(-sqr( pAB*rres)/12.);
      FR  = exp(-sqr( pR *rres)/12.);
    }
    break;
  case 1:
    Fd  = 1./sqrt(1.+sqr(_rD0A *pDAB));
    FdR = 1./sqrt(1.+sqr(_rD0A *pDR ));
    FAB = 1./sqrt(1.+sqr(_rresA*pAB ));
    FR  = 1./sqrt(1.+sqr(_rresA*pR  ));
    s = -2.*p2*p3*ctheta/GeV2;
    break;
  case 2:
    Fd  = 1./sqrt(9.+3.*sqr(_rD0A *pDAB)+Math::powi(_rD0A *pDAB,4));
    FdR = 1./sqrt(9.+3.*sqr(_rD0A *pDR )+Math::powi(_rD0A *pDR ,4));
    FAB = 1./sqrt(9.+3.*sqr(_rresA*pAB )+Math::powi(_rresA*pAB ,4));
    FR  = 1./sqrt(9.+3.*sqr(_rresA*pR  )+Math::powi(_rresA*pR  ,4));
    s = 4./3.*sqr(p2*p3/GeV2)*(3.*sqr(ctheta)-1.);
    break;
  default:
    throw Exception() << "D0toK0PiPiBaBar::amplitude spin is too high ispin = " 
		      << ispin << Exception::runerror;
  }
  // calculate the width term
  Energy2 mwid=wres*Math::powi(pAB/pR,2*ispin+1)*sqr(FAB*mres/FR)/mAB;
  Complex  bw = sqr(mres)-sqr(mAB)-Complex(0.,mwid);


//   for(mAB=700.*MeV;mAB<3*GeV;mAB+=MeV) {
//     pAB = Kinematics::CMMomentum(mAB ,mA,mB);
//     pR  = Kinematics::CMMomentum(mres,mA,mB);
//     FAB=1.;FR=1.;
//     switch(ispin) {
//     case 0:
//       break;
//     case 1:
//       FAB = 1./sqrt(1.+sqr(_rresA*pAB ));
//       FR  = 1./sqrt(1.+sqr(_rresA*pR  ));
//       break;
//     case 2:
//       FAB = 1./sqrt(9.+3.*sqr(_rresA*pAB )+Math::powi(_rresA*pAB ,4));
//       FR  = 1./sqrt(9.+3.*sqr(_rresA*pR  )+Math::powi(_rresA*pR  ,4));
//       break;
//     }
//     FAB = 1./sqrt(9.+3.*sqr(_rresA*pAB )+Math::powi(_rresA*pAB ,4));
//     FR  = 1./sqrt(9.+3.*sqr(_rresA*pR  )+Math::powi(_rresA*pR  ,4));
//     Energy2 mwid=wres*Math::powi(pAB/pR,2*ispin+1)*sqr(FAB*mres/FR)/mAB;
//     bw = sqr(mres)-sqr(mAB)-Complex(0.,mwid);
//     cerr << mAB << " " << 1./real(bw*conj(bw)) << "\n";
//   }
//   exit(0);


  return s*FAB*Fd*GeV2/bw;
}

}
