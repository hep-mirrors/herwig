// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the EtaPiGammaGammaDecayer class.
//

namespace Herwig {
using namespace ThePEG;

inline EtaPiGammaGammaDecayer::EtaPiGammaGammaDecayer() 
{
  // the coupling of the rho to omega and a pion
  _grhoomega=12.924/GeV;
  // the pion decay constant
  _fpi=130.7*MeV;
  // the mass and width of the rho 
  _rhomass  =771.1*MeV;
  _rhowidth =149.2*MeV;
  _rhoconst=0.;_mpi=0.;
  // the coupling for the conversion of a rho to a photon
  _grho=_rhomass/_fpi;
  // use local values of the rho mass and width
  _localparameters=true;
  // ratios of the decay constants
  _ratiofpif8 =1./1.3;
  _ratiofpif0 =1./1.04;
  _theta = -pi/9.;
  // the maximum weights for the different decays
  _etamax  =1.2232e-06;
  _etapmax =0.00105024;
  // the constants for the matrix elements
  for(unsigned int ix=0;ix<2;++ix){_Dconst[ix]=0.;_Econst[ix]=0.;}
}

inline EtaPiGammaGammaDecayer::EtaPiGammaGammaDecayer(const EtaPiGammaGammaDecayer & x)
  : DecayIntegrator(x), _grhoomega(x._grhoomega),_fpi(x._fpi),_grho(x._grho),
    _rhomass(x._rhomass),_rhowidth(x._rhowidth),_mpi(x._mpi),
    _rhoconst(x._rhoconst),_localparameters(x._localparameters),
    _ratiofpif8(x._ratiofpif8),_ratiofpif0(x._ratiofpif0),_theta(x._theta),
    _etamax(x._etamax),_etapmax(x._etapmax) 
 {
   for(unsigned int ix=0;ix<2;++ix)
     {
       _Dconst[ix]=x._Dconst[ix];
       _Econst[ix]=x._Econst[ix];
     }
 }

inline IBPtr EtaPiGammaGammaDecayer::clone() const {
  return new_ptr(*this);
}

inline IBPtr EtaPiGammaGammaDecayer::fullclone() const {
  return new_ptr(*this);
}

inline void EtaPiGammaGammaDecayer::doupdate() throw(UpdateException) {
  DecayIntegrator::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void EtaPiGammaGammaDecayer::doinit() throw(InitException) {
  DecayIntegrator::doinit();
  // set rho parameters if needed
  tPDPtr rho=getParticleData(ParticleID::rho0);
  if(!_localparameters)
    {
      _rhomass  = rho->mass();
      _rhowidth = rho->width();
    }
  // constant for the running rho width
  _mpi=getParticleData(ParticleID::pi0)->mass();
  Energy pcm =Kinematics::pstarTwoBodyDecay(_rhomass,_mpi,_mpi);
  _rhoconst=_rhomass*_rhomass*_rhowidth/(pcm*pcm*pcm);
  // set the prefactors
  double conv=sqrt(4.*pi*SM().alphaEM());
  conv *=_fpi*_fpi*_grho/_rhomass/_rhomass;
  InvEnergy pre=2.*sqrt(3.)/9.*_grhoomega*_grhoomega*conv*conv;
  double fact[2];
  // constants for eta
  fact[0] = _ratiofpif8*cos(_theta)-sqrt(2.)*_ratiofpif0*sin(_theta);
  // constants for eta'
  fact[1] = _ratiofpif8*sin(_theta)+sqrt(2.)*_ratiofpif0*cos(_theta);
  for(unsigned int ix=0;ix<2;++ix)
    {
      _Dconst[ix]=fact[ix]*pre;
      _Econst[ix]=fact[ix]*pre;
    }
  // set up the phsae space for the decays
  tPDPtr eta[2]={getParticleData(ParticleID::eta),
		 getParticleData(ParticleID::etaprime)};
  PDVector extpart;extpart.resize(4);
  extpart[1] = getParticleData(ParticleID::pi0);
  extpart[2] = getParticleData(ParticleID::gamma);
  extpart[3] = getParticleData(ParticleID::gamma);
  vector<double> dummyweights(2,0.5);
  DecayPhaseSpaceChannelPtr newchannel;
  DecayPhaseSpaceModePtr mode;
  for(unsigned int ix=0;ix<2;++ix)
    {
      extpart[0] = eta[ix];
      mode = new DecayPhaseSpaceMode(extpart,this);
      newchannel=new_ptr(DecayPhaseSpaceChannel(mode));
      newchannel->addIntermediate(extpart[0],0, 0.0,-1,2);
      newchannel->addIntermediate(rho,0,0.0, 1,3);
      newchannel->init();
      mode->addChannel(newchannel);
      newchannel=new_ptr(DecayPhaseSpaceChannel(mode));
      newchannel->addIntermediate(extpart[0],0, 0.0,-1,3);
      newchannel->addIntermediate(rho,0,0.0, 1,2);
      newchannel->init();
      mode->addChannel(newchannel);
      if(ix==0){addMode(mode,_etamax,dummyweights);}
      else if(ix==1){addMode(mode,_etapmax,dummyweights);}
    }
  
}

inline void EtaPiGammaGammaDecayer::dofinish() {
  DecayIntegrator::dofinish();
}

inline void EtaPiGammaGammaDecayer::doinitrun() {
  DecayIntegrator::doinitrun();
}

inline void EtaPiGammaGammaDecayer::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  DecayIntegrator::rebind(trans);
}

inline IVector EtaPiGammaGammaDecayer::getReferences() {
  IVector ret = DecayIntegrator::getReferences();
  // ret.push_back(dummy);
  return ret;
}

}
