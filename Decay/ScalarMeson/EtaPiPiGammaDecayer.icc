// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the EtaPiPiGammaDecayer class.
//

namespace Herwig {
using namespace ThePEG;

inline EtaPiPiGammaDecayer::EtaPiPiGammaDecayer(const EtaPiPiGammaDecayer & x)
  : DecayIntegrator(x), _fpi(x._fpi), _incoming(x._incoming),
    _coupling(x._coupling), _maxweight(x._maxweight),
    _option(x._option), _aconst(x._aconst),_cconst(x._cconst), _mrho(x._mrho),
    _rhowidth(x._rhowidth),_rhoconst(x._rhoconst),_mpi(x._mpi),
    _localparameters(x._localparameters),_energy(x._energy), _phase(x._phase),
    _Omnesenergy(x._Omnesenergy),
    _Omnesfunctionreal(x._Omnesfunctionreal), _Omnesfunctionimag(x._Omnesfunctionimag),
    _initialize(x._initialize), _npoints(x._npoints), _epscut(x._epscut) 
{for(unsigned int ix=0;ix<2;++ix){_nsize[ix]=x._nsize[ix];}}

inline IBPtr EtaPiPiGammaDecayer::clone() const {
  return new_ptr(*this);
}

inline IBPtr EtaPiPiGammaDecayer::fullclone() const {
  return new_ptr(*this);
}

inline void EtaPiPiGammaDecayer::doupdate() throw(UpdateException) {
  DecayIntegrator::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void EtaPiPiGammaDecayer::dofinish() {
  DecayIntegrator::dofinish();
}

inline void EtaPiPiGammaDecayer::doinitrun() {
  DecayIntegrator::doinitrun();
  if(initialize())
    {for(unsigned int ix=0;ix<_maxweight.size();++ix)
	{_maxweight[ix]=mode(ix)->maxWeight();}}
}

inline void EtaPiPiGammaDecayer::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  DecayIntegrator::rebind(trans);
}

inline IVector EtaPiPiGammaDecayer::getReferences() {
  IVector ret = DecayIntegrator::getReferences();
  // ret.push_back(dummy);
  return ret;
}


// the analytic omnes function  
inline Complex EtaPiPiGammaDecayer::analyticOmnes(Energy2 s) const {
  Energy2 mpi2(_mpi*_mpi),mrho2(_mrho*_mrho);
  double root,pi2(pi*pi);
  Complex f,ii(0.,1.);
  double pre(mpi2/12./pi2/_fpi/_fpi);
  if(s>4.*mpi2) {
    // real piece
    root=sqrt(1.-4.*mpi2/s);
    f=(1.-0.25*s/mpi2)*root*log((root+1.)/(-root+1.))-2.;
    f *=pre;
    // imaginary piece
    f += ii*s/mrho2*_rhoconst/8.*root*root*root;
  }
  else {
    root=sqrt((4.*mpi2-s)/s);
    f=2.*(1.-0.25*s/mpi2)*root*atan(1./root)-2.;
    f *=pre;
  }
  return 1.-s/mrho2-s/48./pi2/_fpi/_fpi*log(mrho2/mpi2)-f;
}
  
inline Complex EtaPiPiGammaDecayer::experimentalOmnes(Energy2 s) const {
  if(!_Oreal) {
    _Oreal = new_ptr(NewInterpolator(_Omnesfunctionreal,_Omnesenergy,3));
    _Oimag = new_ptr(NewInterpolator(_Omnesfunctionimag,_Omnesenergy,3));
  }
  Energy q(sqrt(s)); Complex ii(0.,1.);
  return (*_Oreal)(q)+ii*(*_Oimag)(q);
}
}
