// -*- C++ -*-
//
// EtaPiPiGammaDecayer.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the EtaPiPiGammaDecayer class.
//

namespace Herwig {
using namespace ThePEG;

inline IBPtr EtaPiPiGammaDecayer::clone() const {
  return new_ptr(*this);
}

inline IBPtr EtaPiPiGammaDecayer::fullclone() const {
  return new_ptr(*this);
}

inline void EtaPiPiGammaDecayer::doinitrun() {
  DecayIntegrator::doinitrun();
  if(initialize()) {
    for(unsigned int ix=0;ix<_maxweight.size();++ix)
      _maxweight[ix]=mode(ix)->maxWeight();
  }
}

// the analytic omnes function  
inline Complex EtaPiPiGammaDecayer::analyticOmnes(Energy2 s) const {
  Energy2 mpi2(_mpi*_mpi),mrho2(_mrho*_mrho);
  double root, pi2 = sqr(Constants::pi);
  Complex f,ii(0.,1.);
  double pre(mpi2/12./pi2/_fpi/_fpi);
  if(s>4.*mpi2) {
    // real piece
    root=sqrt(1.-4.*mpi2/s);
    f=(1.-0.25*s/mpi2)*root*log((root+1.)/(-root+1.))-2.;
    f *=pre;
    // imaginary piece
    f += ii*s/mrho2*_rhoconst/8.*pow(root,3);
  }
  else {
    root=sqrt(4.*mpi2/s-1.);
    f=2.*(1.-0.25*s/mpi2)*root*atan(1./root)-2.;
    f *=pre;
  }
  return 1.-s/mrho2-s/48./pi2/_fpi/_fpi*log(mrho2/mpi2)-f;
}
  
inline Complex EtaPiPiGammaDecayer::experimentalOmnes(Energy2 s) const {
  if(!_oreal) {
    _oreal = make_InterpolatorPtr(_omnesfunctionreal,_omnesenergy,3);
    _oimag = make_InterpolatorPtr(_omnesfunctionimag,_omnesenergy,3);
  }
  Energy q(sqrt(s)); Complex ii(0.,1.);
  return (*_oreal)(q)+ii*(*_oimag)(q);
}

inline OmnesIntegrand::OmnesIntegrand(Interpolator<double,Energy>::Ptr in,Energy2 eps) {
  _interpolator=in;
  _precision=eps;
}

inline void OmnesIntegrand::setScale(Energy2 in) {
  _s=in;
}

inline InvEnergy4 OmnesIntegrand::operator ()(Energy2 xpoint) const {
  InvEnergy4 output = InvEnergy4();
  Energy q(sqrt(xpoint));
  if(abs(xpoint-_s)>_precision) 
    output= (*_interpolator)(q)/xpoint/(xpoint-_s);
  return output;
}
}
