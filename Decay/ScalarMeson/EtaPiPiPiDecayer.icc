// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the EtaPiPiPiDecayer class.
//

namespace Herwig {
using namespace ThePEG;

inline EtaPiPiPiDecayer::EtaPiPiPiDecayer() 
{
  // eta to pi+pi-pi0
  _incoming.push_back(221);_outgoing.push_back(111);_charged.push_back(true);
  _prefactor.push_back(0.037165);
  _a.push_back(-1.17);_b.push_back(0.21);_c.push_back(0.06);
  _maxweight.push_back(0.000349837);
  // eta to pi0pi0pi0
  _incoming.push_back(221);_outgoing.push_back(111);_charged.push_back(false);
  _prefactor.push_back(0.08126);
  _a.push_back(0.);_b.push_back(-0.062);_c.push_back(-0.062);
  _maxweight.push_back(0.000509929);
  // eta' to pi+pi-pi0
  _incoming.push_back(331);_outgoing.push_back(111);_charged.push_back(true);
  _prefactor.push_back(0.037165);
  _a.push_back(-3.08);_b.push_back(0.13);_c.push_back(0.62);
  _maxweight.push_back(0.00459752);
  // eta' to pi0pi0pi0
  _incoming.push_back(331);_outgoing.push_back(111);_charged.push_back(false);
  _prefactor.push_back(0.08126);
  _a.push_back(0.0);_b.push_back(-0.86);_c.push_back(-0.86);
  _maxweight.push_back(0.00357185);
  // eta' to pi+pi-eta
  _incoming.push_back(331);_outgoing.push_back(221);_charged.push_back(true);
  _prefactor.push_back(0.037165);
  _a.push_back(-0.093);_b.push_back(-0.059);_c.push_back(-0.003);
  _maxweight.push_back(9.5407e-05);
  // eta' to pi0pi0eta
  _incoming.push_back(331);_outgoing.push_back(221);_charged.push_back(false);
  _prefactor.push_back(0.08126);
  _a.push_back(-0.105);_b.push_back(-0.065);_c.push_back(-0.004);
  _maxweight.push_back(0.000236483);
}

inline EtaPiPiPiDecayer::EtaPiPiPiDecayer(const EtaPiPiPiDecayer & x)
  : DecayIntegrator(x), _incoming(x._incoming), _outgoing(x._outgoing),
    _charged(x._charged),_prefactor(x._prefactor),_a(x._a),_b(x._b),_c(x._c),
    _maxweight(x._maxweight) {}

inline IBPtr EtaPiPiPiDecayer::clone() const {
  return new_ptr(*this);
}

inline IBPtr EtaPiPiPiDecayer::fullclone() const {
  return new_ptr(*this);
}

inline void EtaPiPiPiDecayer::doupdate() throw(UpdateException) {
  DecayIntegrator::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void EtaPiPiPiDecayer::doinit() throw(InitException) {
  DecayIntegrator::doinit();
  // check consistency of the parameters
  unsigned int isize=_incoming.size();
  if(isize!=_outgoing.size()||isize!=_prefactor.size()||
     isize!=_charged.size()||isize!=_a.size()||
     isize!=_b.size()||isize!=_c.size()||isize!=_maxweight.size())
    {throw InitException() << "Inconsistent parameters in EtaPiPiPiDecayer::doinit()"
			   << Exception::runerror;}
  // external particles for the modes
  PDVector extneut(4),extcharged(4);
  extneut[1]    = getParticleData(ParticleID::pi0);
  extneut[2]    = getParticleData(ParticleID::pi0);
  extcharged[1] = getParticleData(ParticleID::piplus);
  extcharged[2] = getParticleData(ParticleID::piminus);
  tPDPtr sigma=getParticleData(9000221);
  DecayPhaseSpaceModePtr mode;
  DecayPhaseSpaceChannelPtr newchannel;
  vector<double> dummyweights(1,1.);
  for(unsigned int ix=0;ix<_incoming.size();++ix)
    {
      extneut[0]    = getParticleData(_incoming[ix]);
      extcharged[0] = getParticleData(_incoming[ix]);
      extneut[3]    = getParticleData(_outgoing[ix]);
      extcharged[3] = getParticleData(_outgoing[ix]);
      if(_charged[ix])
	{
	  // the pi+pi- mode
	  mode = new DecayPhaseSpaceMode(extcharged,this);
	  newchannel=new_ptr(DecayPhaseSpaceChannel(mode));
	  newchannel->addIntermediate(extcharged[0],0, 0.0,-1,3);
	  newchannel->addIntermediate(sigma,1,0.0, 1,2);
	  newchannel->init();
	  mode->addChannel(newchannel);
	}
      else
	{
      // the pi0pi0 mode
      mode = new DecayPhaseSpaceMode(extneut,this);
      newchannel=new_ptr(DecayPhaseSpaceChannel(mode));
      newchannel->addIntermediate(extneut[0],0, 0.0,-1,3);
      newchannel->addIntermediate(sigma,1,0.0, 1,2);
      newchannel->init();
      mode->addChannel(newchannel);
	}
      addMode(mode,_maxweight[ix],dummyweights);
    }
}

inline void EtaPiPiPiDecayer::dofinish() {
  DecayIntegrator::dofinish();
}

inline void EtaPiPiPiDecayer::doinitrun() {
  DecayIntegrator::doinitrun();
}

inline void EtaPiPiPiDecayer::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  DecayIntegrator::rebind(trans);
}

inline IVector EtaPiPiPiDecayer::getReferences() {
  IVector ret = DecayIntegrator::getReferences();
  // ret.push_back(dummy);
  return ret;
}

}
