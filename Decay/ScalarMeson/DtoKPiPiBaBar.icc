// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DtoKPiPiBaBar class.
//

namespace Herwig {

inline IBPtr DtoKPiPiBaBar::clone() const {
  return new_ptr(*this);
}

inline IBPtr DtoKPiPiBaBar::fullclone() const {
  return new_ptr(*this);
}

inline Complex DtoKPiPiBaBar::amplitude(int ispin,bool gs, Energy mD,
					  Energy mA , Energy mB , Energy mC ,
					  Energy mAB, Energy mAC, Energy mBC,
					  Energy mres, Energy wres) const{
  // compute the production momenta
  Energy pDR  = Kinematics::CMMomentum(mD,mres,mC);
  Energy pDAB = Kinematics::CMMomentum(mD,mAB ,mC);
  // and the decay momenta
  Energy pAB = Kinematics::CMMomentum(mAB ,mA,mB);
  Energy pR  = Kinematics::CMMomentum(mres,mA,mB);
  double Fd(1.),Fr(1.),s(1.);
  switch(ispin) {
  case 0:
    // default values of parameters are correct
    break;
  case 1:
    Fr = sqrt((1.+sqr(_rres*pR ))/(1.+sqr(_rres*pAB )));
//     Fd = sqrt((1.+sqr(_rD0 *pDR))/(1.+sqr(_rD0 *pDAB)));
    Fd = 1.;
    s = ((mAC-mBC)*(mAC+mBC)+(mD-mC)*(mD+mC)*(mB-mA)*(mB+mA)/sqr(mres))/GeV2;
    break;
  case 2:
    Fr = sqrt((9.+3.*sqr(_rres*pR  )+Math::powi(_rres*pR  ,4))/
	      (9.+3.*sqr(_rres*pAB )+Math::powi(_rres*pAB ,4)));
//     Fd = sqrt((9.+3.*sqr(_rD0 *pDR )+Math::powi(_rD0 *pDR ,4))/
// 	      (9.+3.*sqr(_rD0 *pDAB)+Math::powi(_rD0 *pDAB,4)));
    Fd = 1.;
    s = sqr(((mBC-mAC)*(mBC+mAC)+(mD-mC)*(mD+mC)*(mA-mB)*(mA+mB)/sqr(mres))/GeV2)
      -(mAB*mAB-2.*mD*mD-2.*mC*mC+sqr((mD-mC)*(mD+mC))/sqr(mres))*
       (mAB*mAB-2.*mA*mA-2.*mB*mB+sqr((mA-mB)*(mA+mB))/sqr(mres))/3./GeV2/GeV2;
    break;
  default:
    throw Exception() << "DtoKPiPiBaBar::amplitude spin is too high ispin = " 
		      << ispin << Exception::runerror;
  }
  // calculate the width term
  complex<Energy2> bw;
  if(!gs) {
    Energy2 mwid=wres*Math::powi(pAB/pR,2*ispin+1)*sqr(Fr*mres)/mAB;
    bw = sqr(mres)-sqr(mAB)-complex<Energy2>(0.*MeV2,mwid);
  }
  else {
    Energy2    M2 = sqr(mres);
    Energy2    s  = sqr(mAB);
    Energy     ks = sqrt(0.25*s -sqr(mA));
    Energy     kM = sqrt(0.25*M2-sqr(mA));
    double     hs = 2./Constants::pi*ks/mAB *log((mAB +2.*ks)/2./mA);
    double     hM = 2./Constants::pi*kM/mres*log((mres+2.*kM)/2./mA);
    InvEnergy2 dh =(0.5+sqr(mA)/mres/kM*log((mres+2.*kM)/2./mA))/Constants::pi/M2;
    bw = M2-s+wres*(M2/pow<3,1>(kM))*(sqr(ks)*(hs-hM)+sqr(kM)*dh*(M2-s))
      -complex<Energy2>(0.*MeV2,M2*wres*Math::powi(double(ks/kM),3)/mAB);
//     Energy d = 3./Constants::pi*sqr(mA/kM)*log((mres+2.*kM)/2./mA)
//       +mres/2./Constants::pi/kM-sqr(mA)*mres/Constants::pi/Math::powi(kM,3);
  }
  return s*Fr*Fd*GeV2/bw;
}

inline InvEnergy4 DtoKPiPiBaBar::rho3(Energy2 s,Energy2 s1, Energy2 s2) const {
  // return if rho's below threshold
  Energy2 low(4.*sqr(_mpi));
  if(s1<low||s2<low) return 0./GeV2/GeV2;
  // return is total below threshold
  Energy m1(sqrt(s1)),m2(sqrt(s2)),m0(sqrt(s));
  if(m0<m1+m2) return 0./GeV2/GeV2;
  // calulate running widths
  Energy p0 = Kinematics::CMMomentum(_mrho770,_mpi,_mpi);
  Energy p1 = Kinematics::CMMomentum(   m1   ,_mpi,_mpi);
  Energy p2 = Kinematics::CMMomentum(   m2   ,_mpi,_mpi);
  double F1 = sqrt((1.+sqr(_rres*p0))/(1.+sqr(_rres*p1)));
  double F2 = sqrt((1.+sqr(_rres*p0))/(1.+sqr(_rres*p2)));
  Energy2 mwid1 = _wrho770*Math::powi(p1/p0,3)*sqr(F1*_mrho770)/m1;
  Energy2 mwid2 = _wrho770*Math::powi(p2/p0,3)*sqr(F2*_mrho770)/m2;
  return mwid1*mwid2*sqrt(sqr(s+s1-s2)-4*s*s1)/s/
    (sqr(sqr(_mrho770)-s1)+sqr(mwid1))/
    (sqr(sqr(_mrho770)-s2)+sqr(mwid2))/sqr(Constants::pi);
}

inline DtoKPiPiBaBarInnerIntegrand::
DtoKPiPiBaBarInnerIntegrand(DtoKPiPiBaBarPtr in) : _decayer(in) 
{}

inline InvEnergy4 DtoKPiPiBaBarInnerIntegrand::operator ()(Energy2 s2) const {
  return _decayer->rho3(_s,_s1,s2);
}

inline void DtoKPiPiBaBarInnerIntegrand::s(Energy2 in) const {
  _s=in;
}

inline void DtoKPiPiBaBarInnerIntegrand::s1(Energy2 in) const {
  _s1=in;
}

inline DtoKPiPiBaBarOuterIntegrand::
DtoKPiPiBaBarOuterIntegrand(DtoKPiPiBaBarPtr din,Energy min) : _decayer(din),
							       integral(din),_mpi(min)
{}

inline InvEnergy2 DtoKPiPiBaBarOuterIntegrand::operator ()(Energy2 s1) const {
  Energy E2s = 0.5*sqrt(s1);
  Energy E3s = 0.5*(_s-s1-sqr(_mpi))/sqrt(s1);
  Energy2 a = E2s*E3s+sqr(_mpi);
  Energy2 b = sqrt(sqr(E2s)-sqr(_mpi))*sqrt(sqr(E3s)-sqr(_mpi));
  Energy2 low = 2.*(a-b);
  Energy2 upp = 2.*(a+b);
  integral. s(_s);
  integral.s1(s1);
  return _integrator.value(integral,low,upp);
}

inline void DtoKPiPiBaBarOuterIntegrand::s(Energy2 in) const {
  _s=in;
}
}
