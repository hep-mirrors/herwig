// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DtoKPiPiBaBar class.
//

namespace Herwig {

inline IBPtr DtoKPiPiBaBar::clone() const {
  return new_ptr(*this);
}

inline IBPtr DtoKPiPiBaBar::fullclone() const {
  return new_ptr(*this);
}

inline Complex DtoKPiPiBaBar::amplitude(int ispin,bool gs, Energy mD,
					  Energy mA , Energy mB , Energy mC ,
					  Energy mAB, Energy mAC, Energy mBC,
					  Energy mres, Energy wres) const{
  // compute the production momenta
  Energy pDR  = Kinematics::CMMomentum(mD,mres,mC);
  Energy pDAB = Kinematics::CMMomentum(mD,mAB ,mC);
  // and the decay momenta
  Energy pAB = Kinematics::CMMomentum(mAB ,mA,mB);
  Energy pR  = Kinematics::CMMomentum(mres,mA,mB);
  double Fd(1.),Fr(1.),s(1.);
  switch(ispin) {
  case 0:
    // default values of parameters are correct
    break;
  case 1:
    Fr = sqrt((1.+sqr(_rres*pR ))/(1.+sqr(_rres*pAB )));
    Fd = sqrt((1.+sqr(_rD0 *pDR))/(1.+sqr(_rD0 *pDAB)));
    s = ((mAC-mBC)*(mAC+mBC)+(mD-mC)*(mD+mC)*(mB-mA)*(mB+mA)/sqr(mres))/GeV2;
    break;
  case 2:
    Fr = sqrt((9.+3.*sqr(_rres*pR  )+Math::powi(_rres*pR  ,4))/
	      (9.+3.*sqr(_rres*pAB )+Math::powi(_rres*pAB ,4)));
    Fd = sqrt((9.+3.*sqr(_rD0 *pDR )+Math::powi(_rD0 *pDR ,4))/
	      (9.+3.*sqr(_rD0 *pDAB)+Math::powi(_rD0 *pDAB,4)));
    s = sqr(((mBC-mAC)*(mBC+mAC)+(mD-mC)*(mD+mC)*(mB-mA)*(mB+mA)/sqr(mres))/GeV2)
      -(mAB*mAB-2.*mD*mD-2.*mC*mC+sqr((mD-mC)*(mD+mC))/sqr(mres))*
       (mAB*mAB-2.*mA*mA-2.*mB*mB+sqr((mA-mB)*(mA+mB))/sqr(mres))/3./GeV2/GeV2;
    break;
  default:
    throw Exception() << "DtoKPiPiBaBar::amplitude spin is too high ispin = " 
		      << ispin << Exception::runerror;
  }
  // calculate the width term
  Complex bw;
  if(!gs) {
    Energy2 mwid=wres*Math::powi(pAB/pR,2*ispin+1)*sqr(Fr*mres)/mAB;
    bw = sqr(mres)-sqr(mAB)-Complex(0.,mwid);
  }
  else {
    Energy2    M2 = sqr(mres);
    Energy2    s  = sqr(mAB);
    Energy     ks = sqrt(0.25*s -sqr(mA));
    Energy     kM = sqrt(0.25*M2-sqr(mA));
    double     hs = 2./pi*ks/mAB *log((mAB +2.*ks)/2./mA);
    double     hM = 2./pi*kM/mres*log((mres+2.*kM)/2./mA);
    InvEnergy2 dh =(0.5+sqr(mA)/mres/kM*log((mres+2.*kM)/2./mA))/pi/M2;
    bw = M2-s+wres*(M2/Math::powi(kM,3))*(sqr(ks)*(hs-hM)+sqr(kM)*dh*(M2-s))
      -Complex(0.,M2*wres*Math::powi(ks/kM,3)/mAB);
    Energy d = 3./pi*sqr(mA/kM)*log((mres+2.*kM)/2./mA)
      +mres/2./pi/kM-sqr(mA)*mres/pi/Math::powi(kM,3);
    bw/=1.4;
  }
  return s*Fr*Fd*GeV2/bw;
}
}
