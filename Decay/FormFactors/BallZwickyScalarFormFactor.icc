// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the BallZwickyScalarFormFactor class.
//

namespace Herwig {
using namespace ThePEG;

inline BallZwickyScalarFormFactor::
BallZwickyScalarFormFactor(const BallZwickyScalarFormFactor & x)
  : ScalarFormFactor(x),_r10(x._r10),_r20(x._r20),_r1plus(x._r1plus),_r2plus(x._r2plus),
    _r1T(x._r1T),_r2T(x._r2T),_m120(x._m120),_mfit20(x._mfit20),_m12plus(x._m12plus),
    _mfit2plus(x._mfit2plus),_m12T(x._m12T),_mfit2T(x._mfit2T), _thetaeta(x._thetaeta)
{}

inline IBPtr BallZwickyScalarFormFactor::clone() const {
  return new_ptr(*this);
}

inline IBPtr BallZwickyScalarFormFactor::fullclone() const {
  return new_ptr(*this);
}

inline void BallZwickyScalarFormFactor::doupdate() throw(UpdateException) {
  ScalarFormFactor::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void BallZwickyScalarFormFactor::doinit() throw(InitException) {
  ScalarFormFactor::doinit();
  unsigned int isize=numberOfFactors();
  if(isize!=_r10.size()||isize!=_r20.size()||isize!=_r1plus.size()||
     isize!=_r2plus.size()||isize!=_r1T.size()||
     isize!=_r2T.size()||isize!=_m120.size()||isize!=_mfit20.size()||
     isize!=_m12plus.size()||isize!=_mfit2plus.size()||
     isize!=_m12T.size()||isize!=_mfit2T.size())
    {throw InitException() << "Inconsistent parameters in " 
			   << "BallZwickyScalarFormFactor::doinit()" 
			   << Exception::abortnow;}
}

inline void BallZwickyScalarFormFactor::dofinish() {
  ScalarFormFactor::dofinish();
}

inline void BallZwickyScalarFormFactor::doinitrun() {
  ScalarFormFactor::doinitrun();
  /*
  // output some graphs to check the answers
  int id0,id1;
  unsigned int iz;
  Energy m0,m1; 
  Energy2 q2,step(14./100.*GeV2);
  tcPDPtr in,out;
  Complex f0,fp,ft;
  ofstream output("Ball.top");
  for(unsigned int ix=0;ix<numberOfFactors();++ix)
    {
      particleID(ix,id0,id1);
      in = getParticleData(id0);m0=in->mass();
      out= getParticleData(id1);m1=out->mass();
      output << "new frame " << endl;
      output << "set font duplex" << endl;
      output << "title top \"" << in->PDGName() << " to " << out->PDGName() 
	     << " scalar form factors \"" << endl;
      output << "set limits x 0 14. y 0 1" << endl;
      double rt(sqrt(2.));
      for(iz=0;iz<3;++iz)
	{
	  q2=0.;
	  for( ;q2<14.*GeV2+step;q2+=step)
	    {
	      ScalarScalarFormFactor(q2,ix,id0,id1,m0,m1,f0,fp);
	      ScalarScalarSigmaFormFactor(q2,ix,id0,id1,m0,m1,ft);
	      if(id1==111||id1==221){f0*=rt;fp*=rt;ft*=rt;}
	      if(iz==0){output << q2/GeV2 << "   " << f0.real() << endl;}
	      else if(iz==1){output << q2/GeV2 << "   " << fp.real() << endl;}
	      else if(iz==2){output << q2/GeV2 << "   " << ft.real() << endl;}
	    }
	  if(iz==0){output      << "join red"    << endl;}
	  else if(iz==1){output << "join blue"   << endl;}
	  else if(iz==2){output << "join green"   << endl;}
	}
    }
  */
}

inline void BallZwickyScalarFormFactor::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  ScalarFormFactor::rebind(trans);
}

inline IVector BallZwickyScalarFormFactor::getReferences() {
  IVector ret = ScalarFormFactor::getReferences();
  // ret.push_back(dummy);
  return ret;
}

}
