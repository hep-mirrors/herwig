// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the BtoSGammaKagan class.
//

namespace Herwig {

inline IBPtr BtoSGammaKagan::clone() const {
  return new_ptr(*this);
}

inline IBPtr BtoSGammaKagan::fullclone() const {
  return new_ptr(*this);
}

inline double BtoSGammaKagan::Delta(double y, double alphaS) const {
  // goes to zero for large y
  if(y<=_ycut) {
    double ln(log(1.-y));
    return -4./3./pi/(1.-y)*alphaS*(ln+1.75)*exp(-2.*alphaS/3./pi*ln*(ln+3.5));
  }
  else return 0.;
}

inline double BtoSGammaKagan::semiLeptonicf() const {
  double z2=sqr(_zratio);
  return 1.-8.*_zratio*(1.-z2)-sqr(z2)-12.*z2*log(_zratio);
}

inline double BtoSGammaKagan::s22(double y) const {
  return (*_s22inter)(y);
}

inline double BtoSGammaKagan::s27(double y) const {
  return (*_s27inter)(y);
}

inline double BtoSGammaKagan::s77(double y) const {
  if(y>_ycut){y=_ycut;}
  return 1./3.*(7.+y*(1.-2.*y)-2.*(1.+y)*log(1.-y));
}

inline double BtoSGammaKagan::s78(double y) const {
  if(y>_ycut) y=_ycut;
  return 8./9.*((1.-y)/y*log(1.-y)+1.+0.25*y*y);
}

inline double BtoSGammaKagan::s88(double y) const {
  double ratio(_mb/_ms),y2(sqr(y));
  if(y>_ycut){y=_ycut;}
  return 1./27.*(2.*(2.-2.*y+y2)/y*(log(1.-y)+2.*log(ratio))-2.*y2-y-8.*(1.-y)/y);
}
  
inline double BtoSGammaKagan::realG(double t) const {
  if(t<4.) {
    double at(atan(sqrt(t/(4.-t))));
    return -2.*sqr(at);
  }
  else {
    double ln(log(0.5*(sqrt(t)+sqrt(t-4.))));
    return 2.*(sqr(ln)-0.25*sqr(pi));
  }
}

inline double BtoSGammaKagan::imagG(double t) const {
  if(t<4.) return 0.;
  else     return -2.*pi*log(0.5*(sqrt(t)+sqrt(t-4.)));
}

inline double BtoSGammaKagan::operator() (double x) const {
  if(_iopt==0) {
    double reg(realG(x/_zratio)),img(imagG(x/_zratio));
    return 16./27.*(1.-x)*(_zratio*_zratio/x/x*(sqr(reg)+sqr(img))+_zratio/x*reg+0.25);
  }
  else {
    return -8./9.*_zratio*(realG(x/_zratio)+0.5*x/_zratio);
  }
}

inline double BtoSGammaKagan::alphaS(Energy Q) {
  double lo(1.-0.5*_beta0*_alphaSZ/pi*log(_mz/Q));
  return _alphaSZ/lo*(1.-0.25*_beta1/_beta0*_alphaSZ/pi*log(lo)/lo);
}

inline double BtoSGammaKagan::KNLO(double y) const {
  return _delta*Delta(y,_alphaSM)
    +_alphaSM/pi*(s22(y)*sqr(_c20)+s77(y)*sqr(_c70)
    		  +s88(y)*sqr(_c80)+s78(y)*_c70*_c80
    		  +s27(y)*_c20*(_c70-_c80/3.));
}

inline InvEnergy BtoSGammaKagan::operator() (Energy kp) const {
  InvEnergy fermi = exponentialFermiFunction(kp,_fermilambda,_fermia,
					     _ferminorm,_fermilambda1);
  if(_iopt==1) fermi *=KNLO(_MB*_y/(_mb+kp))*_MB/(_mb+kp);
  return fermi;
}

inline void BtoSGammaKagan::doinitrun() {
  BtoSGammaHadronicMass::doinitrun();
  _pmHinter = new_ptr(Interpolator<InvEnergy,Energy>(_spectrum,_mHinter,3));
}

}
