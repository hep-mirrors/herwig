// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the BallZwickyVectorFormFactor class.
//

namespace Herwig {
using namespace ThePEG;

inline BallZwickyVectorFormFactor::BallZwickyVectorFormFactor(const BallZwickyVectorFormFactor & x)
  : ScalarFormFactor(x),_Vr1(x._Vr1),_Vr2(x._Vr2),_A0r1(x._A0r1),_A0r2(x._A0r2),
    _A1r1(x._A1r1),_A1r2(x._A1r2), _A2r1(x._A2r1), _A2r2(x._A2r2),_T1r1(x._T1r1),
    _T1r2(x._T1r2),_T2r1(x._T2r1),_T2r2(x._T2r2), _T3r1(x._T3r1), _T3r2(x._T3r2),
    _VmR2(x._VmR2),_Vmfit2(x._Vmfit2),_A0mR2(x._A0mR2),_A0mfit2(x._A0mfit2),
    _A1mR2(x._A1mR2),_A1mfit2(x._A1mfit2),_A2mR2(x._A2mR2),_A2mfit2(x._A2mfit2),
    _T1mR2(x._T1mR2),_T1mfit2(x._T1mfit2),_T2mR2(x._T2mR2),
    _T2mfit2(x._T2mfit2),_T3mR2(x._T3mR2),_T3mfit2(x._T3mfit2), _cutoff(x._cutoff) {}

inline IBPtr BallZwickyVectorFormFactor::clone() const {
  return new_ptr(*this);
}

inline IBPtr BallZwickyVectorFormFactor::fullclone() const {
  return new_ptr(*this);
}

inline void BallZwickyVectorFormFactor::doupdate() throw(UpdateException) {
  ScalarFormFactor::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void BallZwickyVectorFormFactor::doinit() throw(InitException) {
  ScalarFormFactor::doinit();
  unsigned int isize(numberOfFactors());
  if(isize!=_Vr1.size()||isize!=_Vr2.size()||isize!=_A0r1.size()||isize!=_A0r2.size()||
     isize!=_A1r1.size()||isize!=_A1r2.size()||isize!=_A2r1.size()||isize!=_A2r2.size()||
     isize!=_T1r1.size()||isize!=_T1r2.size()||isize!=_T2r1.size()||isize!=_T2r2.size()||
     isize!=_T3r1.size()||isize!=_T3r2.size()||isize!=_VmR2.size()||
     isize!=_Vmfit2.size()||isize!=_A0mR2.size()||isize!=_A0mfit2.size()||
     isize!=_A1mR2.size()||isize!=_A1mfit2.size()||isize!=_A2mR2.size()||
     isize!=_A2mfit2.size()||isize!=_T1mR2.size()||isize!=_T1mfit2.size()||
     isize!=_T2mR2.size()||isize!=_T2mfit2.size()||isize!=_T3mR2.size()||
     isize!=_T3mfit2.size())
    {throw InitException() << "Inconsistent parameters in " 
			   << "BallZwickyScalarFormFactor::doinit()" 
			   << Exception::abortnow;}
}

inline void BallZwickyVectorFormFactor::dofinish() {
  ScalarFormFactor::dofinish();
}

inline void BallZwickyVectorFormFactor::doinitrun() {
  ScalarFormFactor::doinitrun();
  /*
  // output some graphs to check the answers
  int id0,id1;
  unsigned int iz;
  Energy m0,m1;
  Energy2 q2,step(14./100.*GeV2);
  tcPDPtr in,out;
  Complex A0,A1,A2,V;
  ofstream output("Ball.top");
  for(unsigned int ix=0;ix<numberOfFactors();++ix)
    {
      particleID(ix,id0,id1);
      in = getParticleData(id0);m0=in->mass();
      out= getParticleData(id1);m1=out->mass();
      output << "new frame " << endl;
      output << "set font duplex" << endl;
      output << "title top \"" << in->PDGName() << " to " << out->PDGName() 
	     << " vector form factors \"" << endl;
      output << "set limits x 0 14. y 0 1" << endl;
      double rt(sqrt(2.));
      for(iz=0;iz<4;++iz)
	{
	  q2=0.;
	  for( ;q2<14.*GeV2+step;q2+=step)
	    {
	      ScalarVectorFormFactor(q2,ix,id0,id1,m0,m1,A0,A1,A2,V);
	      if(id1==113||id1==223){A0*=rt;A1*=rt;A2*=rt;V*=rt;}
	      if(iz==0){output << q2/GeV2 << "   " << A0.real() << endl;}
	      else if(iz==1){output << q2/GeV2 << "   " << A1.real() << endl;}
	      else if(iz==2){output << q2/GeV2 << "   " << A2.real() << endl;}
	      else if(iz==3){output << q2/GeV2 << "   " << V.real() << endl;}
	    }
	  if(iz==0){output      << "join red"    << endl;}
	  else if(iz==1){output << "join blue"   << endl;}
	  else if(iz==2){output << "join green"  << endl;}
	  else if(iz==3){output << "join yellow" << endl;}
	}
      output << "new frame " << endl;
      output << "set font duplex" << endl;
      output << "title top \"" << in->PDGName() << " to " << out->PDGName() 
	     << " penguin form factors\" " << endl;
      output << "set limits x 0 14. y 0 1" << endl;
      for(iz=0;iz<3;++iz)
	{
	  q2=0.;
	  for( ;q2<14.*GeV2+step;q2+=step)
	    {
	      ScalarVectorSigmaFormFactor(q2,ix,id0,id1,m0,m1,A0,A1,A2);
	      if(id1==113||id1==223){A0*=rt;A1*=rt;A2*=rt;}
	      if(iz==0){output << q2/GeV2 << "   " << A0.real() << endl;}
	      else if(iz==1){output << q2/GeV2 << "   " << A1.real() << endl;}
	      else if(iz==2){output << q2/GeV2 << "   " << A2.real() << endl;}
	    }
	  if(iz==0){output      << "join red"    << endl;}
	  else if(iz==1){output << "join blue"   << endl;}
	  else if(iz==2){output << "join green"  << endl;}
	}
    }
  */
}

inline void BallZwickyVectorFormFactor::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  ScalarFormFactor::rebind(trans);
}

inline IVector BallZwickyVectorFormFactor::getReferences() {
  IVector ret = ScalarFormFactor::getReferences();
  // ret.push_back(dummy);
  return ret;
}

}
