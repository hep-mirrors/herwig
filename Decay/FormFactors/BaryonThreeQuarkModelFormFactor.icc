// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the BaryonThreeQuarkModelFormFactor class.
//

namespace Herwig {
using namespace ThePEG;

inline BaryonThreeQuarkModelFormFactor::BaryonThreeQuarkModelFormFactor() 
{
  // default parameters
  _initialize=false;
  _order=50;
  _mlight   = 420*MeV;
  _mstrange = 570*MeV;
  _LambdaQ  = 2.5*GeV;
  _Lambdaqq = 0.71*GeV;
  _Lambdasq = 850*MeV;
  _Lambdass = 1.0*GeV;
  // modes handled by this form factor
  // lambda_b
  addFormFactor(5122,4122,2,2,1,2,5,4);
  // xi_b
  addFormFactor(5232,4232,2,2,2,3,5,4);
  addFormFactor(5132,4132,2,2,1,3,5,4);
  // sigma_b
  addFormFactor(5112,4112,2,2,1,1,5,4);
  addFormFactor(5212,4212,2,2,2,1,5,4);
  addFormFactor(5222,4222,2,2,2,2,5,4);
  // omega_b
  addFormFactor(5332,4332,2,2,3,3,5,4);
  // sigma_b-> sigma_c*
  addFormFactor(5112,4114,2,4,1,1,5,4);
  addFormFactor(5212,4214,2,4,2,1,5,4);
  addFormFactor(5222,4224,2,4,2,2,5,4);
  // omega_b -> omega_c*
  addFormFactor(5332,4334,2,4,3,3,5,4);
  // set the inital number of form factors
  initialModes(numberOfFactors());
}

inline BaryonThreeQuarkModelFormFactor::BaryonThreeQuarkModelFormFactor(const BaryonThreeQuarkModelFormFactor & x)
  : BaryonFormFactor(x),_initialize(x._initialize), _order(x._order),
    _mlight(x._mlight),_mstrange(x._mstrange),_LambdaQ(x._LambdaQ),
    _Lambdaqq(x._Lambdaqq),_Lambdasq(x._Lambdasq),_Lambdass(x._Lambdass),
    _C0(x._C0),_C1(x._C1),_C2(x._C2)
 {}

inline IBPtr BaryonThreeQuarkModelFormFactor::clone() const {
  return new_ptr(*this);
}

inline IBPtr BaryonThreeQuarkModelFormFactor::fullclone() const {
  return new_ptr(*this);
}

inline void BaryonThreeQuarkModelFormFactor::doupdate() throw(UpdateException) {
  BaryonFormFactor::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void BaryonThreeQuarkModelFormFactor::dofinish() {
  BaryonFormFactor::dofinish();
}

inline void BaryonThreeQuarkModelFormFactor::doinitrun() {
  BaryonFormFactor::doinitrun();
}

inline void BaryonThreeQuarkModelFormFactor::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  BaryonFormFactor::rebind(trans);
}

inline IVector BaryonThreeQuarkModelFormFactor::getReferences() {
  IVector ret = BaryonFormFactor::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// return the phi_N functions calculated using recursion
inline vector<double> BaryonThreeQuarkModelFormFactor::phiFunction(double omega)
{
  vector<double> output;
  double root(sqrt(omega*omega-1.));
  output.push_back(1./root*log(omega+root));
  if(omega<1.00001){output.back()=1.;}
  if(_order>0){output.push_back(2./(omega+1.));}
  if(_order<2){return output;}
  for(unsigned int ix=2;ix<=_order+2;++ix)
    {output.push_back(2./ix/(omega+1.)*(1.+(ix-1)*output[ix-2]));}
  return output;
}

inline void BaryonThreeQuarkModelFormFactor::SN(double y, int N, double & SNm2,
						double & SN)
{
  // special cases for the low lying values
  if(N==0)
    {
      double root=sqrt((1.+y)*(3.+y));
      SN   = 0.5/y*sqrt((1.+y)/(3.+y))*log((root+y)/(root-y));
      SNm2 = 0.5/(y+3.)*(SN+(1.+y)/(3.+4.*y)); 
    }
  else if(N==1)
    {
      SN   = sqrt(1.+y)/y*asin(y/sqrt(1.+y)/sqrt(3.+y));
      SNm2 = 1./(3.+y)*sqrt((1.+y)/(3.+4.*y)); 
    }
  else if(N==2)
    {
      double root=sqrt((1.+y)*(3.+y));
      SN   = 1.;
      SNm2 = 0.5/y*sqrt((1.+y)/(3.+y))*log((root+y)/(root-y));
    }
  // the general case
  else
    {
      int ix; double root;
      if(N%2==0)
	{
	  SN=1.;
	  ix=2;
	  root=1.;
	}
      else
	{
	  SN = sqrt(1.+y)/y*asin(y/sqrt(1.+y)/sqrt(3.+y));
	  ix=1;
	  root=sqrt((1.+y)/(3.+4.*y));
	}
      do
	{
	  SNm2=SN;
	  ix+=2;
	  root*=(3.+4.*y)/(1.+y);
	  SN=1./(float(ix)-1.)*(root+(float(ix)-2.)*(y+3.)*SNm2);
	}
      while(ix<N);
    }
}

// the integrand for the coefficients
inline double BaryonThreeQuarkModelFormFactor::integrandC(double x)
{
  // convert the integration variable
  double y=(1.-x)/x;
  double output =exp(-24.*_mu2*y)*y;
  // the integrals
  double I,Im2;
  SN(y,_N,Im2,I);
  double Nfact=0.5*float(_N)+1.;
  output *= (_a+Nfact/24./(1.+y))*I+1./12./(1.+y)*(_b-Nfact)*Im2;
  return output;
}

}
