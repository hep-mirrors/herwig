// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the BaryonThreeQuarkModelFormFactor class.
//

namespace Herwig {
using namespace ThePEG;

inline BaryonThreeQuarkModelFormFactor::BaryonThreeQuarkModelFormFactor() 
{
  // default parameters
  _initialize=false;
  _order=50;
  _mlight   = 420*MeV;
  _mstrange = 570*MeV;
  _LambdaQ  = 2.5*GeV;
  _Lambdaqq = 0.71*GeV;
  _Lambdasq = 850*MeV;
  _Lambdass = 1.0*GeV;
  // modes handled by this form factor
  // omega_b -> omega_c*
  addFormFactor(5332,4334,2,4,3,3,5,4);
  // sigma_b-> sigma_c*
  addFormFactor(5112,4114,2,4,1,1,5,4);
  addFormFactor(5212,4214,2,4,2,1,5,4);
  addFormFactor(5222,4224,2,4,2,2,5,4);
  // lambda_b
  addFormFactor(5122,4122,2,2,1,2,5,4);
  // xi_b
  addFormFactor(5232,4232,2,2,2,3,5,4);
  addFormFactor(5132,4132,2,2,1,3,5,4);
  // sigma_b
  addFormFactor(5112,4112,2,2,1,1,5,4);
  addFormFactor(5212,4212,2,2,2,1,5,4);
  addFormFactor(5222,4222,2,2,2,2,5,4);
  // omega_b
  addFormFactor(5332,4332,2,2,3,3,5,4);
}

inline BaryonThreeQuarkModelFormFactor::BaryonThreeQuarkModelFormFactor(const BaryonThreeQuarkModelFormFactor & x)
  : BaryonFormFactor(x),_initialize(x._initialize), _order(x._order),
    _mlight(x._mlight),_mstrange(x._mstrange),_LambdaQ(x._LambdaQ),
    _Lambdaqq(x._Lambdaqq),_Lambdasq(x._Lambdasq),_Lambdass(x._Lambdass),
    _C0(x._C0),_C1(x._C1),_C2(x._C2)
 {}

inline IBPtr BaryonThreeQuarkModelFormFactor::clone() const {
  return new_ptr(*this);
}

inline IBPtr BaryonThreeQuarkModelFormFactor::fullclone() const {
  return new_ptr(*this);
}

inline void BaryonThreeQuarkModelFormFactor::doupdate() throw(UpdateException) {
  BaryonFormFactor::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void BaryonThreeQuarkModelFormFactor::doinit() throw(InitException) {
  BaryonFormFactor::doinit();
  // initialization in needed
  if(_initialize)
    {
      Genfun::AbsFunction * integrand= new BaryonCFunction(this);
      
      _C0.resize(0);_C1.resize(0);_C2.resize(0);
      GaussianIntegral *integral= new GaussianIntegral(0.,1.);
      double pre(0.),root(2.*sqrt(6.));
      double gamma1(1),gamma2(1),gamma3(sqrt(acos(-1.)));
      for(unsigned int iy=0;iy<2;++iy)
	{
	  if(iy==0){_mu2=_mlight*_mlight/_LambdaQ/_LambdaQ;}
	  else{_mu2=_mstrange*_mstrange/_LambdaQ/_LambdaQ;}
	  for(unsigned int ix=0;ix<=_order;++ix)
	    {
	      if(ix>0){gamma1*=ix;}
	      if(ix%2==1){gamma2*=float((ix+1)/2);gamma3*=float(ix)/2.;}
	      if(ix%2==0){pre=pow(root,ix)/12.*gamma2/gamma1;}
	      else{pre=pow(root,ix)/12.*gamma3/gamma1;}
	      // for the xi_0 function
	      _a=_mu2;_b=2.;_N=ix;
	      _C0.push_back(pre*(*integral)[*integrand]);
	      // for the xi_1 function
	      _a=_mu2;_b=1.;
	      _C1.push_back(pre*(*integral)[*integrand]);
	      // for the xi_2 function
	      _a=0.;
	      _b=0.;
	      _C2.push_back(pre*(*integral)[*integrand]);
	    }
	}
      // tidy up
      delete integrand;
    }
}

inline void BaryonThreeQuarkModelFormFactor::dofinish() {
  BaryonFormFactor::dofinish();
}

inline void BaryonThreeQuarkModelFormFactor::doinitrun() {
  BaryonFormFactor::doinitrun();
  /*
  cout << "testing the paper form of the me" << endl;
  // first matrix element
  Energy m0=getParticleData(5122)->mass();
  Energy m1=getParticleData(4122)->mass();
  double omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
  Genfun::AbsFunction *me1=new BaryonCMatrixElement(this,m0,m1,1,0);
  GaussianIntegral *integral= new GaussianIntegral(1.,omegamax);
  cout << "testing lambda decay" << (*integral)[*me1]/6.582119E-22 << endl;
  delete me1; delete integral;
  // second matrix element
  m0=getParticleData(5222)->mass();
  m1=getParticleData(4222)->mass();
  omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
  me1=new BaryonCMatrixElement(this,m0,m1,2,0);
  integral= new GaussianIntegral(1.,omegamax);
  cout << "testing sigma decay" << (*integral)[*me1]/6.582119E-22 << endl;
  delete me1; delete integral;
  // third matrix element
  m0=getParticleData(5232)->mass();
  m1=getParticleData(4232)->mass();
  omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
  me1=new BaryonCMatrixElement(this,m0,m1,1,1);
  integral= new GaussianIntegral(1.,omegamax);
  cout << "testing xi decay" << (*integral)[*me1]/6.582119E-22 << endl;
  delete me1; delete integral;
  // fourth matrix element
  m0=getParticleData(5332)->mass();
  m1=getParticleData(4332)->mass();
  omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
  me1=new BaryonCMatrixElement(this,m0,m1,2,2);
  integral= new GaussianIntegral(1.,omegamax);
  cout << "testing omega decay" << (*integral)[*me1]/6.582119E-22 << endl;
  delete me1; delete integral;
  // fifth matrix element
  m0=getParticleData(5222)->mass();
  m1=getParticleData(4224)->mass();
  omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
  me1=new BaryonCMatrixElement(this,m0,m1,3,0);
  integral= new GaussianIntegral(1.,omegamax);
  cout << "testing sigma decay" << (*integral)[*me1]/6.582119E-22 << endl;
  delete me1; delete integral;
  // fourth matrix element
  m0=getParticleData(5332)->mass();
  m1=getParticleData(4334)->mass();
  omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
  me1=new BaryonCMatrixElement(this,m0,m1,3,2);
  integral= new GaussianIntegral(1.,omegamax);
  cout << "testing omega decay" << (*integral)[*me1]/6.582119E-22 << endl;
  */
}

inline void BaryonThreeQuarkModelFormFactor::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  BaryonFormFactor::rebind(trans);
}

inline IVector BaryonThreeQuarkModelFormFactor::getReferences() {
  IVector ret = BaryonFormFactor::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// return the phi_N functions calculated using recursion
inline vector<double> BaryonThreeQuarkModelFormFactor::phiFunction(double omega)
{
  vector<double> output;
  double root=sqrt(omega*omega-1.);
  output.push_back(1./root*log(omega+root));
  if(omega<1.00001){output.back()=1.;}
  if(_order>0){output.push_back(2./(omega+1.));}
  if(_order<2){return output;}
  for(unsigned int ix=2;ix<=_order+2;++ix)
    {output.push_back(2./ix/(omega+1.)*(1.+(ix-1)*output[ix-2]));}
  return output;
}

inline void BaryonThreeQuarkModelFormFactor::SN(double y, int N, double & SNm2,
						double & SN)
{
  // special cases for the low lying values
  if(N==0)
    {
      double root=sqrt((1.+y)*(3.+y));
      SN   = 0.5/y*sqrt((1.+y)/(3.+y))*log((root+y)/(root-y));
      SNm2 = 0.5/(y+3.)*(SN+(1.+y)/(3.+4.*y)); 
    }
  else if(N==1)
    {
      SN   = sqrt(1.+y)/y*asin(y/sqrt(1.+y)/sqrt(3.+y));
      SNm2 = 1./(3.+y)*sqrt((1.+y)/(3.+4.*y)); 
    }
  else if(N==2)
    {
      double root=sqrt((1.+y)*(3.+y));
      SN   = 1.;
      SNm2 = 0.5/y*sqrt((1.+y)/(3.+y))*log((root+y)/(root-y));
    }
  // the general case
  else
    {
      int ix; double root;
      if(N%2==0)
	{
	  SN=1.;
	  ix=2;
	  root=1.;
	}
      else
	{
	  SN = sqrt(1.+y)/y*asin(y/sqrt(1.+y)/sqrt(3.+y));
	  ix=1;
	  root=sqrt((1.+y)/(3.+4.*y));
	}
      do
	{
	  SNm2=SN;
	  ix+=2;
	  root*=(3.+4.*y)/(1.+y);
	  SN=1./(float(ix)-1.)*(root+(float(ix)-2.)*(y+3.)*SNm2);
	}
      while(ix<N);
    }
}

// the integrand for the coefficients
inline double BaryonThreeQuarkModelFormFactor::integrandC(double x)
{
  // convert the integration variable
  double y=(1.-x)/x;
  double output =exp(-24.*_mu2*y)*y;
  // the integrals
  double I,Im2;
  SN(y,_N,Im2,I);
  double Nfact=0.5*float(_N)+1.;
  output *= (_a+Nfact/24./(1.+y))*I+1./12./(1.+y)*(_b-Nfact)*Im2;
  return output;
}

  inline double BaryonThreeQuarkModelFormFactor::widthIntegrand(double omega,Energy m0, Energy m1, int type, int imass)
 {
   InvEnergy2 GF=1.16639E-5/GeV2;
   double vcb=0.04;
   // the IW function
   vector<double> phi=phiFunction(omega);
   double Hpp(0.),Hmm(0.),Hp0(0.),Hm0(0.),Hppb(0.),Hmmb(0.);
   double HA3(0.),HV3(0.),HA1(0.),HV1(0.),HA0(0.),HV0(0.);
   double lambdabar,xit;
   if(imass==0){lambdabar=_Lambdaqq/_LambdaQ;}
   else if(imass==1){lambdabar=_Lambdasq/_LambdaQ;}
   else{lambdabar=_Lambdass/_LambdaQ;}
   if(type==1)
     {
       double power(1.),numer(0.),denom(0.);
       unsigned int iy;
       for(unsigned int ix=0;ix<=_order;++ix)
	 {
	   if(imass>0){iy=ix+_order+1;}
	   else{iy=ix;}
	   numer+=phi[ix]*power*_C0[iy];
	   denom+=power*_C0[iy];
	   power*=lambdabar;
	 }
       double xi0=numer/denom;
       Hpp = xi0;
       Hmm = xi0;
       Hp0 = xi0*((m0+m1)*sqrt(omega-1.)-(m0-m1)*sqrt(omega+1.));
       Hm0 = xi0*((m0+m1)*sqrt(omega-1.)+(m0-m1)*sqrt(omega+1.));
     }
   else if(type==2)
     {
       double power(1.),numer[2]={0.,0.},denom(0.);
       unsigned int iy;
       for(unsigned int ix=0;ix<=_order;++ix)
	 {
	   if(imass>0){iy=ix+_order+1;}
	   else{iy=ix;}
	   numer[0]+=phi[ix]*power*_C1[iy];
	   denom+=power*_C1[iy];
	   numer[1]+=power*_C2[iy]*(phi[ix]-phi[ix+2]);
	   power*=lambdabar;
	 }
       numer[1]/=(omega-1.);
       double xi1=numer[0]/denom;
       double xi2=numer[1]/denom;
       xit = xi1*omega-xi2*(omega*omega-1.);
       double xiLp = xi1*(omega+2.)-xi2*(omega*omega-1.);
       double xiLm = xi1*(omega-2.)-xi2*(omega*omega-1.);
       //double xiLp(xit),xiLm(xit);
       Hpp = 1./3.*xit;
       Hmm = 1./3.*xit;
       Hp0 = 1./3.*((m0+m1)*sqrt(omega-1.)*xiLp-(m0-m1)*xiLm*sqrt(omega+1.));
       Hm0 = 1./3.*((m0+m1)*sqrt(omega-1.)*xiLp+(m0-m1)*xiLm*sqrt(omega+1.));
     }
   else
     {
       double power(1.),numer[2]={0.,0.},denom(0.);
       unsigned int iy;
       for(unsigned int ix=0;ix<=_order;++ix)
	 {
	   if(imass>0){iy=ix+_order+1;}
	   else{iy=ix;}
	   numer[0]+=phi[ix]*power*_C1[iy];
	   denom+=power*_C1[iy];
	   numer[1]+=power*_C2[iy]*(phi[ix]-phi[ix+2]);
	   power*=lambdabar;
	 }
       numer[1]/=(omega-1.);
       double xi1=numer[0]/denom;
       double xi2=numer[1]/denom;
       // the form factors
       double N1(0.),N2(0.),N3(0.),N4(0.),K1(0.),K2(0.),K3(0.),K4(0.),orr(1./sqrt(3.));
       N1 = orr*(xi1-(omega-1.)*xi2);
       K1 = orr*(xi1-(omega+1.)*xi2);
       N2 = 0.;
       K2 = 0.;
       N3 =-2.*orr*xi2;
       K3 =-N3;
       N4 = 2.*orr*xi1;
       K4 =-2.*orr*xi1;
       // the coefficients
       xit  = xi1*omega-xi2*(omega*omega-1.);
       double xiLps = xi1*(omega-1.)-xi2*(omega*omega-1.);
       double xiLms = xi1*(omega+1.)-xi2*(omega*omega-1.);
       Hpp  = sqrt(2.)/3.*xit;
       Hmm  =-sqrt(2.)/3.*xit;
       Hppb = sqrt(2./3.)*xi1;
       Hmmb =-sqrt(2./3.)*xi1;
       Hp0  = sqrt(2.)/3.*((m0+m1)*sqrt(omega-1.)*xiLps-(m0-m1)*xiLms*sqrt(omega+1.));
       Hm0  = sqrt(2.)/3.*((m0+m1)*sqrt(omega-1.)*xiLps+(m0-m1)*xiLms*sqrt(omega+1.));
       HA3 = sqrt(2.*m0*m1*(omega+1.))*K4;
       HV3 =-sqrt(2.*m0*m1*(omega-1.))*N4;
       HV1 = sqrt(2./3.)*sqrt(m0*m1*(omega-1.))*(N4-2.*(omega+1.)*N1);
       HA1 = sqrt(2./3.)*sqrt(m0*m1*(omega+1.))*(K4-2.*(omega-1.)*K1);
       HV0 = -2./sqrt(3.)*sqrt(m0*m1*(omega-1.))*((m0*omega-m1)*N4-(m0-m1)*(omega+1.)*N1
						  +m1*(omega*omega-1.)*N2
						  +m0*(omega*omega-1.)*N3);
       HA0 =  2./sqrt(3.)*sqrt(m0*m1*(omega+1.))*((m0*omega-m1)*K4+(m0+m1)*(omega-1.)*K1
						  +m1*(omega*omega-1.)*K2
						  +m0*(omega*omega-1.)*K3);
     }
   // prefactors
   double omegamax=0.5*(m0*m0+m1*m1)/m0/m1;
   Hpp  *= -2.*sqrt(m0*m1)*(sqrt(omega-1.)-sqrt(omega+1.));
   Hmm  *= -2.*sqrt(m0*m1)*(sqrt(omega-1.)+sqrt(omega+1.));
   Hppb *= -2.*sqrt(m0*m1)*(sqrt(omega-1.)-sqrt(omega+1.));
   Hmmb *= -2.*sqrt(m0*m1)*(sqrt(omega-1.)+sqrt(omega+1.));
   Hp0  *= 1./sqrt(omegamax-omega);
   Hm0  *= 1./sqrt(omegamax-omega);
   HV0 *=1./sqrt(2.*m0*m1*(omegamax-omega));
   HA0 *=1./sqrt(2.*m0*m1*(omegamax-omega));
   double pi=acos(-1.);
   double kw=GF*GF*vcb*vcb/8./pi/pi/pi*m1*m1*m1/6.*
     (omegamax-omega)*sqrt(omega*omega-1.);
   double output;
   if(type<=2)
     {output=kw*(Hpp*Hpp+Hmm*Hmm+Hp0*Hp0+Hm0*Hm0+Hppb*Hppb+Hmmb*Hmmb);}
   else
     {output=2.*kw*(HA3*HA3 +HV3*HV3+HA0*HA0+HV0*HV0+HA1*HA1+HV1*HV1);}
   return output;
}

}
