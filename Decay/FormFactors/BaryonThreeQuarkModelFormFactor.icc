// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the BaryonThreeQuarkModelFormFactor class.
//

namespace Herwig {
using namespace ThePEG;

inline IBPtr BaryonThreeQuarkModelFormFactor::clone() const {
  return new_ptr(*this);
}

inline IBPtr BaryonThreeQuarkModelFormFactor::fullclone() const {
  return new_ptr(*this);
}

// return the phi_N functions calculated using recursion
inline vector<double> BaryonThreeQuarkModelFormFactor::phiFunction(double omega) {
  vector<double> output;
  double root(sqrt(omega*omega-1.));
  output.push_back(1./root*log(omega+root));
  if(omega<1.00001){output.back()=1.;}
  if(_order>0){output.push_back(2./(omega+1.));}
  if(_order<2){return output;}
  for(unsigned int ix=2;ix<=_order+2;++ix) {
    output.push_back(2./ix/(omega+1.)*(1.+(ix-1)*output[ix-2]));
  }
  return output;
}

inline void BaryonThreeQuarkModelFormFactor::SN(double y, int N, double & SNm2,
						double & SN)
{
  // special cases for the low lying values
  if(N==0)
    {
      double root=sqrt((1.+y)*(3.+y));
      SN   = 0.5/y*sqrt((1.+y)/(3.+y))*log((root+y)/(root-y));
      SNm2 = 0.5/(y+3.)*(SN+(1.+y)/(3.+4.*y)); 
    }
  else if(N==1)
    {
      SN   = sqrt(1.+y)/y*asin(y/sqrt(1.+y)/sqrt(3.+y));
      SNm2 = 1./(3.+y)*sqrt((1.+y)/(3.+4.*y)); 
    }
  else if(N==2)
    {
      double root=sqrt((1.+y)*(3.+y));
      SN   = 1.;
      SNm2 = 0.5/y*sqrt((1.+y)/(3.+y))*log((root+y)/(root-y));
    }
  // the general case
  else
    {
      int ix; double root;
      if(N%2==0)
	{
	  SN=1.;
	  ix=2;
	  root=1.;
	}
      else
	{
	  SN = sqrt(1.+y)/y*asin(y/sqrt(1.+y)/sqrt(3.+y));
	  ix=1;
	  root=sqrt((1.+y)/(3.+4.*y));
	}
      do
	{
	  SNm2=SN;
	  ix+=2;
	  root*=(3.+4.*y)/(1.+y);
	  SN=1.0/(ix-1.0)*(root+(ix-2.0)*(y+3.)*SNm2);
	}
      while(ix<N);
    }
}

// the integrand for the coefficients
inline double BaryonThreeQuarkModelFormFactor::integrandC(double x)
{
  // convert the integration variable
  double y=(1.-x)/x;
  double output =exp(-24.*_mu2*y)*y;
  // the integrals
  double I,Im2;
  SN(y,_N,Im2,I);
  double Nfact=0.5*_N+1.0;
  output *= (_a+Nfact/24./(1.+y))*I+1./12./(1.+y)*(_b-Nfact)*Im2;
  return output;
}

inline BaryonCFunction::BaryonCFunction(BaryonThreeQuarkModelFormFactorPtr in)
  : _formFactor(in)
{}

// calculate the integrand  
inline double BaryonCFunction::operator() (double x) const {
  return _formFactor->integrandC(x);
}
}
