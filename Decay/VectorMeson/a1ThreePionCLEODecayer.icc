// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the a1ThreePionCLEODecayer class.
//

namespace Herwig {
using namespace ThePEG;
 
inline a1ThreePionCLEODecayer::a1ThreePionCLEODecayer(const a1ThreePionCLEODecayer & x)
  : DecayIntegrator(x),_rhomass(x._rhomass),_rhowidth(x._rhowidth),
    _prhocc(x._prhocc),_prhoc0(x._prhoc0),_f2mass(x._f2mass),_f2width(x._f2width),
    _pf2cc(x._pf2cc),_pf200(x._pf200),_f0mass(x._f0mass),_f0width(x._f0width),
    _pf0cc(x._pf0cc),_pf000(x._pf000),_sigmamass(x._sigmamass),
    _sigmawidth(x._sigmawidth),_psigmacc(x._psigmacc),_psigma00(x._psigma00),
    _mpi0(x._mpi0),_mpic(x._mpic),
    _coupling(x._coupling),_rhomagP(x._rhomagP),_rhophaseP(x._rhophaseP),
    _rhocoupP(x._rhocoupP),_rhomagD(x._rhomagD),_rhophaseD(x._rhophaseD),
    _rhocoupD(x._rhocoupD),_f2mag(x._f2mag),_f2phase(x._f2phase),_f2coup(x._f2coup),
    _f0mag(x._f0mag),_f0phase(x._f0phase), _f0coup(x._f0coup),
    _sigmamag(x._sigmamag),_sigmaphase(x._sigmaphase),_sigmacoup(x._sigmacoup),
    _localparameters(x._localparameters),_zerowgts(x._zerowgts),
    _onewgts(x._onewgts),_twowgts(x._twowgts),_threewgts(x._threewgts),
    _zeromax(x._zeromax),_onemax(x._onemax),
    _twomax(x._twomax),_threemax(x._threemax) {}
  
inline IBPtr a1ThreePionCLEODecayer::clone() const {
  return new_ptr(*this);
}
  
inline IBPtr a1ThreePionCLEODecayer::fullclone() const {
  return new_ptr(*this);
}

inline void a1ThreePionCLEODecayer::doinitrun() {
  DecayIntegrator::doinitrun();
  if(initialize())
    {
      // get the weights for the different channels
      for(unsigned int ix=0;ix<_zerowgts.size();++ix)
	{_zerowgts[ix]=mode(0)->channelWeight(ix);}
      for(unsigned int ix=0;ix<_onewgts.size();++ix)
	{_onewgts[ix]=mode(1)->channelWeight(ix);}
      for(unsigned int ix=0;ix<_twowgts.size();++ix)
	{_twowgts[ix]=mode(2)->channelWeight(ix);}
      for(unsigned int ix=0;ix<_threewgts.size();++ix)
	{_threewgts[ix]=mode(3)->channelWeight(ix);}
      // get the maximum weight
      _zeromax  = mode(0)->maxWeight();
      _onemax   = mode(1)->maxWeight();
      _twomax   = mode(2)->maxWeight();
      _threemax = mode(3)->maxWeight();
    }
}

// breit wigner for the sigma
inline Complex a1ThreePionCLEODecayer::sigmaBreitWigner(Energy2 q2,int icharge) const
{
  Energy q=sqrt(q2);
  double ratio; Complex ii(0.,1.);
  if(icharge==0){ratio=Kinematics::pstarTwoBodyDecay(q,_mpic,_mpic)/_psigmacc;}
  else{ratio=Kinematics::pstarTwoBodyDecay(q,_mpi0,_mpi0)/_psigma00;}
  Energy gamrun=_sigmawidth*ratio*_sigmamass/q;
  return _sigmamass*_sigmamass/(_sigmamass*_sigmamass-q2-ii*_sigmamass*gamrun);
}

// breit wigner for the f_0
inline Complex a1ThreePionCLEODecayer::f0BreitWigner(Energy2 q2,int icharge) const
{
  Energy q=sqrt(q2);
  double ratio; Complex ii(0.,1.);
  if(icharge==0){ratio=Kinematics::pstarTwoBodyDecay(q,_mpic,_mpic)/_pf0cc;}
  else{ratio=Kinematics::pstarTwoBodyDecay(q,_mpi0,_mpi0)/_pf000;}
  Energy gamrun=_f0width*ratio*_f0mass/q;
  return _f0mass*_f0mass/(_f0mass*_f0mass-q2-ii*_f0mass*gamrun);
}

// breit wigner for the f_2
inline Complex a1ThreePionCLEODecayer::f2BreitWigner(Energy2 q2,int icharge) const
{
  Energy q=sqrt(q2);
  double ratio; Complex ii(0.,1.);
  if(icharge==0){ratio=Kinematics::pstarTwoBodyDecay(q,_mpic,_mpic)/_pf2cc;}
  else{ratio=Kinematics::pstarTwoBodyDecay(q,_mpi0,_mpi0)/_pf200;}
  ratio*= ratio*ratio*ratio*ratio;
  Energy gamrun=_f2width*ratio*_f2mass/q;
  return _f2mass*_f2mass/(_f2mass*_f2mass-q2-ii*_f2mass*gamrun);
}

// breit wigner for the rho
inline Complex a1ThreePionCLEODecayer::rhoBreitWigner(int ires, Energy2 q2,
						      int icharge) const
{
  Energy q=sqrt(q2);
  double ratio; Complex ii(0.,1.);
  if(icharge==0){ratio=Kinematics::pstarTwoBodyDecay(q,_mpic,_mpic)/_prhocc[ires];}
  else{ratio=Kinematics::pstarTwoBodyDecay(q,_mpic,_mpi0)/_prhoc0[ires];}
  ratio*= ratio*ratio;
  Energy gamrun=_rhowidth[ires]*ratio*_rhomass[ires]/q;
  return _rhomass[ires]*_rhomass[ires]/(_rhomass[ires]*_rhomass[ires]
					-q2-ii*_rhomass[ires]*gamrun);
}

}
