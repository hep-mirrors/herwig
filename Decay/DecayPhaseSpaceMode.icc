// -*- C++ -*-
//
// DecayPhaseSpaceMode.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the DecayPhaseSpaceMode class.
//

namespace Herwig {
using namespace ThePEG;

// default constructor
inline DecayPhaseSpaceMode::DecayPhaseSpaceMode()
  :  _niter(10), _npoint(10000), _ntry(500),
     _partial(-1)
{}

// constructor with decayer and particles
inline DecayPhaseSpaceMode::DecayPhaseSpaceMode(tPDVector in, tcDecayIntegratorPtr intin) 
  :  _integrator(intin), _niter(10), _npoint(10000), _ntry(500),
     _extpart(in),  _partial(-1)
{}

inline IBPtr DecayPhaseSpaceMode::clone() const {
  return new_ptr(*this);
}

inline IBPtr DecayPhaseSpaceMode::fullclone() const {
  return new_ptr(*this);
}

// set the maximum weight
inline void DecayPhaseSpaceMode::setMaxWeight(double wgt) const {
  _maxweight=wgt;
}

// add a new channel
inline void DecayPhaseSpaceMode::
addChannel(Ptr<Herwig::DecayPhaseSpaceChannel>::pointer in) {
  in->init();
  _channels.push_back(in);
}

// return the number of channels
inline unsigned int DecayPhaseSpaceMode::numberChannels() const {
  return _channels.size();
}

// reset the properties of one of the intermediate particles
inline void DecayPhaseSpaceMode::resetIntermediate(int ichan, tcPDPtr part,
						   Energy mass, Energy width) {
  if(!part) return;
  _channels[ichan]->resetIntermediate(part,mass,width);
}

// select which phase-space channel to use to output the particles
inline int DecayPhaseSpaceMode::selectChannel(const Particle & inpart,
					      ParticleVector & particles) const {
  // if using flat phase-space don't need to do this
  if(_channelwgts.empty()) return 0;
  vector<double> mewgts(_channels.size(),0.0);
  double total=0.;
  for(unsigned int ix=0,N=_channels.size();ix<N;++ix) {
    mewgts[ix]=me2(false,ix,inpart,particles);
    total+=mewgts[ix];
  }
  // randomly pick a channel
  total*=UseRandom::rnd();
  int ichan=-1;
  do {
    ++ichan;
    total-=mewgts[ichan];
  }
  while(ichan<int(_channels.size())&&total>0.);
  return ichan;
}

// set the weights for the integration channels
inline void DecayPhaseSpaceMode::setWeights(const vector<double> & in) const {
  _channelwgts=in;
}

// access to the external particles
inline tcPDPtr DecayPhaseSpaceMode::externalParticles(int ix) const {
  return _extpart[ix];
}

// number of external particles
inline unsigned int DecayPhaseSpaceMode::numberofParticles() const {
  return _extpart.size();
}

// return the matrix element squared
inline double DecayPhaseSpaceMode::me2(bool bin,const int ichan ,const Particle &inpart,
				       const ParticleVector &outpart) const {
  return _integrator->me2(bin,ichan,inpart,outpart);
}

// set the integration parameter
inline void DecayPhaseSpaceMode::setIntegrate(int iter,int points,int ntry) {
  _niter=iter;
  _npoint=points;
  _ntry=ntry;
}
 
// reset the properities of all intermediates
inline void DecayPhaseSpaceMode::resetIntermediate(tcPDPtr part, Energy mass,
						   Energy width) {
  for(unsigned int ix=0,N=_channels.size();ix<N;++ix)
    _channels[ix]->resetIntermediate(part,mass,width);
}

// get the maximum weight
inline double DecayPhaseSpaceMode::maxWeight() const {
  return _maxweight;
}

// get the weight for a channel
inline double DecayPhaseSpaceMode::channelWeight(unsigned int in) const {
  return _channelwgts[in];
}

inline Energy DecayPhaseSpaceMode::weight(bool vertex,bool cc,int & ichan,
					  const Particle & inpart,
					  ParticleVector & particles) const {
  // generate the phase space point and get the weight
  ichan=0;
  Energy phwgt = (_channels.size()==0) ? 
    flatPhaseSpace(cc,inpart,particles) : channelPhaseSpace(cc,ichan,inpart,particles);
  // generate the matrix element
  return me2(vertex,-1,inpart,particles)*phwgt;
}

inline void DecayPhaseSpaceMode::setPartialWidth(int in) {
  _partial=in;
}

inline unsigned int  DecayPhaseSpaceMode::selectedChannel() const {
  return _ichannel;
}
}
