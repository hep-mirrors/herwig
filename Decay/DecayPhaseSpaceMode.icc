// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DecayPhaseSpaceMode class.
//

namespace Herwig {
using namespace ThePEG;

inline IBPtr DecayPhaseSpaceMode::clone() const {
  return new_ptr(*this);
}

inline IBPtr DecayPhaseSpaceMode::fullclone() const {
  return new_ptr(*this);
}

inline void DecayPhaseSpaceMode::doupdate() throw(UpdateException) {
  Interfaced::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}


inline void DecayPhaseSpaceMode::dofinish() {
  Interfaced::dofinish();
}

inline void DecayPhaseSpaceMode::doinit() throw(InitException) {
  Interfaced::doinit();
}

inline void DecayPhaseSpaceMode::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  Interfaced::rebind(trans);
}

inline IVector DecayPhaseSpaceMode::getReferences() {
  IVector ret = Interfaced::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// set the maximum weight
inline void DecayPhaseSpaceMode::setMaxWeight(double wgt) const {_MaxWeight=wgt;}

// add a new channel
inline void DecayPhaseSpaceMode::
addChannel(Ptr<Herwig::DecayPhaseSpaceChannel>::pointer in)
{
  in->init();
  _channels.push_back(in);
}

// return the number of channels
inline unsigned int DecayPhaseSpaceMode::numberChannels() const{return _channels.size();}

// reset the properties of one of the intermediate particles
inline void DecayPhaseSpaceMode::resetIntermediate(int ichan, tcPDPtr part,
					       Energy mass, Energy width)
{_channels[ichan]->resetIntermediate(part,mass,width);}

// select which phase-space channel to use to output the particles
inline int DecayPhaseSpaceMode::selectChannel(const Particle & inpart,
					      ParticleVector & particles) const
{
  // if using flat phase-space don't need to do this
  if(_channelwgts.empty()){return 0;}
  vector<double> mewgts(_channels.size(),0.0);
  double total=0.;
  for(unsigned int ix=0,N=_channels.size();ix<N;++ix)
    {mewgts[ix]=me2(false,ix,inpart,particles);total+=mewgts[ix];}
  // randomly pick a channel
  total*=CurrentGenerator::current().rnd();
  int ichan=-1;
  do{++ichan;total-=mewgts[ichan];}
  while(ichan<int(_channels.size())&&total>0.);
  return ichan;
}


// set the weights for the integration channels
inline void DecayPhaseSpaceMode::setWeights(const vector<double> in) const 
{_channelwgts=in;}

// access to the external particles
inline tcPDPtr DecayPhaseSpaceMode::externalParticles(int ix) const
{return _extpart[ix];}

// number of external particles
inline unsigned int DecayPhaseSpaceMode::numberofParticles() const
{return _extpart.size();}

// return the matrix element squared
inline double DecayPhaseSpaceMode::me2(bool bin,const int ichan ,const Particle &inpart,
				       const ParticleVector &outpart) const
{return _integrator->me2(bin,ichan,inpart,outpart);}

// set the integration parameter
inline void DecayPhaseSpaceMode::setIntegrate(int iter,int points,int ntry)
{
  _niter=iter;
  _npoint=points;
  _ntry=ntry;
}
 
// reset the properities of all intermediates
inline void DecayPhaseSpaceMode::resetIntermediate(tcPDPtr part, Energy mass,
						   Energy width)
{
  for(unsigned int ix=0,N=_channels.size();ix<N;++ix)
    {_channels[ix]->resetIntermediate(part,mass,width);}
}

// get the maximum weight
inline double DecayPhaseSpaceMode::maxWeight() const {return _MaxWeight;}

// get the weight for a channel
inline double DecayPhaseSpaceMode::channelWeight(unsigned int in) const 
{return _channelwgts[in];}
}
