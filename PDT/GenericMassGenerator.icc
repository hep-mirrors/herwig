// -*- C++ -*-
//
// GenericMassGenerator.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the GenericMassGenerator class.
//

namespace Herwig {
using namespace ThePEG;

inline GenericMassGenerator::GenericMassGenerator() 
  : _maxwgt(),_BWshape(0),_ngenerate(100),
    _lowermass(),_uppermass(),
    _mass(),_width(), 
    _mass2(),_mwidth(),
    _ninitial(1000),
    _initialize(false), _widthopt(false) {}

inline IBPtr GenericMassGenerator::clone() const {
  return new_ptr(*this);
}

inline IBPtr GenericMassGenerator::fullclone() const {
  return new_ptr(*this);
}

// generate the mass (default from ThePEG)
inline Energy GenericMassGenerator::mass(const ParticleData & in) const {
  return mass(in,_lowermass,_uppermass);
}

// generate mass with limits
inline Energy GenericMassGenerator::mass(const ParticleData & in,
					 Energy low, Energy upp) const {
  if(upp<low) return low;
  Energy output;
  int ntry=0; double wgt=0.;
  do {
    ++ntry;
    output=mass(in,wgt,low,upp,3);
    if(wgt>_maxwgt) _maxwgt=wgt;
  }
  while(_maxwgt*(UseRandom::rnd())>wgt&&ntry<_ngenerate);
  return (ntry>=_ngenerate) ? _mass : output;
}

// return the mass with a weight	 
inline Energy GenericMassGenerator::mass(const ParticleData &in,double & wgt) const {
  return mass(in,wgt,_lowermass,_uppermass);
}

inline Energy GenericMassGenerator::mass(const ParticleData &in,double & wgt,
					 int shape) const  {
  return mass(in,wgt,_lowermass,_uppermass,shape);
}

inline Energy GenericMassGenerator::mass(const ParticleData &in,double & wgt, 
					 const Energy low,const Energy upp) const {
  return mass(in,wgt,low,upp,_BWshape);
}

// member that does the work
inline Energy GenericMassGenerator::mass(const ParticleData &,double & wgt, 
					 const Energy low,const Energy upp,
					 int shape) const {
  // calculate the mass square using fixed width BW
  Energy  lo=max(low,_lowermass),up=min(upp,_uppermass);
  double  rhomin=atan((lo*lo-_mass2)/_mwidth);
  double  rhomax=atan((up*up-_mass2)/_mwidth)-rhomin;
  double  rho=rhomin+rhomax*(UseRandom::rnd());
  Energy2 q2 = _mass2+_mwidth*tan(rho);
  Energy  q = sqrt(q2);  
  wgt = rhomax*weight(q,shape);
  // return the mass
  return q;
}

inline Energy GenericMassGenerator::lowerLimit() const {
  return _lowermass;
}

inline Energy GenericMassGenerator::upperLimit() const {
  return _uppermass;
}

inline Energy GenericMassGenerator::nominalMass() const {
  return _mass;
}

inline Energy GenericMassGenerator::nominalWidth() const {
  return _width;
}

inline double GenericMassGenerator::weight(Energy q) const {
  return weight(q,_BWshape);
}

inline double GenericMassGenerator::weight(Energy q,int shape) const {
  Energy2 q2 = q*q;
  Energy4 sq=sqr(q2-_mass2);
  Energy gam=width(q);
  // finish the calculation of the width
  Energy2 num;
  if(shape==2)      num = _mass*gam;
  else if(shape==3) num = _mass*_width;
  else              num = q*gam;
  Energy4 den = (shape==2) ? sq+_mass2*gam*gam : sq+q2*gam*gam;
  return num/den*(sq+_mwidth*_mwidth)/Constants::pi/_mwidth;
}

inline Energy GenericMassGenerator::width(Energy q) const {
  return (_BWshape==1||!_widthgen) ? 
    _width : _widthgen->width(*_particle,q);
}

inline tcPDPtr GenericMassGenerator::particle() const {
  return _particle;
}

}
