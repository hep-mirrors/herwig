// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the GenericMassGenerator class.
//

namespace Herwig {
using namespace ThePEG;

inline GenericMassGenerator::GenericMassGenerator() 
{
 
  _lowermass=0.;_uppermass=0.;
  _maxwgt=0.;
  _BWshape=0;
  _ngenerate=100;
  _mass=0.;_width=0.; 
  _mass2=0.;_mwidth=0.;
  _ninitial=1000;
  _initialize=false;
}

inline GenericMassGenerator::GenericMassGenerator(const GenericMassGenerator & x)
  : MassGenerator(x),_maxwgt(x._maxwgt),_BWshape(x._BWshape),_ngenerate(x._ngenerate),
    _particle(x._particle),_antiparticle(x._antiparticle),
    _lowermass(x._lowermass),_uppermass(x._uppermass),_mass(x._mass),_width(x._width),
    _mass2(x._mass2),_mwidth(x._mwidth),_ninitial(x._ninitial),
    _initialize(x._initialize), _widthgen(x._widthgen) { }

inline IBPtr GenericMassGenerator::clone() const {
  return new_ptr(*this);
}

inline IBPtr GenericMassGenerator::fullclone() const {
  return new_ptr(*this);
}

inline void GenericMassGenerator::doupdate() throw(UpdateException) {
  MassGenerator::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}


inline void GenericMassGenerator::dofinish() {
  MassGenerator::dofinish();
}

inline void GenericMassGenerator::doinitrun() {
  MassGenerator::doinitrun();
}

inline void GenericMassGenerator::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  MassGenerator::rebind(trans);
}

inline IVector GenericMassGenerator::getReferences() {
  IVector ret = MassGenerator::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// generate the mass (default from ThePEG)
inline Energy GenericMassGenerator::mass(const ParticleData & in) const
{return mass(in,_lowermass,_uppermass);}

// generate mass with limits
inline Energy GenericMassGenerator::mass(const ParticleData & in,
					 Energy low, Energy upp) const
{
  Energy output;
  int ntry=0; double wgt=0.;
  do 
    {
      ++ntry;
      output=mass(in,wgt,low,upp);
      if(wgt>_maxwgt){_maxwgt=wgt;}
    }
  while(_maxwgt*(generator()->rnd())>wgt&&ntry<_ngenerate);
  if(ntry>=_ngenerate){return _mass;}
  return output;
}

// return the mass with a weight	 
inline Energy GenericMassGenerator::mass(const ParticleData &in,double & wgt) const   
{return mass(in,wgt,_lowermass,_uppermass);}

// member that does the work
inline Energy GenericMassGenerator::mass(const ParticleData &in,double & wgt, 
					 const Energy low,const Energy upp) const
{
  // calculate the mass square using fixed width BW
  Energy  lo=max(low,_lowermass),up=min(upp,_uppermass);
  double  rhomin=atan((lo*lo-_mass2)/_mwidth);
  double  rhomax=atan((up*up-_mass2)/_mwidth)-rhomin;
  double  rho=rhomin+rhomax*(generator()->rnd());
  Energy2 q2 = _mass2+_mwidth*tan(rho);
  Energy  q = sqrt(q2);  
  wgt = rhomax*weight(q);
  // return the mass
  return q;
}

inline Energy GenericMassGenerator::lowerLimit() const {return _lowermass;}
inline Energy GenericMassGenerator::upperLimit() const {return _uppermass;}
inline Energy GenericMassGenerator::nominalMass() const {return _mass;}
inline Energy GenericMassGenerator::nominalWidth() const {return _width;}

inline double GenericMassGenerator::weight(Energy q) const
{
  Energy2 q2 = q*q;
  double  sq=(q2-_mass2)*(q2-_mass2);
  Energy gam=width(q);
  // finish the calculation of the width
  Energy2 num;
  if(_BWshape==2){num=_mass*gam;}
  else if(_BWshape==3){num=1.;}
  else{num=q*gam;}
  Energy2 den;
  if(_BWshape==2){den=sq+_mass2*gam*gam;}
  else{den=sq+q2*gam*gam;}
  return num/den*(sq+_mwidth*_mwidth)/pi/_mwidth;
}

inline Energy GenericMassGenerator::width(Energy q) const
{
  Energy gam(0.);
  if(_BWshape==1||!_widthgen){gam=_width;}
  else{gam=_widthgen->width(*_particle,q);}
  return gam;
}

}
