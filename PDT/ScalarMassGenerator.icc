// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ScalarMassGenerator class.
//

namespace Herwig {
  using namespace ThePEG;

inline IBPtr ScalarMassGenerator::clone() const {
  return new_ptr(*this);
}

inline IBPtr ScalarMassGenerator::fullclone() const {
  return new_ptr(*this);
}

inline void ScalarMassGenerator::doinit() throw(InitException) {
  // initialise the local variables
  for(unsigned int ix=0;ix<_mass1.size();++ix)
    {
      _mplus.push_back(_mass1[ix]+_mass2[ix]);
      _m2plus.push_back(_mplus[ix]*_mplus[ix]);
      _mminus.push_back(abs(_mass1[ix]-_mass2[ix]));
      _m2minus.push_back(_mminus[ix]*_mminus[ix]);
      _term.push_back(-abs(log(_mass1[ix]/_mass2[ix]))*_mminus[ix]*_mplus[ix]
		      /Constants::pi);
    }
  // rest of the initialisation is handled in the base class
  GenericMassGenerator::doinit();
}

// weight for the factor
inline double ScalarMassGenerator::weight(Energy q) const
{
  Energy2 q2 = q*q;
  Energy2 mass2=nominalMass()*nominalMass();
  Energy2 mwidth=nominalMass()*nominalWidth();
  Energy2 sq = mass2-q2;
  // numerator
  Energy2 num=q*width(q);
  // complex denominantor
  complex<Energy2> 
    denom = sq+real(selfEnergy(nominalMass()))-selfEnergy(q)-Complex(0.,1.)*num;
  Energy4 den = real(denom*conj(denom));
  return num/den*(sq*sq+mwidth*mwidth)/Constants::pi/mwidth;
}

  inline complex<Energy2> ScalarMassGenerator::selfEnergy(Energy q) const
{
  using Constants::pi;
  complex<Energy2> self(0.*GeV2);
  Energy2 q2=q*q;
  double rho(0.); 
  Energy rootp,rootm; 
  //  Energy2 temp(0.*GeV2);
  for(unsigned int ix=0;ix<_mass1.size();++ix)
    {
      if(q>_mplus[ix])
	{
	  rootp = sqrt(q2-_m2plus[ix]);
	  rootm = sqrt(q2-_m2minus[ix]);
	  rho = rootp*rootm/q2;
	  self+=_coupling[ix]*_coupling[ix]/16./pi*
	    (_term[ix]/q2+rho/pi*log((rootm-rootp)/(rootm+rootp)));
	  //  temp+=rho*_coupling[ix]*_coupling[ix]/16./pi;
	}
      else if(q>_mminus[ix])
	{
	  rootp = sqrt(_m2plus[ix]-q2);
	  rootm = sqrt(q2-_m2minus[ix]);
	  rho = rootp*rootm/q2;
	  self+=_coupling[ix]*_coupling[ix]/16./pi*
	    (_term[ix]/q2-rho*(1.-2./pi*atan(rootp/rootm)));
	}
      else
	{
	  rootp = sqrt(_m2plus[ix]-q2);
	  rootm = sqrt(_m2minus[ix]-q2);
	  rho = rootp*rootm/q2;
	  self+=_coupling[ix]*_coupling[ix]/16./pi*
	    (_term[ix]/q2-rho/pi*log((rootp-rootm)/(rootp+rootm)));
	}
    }
  return self;
}

}
