// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ScalarMassGenerator class.
//

namespace Herwig {
  using namespace ThePEG;

inline ScalarMassGenerator::ScalarMassGenerator() {}

inline ScalarMassGenerator::ScalarMassGenerator(const ScalarMassGenerator & x)
  : GenericMassGenerator(x), _coupling(x._coupling), _mass1(x._mass1),
    _mass2(x._mass2),_mplus(x._mplus), _mminus(x._mminus), _m2plus(x._m2plus),
    _m2minus(x._m2minus), _term(x._term) {}

inline IBPtr ScalarMassGenerator::clone() const {
  return new_ptr(*this);
}

inline IBPtr ScalarMassGenerator::fullclone() const {
  return new_ptr(*this);
}

inline void ScalarMassGenerator::doupdate() throw(UpdateException) {
  GenericMassGenerator::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void ScalarMassGenerator::doinit() throw(InitException) {
  // initialise the local variables
  for(unsigned int ix=0;ix<_mass1.size();++ix)
    {
      _mplus.push_back(_mass1[ix]+_mass2[ix]);
      _m2plus.push_back(_mplus[ix]*_mplus[ix]);
      _mminus.push_back(abs(_mass1[ix]-_mass2[ix]));
      _m2minus.push_back(_mminus[ix]*_mminus[ix]);
      _term.push_back(-abs(log(_mass1[ix]/_mass2[ix]))*_mminus[ix]*_mplus[ix]/pi);
    }
  // rest of the initialisation is handled in the base class
  GenericMassGenerator::doinit();
}

inline void ScalarMassGenerator::dofinish() {
  GenericMassGenerator::dofinish();
}

inline void ScalarMassGenerator::doinitrun() {
  GenericMassGenerator::doinitrun();
}

inline void ScalarMassGenerator::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  GenericMassGenerator::rebind(trans);
}

inline IVector ScalarMassGenerator::getReferences() {
  IVector ret = GenericMassGenerator::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// weight for the factor
inline double ScalarMassGenerator::weight(Energy q) const
{
  Energy2 q2 = q*q;
  Energy2 mass2=nominalMass()*nominalMass();
  Energy2 mwidth=nominalMass()*nominalWidth();
  Energy2 sq = mass2-q2;
  // numerator
  Energy2 num=q*width(q);
  // complex denominantor
  complex<Energy2> 
    denom = sq+real(selfEnergy(nominalMass()))-selfEnergy(q)-Complex(0.,1.)*num;
  double den = real(denom*conj(denom));
  return num/den*(sq*sq+mwidth*mwidth)/pi/mwidth;
}

  inline complex<Energy2> ScalarMassGenerator::selfEnergy(Energy q) const
{
  complex<Energy2> self(0.);
  Energy q2=q*q;
  double rho(0.); 
  Energy rootp,rootm; 
  double temp(0.);
  for(unsigned int ix=0;ix<_mass1.size();++ix)
    {
      if(q>_mplus[ix])
	{
	  rootp = sqrt(q2-_m2plus[ix]);
	  rootm = sqrt(q2-_m2minus[ix]);
	  rho = rootp*rootm/q2;
	  self+=_coupling[ix]*_coupling[ix]/16./pi*
	    (_term[ix]/q2+rho/pi*log((rootm-rootp)/(rootm+rootp)));
	  temp+=rho*_coupling[ix]*_coupling[ix]/16./pi;
	}
      else if(q>_mminus[ix])
	{
	  rootp = sqrt(_m2plus[ix]-q2);
	  rootm = sqrt(q2-_m2minus[ix]);
	  rho = rootp*rootm/q2;
	  self+=_coupling[ix]*_coupling[ix]/16./pi*
	    (_term[ix]/q2-rho*(1.-2./pi*atan(rootp/rootm)));
	}
      else
	{
	  rootp = sqrt(_m2plus[ix]-q2);
	  rootm = sqrt(_m2minus[ix]-q2);
	  rho = rootp*rootm/q2;
	  self+=_coupling[ix]*_coupling[ix]/16./pi*
	    (_term[ix]/q2-rho/pi*log((rootp-rootm)/(rootp+rootm)));
	}
    }
  return self;
}

}
