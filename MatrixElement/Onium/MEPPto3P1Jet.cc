// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEPPto3P1Jet class.
//

#include "MEPPto3P1Jet.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Utilities/EnumIO.h"
#include "ThePEG/Helicity/WaveFunction/ScalarWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorBarWaveFunction.h"
#include "ThePEG/StandardModel/StandardModelBase.h"
#include "ThePEG/Helicity/epsilon.h"
#include "Herwig/MatrixElement/ProductionMatrixElement.h"
#include "Herwig/MatrixElement/HardVertex.h"

using namespace Herwig;

void MEPPto3P1Jet::doinit() {
  HwMEBase::doinit();
  // get the non-perturbative ME
  O1_ = params_->singletMEProduction<1>(state_,n_,1,1);
  // set the mass option
  massOption(vector<unsigned int>({mOpt_+1,0}));
}

IBPtr MEPPto3P1Jet::clone() const {
  return new_ptr(*this);
}

IBPtr MEPPto3P1Jet::fullclone() const {
  return new_ptr(*this);
}

void MEPPto3P1Jet::persistentOutput(PersistentOStream & os) const {
  os << params_ << ounit(O1_,GeV*GeV2*GeV2) << oenum(state_) << n_ << process_ << mOpt_;
}

void MEPPto3P1Jet::persistentInput(PersistentIStream & is, int) {
  is >> params_ >> iunit(O1_,GeV*GeV2*GeV2) >> ienum(state_) >> n_ >> process_ >> mOpt_;
}

// The following static variable is needed for the type
// description system in ThePEG.
DescribeClass<MEPPto3P1Jet,HwMEBase>
describeHerwigMEPPto3P1Jet("Herwig::MEPPto3P1Jet",
			   "HwOniumParameters.so HwMEHadronOnium.so");

void MEPPto3P1Jet::Init() {

  static ClassDocumentation<MEPPto3P1Jet> documentation
    ("The MEPPto3P1Jet class implements the q qbar -> 3P1 g, g q to 3P1 q"
     " and g g to 3P1 g processes");

  static Reference<MEPPto3P1Jet,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEPPto3P1Jet::params_, false, false, true, false, false);
  
  static Switch<MEPPto3P1Jet,OniumState> interfaceState
    ("State",
     "The type of onium state",
     &MEPPto3P1Jet::state_, ccbar, false, false);
  static SwitchOption interfaceStateccbar
    (interfaceState,
     "ccbar",
     "Charmonium state",
     ccbar);
  static SwitchOption interfaceStatebbbar
    (interfaceState,
     "bbbar",
     "Bottomonium state",
     bbbar);
  
  static Parameter<MEPPto3P1Jet,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEPPto3P1Jet::n_, 1, 1, 10,
     false, false, Interface::limited);

  static Switch<MEPPto3P1Jet,unsigned int> interfaceProcess
    ("Process",
     "Which processes to generate",
     &MEPPto3P1Jet::process_, 0, false, false);
  static SwitchOption interfaceProcessAll
    (interfaceProcess,
     "All",
     "Generate all the processes",
     0);
  static SwitchOption interfaceProcessGQto3P1Q
    (interfaceProcess,
     "GQto3P1Q",
     "The g q -> 3P1 q process",
     1);
  static SwitchOption interfaceProcessGQbarto3P1Qbar
    (interfaceProcess,
     "GQbarto3P1Qbar",
     "The g qbar -> 3P1 qbar process",
     2);
  static SwitchOption interfaceProcessQQbarto3P1G
    (interfaceProcess,
     "QQbarto3P1G",
     "The q qbar -> 3P1 g process",
     3);
  static SwitchOption interfaceProcessGGto3P1G
    (interfaceProcess,
     "GGto3P1G",
     "The g g -> 3P1 g process",
     4);

  static Switch<MEPPto3P1Jet,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 3P1 mass",
     &MEPPto3P1Jet::mOpt_, 0, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 3P1 state.",
     1);

}

void MEPPto3P1Jet::getDiagrams() const {
  // construct the meson PDG code from quark ids
  unsigned int iq = 4+state_;
  tcPDPtr ps = getParticleData(long(iq*110 + 20003 + (n_-1)*100000));
  tcPDPtr g = getParticleData(ParticleID::g);
  // processes involving quarks
  for ( int i = 1; i <= 3; ++i ) {
    tcPDPtr q = getParticleData(i);
    tcPDPtr qb = q->CC();
    if(process_ == 0 || process_ == 1)
      add(new_ptr((Tree2toNDiagram(3), g, g, q , 1, ps, 2, q , -1)));
    if(process_ == 0 || process_ == 2)
      add(new_ptr((Tree2toNDiagram(3), g, g, qb, 1, ps, 2, qb, -2)));
    if(process_ == 0 || process_ == 3)
      add(new_ptr((Tree2toNDiagram(2), q, qb, 1, g, 3, ps, 3, g, -3)));
  }
  // g g -> 3P1 g (s,t,u 4-point)
  if(process_ == 0 || process_ == 4) {
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, g, 3, ps, 3, g , -4)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 1, ps, 2, g , -5)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 2, ps, 1, g , -6)));
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, ps, 1, g , -7)));
  }
}

Selector<MEBase::DiagramIndex>
MEPPto3P1Jet::diagrams(const DiagramVector & diags) const {
  Selector<DiagramIndex> sel;
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 ||
  	 diags[i]->id() == -2 ||
  	 diags[i]->id() == -3 ) sel.insert(1.0, i);
    else
      sel.insert(meInfo()[abs(diags[i]->id())-4],i);
  return sel;
}

Selector<const ColourLines *>
MEPPto3P1Jet::colourGeometries(tcDiagPtr diag) const {
  // g q -> 3P1 q
  static ColourLines cgq   ("1 2  5, -1 -2  3");
  // g qbar -> 3P1 qbar
  static ColourLines cgqbar("1 2 -3, -1 -2 -5");
  // q qbar -> 3P1 g
  static ColourLines cqqbar("1 3  5, -2 -3 -5");
  // g g -> 3P1 g
  static ColourLines cs[2]={ColourLines("1 3 5, -1 2, -2 -3 -5"),
  			    ColourLines("1 -2, -1 -3 -5, 2 3 5")};
  static ColourLines ct[2]={ColourLines("1 2 5, -1 -2 3, -3 -5"),
  			    ColourLines("1 2 -3, -1 -2 -5, 3 5")};
  static ColourLines cu[2]={ColourLines("1 5, -1 -2 3, -3 2 -5"),
  			    ColourLines("1 2 -3, -1 -5, 3 -2 5")};
  // 4 point
  static ColourLines c4[2]={ColourLines("1 -2,  2  4, -1 -4"),
  			    ColourLines("1  4, -4 -2,  2 -1")};
  // create the selector
  Selector<const ColourLines *> sel;
  if      (diag->id() == -1) sel.insert(1.0, &cgq   );
  else if (diag->id() == -2) sel.insert(1.0, &cgqbar);
  else if (diag->id() == -3) sel.insert(1.0, &cqqbar);
  else if (diag->id() == -4) {
    sel.insert(0.5, &cs[0]);
    sel.insert(0.5, &cs[1]);
  }
  else if (diag->id() == -5) {
    sel.insert(0.5, &ct[0]);
    sel.insert(0.5, &ct[1]);
  }
  else if (diag->id() == -6) {
    sel.insert(0.5, &cu[0]);
    sel.insert(0.5, &cu[1]);
  }
  else if (diag->id() == -7) {
    sel.insert(0.5, &c4[0]);
    sel.insert(0.5, &c4[1]);
  }
  return sel;
}

Energy2 MEPPto3P1Jet::scale() const {
  return sHat();
}

double MEPPto3P1Jet::me2() const {
  // return value
  double output(0.);
  // mass of the 3P1 state
  Energy  M  = meMomenta()[2].mass();
  Energy2 M2 = sqr(meMomenta()[2].mass());
  if(mePartonData()[0]->id()==ParticleID::g) {
    // g qbar -> 3P1 qbar
    if(mePartonData()[1]->id()==ParticleID::g) {
      // // weights for the different diagrams
      // DVector save(4,0.);
      // save[0] = (8*sqr(sHat()-3*M2)*tHat()*uHat())/pow<4,1>(tHat() + uHat());
      // save[1] = (4*tHat()*sqr(uHat()-3*M2)*
      // 		 (pow<4,1>(M2) + pow<4,1>(sHat()) +pow<4,1>(tHat()) - 
      // 		  2*(pow<3,1>(M2) + pow<3,1>(sHat()) - pow<3,1>(tHat()))*uHat() + 
      // 		  (sqr(M2) + sqr(sHat()) + sqr(tHat()))*sqr(uHat())))/
      // 	(pow<4,1>(M2 - uHat())*uHat()*sqr(tHat() + uHat()));
      // save[2] = (4*sqr(-3*M2 + tHat())*uHat()*
      // 		 (pow<4,1>(M2) + pow<4,1>(sHat()) - 2*pow<3,1>(M2)*tHat() - 
      // 		  2*pow<3,1>(sHat())*tHat() + sqr(M2)*sqr(tHat()) + 
      // 		  sqr(sHat())*sqr(tHat()) + sqr(uHat())*sqr(tHat() + uHat())))/
      // 	(pow<4,1>(M2 - tHat())*tHat()*sqr(tHat() + uHat()));
      // save[3]=tHat()*uHat()*(16*pow<10,1>(M2)-32*pow<9,1>(M2)*(tHat()+uHat())
      // 			     +2*sHat()*sqr(tHat())*sqr(tHat()-uHat())*sqr(uHat())*pow<3,1>(tHat()+uHat())
      // 			     +sqr(tHat())*sqr(uHat())*pow<4,1>(tHat()+uHat())*(sqr(tHat())+sqr(uHat()))
      // 			     +2*pow<3,1>(sHat())*(tHat()+uHat())*(sqr(tHat())+sqr(uHat()))*
      // 			     (sqr(tHat())-tHat()*uHat()+sqr(uHat()))*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
      // 			     +4*pow<8,1>(M2)*(4*sqr(sHat())+5*sqr(tHat())+28*tHat()*uHat()+5*sqr(uHat()))
      // 			     +pow<4,1>(sHat())*sqr(pow<3,1>(tHat())+pow<3,1>(uHat()))
      // 			     +sqr(sHat())*(pow<8,1>(tHat())+2*pow<7,1>(tHat())*uHat()
      // 					   +6*pow<6,1>(tHat())*sqr(uHat())+4*pow<5,1>(tHat())*pow<3,1>(uHat())
      // 					   +14*pow<4,1>(tHat())*pow<4,1>(uHat())+4*pow<3,1>(tHat())*pow<5,1>(uHat())
      // 					   +6*sqr(tHat())*pow<6,1>(uHat())+2*tHat()*pow<7,1>(uHat())+pow<8,1>(uHat()))
      // 			     -4*pow<7,1>(M2)*(16*pow<3,1>(sHat())+26*sqr(sHat())*(tHat()+uHat())
      // 					      +4*sHat()*(2*sqr(tHat())+tHat()*uHat()+2*sqr(uHat()))
      // 					      +(tHat()+uHat())*(7*sqr(tHat())+22*tHat()*uHat()+7*sqr(uHat())))
      // 			     +pow<6,1>(M2)*(64*pow<4,1>(sHat())+280*pow<3,1>(sHat())*(tHat()+uHat())
      // 					    +2*sHat()*(tHat()+uHat())*(87*sqr(tHat())-40*tHat()*uHat()+87*sqr(uHat()))
      // 					    +sqr(sHat())*(397*sqr(tHat())+482*tHat()*uHat()+397*sqr(uHat()))
      // 					    +10*(9*pow<4,1>(tHat())+3*pow<3,1>(tHat())*uHat()
      // 						 +28*sqr(tHat())*sqr(uHat())+3*tHat()*pow<3,1>(uHat())+9*pow<4,1>(uHat())))
      // 			     -2*pow<5,1>(M2)*(72*pow<4,1>(sHat())*(tHat()+uHat())+3*sqr(sHat())*(tHat()+uHat())*(137*sqr(tHat())+62*tHat()*uHat()+137*sqr(uHat()))+pow<3,1>(sHat())*(317*sqr(tHat())+378*tHat()*uHat()+317*sqr(uHat()))+2*(tHat()+uHat())*(40*pow<4,1>(tHat())-21*pow<3,1>(tHat())*uHat()+66*sqr(tHat())*sqr(uHat())-21*tHat()*pow<3,1>(uHat())+40*pow<4,1>(uHat()))+sHat()*(213*pow<4,1>(tHat())+130*pow<3,1>(tHat())*uHat()+178*sqr(tHat())*sqr(uHat())+130*tHat()*pow<3,1>(uHat())+213*pow<4,1>(uHat())))
      // 			     +pow<4,1>(M2)*(3*pow<4,1>(sHat())*(59*sqr(tHat())+54*tHat()*uHat()+59*sqr(uHat()))+4*pow<3,1>(sHat())*(tHat()+uHat())*(180*sqr(tHat())+91*tHat()*uHat()+180*sqr(uHat()))+2*sHat()*(tHat()+uHat())*(268*pow<4,1>(tHat())-47*pow<3,1>(tHat())*uHat()+282*sqr(tHat())*sqr(uHat())-47*tHat()*pow<3,1>(uHat())+268*pow<4,1>(uHat()))+sqr(sHat())*(981*pow<4,1>(tHat())+1496*pow<3,1>(tHat())*uHat()+2054*sqr(tHat())*sqr(uHat())+1496*tHat()*pow<3,1>(uHat())+981*pow<4,1>(uHat()))+2*(80*pow<6,1>(tHat())+111*pow<5,1>(tHat())*uHat()+30*pow<4,1>(tHat())*sqr(uHat())+138*pow<3,1>(tHat())*pow<3,1>(uHat())+30*sqr(tHat())*pow<4,1>(uHat())+111*tHat()*pow<5,1>(uHat())+80*pow<6,1>(uHat())))
      // 			     +2*pow<3,1>(M2)*(-2*pow<4,1>(sHat())*(tHat()+uHat())*(31*sqr(tHat())-4*tHat()*uHat()+31*sqr(uHat()))-2*sqr(sHat())*(tHat()+uHat())*(157*pow<4,1>(tHat())+102*pow<3,1>(tHat())*uHat()+306*sqr(tHat())*sqr(uHat())+102*tHat()*pow<3,1>(uHat())+157*pow<4,1>(uHat()))-pow<3,1>(sHat())*(243*pow<4,1>(tHat())+336*pow<3,1>(tHat())*uHat()+514*sqr(tHat())*sqr(uHat())+336*tHat()*pow<3,1>(uHat())+243*pow<4,1>(uHat()))-3*(tHat()+uHat())*(14*pow<6,1>(tHat())+21*pow<5,1>(tHat())*uHat()+8*pow<4,1>(tHat())*sqr(uHat())+18*pow<3,1>(tHat())*pow<3,1>(uHat())+8*sqr(tHat())*pow<4,1>(uHat())+21*tHat()*pow<5,1>(uHat())+14*pow<6,1>(uHat()))-sHat()*(168*pow<6,1>(tHat())+209*pow<5,1>(tHat())*uHat()+150*pow<4,1>(tHat())*sqr(uHat())+186*pow<3,1>(tHat())*pow<3,1>(uHat())+150*sqr(tHat())*pow<4,1>(uHat())+209*tHat()*pow<5,1>(uHat())+168*pow<6,1>(uHat())))
      // 			     +sqr(M2)*(18*pow<8,1>(tHat())+76*pow<7,1>(tHat())*uHat()+157*pow<6,1>(tHat())*sqr(uHat())+90*pow<5,1>(tHat())*pow<3,1>(uHat())+126*pow<4,1>(tHat())*pow<4,1>(uHat())+90*pow<3,1>(tHat())*pow<5,1>(uHat())+157*sqr(tHat())*pow<6,1>(uHat())+76*tHat()*pow<7,1>(uHat())+18*pow<8,1>(uHat())+18*pow<4,1>(sHat())*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))*(3*sqr(tHat())-2*tHat()*uHat()+3*sqr(uHat()))+2*pow<3,1>(sHat())*(tHat()+uHat())*(91*pow<4,1>(tHat())+23*pow<3,1>(tHat())*uHat()+164*sqr(tHat())*sqr(uHat())+23*tHat()*pow<3,1>(uHat())+91*pow<4,1>(uHat()))+2*sHat()*(tHat()+uHat())*(45*pow<6,1>(tHat())+43*pow<5,1>(tHat())*uHat()+17*pow<4,1>(tHat())*sqr(uHat())+36*pow<3,1>(tHat())*pow<3,1>(uHat())+17*sqr(tHat())*pow<4,1>(uHat())+43*tHat()*pow<5,1>(uHat())+45*pow<6,1>(uHat()))+sqr(sHat())*(201*pow<6,1>(tHat())+350*pow<5,1>(tHat())*uHat()+620*pow<4,1>(tHat())*sqr(uHat())+742*pow<3,1>(tHat())*pow<3,1>(uHat())+620*sqr(tHat())*pow<4,1>(uHat())+350*tHat()*pow<5,1>(uHat())+201*pow<6,1>(uHat())))
      // 			     +2*M2*(-(tHat()*uHat()*pow<3,1>(tHat()+uHat())*(3*tHat()+uHat())*(tHat()+3*uHat())*(sqr(tHat())-tHat()*uHat()+sqr(uHat())))-6*pow<4,1>(sHat())*(pow<5,1>(tHat())+pow<3,1>(tHat())*sqr(uHat())+sqr(tHat())*pow<3,1>(uHat())+pow<5,1>(uHat()))-sqr(sHat())*(tHat()+uHat())*(13*pow<6,1>(tHat())+13*pow<5,1>(tHat())*uHat()+30*pow<4,1>(tHat())*sqr(uHat())+36*pow<3,1>(tHat())*pow<3,1>(uHat())+30*sqr(tHat())*pow<4,1>(uHat())+13*tHat()*pow<5,1>(uHat())+13*pow<6,1>(uHat()))-pow<3,1>(sHat())*(16*pow<6,1>(tHat())+19*pow<5,1>(tHat())*uHat()+31*pow<4,1>(tHat())*sqr(uHat())+32*pow<3,1>(tHat())*pow<3,1>(uHat())+31*sqr(tHat())*pow<4,1>(uHat())+19*tHat()*pow<5,1>(uHat())+16*pow<6,1>(uHat()))-sHat()*(3*pow<8,1>(tHat())+9*pow<7,1>(tHat())*uHat()+19*pow<6,1>(tHat())*sqr(uHat())-5*pow<5,1>(tHat())*pow<3,1>(uHat())+12*pow<4,1>(tHat())*pow<4,1>(uHat())-5*pow<3,1>(tHat())*pow<5,1>(uHat())+19*sqr(tHat())*pow<6,1>(uHat())+9*tHat()*pow<7,1>(uHat())+3*pow<8,1>(uHat()))))/(pow<4,1>(M2-tHat())*pow<4,1>(M2-uHat())*pow<4,1>(tHat()+uHat()));
      // meInfo(save);
      // // matrix element
      // output = 64./9.*O1_*pow<3,1>(Constants::pi*standardModel()->alphaS(scale())/M)/sHat()*
      // 	(9*pow<4,1>(M2)*sqr(M2-tHat())*sqr(M2-uHat())*sqr(tHat()+uHat())*
      // 	 sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat())-M2*(tHat()+uHat()))
      // 	 +pow<4,1>(sHat())*sqr(tHat()+uHat())*sqr(uHat()*(sHat()+uHat())*(sqr(sHat())+sHat()*uHat()+sqr(uHat()))
      // 						  +sqr(M2)*(3*sqr(sHat())+6*sHat()*uHat()+sqr(uHat()))
      // 						  -M2*(3*sHat()+uHat())*(sqr(sHat())+2*sHat()*uHat()+2*sqr(uHat())))
      // 	 +sqr(M2-tHat())*pow<4,1>(tHat())*sqr(uHat()*(tHat()+uHat())*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
      // 					      +sqr(M2)*(3*sqr(tHat())+6*tHat()*uHat()+sqr(uHat()))
      // 					      -M2*(3*tHat()+uHat())*(sqr(tHat())+2*tHat()*uHat()+2*sqr(uHat())))
      // 	 +sqr(M2-uHat())*pow<4,1>(uHat())*sqr(tHat()*(tHat()+uHat())*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
      // 					      -M2*(tHat()+3*uHat())*(2*sqr(tHat())+2*tHat()*uHat()+sqr(uHat()))
      // 					      +sqr(M2)*(sqr(tHat())+6*tHat()*uHat()+3*sqr(uHat()))))
      // 	/(pow<4,1>(M2-tHat())*tHat()*pow<4,1>(M2-uHat())*uHat()*pow<4,1>(tHat()+uHat()));
      // // test vs NPB 291 731
      // // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // // Energy6 Q(sHat()*tHat()*uHat());
      // // Energy4 P(sHat()*tHat()+tHat()*uHat()+uHat()*sHat());
      // // double test = 16.*Constants::pi*sqr(sHat())*
      // // 	4.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/M/M2/sqr(sHat())/Q/pow<4,1>(Q-M2*P)*
      // // 	(9.*sqr(M2*sqr(P))*(pow<4,1>(M2)-2.*sqr(M2)*P+sqr(P)) -6*M2*pow<3,1>(P)*Q*(2.*pow<4,1>(M2)-5.*sqr(M2)*P+sqr(P))
      // // 	 -sqr(P*Q)*(pow<4,1>(M2)+2.*sqr(M2)*P-sqr(P))+2.*M2*P*pow<3,1>(Q)*(sqr(M2)-P)+6.*pow<4,1>(M*Q));
      // // cerr << "testing matrix element " << output << " " << test << " "
      // // 	   << (output-test)/(output+test) << " " << output/test << "\n";
      assert(false);
    }
    else if(mePartonData()[1]->id()<0) {
      // helicity amplitude version of ME
      // VectorWaveFunction      g1w(meMomenta()[0],mePartonData()[0],incoming);
      // SpinorBarWaveFunction   q2w(meMomenta()[1],mePartonData()[1],incoming);
      // VectorWaveFunction      v3w(meMomenta()[2],mePartonData()[2],outgoing);
      // SpinorWaveFunction      q4w(meMomenta()[3],mePartonData()[3],outgoing);
      // vector<VectorWaveFunction>    g1;
      // vector<SpinorBarWaveFunction> q2;
      // vector<VectorWaveFunction>    v3;
      // vector<SpinorWaveFunction>    q4;
      // for(unsigned int ix=0;ix<2;++ix) {
      // 	g1w.reset(2*ix);
      // 	g1.push_back(g1w);
      // 	q2w.reset(ix);
      // 	q2.push_back(q2w);
      // 	q4w.reset(ix);
      // 	q4.push_back(q4w);
      // }
      // for(unsigned int ix=0;ix<3;++ix) {
      // 	v3w.reset(ix,vector_phase);
      // 	v3.push_back(v3w);
      // }
      // double total(0.);
      // ProductionMatrixElement me(PDT::Spin1,PDT::Spin1Half,PDT::Spin1,PDT::Spin1Half);
      // Complex phase = exp(Complex(0.,meMomenta()[2].phi()));
      // me(0,0,0,0)=(Complex(0,2)*phase*sHat()*sqrt(-(uHat()/sHat())))/M2;
      // me(0,0,1,0)=(Complex(0,1)*sqrt(2)*sHat()*sqrt(-tHat()))/pow<3,1>(M);
      // me(0,1,0,1)=(Complex(0,2)*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*phase-M2*phase*sHat());
      // me(0,1,1,1)=(Complex(0,1)*sqrt(2)*(M2+sHat())*sqrt(-tHat())*uHat())/(pow<3,1>(M)*sqr(phase)*(M2-sHat()));
      // me(0,1,2,1)=(Complex(0,2)*tHat()*sqrt(-(sHat()*uHat())))/(pow(phase,3)*(sqr(M2)-M2*sHat()));
      // me(2,0,0,0)=(Complex(0,-2)*pow(phase,3)*tHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)-M2*sHat());
      // me(2,0,1,0)=(Complex(0,1)*sqrt(2)*sqr(phase)*(M2+sHat())*sqrt(-tHat())*uHat())/(pow<5,1>(M)-pow<3,1>(M)*sHat());
      // me(2,0,2,0)=(Complex(0,-2)*phase*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)-M2*sHat());
      // me(2,1,1,1)=(Complex(0,1)*sqrt(2)*sHat()*sqrt(-tHat()))/pow<3,1>(M);
      // me(2,1,2,1)=(Complex(0,-2)*sHat()*sqrt(-(uHat()/sHat())))/(M2*phase);
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q4[ih4].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
      //     for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	    for(unsigned int ih3=0;ih3<3;++ih3) {
      // 	      auto eps1 = epsilon(meMomenta()[2],v3[ih3].wave(),g1[ih1].wave());
      // 	      auto eps2 = epsilon(fCurrent,meMomenta()[2],v3[ih3].wave());
      // 	      Complex amp =-((M2-tHat())*(eps1*fCurrent)
      // 			     +2.*(meMomenta()[2]*g1[ih1].wave())*(eps2*meMomenta()[0])
      // 			     -2.*(fCurrent*meMomenta()[2])*(eps1*meMomenta()[0])
      // 			     )/sqr(M2);
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10&&test>1e-10) cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 								     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << amp/me(2*ih1,ih2,ih3,ih4) << "\n";
      // 	      total+= norm(amp);
      // 	    }
      // 	  }
      // 	}
      // }
      // spin sum version
      double total = -((4*sqr(M2-sHat())*sqr(sHat())*tHat()+8*M2*sHat()*(sqr(M2-sHat())+sqr(tHat()))*uHat()+4*sqr(M2+sHat())*tHat()*sqr(uHat())+8*M2*sHat()*pow<3,1>(uHat()))/(pow<3,1>(M2)*sqr(M2-sHat())));
      // final factors
      output = 128.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))/81./pow<4,1>(tHat()-M2)*total;
      // analytic test
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -16.*Constants::pi*sqr(sHat())*
      // 	16.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/(3.*M*M2*sqr(sHat())*pow<4,1>(tHat()-M2))*
      // 	(tHat()*(sqr(sHat())+sqr(uHat()))+4.*M2*sHat()*uHat());
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    // g q -> 3P1 q
    else if(mePartonData()[1]->id()<6) {
      // helicity amplitude version of ME
      // VectorWaveFunction      g1w(meMomenta()[0],mePartonData()[0],incoming);
      // SpinorWaveFunction      q2w(meMomenta()[1],mePartonData()[1],incoming);
      // VectorWaveFunction      v3w(meMomenta()[2],mePartonData()[2],outgoing);
      // SpinorBarWaveFunction   q4w(meMomenta()[3],mePartonData()[3],outgoing);
      // vector<VectorWaveFunction> g1;
      // vector<SpinorWaveFunction> q2;
      // vector<VectorWaveFunction> v3;
      // vector<SpinorBarWaveFunction> q4;
      // for(unsigned int ix=0;ix<2;++ix) {
      //   g1w.reset(2*ix);
      //   g1.push_back(g1w);
      //   q2w.reset(ix);
      //   q2.push_back(q2w);
      //   q4w.reset(ix);
      //   q4.push_back(q4w);
      // }
      // for(unsigned int ix=0;ix<3;++ix) {
      // 	v3w.reset(ix,vector_phase);
      // 	v3.push_back(v3w);
      // }
      // double total(0.);
      // ProductionMatrixElement me(PDT::Spin1,PDT::Spin1Half,PDT::Spin1,PDT::Spin1Half);
      // Complex phase = exp(Complex(0.,meMomenta()[2].phi()));
      // me(0,0,0,0)=(Complex(0,-2)*phase*sHat()*sqrt(-(uHat()/sHat())))/M2;
      // me(0,0,1,0)=(Complex(0,-1)*sqrt(2)*sHat()*sqrt(-tHat()))/pow<3,1>(M);
      // me(0,1,0,1)=(Complex(0,-2)*uHat()*sqrt(-(sHat()*uHat())))/M2/phase/(M2-sHat());
      // me(0,1,1,1)=(Complex(0,-1)*sqrt(2)*(M2+sHat())*sqrt(-tHat())*uHat())/(pow<3,1>(M)*sqr(phase)*(M2-sHat()));
      // me(0,1,2,1)=(Complex(0,-2)*tHat()*sqrt(-(sHat()*uHat())))/(pow(phase,3)*(sqr(M2)-M2*sHat()));
      // me(2,0,0,0)=(Complex(0,2)*pow(phase,3)*tHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)-M2*sHat());
      // me(2,0,1,0)=(Complex(0,-1)*sqrt(2)*sqr(phase)*(M2+sHat())*sqrt(-tHat())*uHat())/(pow<5,1>(M)-pow<3,1>(M)*sHat());
      // me(2,0,2,0)=(Complex(0,2)*phase*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)-M2*sHat());
      // me(2,1,1,1)=(Complex(0,-1)*sqrt(2)*sHat()*sqrt(-tHat()))/pow<3,1>(M);
      // me(2,1,2,1)=(Complex(0,2)*sHat()*sqrt(-(uHat()/sHat())))/(M2*phase);
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      //     for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	    for(unsigned int ih3=0;ih3<3;++ih3) {
      // 	      auto eps1 = epsilon(meMomenta()[2],v3[ih3].wave(),g1[ih1].wave());
      // 	      auto eps2 = epsilon(fCurrent,meMomenta()[2],v3[ih3].wave());
      // 	      Complex amp = ((M2-tHat())*(eps1*fCurrent)
      // 			     +2.*(meMomenta()[2]*g1[ih1].wave())*(eps2*meMomenta()[0])
      // 			     -2.*(fCurrent*meMomenta()[2])*(eps1*meMomenta()[0])
      // 			     )/sqr(M2);
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10&&test>1e-10) cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 								     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << amp/me(2*ih1,ih2,ih3,ih4) << "\n";
      // 	      total+= norm(amp);
      // 	    }
      // 	  }
      // 	}
      // }
      // spin sum version
      double total = -((4*sqr(M2-sHat())*sqr(sHat())*tHat()+8*M2*sHat()*(sqr(M2-sHat())+sqr(tHat()))*uHat()+4*sqr(M2+sHat())*tHat()*sqr(uHat())+8*M2*sHat()*pow<3,1>(uHat()))/(pow<3,1>(M2)*sqr(M2-sHat())));
      // final factors
      output = 128.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))/81./pow<4,1>(tHat()-M2)*total;
      // analytic test
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -16.*Constants::pi*sqr(sHat())*
      // 	16.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/(3.*M*M2*sqr(sHat())*pow<4,1>(tHat()-M2))*
      // 	(tHat()*(sqr(sHat())+sqr(uHat()))+4.*M2*sHat()*uHat());
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    else assert(false);
  }
  // q qbar -> 3P1 g
  else if(mePartonData()[0]->id()==-mePartonData()[1]->id()) {
    // helicity amplitude version of ME
    // SpinorWaveFunction      q1w(meMomenta()[0],mePartonData()[1],incoming);
    // SpinorBarWaveFunction   q2w(meMomenta()[1],mePartonData()[0],incoming);
    // VectorWaveFunction      v3w(meMomenta()[2],mePartonData()[2],outgoing);
    // VectorWaveFunction      g4w(meMomenta()[3],mePartonData()[3],outgoing);
    // vector<SpinorWaveFunction>    q1;
    // vector<SpinorBarWaveFunction> q2;
    // vector<VectorWaveFunction>    v3;
    // vector<VectorWaveFunction>    g4;
    // for(unsigned int ix=0;ix<2;++ix) {
    //   g4w.reset(2*ix,vector_phase);
    //   g4.push_back(g4w);
    //   q1w.reset(ix);
    //   q1.push_back(q1w);
    //   q2w.reset(ix);
    //   q2.push_back(q2w);
    // }
    // for(unsigned int ix=0;ix<3;++ix) {
    // 	v3w.reset(ix,vector_phase);
    // 	v3.push_back(v3w);
    // }
    // double total(0.);
    // ProductionMatrixElement me(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin1,PDT::Spin1);
    // Complex phase = exp(Complex(0.,meMomenta()[2].phi()));
    // me(0,1,0,0)=(Complex(0,2)*phase*sqrt(tHat()*uHat()))/M2;
    // me(0,1,1,0)=(Complex(0,-1)*sqrt(2)*sqrt(sHat())*tHat())/pow<3,1>(M);
    // me(0,1,1,2)=(Complex(0,1)*sqrt(2)*sqrt(sHat())*uHat())/(pow<3,1>(M)*sqr(phase));
    // me(0,1,2,2)=(Complex(0,-2)*sqrt(tHat()*uHat()))/(M2*pow(phase,3));
    // me(1,0,0,0)=(Complex(0,2)*pow(phase,3)*sqrt(tHat()*uHat()))/M2;
    // me(1,0,1,0)=(Complex(0,1)*sqrt(2)*sqr(phase)*sqrt(sHat())*uHat())/pow<3,1>(M);
    // me(1,0,1,2)=(Complex(0,-1)*sqrt(2)*sqrt(sHat())*tHat())/pow<3,1>(M);
    // me(1,0,2,2)=(Complex(0,-2)*sqrt(tHat()*uHat()))/(M2*phase);
    // for(unsigned int ih1=0;ih1<2;++ih1) {
    //   for(unsigned int ih2=0;ih2<2;++ih2) {
    //     LorentzPolarizationVectorE fCurrent = q1[ih1].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
    //  	for(unsigned int ih4=0;ih4<2;++ih4) {
    // 	  for(unsigned int ih3=0;ih3<3;++ih3) {
    // 	    auto eps1 = epsilon(meMomenta()[2],v3[ih3].wave(),g4[ih4].wave());
    // 	    auto eps2 = epsilon(fCurrent,meMomenta()[2],v3[ih3].wave());
    // 	    Complex amp = ((M2-sHat())*(eps1*fCurrent) + 2.*(fCurrent*meMomenta()[2])*(eps1*meMomenta()[3])
    // 			   -2.*(meMomenta()[2]*g4[ih4].wave())*(eps2*meMomenta()[3]))/sqr(M2);
    // 	    double test = norm(amp/me(ih1,ih2,ih3,2*ih4)-1);
    // 	    if(norm(me(ih1,ih2,ih3,2*ih4))>1e-10&&test>1e-10) 
    // 	      cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
    // 		   << amp << " " << me(ih1,ih2,ih3,2*ih4) << " " << amp/me(ih1,ih2,ih3,2*ih4) << "\n";
    // 	    total+= norm(amp);
    // 	  }
    // 	}
    //   }
    // }
    // spin sum version
    double total = 4.*(4.*M2*tHat()*uHat()+sHat()*(sqr(tHat())+sqr(uHat())))/pow<3,1>(M2);
    // final factors
    output = 1024.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))/(243.*pow<4,1>(sHat()-M2))*total;
    // analytic test
    // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
    // double test = 16.*Constants::pi*sqr(sHat())*8./3.*sqr(tHat()/sHat())*
    //   16.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02*
    //   (sHat()*(sqr(tHat())+sqr(uHat()))+4.*M2*tHat()*uHat())/3./M/M2/sqr(tHat())/pow<4,1>(sHat()-M2);
    // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
  }
  else
    assert(false);
  return output;
}

void MEPPto3P1Jet::constructVertex(tSubProPtr sub) {
  // extract the particles in the hard process
  ParticleVector hard;
  hard.reserve(4);
  hard.push_back(sub->incoming().first);
  hard.push_back(sub->incoming().second);
  hard.push_back(sub->outgoing()[0]);
  hard.push_back(sub->outgoing()[1]);
  // get them in the right order
  bool swapped(false);
  if(hard[0]->id()==-hard[1]->id()) {
    if(hard[0]->id()<0) swapped = true;
  }
  else if(hard[0]->id()!=ParticleID::g) {
    swapped=true;
  }
  if(swapped) {
    swap(hard[0],hard[1]);
    swap(hard[2],hard[3]);
  }
  // boost to partonic CMS
  Lorentz5Momentum pcms = hard[0]->momentum()+hard[1]->momentum();
  LorentzRotation boost(-pcms.boostVector());
  for(PPtr part : hard) part->transform(boost);
  // extract kinematic variables
  Energy  M  = hard[2]->mass();
  Energy2 M2 = sqr(M);
  double phi = hard[2]->momentum().phi();
  Complex phase = exp(Complex(0.,phi));
  Energy2 sh = (hard[0]->momentum()+hard[1]->momentum()).m2();
  Energy2 th = (hard[0]->momentum()-hard[2]->momentum()).m2();
  Energy2 uh = (hard[0]->momentum()-hard[3]->momentum()).m2();
  // set basis states and compute the matrix element
  ProductionMatrixElement me;
  vector<VectorWaveFunction> v3;
  VectorWaveFunction(v3,hard[2],outgoing,true ,false,true,vector_phase);
  if(hard[0]->id()==ParticleID::g) {
    // g g -> 3P1 g
    if(hard[1]->id()==ParticleID::g) {
      vector<VectorWaveFunction> g1,g2,g4;
      VectorWaveFunction( g1,hard[0],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g2,hard[1],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g4,hard[3],outgoing,true , true,true,vector_phase);
      ProductionMatrixElement me(PDT::Spin1,PDT::Spin1,PDT::Spin1,PDT::Spin1);
      //     Complex phase = exp(Complex(0.,phi));
      //     Energy2 um(uh-M2),tm(th-M2),sm(sh-M2);
      //     me(0,0,0,0)=(sqrt(2)*phase*sqr(sh)*(uh*(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))+sqr(M2)*(3*sqr(sh)+6*sh*uh+sqr(uh))-M2*(3*sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh))))/(sm*sqr(tm)*sqrt(th*uh)*sqr(um));
      //     me(0,0,0,2)=(3*sqrt(2)*sqr(M2)*(M2*sm+sqr(th)+th*uh+sqr(uh)))/(phase*sm*tm*sqrt(th*uh)*um);
      //     me(0,2,0,0)=-((sqrt(2)*sqr(th)*(-(sm*uh*(sqr(th)+th*uh+sqr(uh)))+sqr(M2)*(3*sqr(th)+6*th*uh+sqr(uh))-M2*(3*th+uh)*(sqr(th)+2*th*uh+2*sqr(uh))))/(phase*sqr(sm)*(-M2+th)*sqrt(th*uh)*sqr(um)));
      //     me(0,2,0,2)=(sqrt(2)*sqr(uh)*(-(sm*th*(sqr(th)+th*uh+sqr(uh)))-M2*(th+3*uh)*(2*sqr(th)+2*th*uh+sqr(uh))+sqr(M2)*(sqr(th)+6*th*uh+3*sqr(uh))))/(pow(phase,3)*sqr(sm)*sqr(tm)*sqrt(th*uh)*(-M2+uh));
      //     me(2,0,0,0)=-((sqrt(2)*pow(phase,3)*sqr(uh)*(-(sm*th*(sqr(th)+th*uh+sqr(uh)))-M2*(th+3*uh)*(2*sqr(th)+2*th*uh+sqr(uh))+sqr(M2)*(sqr(th)+6*th*uh+3*sqr(uh))))/(sqr(sm)*sqr(tm)*sqrt(th*uh)*(-M2+uh)));
      //     me(2,0,0,2)=(sqrt(2)*phase*sqr(th)*(-(sm*uh*(sqr(th)+th*uh+sqr(uh)))+sqr(M2)*(3*sqr(th)+6*th*uh+sqr(uh))-M2*(3*th+uh)*(sqr(th)+2*th*uh+2*sqr(uh))))/(sqr(sm)*(-M2+th)*sqrt(th*uh)*sqr(um));
      //     me(2,2,0,0)=(-3*sqrt(2)*sqr(M2)*phase*(M2*sm+sqr(th)+th*uh+sqr(uh)))/(sm*tm*sqrt(th*uh)*um);
      //     me(2,2,0,2)=-((sqrt(2)*sqr(sh)*(uh*(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))+sqr(M2)*(3*sqr(sh)+6*sh*uh+sqr(uh))-M2*(3*sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh))))/(phase*sm*sqr(tm)*sqrt(th*uh)*sqr(um)));
      //     // test the average result
      //     // double aver = me.average();
      //     // double test = 4.*(9*pow<4,1>(M2)*sqr(M2-th)*sqr(M2-uh)*sqr(th+uh)*
      //     // 			sqr(sqr(th)+th*uh+sqr(uh)-M2*(th+uh))
      //     // 			+pow<4,1>(sh)*sqr(th+uh)*sqr(uh*(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))
      //     // 						     +sqr(M2)*(3*sqr(sh)+6*sh*uh+sqr(uh))
      //     // 						     -M2*(3*sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh)))
      //     // 			+sqr(M2-th)*pow<4,1>(th)*sqr(uh*(th+uh)*(sqr(th)+th*uh+sqr(uh))
      //     // 						     +sqr(M2)*(3*sqr(th)+6*th*uh+sqr(uh))
      //     // 						     -M2*(3*th+uh)*(sqr(th)+2*th*uh+2*sqr(uh)))
      //     // 			+sqr(M2-uh)*pow<4,1>(uh)*sqr(th*(th+uh)*(sqr(th)+th*uh+sqr(uh))
      //     // 						     -M2*(th+3*uh)*(2*sqr(th)+2*th*uh+sqr(uh))
      //     // 						     +sqr(M2)*(sqr(th)+6*th*uh+3*sqr(uh))))
      //     // 	/(pow<4,1>(M2-th)*th*pow<4,1>(M2-uh)*uh*pow<4,1>(th+uh));
      //     // 	cerr << "testing spin correlations " << test << " " << me.average() << " "
      //     // 	     << abs(test-aver)/(test+aver) << "\n";
    }
    // g qbar -> 3P1 qbar
    else if(hard[1]->id()<0) {
      vector<VectorWaveFunction>    g1;
      vector<SpinorBarWaveFunction> q2;
      vector<SpinorWaveFunction>    q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
      SpinorWaveFunction(   q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin1,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0)=(Complex(0,2)*phase*sh*sqrt(-(uh/sh)))/M2;
	me(0,0,1,0)=(Complex(0,1)*sqrt(2)*sh*sqrt(-th))/pow<3,1>(M);
	me(0,1,0,1)=(Complex(0,2)*uh*sqrt(-(sh*uh)))/(sqr(M2)*phase-M2*phase*sh);
	me(0,1,1,1)=(Complex(0,1)*sqrt(2)*(M2+sh)*sqrt(-th)*uh)/(pow<3,1>(M)*sqr(phase)*(M2-sh));
	me(0,1,2,1)=(Complex(0,2)*th*sqrt(-(sh*uh)))/(pow(phase,3)*(sqr(M2)-M2*sh));
	me(2,0,0,0)=(Complex(0,-2)*pow(phase,3)*th*sqrt(-(sh*uh)))/(sqr(M2)-M2*sh);
	me(2,0,1,0)=(Complex(0,1)*sqrt(2)*sqr(phase)*(M2+sh)*sqrt(-th)*uh)/(pow<5,1>(M)-pow<3,1>(M)*sh);
	me(2,0,2,0)=(Complex(0,-2)*phase*uh*sqrt(-(sh*uh)))/(sqr(M2)-M2*sh);
	me(2,1,1,1)=(Complex(0,1)*sqrt(2)*sh*sqrt(-th))/pow<3,1>(M);
	me(2,1,2,1)=(Complex(0,-2)*sh*sqrt(-(uh/sh)))/(M2*phase);
      }
      else {
	phase *= -1.;
	me(0,0,0,0)=(Complex(0,2)*sqr(phase)*sqrt(-(sh*uh))*(th+uh))/(M2*(-M2+sh));
	me(0,0,1,0)=(Complex(0,-1)*sqrt(2)*phase*sh*sqrt(-th))/pow<3,1>(M);
	me(0,1,0,1)=(Complex(0,-2)*sqr(phase)*uh*sqrt(-(sh*uh)))/(sqr(M2)-M2*sh);
	me(0,1,1,1)=(Complex(0,-1)*sqrt(2)*phase*(M2+sh)*sqrt(-th)*uh)/(pow<5,1>(M)-pow<3,1>(M)*sh);
	me(0,1,2,1)=(Complex(0,2)*th*sqrt(-(sh/uh))*uh)/(sqr(M2)-M2*sh);
	me(2,0,0,0)=(Complex(0,-2)*th*sqrt(-(sh/uh))*uh)/(sqr(M2)-M2*sh);
	me(2,0,1,0)=(Complex(0,1)*sqrt(2)*(M2+sh)*sqrt(-(th/sqr(M2-sh)))*uh)/(pow<3,1>(M)*phase);
	me(2,0,2,0)=(Complex(0,2)*uh*sqrt(-(sh*uh)))/(sqr(phase)*(sqr(M2)-M2*sh));
	me(2,1,1,1)=(Complex(0,-1)*sqrt(2)*sh*sqrt(-th))/(pow<3,1>(M)*phase);
	me(2,1,2,1)=(Complex(0,2)*sqrt(-(sh*uh))*(th+uh))/(M2*sqr(phase)*(M2-sh));
      }
      // Helicity code version
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      // 	  LorentzPolarizationVectorE fCurrent = q4[ih4].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
      // 	  for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	    for(unsigned int ih3=0;ih3<3;++ih3) {
      // 	      auto eps1 = epsilon(hard[2]->momentum(),v3[ih3].wave(),g1[ih1].wave());
      // 	      auto eps2 = epsilon(fCurrent,hard[2]->momentum(),v3[ih3].wave());
      // 	      Complex amp =-((M2-th)*(eps1*fCurrent)
      // 			     +2.*(hard[2]->momentum()*g1[ih1].wave())*(eps2*hard[0]->momentum())
      // 			     -2.*(fCurrent*hard[2]->momentum())*(eps1*hard[0]->momentum())
      // 			     )/sqr(M2);
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10&&test>1e-10)
      // 		cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << amp/me(2*ih1,ih2,ih3,ih4) << "\n";
      // 	    }
      // 	  }
      // 	}
      // }
    }
    // g q -> 3P1 q
    else if(hard[1]->id()<6) {
      vector<VectorWaveFunction> g1;
      vector<SpinorWaveFunction> q2;
      vector<SpinorBarWaveFunction> q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorWaveFunction(   q2,hard[1],incoming,false,true);
      SpinorBarWaveFunction(q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin1,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0)=(Complex(0,-2)*phase*sh*sqrt(-(uh/sh)))/M2;
	me(0,0,1,0)=(Complex(0,-1)*sqrt(2)*sh*sqrt(-th))/pow<3,1>(M);
	me(0,1,0,1)=(Complex(0,-2)*uh*sqrt(-(sh*uh)))/M2/phase/(M2-sh);
	me(0,1,1,1)=(Complex(0,-1)*sqrt(2)*(M2+sh)*sqrt(-th)*uh)/(pow<3,1>(M)*sqr(phase)*(M2-sh));
	me(0,1,2,1)=(Complex(0,-2)*th*sqrt(-(sh*uh)))/(pow(phase,3)*(sqr(M2)-M2*sh));
	me(2,0,0,0)=(Complex(0,2)*pow(phase,3)*th*sqrt(-(sh*uh)))/(sqr(M2)-M2*sh);
	me(2,0,1,0)=(Complex(0,-1)*sqrt(2)*sqr(phase)*(M2+sh)*sqrt(-th)*uh)/(pow<5,1>(M)-pow<3,1>(M)*sh);
	me(2,0,2,0)=(Complex(0,2)*phase*uh*sqrt(-(sh*uh)))/(sqr(M2)-M2*sh);
	me(2,1,1,1)=(Complex(0,-1)*sqrt(2)*sh*sqrt(-th))/pow<3,1>(M);
	me(2,1,2,1)=(Complex(0,2)*sh*sqrt(-(uh/sh)))/(M2*phase);
      }
      else {
	phase *=-1.;
	me(0,0,0,0)=(Complex(0,2)*sqr(phase)*sqrt(-(sh*uh))*(th+uh))/(sqr(M2)-M2*sh);
	me(0,0,1,0)=(Complex(0,1)*sqrt(2)*phase*sh*sqrt(-th))/pow<3,1>(M);
	me(0,1,0,1)=(Complex(0,2)*sqr(phase)*uh*sqrt(-(sh*uh)))/(sqr(M2)-M2*sh);
	me(0,1,1,1)=(Complex(0,-1)*sqrt(2)*phase*(M2+sh)*sqrt(-(th/sqr(M2-sh)))*uh)/pow<3,1>(M);
	me(0,1,2,1)=(Complex(0,-2)*th*sqrt(-(sh/uh))*uh)/(sqr(M2)-M2*sh);
	me(2,0,0,0)=(Complex(0,2)*th*sqrt(-(sh/uh))*uh)/(sqr(M2)-M2*sh);
	me(2,0,1,0)=(Complex(0,1)*sqrt(2)*(M2+sh)*sqrt(-th)*uh)/(pow<3,1>(M)*phase*(M2-sh));
	me(2,0,2,0)=(Complex(0,2)*uh*sqrt(-(sh*uh)))/(M2*sqr(phase)*(-M2+sh));
	me(2,1,1,1)=(Complex(0,1)*sqrt(2)*sh*sqrt(-th))/(pow<3,1>(M)*phase);
	me(2,1,2,1)=(Complex(0,2)*sqrt(-(sh*uh))*(th+uh))/(M2*sqr(phase)*(-M2+sh));
      }
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      //     for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	    for(unsigned int ih3=0;ih3<3;++ih3) {
      // 	      auto eps1 = epsilon(hard[2]->momentum(),v3[ih3].wave(),g1[ih1].wave());
      // 	      auto eps2 = epsilon(fCurrent,hard[2]->momentum(),v3[ih3].wave());
      // 	      Complex amp = ((M2-th)*(eps1*fCurrent)
      // 			     +2.*(hard[2]->momentum()*g1[ih1].wave())*(eps2*hard[0]->momentum())
      // 			     -2.*(fCurrent*hard[2]->momentum())*(eps1*hard[0]->momentum())
      // 			     )/sqr(M2);
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10&&test>1e-10)
      // 		cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << amp/me(2*ih1,ih2,ih3,ih4) << "\n";
      // 	    }
      // 	  }
      // 	}
      // }
    }
    else
      assert(false);
  }
  else if(hard[0]->id()==-hard[1]->id()) {
    vector<SpinorWaveFunction>    q1;
    vector<SpinorBarWaveFunction> q2;
    vector<VectorWaveFunction>    g4;
    SpinorWaveFunction(   q1,hard[0],incoming,false,true);
    SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
    VectorWaveFunction(   g4,hard[3],outgoing,true,true,true,vector_phase);
    g4[1]=g4[2];
    // matrix element
    me = ProductionMatrixElement(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin1,PDT::Spin1);
    if(!swapped) {
      me(0,1,0,0)=(Complex(0,2)*phase*sqrt(th*uh))/M2;
      me(0,1,1,0)=(Complex(0,-1)*sqrt(2)*sqrt(sh)*th)/pow<3,1>(M);
      me(0,1,1,2)=(Complex(0,1)*sqrt(2)*sqrt(sh)*uh)/(pow<3,1>(M)*sqr(phase));
      me(0,1,2,2)=(Complex(0,-2)*sqrt(th*uh))/(M2*pow(phase,3));
      me(1,0,0,0)=(Complex(0,2)*pow(phase,3)*sqrt(th*uh))/M2;
      me(1,0,1,0)=(Complex(0,1)*sqrt(2)*sqr(phase)*sqrt(sh)*uh)/pow<3,1>(M);
      me(1,0,1,2)=(Complex(0,-1)*sqrt(2)*sqrt(sh)*th)/pow<3,1>(M);
      me(1,0,2,2)=(Complex(0,-2)*sqrt(th*uh))/(M2*phase);
    }
    else {
      phase *=-1.;
      me(0,1,0,0)=(Complex(0,-2)*pow(phase,3)*sqrt(th*uh))/M2;
      me(0,1,1,0)=(Complex(0,1)*sqrt(2)*sqr(phase)*sqrt(sh)*th)/pow<3,1>(M);
      me(0,1,1,2)=(Complex(0,-1)*sqrt(2)*sqrt(sh)*uh)/pow<3,1>(M);
      me(0,1,2,2)=(Complex(0,2)*sqrt(th*uh))/(M2*phase);
      me(1,0,0,0)=(Complex(0,-2)*phase*sqrt(th*uh))/M2;
      me(1,0,1,0)=(Complex(0,-1)*sqrt(2)*sqrt(sh)*uh)/pow<3,1>(M);
      me(1,0,1,2)=(Complex(0,1)*sqrt(2)*sqrt(sh)*th)/(pow<3,1>(M)*sqr(phase));
      me(1,0,2,2)=(Complex(0,2)*sqrt(th*uh))/(M2*pow(phase,3));
    }
    // Helicity code version
    // for(unsigned int ih1=0;ih1<2;++ih1) {
    //   for(unsigned int ih2=0;ih2<2;++ih2) {
    //     LorentzPolarizationVectorE fCurrent = q1[ih1].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());	
    //  	for(unsigned int ih4=0;ih4<2;++ih4) {
    // 	  for(unsigned int ih3=0;ih3<3;++ih3) {
    // 	    auto eps1 = epsilon(hard[2]->momentum(),v3[ih3].wave(),g4[ih4].wave());
    // 	    auto eps2 = epsilon(fCurrent,hard[2]->momentum(),v3[ih3].wave());
    // 	    Complex amp = ((M2-sh)*(eps1*fCurrent) + 2.*(fCurrent*hard[2]->momentum())*(eps1*hard[3]->momentum())
    // 			   -2.*(hard[2]->momentum()*g4[ih4].wave())*(eps2*hard[3]->momentum()))/sqr(M2);
    // 	    double test=norm(amp/me(ih1,ih2,ih3,2*ih4)-1.);
    // 	    if(norm(me(ih1,ih2,ih3,2*ih4))>1e-10&&test>1e-10 ) 
    // 	      cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
    // 		   << amp << " " << me(ih1,ih2,ih3,2*ih4) << " " << amp/me(ih1,ih2,ih3,2*ih4) << "\n";
    // 	  }
    // 	}
    //   }
    // }
  }
  else
    assert(false);
  // construct the vertex
  HardVertexPtr hardvertex = new_ptr(HardVertex());
  // // set the matrix element for the vertex
  hardvertex->ME(me);
  // set the pointers and to and from the vertex
  for(unsigned int i = 0; i < hard.size(); ++i)
    hard[i]->spinInfo()->productionVertex(hardvertex);
  // boost back to lab
  boost = LorentzRotation(pcms.boostVector());
  for(PPtr part : hard)
    part->transform(boost);
}
