// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEPPto1P1Jet class.
//

#include "MEPPto1P1Jet.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Utilities/EnumIO.h"
#include "ThePEG/StandardModel/StandardModelBase.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "Herwig/MatrixElement/ProductionMatrixElement.h"
#include "Herwig/MatrixElement/HardVertex.h"

using namespace Herwig;

void MEPPto1P1Jet::doinit() {
  HwMEBase::doinit();
  // get the non-perturbative ME
  O1_ = params_->singletMEProduction<1>(state_,n_,0,1);
  // set the mass option
  massOption(vector<unsigned int>({mOpt_+1,0}));
}

IBPtr MEPPto1P1Jet::clone() const {
  return new_ptr(*this);
}

IBPtr MEPPto1P1Jet::fullclone() const {
  return new_ptr(*this);
}

void MEPPto1P1Jet::persistentOutput(PersistentOStream & os) const {
  os << params_ << ounit(O1_,GeV*GeV2*GeV2) << oenum(state_) << n_ << mOpt_;
}

void MEPPto1P1Jet::persistentInput(PersistentIStream & is, int) {
  is >> params_ >> iunit(O1_,GeV*GeV2*GeV2) >> ienum(state_) >> n_ >> mOpt_;
}

//The following static variable is needed for the type
// description system in ThePEG.
DescribeClass<MEPPto1P1Jet,HwMEBase>
describeHerwigMEPPto1P1Jet("Herwig::MEPPto1P1Jet",
			   "HwOniumParameters.so HwMEHadronOnium.so");

void MEPPto1P1Jet::Init() {

  static ClassDocumentation<MEPPto1P1Jet> documentation
    ("The MEPPto1P1Jet class implements the g g to 1P1 g processes");

  static Reference<MEPPto1P1Jet,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEPPto1P1Jet::params_, false, false, true, false, false);
  
  static Switch<MEPPto1P1Jet,OniumState> interfaceState
    ("State",
     "The type of onium state",
     &MEPPto1P1Jet::state_, ccbar, false, false);
  static SwitchOption interfaceStateccbar
    (interfaceState,
     "ccbar",
     "Charmonium state",
     ccbar);
  static SwitchOption interfaceStatebbbar
    (interfaceState,
     "bbbar",
     "Bottomonium state",
     bbbar);
  
  static Parameter<MEPPto1P1Jet,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEPPto1P1Jet::n_, 1, 1, 10,
     false, false, Interface::limited);

  static Switch<MEPPto1P1Jet,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 1P1 mass",
     &MEPPto1P1Jet::mOpt_, 0, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 1P1 state.",
     1);
}

void MEPPto1P1Jet::getDiagrams() const {
  // construct the meson PDG code from quark ids
  unsigned int iq = 4+state_;
  tcPDPtr ps = getParticleData(long(iq*110+10003 + (n_-1)*100000));
  tcPDPtr g = getParticleData(ParticleID::g);
  add(new_ptr((Tree2toNDiagram(2), g, g, 1, ps, 1, g , -1)));
}

Selector<MEBase::DiagramIndex>
MEPPto1P1Jet::diagrams(const DiagramVector & diags) const {
  Selector<DiagramIndex> sel;
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 ) sel.insert(1.0, i);
  return sel;
}

Selector<const ColourLines *>
MEPPto1P1Jet::colourGeometries(tcDiagPtr ) const {
  static ColourLines c1("1 -2,  2  4, -1 -4");
  static ColourLines c2("1  4, -4 -2,  2 -1");
  Selector<const ColourLines *> sel;
  sel.insert(0.5, &c1);
  sel.insert(0.5, &c2);
  return sel;
}

Energy2 MEPPto1P1Jet::scale() const {
  return sHat();
}

double MEPPto1P1Jet::me2() const {
  Energy M = meMomenta()[2].mass();
  Energy2 M2=sqr(M);
  InvEnergy4 me2 = -1024*
    (pow<6,1>(M2)*(M2 - sHat()) + 
     2*(M2 - sHat())*tHat()*uHat()*
     sqr(sqr(tHat()) + tHat()*uHat() + sqr(uHat())) - 2*pow<5,1>(M2)*
     (sqr(tHat()) + 4*tHat()*uHat() + sqr(uHat())) + 
     2*pow<4,1>(M2)*(M2 - sHat())*
     (sqr(tHat()) + 7*tHat()*uHat() + sqr(uHat())) + 
     sqr(M2)*(M2 - sHat())*tHat()*uHat()*
     (13*sqr(tHat()) + 23*tHat()*uHat() + 
      13*sqr(uHat())) - 
     pow<3,1>(M2)*(pow<4,1>(tHat()) + 
		   18*pow<3,1>(tHat())*uHat() + 
		   32*sqr(tHat())*sqr(uHat()) + 
		   18*tHat()*pow<3,1>(uHat()) + pow<4,1>(uHat())) - 
     2*M2*tHat()*uHat()*
     (3*pow<4,1>(tHat()) + 10*pow<3,1>(tHat())*uHat() + 
      15*sqr(tHat())*sqr(uHat()) + 
      10*tHat()*pow<3,1>(uHat()) + 3*pow<4,1>(uHat())))
    /pow<3,1>((uHat()-M2)*(tHat()-M2)*(sHat()-M2));
  double output = 5./324.*pow(Constants::pi*standardModel()->alphaS(scale()),3)*O1_/M*me2;
  // test vs NPB 291 731
  // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
  // Energy6 Q(sHat()*tHat()*uHat());
  // Energy4 P(sHat()*tHat()+tHat()*uHat()+uHat()*sHat());
  // double test = 16.*Constants::pi*sqr(sHat())*
  //   40*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/3./M/sqr(sHat())/pow<3,1>(Q-M2*P)*
  //   (-pow<5,1>(M2)*P + pow<3,1>(M2)*sqr(P) +Q*(-7*sqr(M2)*P+5*pow<4,1>(M2)+2.*sqr(P)) +4.*M2*sqr(Q));
  // cerr << "testing matrix element " << output << " " << test << " "
  //      << (output-test)/(output+test) << " " << output/test << "\n";
  return output;
}


void MEPPto1P1Jet::constructVertex(tSubProPtr sub) {
  using namespace ThePEG::Helicity;
  // extract the particles in the hard process
  // only one order
  ParticleVector hard;
  hard.reserve(4);
  hard.push_back(sub->incoming().first);
  hard.push_back(sub->incoming().second);
  hard.push_back(sub->outgoing()[0]);
  hard.push_back(sub->outgoing()[1]);
  // boost to partonic CMS
  Lorentz5Momentum pcms = hard[0]->momentum()+hard[1]->momentum();
  LorentzRotation boost(-pcms.boostVector());
  for(PPtr part : hard) part->transform(boost);
  // set the wavefunctions
  vector<VectorWaveFunction> g1,g2,psi,g4;
  VectorWaveFunction( g1,hard[0],incoming,false, true,true,vector_phase);
  VectorWaveFunction( g2,hard[1],incoming,false, true,true,vector_phase);
  VectorWaveFunction(psi,hard[2],outgoing,true ,false,true,vector_phase);
  VectorWaveFunction( g4,hard[3],outgoing,true , true,true,vector_phase);
  // extract kinematic variables
  Energy M = hard[2]->mass();
  Energy2 M2 = sqr(hard[2]->mass());
  double phi = hard[2]->momentum().phi();
  Energy2 sh = (hard[0]->momentum()+hard[1]->momentum()).m2();
  Energy2 th = (hard[0]->momentum()-hard[2]->momentum()).m2();
  Energy2 uh = (hard[0]->momentum()-hard[3]->momentum()).m2();
  Energy2 um(uh-M2),tm(th-M2),sm(sh-M2);
  Complex phase = exp(Complex(0.,phi));
  Energy rstu = sqrt(th*uh/sh);
  // calculate the matrix element
  ProductionMatrixElement me(PDT::Spin1,PDT::Spin1,PDT::Spin1,PDT::Spin1);
  me(0,0,0,0)=-16.*sqr(phase)*sqr(sh)*(pow<3,1>(M2)*(sh + uh) + sqr(sh)*uh*(sh + uh) + M2*sh*uh*(sh + 2*uh)
				       - sqr(M2)*(sqr(sh) + 3*sh*uh + sqr(uh)))/(sqr(sm)*sqr(tm)*sqr(um));
  me(0,0,0,2)=-16.*sqr(M2)*sh*(M2 + sh)*th*uh/(sqr(sm)*sqr(tm)*sqr(um));
  me(0,0,1,0)=16.*sqrt(2)*M*phase*rstu*pow<4,1>(sh)*(-th + uh)/(sqr(sm)*sqr(tm)*sqr(um));
  me(0,0,1,2)=16.*sqrt(2)*pow<5,1>(M)*rstu*sqr(sh)*(th - uh)/(phase*sqr(sm)*sqr(tm)*sqr(um));
  me(0,0,2,0)=-16.*pow<3,1>(sh)*(M2 + sh)*th*uh/(sqr(sm)*sqr(tm)*sqr(um));
  me(0,0,2,2)=16.*sqr(M2)*sqr(sh)*(M2*sm + 2*th*uh)/(sqr(phase)*sqr(sm)*sqr(tm)*sqr(um));
  me(0,2,0,0)=16.*sh*th*(-(M2*sh*th) + sh*sqr(th) + sqr(M2)*(sh + th))*uh/(sqr(sm)*sqr(tm)*sqr(um));
  me(0,2,0,2)=16.*sqr(sh)*sqr(uh)*(-sqr(M2) + th*uh)/(sqr(phase)*sqr(sm)*sqr(tm)*sqr(um));
  me(0,2,1,0)=-16.*sqrt(2)*M*sqr(sh)*th*(M2*sh + sqr(th))*sqrt((th*uh)/(sh*sqr(sm)))/(phase*sm*sqr(tm)*sqr(um));
  me(0,2,1,2)=16.*sqrt(2)*M*sqr(sh)*uh*sqrt((th*uh)/(sh*sqr(sm)))*(M2*sh + sqr(uh))/(pow(phase,3)*sm*sqr(tm)*sqr(um));
  me(0,2,2,0)=16.*sqr(sh)*sqr(th)*(sqr(M2) - th*uh)/(sqr(phase)*sqr(sm)*sqr(tm)*sqr(um));
  me(0,2,2,2)=-16.*sh*th*uh*(-(M2*sh*uh) + sh*sqr(uh) + sqr(M2)*(sh + uh))/(pow(phase,4)*sqr(sm)*sqr(tm)*sqr(um));
  me(2,0,0,0)=16.*pow(phase,4)*sh*th*uh*(-(M2*sh*uh) + sh*sqr(uh) + sqr(M2)*(sh + uh))/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,0,0,2)=16.*sqr(phase)*sqr(sh)*sqr(th)*(-sqr(M2) + th*uh)/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,0,1,0)=16.*sqrt(2)*M*pow(phase,3)*sqr(sh)*uh*sqrt((th*uh)/(sh*sqr(sm)))*(M2*sh + sqr(uh))/(sm*sqr(tm)*sqr(um));
  me(2,0,1,2)=-16.*sqrt(2)*M*phase*sqr(sh)*th*(M2*sh + sqr(th))*sqrt((th*uh)/(sh*sqr(sm)))/(sm*sqr(tm)*sqr(um));
  me(2,0,2,0)=16.*sqr(phase)*sqr(sh)*sqr(uh)*(sqr(M2) - th*uh)/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,0,2,2)=-16.*sh*th*(-(M2*sh*th) + sh*sqr(th) + sqr(M2)*(sh + th))*uh/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,2,0,0)=-16.*sqr(M2)*sqr(phase)*sqr(sh)*(M2*sm + 2*th*uh)/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,2,0,2)=16.*pow<3,1>(sh)*(M2 + sh)*th*uh/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,2,1,0)=16.*sqrt(2)*pow<5,1>(M)*phase*rstu*sqr(sh)*(th - uh)/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,2,1,2)=16.*sqrt(2)*M*rstu*pow<4,1>(sh)*(-th + uh)/(phase*sqr(sm)*sqr(tm)*sqr(um));
  me(2,2,2,0)=16.*sqr(M2)*sh*(M2 + sh)*th*uh/(sqr(sm)*sqr(tm)*sqr(um));
  me(2,2,2,2)=16.*sqr(sh)*(pow<3,1>(M2)*(sh + uh) + sqr(sh)*uh*(sh + uh) + M2*sh*uh*(sh + 2*uh)
			   - sqr(M2)*(sqr(sh) + 3*sh*uh + sqr(uh)))/(sqr(phase)*sqr(sm)*sqr(tm)*sqr(um));
  // test the spin averaged result
  // double test =  -1024*sqr(sh)*
  //   (pow<6,1>(M2)*(M2 - sh) + 
  //    2*(M2 - sh)*th*uh*
  //    sqr(sqr(th) + th*uh + sqr(uh)) - 2*pow<5,1>(M2)*
  //    (sqr(th) + 4*th*uh + sqr(uh)) + 
  //    2*pow<4,1>(M2)*(M2 - sh)*
  //    (sqr(th) + 7*th*uh + sqr(uh)) + 
  //    sqr(M2)*(M2 - sh)*th*uh*
  //    (13*sqr(th) + 23*th*uh + 
  //     13*sqr(uh)) - 
  //    pow<3,1>(M2)*(pow<4,1>(th) + 
  // 		   18*pow<3,1>(th)*uh + 
  // 		   32*sqr(th)*sqr(uh) + 
  // 		   18*th*pow<3,1>(uh) + pow<4,1>(uh)) - 
  //    2*M2*th*uh*
  //    (3*pow<4,1>(th) + 10*pow<3,1>(th)*uh + 
  //     15*sqr(th)*sqr(uh) + 
  //     10*th*pow<3,1>(uh) + 3*pow<4,1>(uh)))
  //   /pow<3,1>((uh-M2)*(th-M2)*(sh-M2));
  // double aver = me.average();
  // cerr << "testing spin correlations " << test << " " << me.average() << " "
  //      << abs(test-aver)/(test+aver) << "\n";
  // construct the vertex
  HardVertexPtr hardvertex = new_ptr(HardVertex());
  // // set the matrix element for the vertex
  hardvertex->ME(me);
  // set the pointers and to and from the vertex
  for(unsigned int i = 0; i < hard.size(); ++i)
    hard[i]->spinInfo()->productionVertex(hardvertex);
  // boost back to lab
  boost = LorentzRotation(pcms.boostVector());
  for(PPtr part : hard)
    part->transform(boost);
}
