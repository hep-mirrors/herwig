// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEPPto1S0Jet class.
//

#include "MEPPto1S0Jet.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Utilities/EnumIO.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorBarWaveFunction.h"
#include "ThePEG/Helicity/epsilon.h"
#include "ThePEG/StandardModel/StandardModelBase.h"

using namespace Herwig;

void MEPPto1S0Jet::doinit() {
  HwMEBase::doinit();
  // get the non-perturbative ME
  O1_ = params_->singletMEProduction<0>(state_,n_,0,0);
  // set the mass option
  massOption(vector<unsigned int>({mOpt_+1,0}));
}

IBPtr MEPPto1S0Jet::clone() const {
  return new_ptr(*this);
}

IBPtr MEPPto1S0Jet::fullclone() const {
  return new_ptr(*this);
}

void MEPPto1S0Jet::persistentOutput(PersistentOStream & os) const {
  os << params_ << ounit(O1_,GeV*GeV2) << oenum(state_) << n_ << process_ << mOpt_;
}

void MEPPto1S0Jet::persistentInput(PersistentIStream & is, int) {
  is >> params_ >> iunit(O1_,GeV*GeV2) >> ienum(state_) >> n_ >> process_ >> mOpt_;
}

// The following static variable is needed for the type
// description system in ThePEG.
DescribeClass<MEPPto1S0Jet,HwMEBase>
describeHerwigMEPPto1S0Jet("Herwig::MEPPto1S0Jet",
			   "HwOniumParameters.so HwMEHadronOnium.so");

void MEPPto1S0Jet::Init() {

  static ClassDocumentation<MEPPto1S0Jet> documentation
    ("The MEPPto1S0Jet class implements to q qbar -> 1S0 g, g q to 1S0 q"
     " and g g to 1S0 g processes");

  static Reference<MEPPto1S0Jet,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEPPto1S0Jet::params_, false, false, true, false, false);
  
  static Switch<MEPPto1S0Jet,OniumState> interfaceState
    ("State",
     "The type of onium state",
     &MEPPto1S0Jet::state_, ccbar, false, false);
  static SwitchOption interfaceStateccbar
    (interfaceState,
     "ccbar",
     "Charmonium state",
     ccbar);
  static SwitchOption interfaceStatebbbar
    (interfaceState,
     "bbbar",
     "Bottomonium state",
     bbbar);
  
  static Parameter<MEPPto1S0Jet,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEPPto1S0Jet::n_, 1, 1, 10,
     false, false, Interface::limited);

  static Switch<MEPPto1S0Jet,unsigned int> interfaceProcess
    ("Process",
     "Which processes to generate",
     &MEPPto1S0Jet::process_, 0, false, false);
  static SwitchOption interfaceProcessAll
    (interfaceProcess,
     "All",
     "Generate all the processes",
     0);
  static SwitchOption interfaceProcessGQto1S0Q
    (interfaceProcess,
     "GQto1S0Q",
     "The g q -> 1S0 q process",
     1);
  static SwitchOption interfaceProcessGQbarto1S0Qbar
    (interfaceProcess,
     "GQbarto1S0Qbar",
     "The g qbar -> 1S0 qbar process",
     2);
  static SwitchOption interfaceProcessQQbarto1S0G
    (interfaceProcess,
     "QQbarto1S0G",
     "The q qbar -> 1S0 g process",
     3);
  static SwitchOption interfaceProcessGGto1S0G
    (interfaceProcess,
     "GGto1S0G",
     "The g g -> 1S0 g process",
     3);

  static Switch<MEPPto1S0Jet,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 1S0 mass",
     &MEPPto1S0Jet::mOpt_, 0, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 1S0 state.",
     1);

}

void MEPPto1S0Jet::getDiagrams() const {
  // construct the meson PDG code from quark ids
  unsigned int iq = 4+state_;
  tcPDPtr ps = getParticleData(long(iq*110+1 + (n_-1)*100000));
  tcPDPtr g = getParticleData(ParticleID::g);
  for ( int i = 1; i <= 3; ++i ) {
    tcPDPtr q = getParticleData(i);
    tcPDPtr qb = q->CC();
    if(process_==0 || process_==1)
      add(new_ptr((Tree2toNDiagram(3), g, g, q, 1, ps, 2, q, -1)));
  }
}

Selector<MEBase::DiagramIndex>
MEPPto1S0Jet::diagrams(const DiagramVector & diags) const {
  Selector<DiagramIndex> sel;
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 ) sel.insert(1.0, i);
  return sel;
}

Selector<const ColourLines *>
MEPPto1S0Jet::colourGeometries(tcDiagPtr diag) const {
  static ColourLines cq("1 2 5, -1 -2 3");
  Selector<const ColourLines *> sel;
  if (diag->id() == -1) sel.insert(1.0, &cq);
  return sel;
}

Energy2 MEPPto1S0Jet::scale() const {
  return sHat();
}

double MEPPto1S0Jet::me2() const {
  for(unsigned int ix=0;ix<mePartonData().size();++ix) {
    cerr << mePartonData()[ix]->PDGName() << " "
	 << meMomenta()[ix]/GeV << " " << meMomenta()[ix].mass()/GeV << "\n";
  }
  VectorWaveFunction      g1w(meMomenta()[0],mePartonData()[0],incoming);
  SpinorWaveFunction      q2w(meMomenta()[1],mePartonData()[1],incoming);
  SpinorBarWaveFunction   q4w(meMomenta()[3],mePartonData()[3],outgoing);
  vector<VectorWaveFunction> g1;
  vector<SpinorWaveFunction> q2;
  vector<SpinorBarWaveFunction> q4;
  for(unsigned int ix=0;ix<2;++ix) {
    g1w.reset(2*ix);
    g1.push_back(g1w);
    q2w.reset(ix);
    q2.push_back(q2w);
    q4w.reset(ix);
    q4.push_back(q4w);
  }
  Energy M = meMomenta()[2].mass();
  double total(0.);
  for(unsigned int ih2=0;ih2<2;++ih2) {
    for(unsigned int ih4=0;ih4<2;++ih4) {
      LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      auto eps = Helicity::epsilon(fCurrent,meMomenta()[2],meMomenta()[0]);
      for(unsigned int ih1=0;ih1<2;++ih1) {
	Complex amp = eps*g1[ih1].wave()/tHat()/M;
	total+= norm(amp);
      }
    }
  }
  double output = 64.*M*O1_*pow(Constants::pi*standardModel()->alphaS(scale()),3)/(27.*sqr(tHat()-sqr(M)))*total;

  // analytic test
  Energy3 R02 = params_->radialWaveFunctionSquared(state_,n_);
  double test = -32.*sqr(Constants::pi)*pow(standardModel()->alphaS(scale()),3)*R02*(sqr(sHat())+sqr(uHat()))/(9.*M*tHat()*sqr(tHat()-sqr(M)));
  cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
  return output;
}



