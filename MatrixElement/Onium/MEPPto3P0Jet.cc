// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEPPto3P0Jet class.
//

#include "MEPPto3P0Jet.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Utilities/EnumIO.h"
#include "ThePEG/Helicity/WaveFunction/ScalarWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorBarWaveFunction.h"
#include "ThePEG/StandardModel/StandardModelBase.h"
#include "Herwig/MatrixElement/ProductionMatrixElement.h"
#include "Herwig/MatrixElement/HardVertex.h"

using namespace Herwig;

void MEPPto3P0Jet::doinit() {
  HwMEBase::doinit();
  // get the non-perturbative ME
  O1_ = params_->singletMEProduction<1>(state_,n_,1,0);
  // set the mass option
  massOption(vector<unsigned int>({mOpt_+1,0}));
}

IBPtr MEPPto3P0Jet::clone() const {
  return new_ptr(*this);
}

IBPtr MEPPto3P0Jet::fullclone() const {
  return new_ptr(*this);
}

void MEPPto3P0Jet::persistentOutput(PersistentOStream & os) const {
  os << params_ << ounit(O1_,GeV*GeV2*GeV2) << oenum(state_) << n_ << process_ << mOpt_;
}

void MEPPto3P0Jet::persistentInput(PersistentIStream & is, int) {
  is >> params_ >> iunit(O1_,GeV*GeV2*GeV2) >> ienum(state_) >> n_ >> process_ >> mOpt_;
}

// The following static variable is needed for the type
// description system in ThePEG.
DescribeClass<MEPPto3P0Jet,HwMEBase>
describeHerwigMEPPto3P0Jet("Herwig::MEPPto3P0Jet",
			   "HwOniumParameters.so HwMEHadronOnium.so");

void MEPPto3P0Jet::Init() {

  static ClassDocumentation<MEPPto3P0Jet> documentation
    ("The MEPPto3P0Jet class implements the q qbar -> 3P0 g, g q to 3P0 q"
     " and g g to 3P0 g processes");

  static Reference<MEPPto3P0Jet,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEPPto3P0Jet::params_, false, false, true, false, false);
  
  static Switch<MEPPto3P0Jet,OniumState> interfaceState
    ("State",
     "The type of onium state",
     &MEPPto3P0Jet::state_, ccbar, false, false);
  static SwitchOption interfaceStateccbar
    (interfaceState,
     "ccbar",
     "Charmonium state",
     ccbar);
  static SwitchOption interfaceStatebbbar
    (interfaceState,
     "bbbar",
     "Bottomonium state",
     bbbar);
  
  static Parameter<MEPPto3P0Jet,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEPPto3P0Jet::n_, 1, 1, 10,
     false, false, Interface::limited);

  static Switch<MEPPto3P0Jet,unsigned int> interfaceProcess
    ("Process",
     "Which processes to generate",
     &MEPPto3P0Jet::process_, 0, false, false);
  static SwitchOption interfaceProcessAll
    (interfaceProcess,
     "All",
     "Generate all the processes",
     0);
  static SwitchOption interfaceProcessGQto3P0Q
    (interfaceProcess,
     "GQto3P0Q",
     "The g q -> 3P0 q process",
     1);
  static SwitchOption interfaceProcessGQbarto3P0Qbar
    (interfaceProcess,
     "GQbarto3P0Qbar",
     "The g qbar -> 3P0 qbar process",
     2);
  static SwitchOption interfaceProcessQQbarto3P0G
    (interfaceProcess,
     "QQbarto3P0G",
     "The q qbar -> 3P0 g process",
     3);
  static SwitchOption interfaceProcessGGto3P0G
    (interfaceProcess,
     "GGto3P0G",
     "The g g -> 3P0 g process",
     4);

  static Switch<MEPPto3P0Jet,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 3P0 mass",
     &MEPPto3P0Jet::mOpt_, 0, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 3P0 state.",
     1);

}

void MEPPto3P0Jet::getDiagrams() const {
  // construct the meson PDG code from quark ids
  unsigned int iq = 4+state_;
  tcPDPtr ps = getParticleData(long(iq*110 + 10001 + (n_-1)*100000));
  tcPDPtr g = getParticleData(ParticleID::g);
  // processes involving quarks
  for ( int i = 1; i <= 3; ++i ) {
    tcPDPtr q = getParticleData(i);
    tcPDPtr qb = q->CC();
    if(process_ == 0 || process_ == 1)
      add(new_ptr((Tree2toNDiagram(3), g, g, q , 1, ps, 2, q , -1)));
    if(process_ == 0 || process_ == 2)
      add(new_ptr((Tree2toNDiagram(3), g, g, qb, 1, ps, 2, qb, -2)));
    if(process_ == 0 || process_ == 3)
      add(new_ptr((Tree2toNDiagram(2), q, qb, 1, g, 3, ps, 3, g, -3)));
  }
  // g g -> 3P0 g (s,t,u 4-point)
  if(process_ == 0 || process_ == 4) {
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, g, 3, ps, 3, g , -4)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 1, ps, 2, g , -5)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 2, ps, 1, g , -6)));
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, ps, 1, g , -7)));
  }
}

Selector<MEBase::DiagramIndex>
MEPPto3P0Jet::diagrams(const DiagramVector & diags) const {
  Selector<DiagramIndex> sel;
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 ||
  	 diags[i]->id() == -2 ||
  	 diags[i]->id() == -3 ) sel.insert(1.0, i);
    else
      sel.insert(meInfo()[abs(diags[i]->id())-4],i);
  return sel;
}

Selector<const ColourLines *>
MEPPto3P0Jet::colourGeometries(tcDiagPtr diag) const {
  // g q -> 3P0 q
  static ColourLines cgq   ("1 2  5, -1 -2  3");
  // g qbar -> 3P0 qbar
  static ColourLines cgqbar("1 2 -3, -1 -2 -5");
  // q qbar -> 3P0 g
  static ColourLines cqqbar("1 3  5, -2 -3 -5");
  // g g -> 3P0 g
  static ColourLines cs[2]={ColourLines("1 3 5, -1 2, -2 -3 -5"),
  			    ColourLines("1 -2, -1 -3 -5, 2 3 5")};
  static ColourLines ct[2]={ColourLines("1 2 5, -1 -2 3, -3 -5"),
  			    ColourLines("1 2 -3, -1 -2 -5, 3 5")};
  static ColourLines cu[2]={ColourLines("1 5, -1 -2 3, -3 2 -5"),
  			    ColourLines("1 2 -3, -1 -5, 3 -2 5")};
  // 4 point
  static ColourLines c4[2]={ColourLines("1 -2,  2  4, -1 -4"),
  			    ColourLines("1  4, -4 -2,  2 -1")};
  // create the selector
  Selector<const ColourLines *> sel;
  if      (diag->id() == -1) sel.insert(1.0, &cgq   );
  else if (diag->id() == -2) sel.insert(1.0, &cgqbar);
  else if (diag->id() == -3) sel.insert(1.0, &cqqbar);
  else if (diag->id() == -4) {
    sel.insert(0.5, &cs[0]);
    sel.insert(0.5, &cs[1]);
  }
  else if (diag->id() == -5) {
    sel.insert(0.5, &ct[0]);
    sel.insert(0.5, &ct[1]);
  }
  else if (diag->id() == -6) {
    sel.insert(0.5, &cu[0]);
    sel.insert(0.5, &cu[1]);
  }
  else if (diag->id() == -7) {
    sel.insert(0.5, &c4[0]);
    sel.insert(0.5, &c4[1]);
  }
  return sel;
}

Energy2 MEPPto3P0Jet::scale() const {
  return sHat();
}

double MEPPto3P0Jet::me2() const {
  // return value
  double output(0.);
  // mass of the 3P0 state
  Energy  M  = meMomenta()[2].mass();
  Energy2 M2 = sqr(meMomenta()[2].mass());
  if(mePartonData()[0]->id()==ParticleID::g) {
    // g qbar -> 3P0 qbar
    if(mePartonData()[1]->id()==ParticleID::g) {
      // weights for the different diagrams
      DVector save(4,0.);
      save[0] = (8*sqr(sHat()-3*M2)*tHat()*uHat())/pow<4,1>(tHat() + uHat());
      save[1] = (4*tHat()*sqr(uHat()-3*M2)*
		 (pow<4,1>(M2) + pow<4,1>(sHat()) +pow<4,1>(tHat()) - 
		  2*(pow<3,1>(M2) + pow<3,1>(sHat()) - pow<3,1>(tHat()))*uHat() + 
		  (sqr(M2) + sqr(sHat()) + sqr(tHat()))*sqr(uHat())))/
	(pow<4,1>(M2 - uHat())*uHat()*sqr(tHat() + uHat()));
      save[2] = (4*sqr(-3*M2 + tHat())*uHat()*
		 (pow<4,1>(M2) + pow<4,1>(sHat()) - 2*pow<3,1>(M2)*tHat() - 
		  2*pow<3,1>(sHat())*tHat() + sqr(M2)*sqr(tHat()) + 
		  sqr(sHat())*sqr(tHat()) + sqr(uHat())*sqr(tHat() + uHat())))/
	(pow<4,1>(M2 - tHat())*tHat()*sqr(tHat() + uHat()));
      save[3]=tHat()*uHat()*(16*pow<10,1>(M2)-32*pow<9,1>(M2)*(tHat()+uHat())
			     +2*sHat()*sqr(tHat())*sqr(tHat()-uHat())*sqr(uHat())*pow<3,1>(tHat()+uHat())
			     +sqr(tHat())*sqr(uHat())*pow<4,1>(tHat()+uHat())*(sqr(tHat())+sqr(uHat()))
			     +2*pow<3,1>(sHat())*(tHat()+uHat())*(sqr(tHat())+sqr(uHat()))*
			     (sqr(tHat())-tHat()*uHat()+sqr(uHat()))*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
			     +4*pow<8,1>(M2)*(4*sqr(sHat())+5*sqr(tHat())+28*tHat()*uHat()+5*sqr(uHat()))
			     +pow<4,1>(sHat())*sqr(pow<3,1>(tHat())+pow<3,1>(uHat()))
			     +sqr(sHat())*(pow<8,1>(tHat())+2*pow<7,1>(tHat())*uHat()
					   +6*pow<6,1>(tHat())*sqr(uHat())+4*pow<5,1>(tHat())*pow<3,1>(uHat())
					   +14*pow<4,1>(tHat())*pow<4,1>(uHat())+4*pow<3,1>(tHat())*pow<5,1>(uHat())
					   +6*sqr(tHat())*pow<6,1>(uHat())+2*tHat()*pow<7,1>(uHat())+pow<8,1>(uHat()))
			     -4*pow<7,1>(M2)*(16*pow<3,1>(sHat())+26*sqr(sHat())*(tHat()+uHat())
					      +4*sHat()*(2*sqr(tHat())+tHat()*uHat()+2*sqr(uHat()))
					      +(tHat()+uHat())*(7*sqr(tHat())+22*tHat()*uHat()+7*sqr(uHat())))
			     +pow<6,1>(M2)*(64*pow<4,1>(sHat())+280*pow<3,1>(sHat())*(tHat()+uHat())
					    +2*sHat()*(tHat()+uHat())*(87*sqr(tHat())-40*tHat()*uHat()+87*sqr(uHat()))
					    +sqr(sHat())*(397*sqr(tHat())+482*tHat()*uHat()+397*sqr(uHat()))
					    +10*(9*pow<4,1>(tHat())+3*pow<3,1>(tHat())*uHat()
						 +28*sqr(tHat())*sqr(uHat())+3*tHat()*pow<3,1>(uHat())+9*pow<4,1>(uHat())))
			     -2*pow<5,1>(M2)*(72*pow<4,1>(sHat())*(tHat()+uHat())+3*sqr(sHat())*(tHat()+uHat())*(137*sqr(tHat())+62*tHat()*uHat()+137*sqr(uHat()))+pow<3,1>(sHat())*(317*sqr(tHat())+378*tHat()*uHat()+317*sqr(uHat()))+2*(tHat()+uHat())*(40*pow<4,1>(tHat())-21*pow<3,1>(tHat())*uHat()+66*sqr(tHat())*sqr(uHat())-21*tHat()*pow<3,1>(uHat())+40*pow<4,1>(uHat()))+sHat()*(213*pow<4,1>(tHat())+130*pow<3,1>(tHat())*uHat()+178*sqr(tHat())*sqr(uHat())+130*tHat()*pow<3,1>(uHat())+213*pow<4,1>(uHat())))
			     +pow<4,1>(M2)*(3*pow<4,1>(sHat())*(59*sqr(tHat())+54*tHat()*uHat()+59*sqr(uHat()))+4*pow<3,1>(sHat())*(tHat()+uHat())*(180*sqr(tHat())+91*tHat()*uHat()+180*sqr(uHat()))+2*sHat()*(tHat()+uHat())*(268*pow<4,1>(tHat())-47*pow<3,1>(tHat())*uHat()+282*sqr(tHat())*sqr(uHat())-47*tHat()*pow<3,1>(uHat())+268*pow<4,1>(uHat()))+sqr(sHat())*(981*pow<4,1>(tHat())+1496*pow<3,1>(tHat())*uHat()+2054*sqr(tHat())*sqr(uHat())+1496*tHat()*pow<3,1>(uHat())+981*pow<4,1>(uHat()))+2*(80*pow<6,1>(tHat())+111*pow<5,1>(tHat())*uHat()+30*pow<4,1>(tHat())*sqr(uHat())+138*pow<3,1>(tHat())*pow<3,1>(uHat())+30*sqr(tHat())*pow<4,1>(uHat())+111*tHat()*pow<5,1>(uHat())+80*pow<6,1>(uHat())))
			     +2*pow<3,1>(M2)*(-2*pow<4,1>(sHat())*(tHat()+uHat())*(31*sqr(tHat())-4*tHat()*uHat()+31*sqr(uHat()))-2*sqr(sHat())*(tHat()+uHat())*(157*pow<4,1>(tHat())+102*pow<3,1>(tHat())*uHat()+306*sqr(tHat())*sqr(uHat())+102*tHat()*pow<3,1>(uHat())+157*pow<4,1>(uHat()))-pow<3,1>(sHat())*(243*pow<4,1>(tHat())+336*pow<3,1>(tHat())*uHat()+514*sqr(tHat())*sqr(uHat())+336*tHat()*pow<3,1>(uHat())+243*pow<4,1>(uHat()))-3*(tHat()+uHat())*(14*pow<6,1>(tHat())+21*pow<5,1>(tHat())*uHat()+8*pow<4,1>(tHat())*sqr(uHat())+18*pow<3,1>(tHat())*pow<3,1>(uHat())+8*sqr(tHat())*pow<4,1>(uHat())+21*tHat()*pow<5,1>(uHat())+14*pow<6,1>(uHat()))-sHat()*(168*pow<6,1>(tHat())+209*pow<5,1>(tHat())*uHat()+150*pow<4,1>(tHat())*sqr(uHat())+186*pow<3,1>(tHat())*pow<3,1>(uHat())+150*sqr(tHat())*pow<4,1>(uHat())+209*tHat()*pow<5,1>(uHat())+168*pow<6,1>(uHat())))
			     +sqr(M2)*(18*pow<8,1>(tHat())+76*pow<7,1>(tHat())*uHat()+157*pow<6,1>(tHat())*sqr(uHat())+90*pow<5,1>(tHat())*pow<3,1>(uHat())+126*pow<4,1>(tHat())*pow<4,1>(uHat())+90*pow<3,1>(tHat())*pow<5,1>(uHat())+157*sqr(tHat())*pow<6,1>(uHat())+76*tHat()*pow<7,1>(uHat())+18*pow<8,1>(uHat())+18*pow<4,1>(sHat())*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))*(3*sqr(tHat())-2*tHat()*uHat()+3*sqr(uHat()))+2*pow<3,1>(sHat())*(tHat()+uHat())*(91*pow<4,1>(tHat())+23*pow<3,1>(tHat())*uHat()+164*sqr(tHat())*sqr(uHat())+23*tHat()*pow<3,1>(uHat())+91*pow<4,1>(uHat()))+2*sHat()*(tHat()+uHat())*(45*pow<6,1>(tHat())+43*pow<5,1>(tHat())*uHat()+17*pow<4,1>(tHat())*sqr(uHat())+36*pow<3,1>(tHat())*pow<3,1>(uHat())+17*sqr(tHat())*pow<4,1>(uHat())+43*tHat()*pow<5,1>(uHat())+45*pow<6,1>(uHat()))+sqr(sHat())*(201*pow<6,1>(tHat())+350*pow<5,1>(tHat())*uHat()+620*pow<4,1>(tHat())*sqr(uHat())+742*pow<3,1>(tHat())*pow<3,1>(uHat())+620*sqr(tHat())*pow<4,1>(uHat())+350*tHat()*pow<5,1>(uHat())+201*pow<6,1>(uHat())))
			     +2*M2*(-(tHat()*uHat()*pow<3,1>(tHat()+uHat())*(3*tHat()+uHat())*(tHat()+3*uHat())*(sqr(tHat())-tHat()*uHat()+sqr(uHat())))-6*pow<4,1>(sHat())*(pow<5,1>(tHat())+pow<3,1>(tHat())*sqr(uHat())+sqr(tHat())*pow<3,1>(uHat())+pow<5,1>(uHat()))-sqr(sHat())*(tHat()+uHat())*(13*pow<6,1>(tHat())+13*pow<5,1>(tHat())*uHat()+30*pow<4,1>(tHat())*sqr(uHat())+36*pow<3,1>(tHat())*pow<3,1>(uHat())+30*sqr(tHat())*pow<4,1>(uHat())+13*tHat()*pow<5,1>(uHat())+13*pow<6,1>(uHat()))-pow<3,1>(sHat())*(16*pow<6,1>(tHat())+19*pow<5,1>(tHat())*uHat()+31*pow<4,1>(tHat())*sqr(uHat())+32*pow<3,1>(tHat())*pow<3,1>(uHat())+31*sqr(tHat())*pow<4,1>(uHat())+19*tHat()*pow<5,1>(uHat())+16*pow<6,1>(uHat()))-sHat()*(3*pow<8,1>(tHat())+9*pow<7,1>(tHat())*uHat()+19*pow<6,1>(tHat())*sqr(uHat())-5*pow<5,1>(tHat())*pow<3,1>(uHat())+12*pow<4,1>(tHat())*pow<4,1>(uHat())-5*pow<3,1>(tHat())*pow<5,1>(uHat())+19*sqr(tHat())*pow<6,1>(uHat())+9*tHat()*pow<7,1>(uHat())+3*pow<8,1>(uHat()))))/(pow<4,1>(M2-tHat())*pow<4,1>(M2-uHat())*pow<4,1>(tHat()+uHat()));
      meInfo(save);
      // matrix element
      output = 64./9.*O1_*pow<3,1>(Constants::pi*standardModel()->alphaS(scale())/M)/sHat()*
	(9*pow<4,1>(M2)*sqr(M2-tHat())*sqr(M2-uHat())*sqr(tHat()+uHat())*
	 sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat())-M2*(tHat()+uHat()))
	 +pow<4,1>(sHat())*sqr(tHat()+uHat())*sqr(uHat()*(sHat()+uHat())*(sqr(sHat())+sHat()*uHat()+sqr(uHat()))
						  +sqr(M2)*(3*sqr(sHat())+6*sHat()*uHat()+sqr(uHat()))
						  -M2*(3*sHat()+uHat())*(sqr(sHat())+2*sHat()*uHat()+2*sqr(uHat())))
	 +sqr(M2-tHat())*pow<4,1>(tHat())*sqr(uHat()*(tHat()+uHat())*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
					      +sqr(M2)*(3*sqr(tHat())+6*tHat()*uHat()+sqr(uHat()))
					      -M2*(3*tHat()+uHat())*(sqr(tHat())+2*tHat()*uHat()+2*sqr(uHat())))
	 +sqr(M2-uHat())*pow<4,1>(uHat())*sqr(tHat()*(tHat()+uHat())*(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
					      -M2*(tHat()+3*uHat())*(2*sqr(tHat())+2*tHat()*uHat()+sqr(uHat()))
					      +sqr(M2)*(sqr(tHat())+6*tHat()*uHat()+3*sqr(uHat()))))
	/(pow<4,1>(M2-tHat())*tHat()*pow<4,1>(M2-uHat())*uHat()*pow<4,1>(tHat()+uHat()));
      // test vs NPB 291 731
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // Energy6 Q(sHat()*tHat()*uHat());
      // Energy4 P(sHat()*tHat()+tHat()*uHat()+uHat()*sHat());
      // double test = 16.*Constants::pi*sqr(sHat())*
      // 	4.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/M/M2/sqr(sHat())/Q/pow<4,1>(Q-M2*P)*
      // 	(9.*sqr(M2*sqr(P))*(pow<4,1>(M2)-2.*sqr(M2)*P+sqr(P)) -6*M2*pow<3,1>(P)*Q*(2.*pow<4,1>(M2)-5.*sqr(M2)*P+sqr(P))
      // 	 -sqr(P*Q)*(pow<4,1>(M2)+2.*sqr(M2)*P-sqr(P))+2.*M2*P*pow<3,1>(Q)*(sqr(M2)-P)+6.*pow<4,1>(M*Q));
      // cerr << "testing matrix element " << output << " " << test << " "
      // 	   << (output-test)/(output+test) << " " << output/test << "\n";
    }
    else if(mePartonData()[1]->id()<0) {
      // spin sum version
      double total = -4.*tHat()*(sqr(sHat())+sqr(uHat()))/pow<6,1>(M);
      // final factors
      output = 64.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))*sqr(tHat()-3.*sqr(M))/(81.*sqr(tHat())*pow<4,1>(tHat()-M2))*total;
      // analytic test
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -16.*Constants::pi*sqr(sHat())*
      // 	8.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02*(sqr(sHat())+sqr(uHat()))
      // 	/9./M/M2/sqr(sHat())/tHat()/pow<4,1>(tHat()-M2)*sqr(tHat()-3.*sqr(M));
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    // g q -> 3P0 q
    else if(mePartonData()[1]->id()<6) {
      // spin sum version
      double total = -4.*tHat()*(sqr(sHat())+sqr(uHat()))/pow<6,1>(M);
      // final factors
      output = 64.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))*sqr(tHat()-3.*sqr(M))/(81.*sqr(tHat())*pow<4,1>(tHat()-M2))*total;
      // analytic test
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -16.*Constants::pi*sqr(sHat())*
      // 	8.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02*(sqr(sHat())+sqr(uHat()))
      // 	/9./M/M2/sqr(sHat())/tHat()/pow<4,1>(tHat()-M2)*sqr(tHat()-3.*sqr(M));
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    else assert(false);
  }
  // q qbar -> 3P0 g
  else if(mePartonData()[0]->id()==-mePartonData()[1]->id()) {
    // spin sum version
    double total = 4.*sHat()*(sqr(tHat())+sqr(uHat()))/pow<3,1>(M2);
    // final factors
    output = 512.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))*sqr(sHat()-3.*M2)/(243.*sqr(sHat())*pow<4,1>(sHat()-M2))*total;
    // analytic test
    // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
    // double test = 16.*Constants::pi*8./3.*8.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02*(sqr(tHat())+sqr(uHat()))
    //   	/9./M/M2/sHat()/pow<4,1>(sHat()-M2)*sqr(sHat()-3.*sqr(M));
    //   cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
  }
  else
    assert(false);
  return output;
}

void MEPPto3P0Jet::constructVertex(tSubProPtr sub) {
  // extract the particles in the hard process
  ParticleVector hard;
  hard.reserve(4);
  hard.push_back(sub->incoming().first);
  hard.push_back(sub->incoming().second);
  hard.push_back(sub->outgoing()[0]);
  hard.push_back(sub->outgoing()[1]);
  // get them in the right order
  bool swapped(false);
  if(hard[0]->id()==-hard[1]->id()) {
    if(hard[0]->id()<0) swapped = true;
  }
  else if(hard[0]->id()!=ParticleID::g) {
    swapped=true;
  }
  if(swapped) {
    swap(hard[0],hard[1]);
    swap(hard[2],hard[3]);
  }
  // boost to partonic CMS
  Lorentz5Momentum pcms = hard[0]->momentum()+hard[1]->momentum();
  LorentzRotation boost(-pcms.boostVector());
  for(PPtr part : hard) part->transform(boost);
  // extract kinematic variables
  Energy  M  = hard[2]->mass();
  Energy2 M2 = sqr(M);
  double phi = hard[2]->momentum().phi();
  Energy2 sh = (hard[0]->momentum()+hard[1]->momentum()).m2();
  Energy2 th = (hard[0]->momentum()-hard[2]->momentum()).m2();
  Energy2 uh = (hard[0]->momentum()-hard[3]->momentum()).m2();
  // set basis states and compute the matrix element
  ProductionMatrixElement me;
  ScalarWaveFunction(      hard[2],outgoing,true);
  if(hard[0]->id()==ParticleID::g) {
    // g g -> 3P0 g
    if(hard[1]->id()==ParticleID::g) {
      vector<VectorWaveFunction> g1,g2,g4;
      VectorWaveFunction( g1,hard[0],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g2,hard[1],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g4,hard[3],outgoing,true , true,true,vector_phase);
      ProductionMatrixElement me(PDT::Spin1,PDT::Spin1,PDT::Spin0,PDT::Spin1);
      Complex phase = exp(Complex(0.,phi));
      Energy2 um(uh-M2),tm(th-M2),sm(sh-M2);
      me(0,0,0,0)=(sqrt(2)*phase*sqr(sh)*(uh*(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))+sqr(M2)*(3*sqr(sh)+6*sh*uh+sqr(uh))-M2*(3*sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh))))/(sm*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(0,0,0,2)=(3*sqrt(2)*sqr(M2)*(M2*sm+sqr(th)+th*uh+sqr(uh)))/(phase*sm*tm*sqrt(th*uh)*um);
      me(0,2,0,0)=-((sqrt(2)*sqr(th)*(-(sm*uh*(sqr(th)+th*uh+sqr(uh)))+sqr(M2)*(3*sqr(th)+6*th*uh+sqr(uh))-M2*(3*th+uh)*(sqr(th)+2*th*uh+2*sqr(uh))))/(phase*sqr(sm)*(-M2+th)*sqrt(th*uh)*sqr(um)));
      me(0,2,0,2)=(sqrt(2)*sqr(uh)*(-(sm*th*(sqr(th)+th*uh+sqr(uh)))-M2*(th+3*uh)*(2*sqr(th)+2*th*uh+sqr(uh))+sqr(M2)*(sqr(th)+6*th*uh+3*sqr(uh))))/(pow(phase,3)*sqr(sm)*sqr(tm)*sqrt(th*uh)*(-M2+uh));
      me(2,0,0,0)=-((sqrt(2)*pow(phase,3)*sqr(uh)*(-(sm*th*(sqr(th)+th*uh+sqr(uh)))-M2*(th+3*uh)*(2*sqr(th)+2*th*uh+sqr(uh))+sqr(M2)*(sqr(th)+6*th*uh+3*sqr(uh))))/(sqr(sm)*sqr(tm)*sqrt(th*uh)*(-M2+uh)));
      me(2,0,0,2)=(sqrt(2)*phase*sqr(th)*(-(sm*uh*(sqr(th)+th*uh+sqr(uh)))+sqr(M2)*(3*sqr(th)+6*th*uh+sqr(uh))-M2*(3*th+uh)*(sqr(th)+2*th*uh+2*sqr(uh))))/(sqr(sm)*(-M2+th)*sqrt(th*uh)*sqr(um));
      me(2,2,0,0)=(-3*sqrt(2)*sqr(M2)*phase*(M2*sm+sqr(th)+th*uh+sqr(uh)))/(sm*tm*sqrt(th*uh)*um);
      me(2,2,0,2)=-((sqrt(2)*sqr(sh)*(uh*(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))+sqr(M2)*(3*sqr(sh)+6*sh*uh+sqr(uh))-M2*(3*sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh))))/(phase*sm*sqr(tm)*sqrt(th*uh)*sqr(um)));
      // test the average result
      // double aver = me.average();
      // double test = 4.*(9*pow<4,1>(M2)*sqr(M2-th)*sqr(M2-uh)*sqr(th+uh)*
      // 			sqr(sqr(th)+th*uh+sqr(uh)-M2*(th+uh))
      // 			+pow<4,1>(sh)*sqr(th+uh)*sqr(uh*(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))
      // 						     +sqr(M2)*(3*sqr(sh)+6*sh*uh+sqr(uh))
      // 						     -M2*(3*sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh)))
      // 			+sqr(M2-th)*pow<4,1>(th)*sqr(uh*(th+uh)*(sqr(th)+th*uh+sqr(uh))
      // 						     +sqr(M2)*(3*sqr(th)+6*th*uh+sqr(uh))
      // 						     -M2*(3*th+uh)*(sqr(th)+2*th*uh+2*sqr(uh)))
      // 			+sqr(M2-uh)*pow<4,1>(uh)*sqr(th*(th+uh)*(sqr(th)+th*uh+sqr(uh))
      // 						     -M2*(th+3*uh)*(2*sqr(th)+2*th*uh+sqr(uh))
      // 						     +sqr(M2)*(sqr(th)+6*th*uh+3*sqr(uh))))
      // 	/(pow<4,1>(M2-th)*th*pow<4,1>(M2-uh)*uh*pow<4,1>(th+uh));
      // 	cerr << "testing spin correlations " << test << " " << me.average() << " "
      // 	     << abs(test-aver)/(test+aver) << "\n";
    }
    // g qbar -> 3P0 qbar
    else if(hard[1]->id()<0) {
      vector<VectorWaveFunction>    g1;
      vector<SpinorBarWaveFunction> q2;
      vector<SpinorWaveFunction>    q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
      SpinorWaveFunction(   q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin0,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0) =-sqrt(2.)*sh*sqrt(-th)/M2/M;
	me(0,1,0,1) = exp(Complex(0.,-2.*phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,0,0,0) =-exp(Complex(0., 2.*phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,1,0,1) = sqrt(2.)*sh*sqrt(-th)/M2/M;
      }
      else {
	me(0,0,0,0) = -exp(Complex(0., phi))*sqrt(2.)*sh*sqrt(-th)/M2/M;
	me(0,1,0,1) =  exp(Complex(0., phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,0,0,0) = -exp(Complex(0.,-phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,1,0,1) =  exp(Complex(0.,-phi))*sqrt(2.)*sh*sqrt(-th)/M2/M;
      }
    }
    // g q -> 3P0 q
    else if(hard[1]->id()<6) {
      vector<VectorWaveFunction> g1;
      vector<SpinorWaveFunction> q2;
      vector<SpinorBarWaveFunction> q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorWaveFunction(   q2,hard[1],incoming,false,true);
      SpinorBarWaveFunction(q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin0,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0) = sqrt(2.)*sh*sqrt(-th)/M2/M;
	me(0,1,0,1) =-exp(Complex(0.,-2.*phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,0,0,0) = exp(Complex(0., 2.*phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,1,0,1) =-sqrt(2.)*sh*sqrt(-th)/M2/M;
      }
      else {
	me(0,0,0,0) =  exp(Complex(0., phi))*sqrt(2.)*sh*sqrt(-th)/M2/M;
	me(0,1,0,1) = -exp(Complex(0., phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,0,0,0) =  exp(Complex(0.,-phi))*sqrt(2)*sqrt(-th)*uh/M2/M;
	me(2,1,0,1) = -exp(Complex(0.,-phi))*sqrt(2.)*sh*sqrt(-th)/M2/M;
      }
    }
    else
      assert(false);
  }
  else if(hard[0]->id()==-hard[1]->id()) {
    vector<SpinorWaveFunction>    q1;
    vector<SpinorBarWaveFunction> q2;
    vector<VectorWaveFunction>    g4;
    SpinorWaveFunction(   q1,hard[0],incoming,false,true);
    SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
    VectorWaveFunction(   g4,hard[3],outgoing,true,true,true,vector_phase);
    g4[1]=g4[2];
    // matrix element
    me = ProductionMatrixElement(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin0,PDT::Spin1);
    if(!swapped) {
      me(0,1,0,0) = -sqrt(2.*sh)*th/M2/M;
      me(0,1,0,2) = -exp(Complex(0.,-2.*phi))*sqrt(2.*sh)*uh/M2/M;
      me(1,0,0,0) =  exp(Complex(0., 2.*phi))*sqrt(2.*sh)*uh/M2/M;
      me(1,0,0,2) =  sqrt(2.*sh)*th/M2/M;
    }
    else {
      me(0,1,0,0) = -double(sqrt(2.*sh)*th/M2/M)*exp(Complex(0., 2.*phi));
      me(0,1,0,2) =  sqrt(2.*sh)*uh/M2/M;
      me(1,0,0,0) = -sqrt(2.*sh)*uh/M2/M;
      me(1,0,0,2) = -double(sqrt(2.*sh)*th/M2/M)*exp(Complex(0.,-2.*phi));
    }
  }
  else
    assert(false);
  // construct the vertex
  HardVertexPtr hardvertex = new_ptr(HardVertex());
  // // set the matrix element for the vertex
  hardvertex->ME(me);
  // set the pointers and to and from the vertex
  for(unsigned int i = 0; i < hard.size(); ++i)
    hard[i]->spinInfo()->productionVertex(hardvertex);
  // boost back to lab
  boost = LorentzRotation(pcms.boostVector());
  for(PPtr part : hard)
    part->transform(boost);
}
