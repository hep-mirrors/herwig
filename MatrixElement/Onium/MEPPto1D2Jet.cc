// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEPPto1D2Jet class.
//

#include "MEPPto1D2Jet.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Utilities/EnumIO.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/TensorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorBarWaveFunction.h"
#include "ThePEG/Helicity/epsilon.h"
#include "ThePEG/StandardModel/StandardModelBase.h"
#include "Herwig/MatrixElement/ProductionMatrixElement.h"
#include "Herwig/MatrixElement/HardVertex.h"

using namespace Herwig;

void MEPPto1D2Jet::doinit() {
  HwMEBase::doinit();
  // get the non-perturbative ME
  O1_ = params_->singletMEProduction<2>(state_,n_,0,2);
  // set the mass option
  massOption(vector<unsigned int>({mOpt_+1,0}));
}

IBPtr MEPPto1D2Jet::clone() const {
  return new_ptr(*this);
}

IBPtr MEPPto1D2Jet::fullclone() const {
  return new_ptr(*this);
}

void MEPPto1D2Jet::persistentOutput(PersistentOStream & os) const {
  os << params_ << ounit(O1_,GeV*GeV2*GeV2*GeV2) << oenum(state_) << n_ << process_ << mOpt_;
}

void MEPPto1D2Jet::persistentInput(PersistentIStream & is, int) {
  is >> params_ >> iunit(O1_,GeV*GeV2*GeV2*GeV2) >> ienum(state_) >> n_ >> process_ >> mOpt_;
}

// The following static variable is needed for the type
// description system in ThePEG.
DescribeClass<MEPPto1D2Jet,HwMEBase>
describeHerwigMEPPto1D2Jet("Herwig::MEPPto1D2Jet",
			   "HwOniumParameters.so HwMEHadronOnium.so");

void MEPPto1D2Jet::Init() {

  static ClassDocumentation<MEPPto1D2Jet> documentation
    ("The MEPPto1D2Jet class implements the q qbar -> 1D2 g, g q to 1D2 q"
     " and g g to 1D2 g processes");

  static Reference<MEPPto1D2Jet,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEPPto1D2Jet::params_, false, false, true, false, false);
  
  static Switch<MEPPto1D2Jet,OniumState> interfaceState
    ("State",
     "The type of onium state",
     &MEPPto1D2Jet::state_, ccbar, false, false);
  static SwitchOption interfaceStateccbar
    (interfaceState,
     "ccbar",
     "Charmonium state",
     ccbar);
  static SwitchOption interfaceStatebbbar
    (interfaceState,
     "bbbar",
     "Bottomonium state",
     bbbar);
  
  static Parameter<MEPPto1D2Jet,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEPPto1D2Jet::n_, 1, 1, 10,
     false, false, Interface::limited);

  static Switch<MEPPto1D2Jet,unsigned int> interfaceProcess
    ("Process",
     "Which processes to generate",
     &MEPPto1D2Jet::process_, 0, false, false);
  static SwitchOption interfaceProcessAll
    (interfaceProcess,
     "All",
     "Generate all the processes",
     0);
  static SwitchOption interfaceProcessGQto1D2Q
    (interfaceProcess,
     "GQto1D2Q",
     "The g q -> 1D2 q process",
     1);
  static SwitchOption interfaceProcessGQbarto1D2Qbar
    (interfaceProcess,
     "GQbarto1D2Qbar",
     "The g qbar -> 1D2 qbar process",
     2);
  static SwitchOption interfaceProcessQQbarto1D2G
    (interfaceProcess,
     "QQbarto1D2G",
     "The q qbar -> 1D2 g process",
     3);
  static SwitchOption interfaceProcessGGto1D2G
    (interfaceProcess,
     "GGto1D2G",
     "The g g -> 1D2 g process",
     4);

  static Switch<MEPPto1D2Jet,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 1D2 mass",
     &MEPPto1D2Jet::mOpt_, 0, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 1D2 state.",
     1);

}

void MEPPto1D2Jet::getDiagrams() const {
  // construct the meson PDG code from quark ids
  unsigned int iq = 4+state_;
  tcPDPtr ps = getParticleData(long(iq*110+10005 + (n_-1)*100000));
  tcPDPtr g = getParticleData(ParticleID::g);
  // processes involving quarks
  for ( int i = 1; i <= 3; ++i ) {
    tcPDPtr q = getParticleData(i);
    tcPDPtr qb = q->CC();
    if(process_ == 0 || process_ == 1)
      add(new_ptr((Tree2toNDiagram(3), g, g, q , 1, ps, 2, q , -1)));
    if(process_ == 0 || process_ == 2)
      add(new_ptr((Tree2toNDiagram(3), g, g, qb, 1, ps, 2, qb, -2)));
    if(process_ == 0 || process_ == 3)
      add(new_ptr((Tree2toNDiagram(2), q, qb, 1, g, 3, ps, 3, g, -3)));
  }
  // g g -> 1D2 g (s,t,u 4-point)
  if(process_ == 0 || process_ == 4) {
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, g, 3, ps, 3, g , -4)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 1, ps, 2, g    , -5)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 2, ps, 1, g    , -6)));
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, ps, 1, g       , -7)));
  }
}

Selector<MEBase::DiagramIndex>
MEPPto1D2Jet::diagrams(const DiagramVector & diags) const {
  Energy M=meMomenta()[3].mass();
  Energy2 M2(sqr(M));
  Selector<DiagramIndex> sel;
  DVector save(4);
  if(mePartonData()[1]->id()==ParticleID::g &&
     mePartonData()[1]->id()==ParticleID::g ) {
    save[0] = 256*M2*tHat()*uHat()/(3.*sHat()*sqr(tHat()+uHat()));
    save[1] = 256*M2*tHat()*(sqr(M2)*sqr(sHat())-2*M2*pow<3,1>(sHat())+2*pow<4,1>(sHat())
			     +sqr(M2)*sHat()*tHat()-M2*sqr(sHat())*tHat()+2*pow<3,1>(sHat())*tHat()
			     +sqr(M2)*sqr(tHat())-M2*sHat()*sqr(tHat())+sqr(sHat())*sqr(tHat()))
      /(3.*sHat()*sqr(M2-uHat())*uHat()*sqr(tHat()+uHat()));
    save[2] = 256*M2*uHat()*(sqr(M2)*sqr(sHat())-2*M2*pow<3,1>(sHat())+2*pow<4,1>(sHat())
			     +sqr(M2)*sHat()*uHat()-M2*sqr(sHat())*uHat()+2*pow<3,1>(sHat())*uHat()
			     +sqr(M2)*sqr(uHat())-M2*sHat()*sqr(uHat())+sqr(sHat())*sqr(uHat()))
      /(3.*sHat()*sqr(M2-tHat())*tHat()*sqr(tHat()+uHat()));
    save[3] = 128*M2*(3*pow<10,1>(M2)*sqr(tHat())-24*pow<9,1>(M2)*pow<3,1>(tHat())+81*pow<8,1>(M2)*pow<4,1>(tHat())
		      -153*pow<7,1>(M2)*pow<5,1>(tHat())+180*pow<6,1>(M2)*pow<6,1>(tHat())-135*pow<5,1>(M2)*pow<7,1>(tHat())
		      +60*pow<4,1>(M2)*pow<8,1>(tHat())-12*pow<3,1>(M2)*pow<9,1>(tHat())+8*pow<10,1>(M2)*tHat()*uHat()
		      -66*pow<9,1>(M2)*sqr(tHat())*uHat()+250*pow<8,1>(M2)*pow<3,1>(tHat())*uHat()
		      -540*pow<7,1>(M2)*pow<4,1>(tHat())*uHat()+731*pow<6,1>(M2)*pow<5,1>(tHat())*uHat()
		      -650*pow<5,1>(M2)*pow<6,1>(tHat())*uHat()+375*pow<4,1>(M2)*pow<7,1>(tHat())*uHat()
		      -126*pow<3,1>(M2)*pow<8,1>(tHat())*uHat()+18*sqr(M2)*pow<9,1>(tHat())*uHat()
		      +3*pow<10,1>(M2)*sqr(uHat())-66*pow<9,1>(M2)*tHat()*sqr(uHat())+358*pow<8,1>(M2)*sqr(tHat())*sqr(uHat())
		      -953*pow<7,1>(M2)*pow<3,1>(tHat())*sqr(uHat())+1439*pow<6,1>(M2)*pow<4,1>(tHat())*sqr(uHat())
		      -1312*pow<5,1>(M2)*pow<5,1>(tHat())*sqr(uHat())+760*pow<4,1>(M2)*pow<6,1>(tHat())*sqr(uHat())
		      -295*pow<3,1>(M2)*pow<7,1>(tHat())*sqr(uHat())+72*sqr(M2)*pow<8,1>(tHat())*sqr(uHat())
		      -6*M2*pow<9,1>(tHat())*sqr(uHat())-24*pow<9,1>(M2)*pow<3,1>(uHat())
		      +250*pow<8,1>(M2)*tHat()*pow<3,1>(uHat())-953*pow<7,1>(M2)*sqr(tHat())*pow<3,1>(uHat())
		      +1930*pow<6,1>(M2)*pow<3,1>(tHat())*pow<3,1>(uHat())-2209*pow<5,1>(M2)*pow<4,1>(tHat())*pow<3,1>(uHat())
		      +1479*pow<4,1>(M2)*pow<5,1>(tHat())*pow<3,1>(uHat())-626*pow<3,1>(M2)*pow<6,1>(tHat())*pow<3,1>(uHat())
		      +161*sqr(M2)*pow<7,1>(tHat())*pow<3,1>(uHat())-6*M2*pow<8,1>(tHat())*pow<3,1>(uHat())
		      +81*pow<8,1>(M2)*pow<4,1>(uHat())-540*pow<7,1>(M2)*tHat()*pow<4,1>(uHat())
		      +1439*pow<6,1>(M2)*sqr(tHat())*pow<4,1>(uHat())-2209*pow<5,1>(M2)*pow<3,1>(tHat())*pow<4,1>(uHat())
		      +1996*pow<4,1>(M2)*pow<4,1>(tHat())*pow<4,1>(uHat())-1115*pow<3,1>(M2)*pow<5,1>(tHat())*pow<4,1>(uHat())
		      +352*sqr(M2)*pow<6,1>(tHat())*pow<4,1>(uHat())-4*M2*pow<7,1>(tHat())*pow<4,1>(uHat())
		      -153*pow<7,1>(M2)*pow<5,1>(uHat())+731*pow<6,1>(M2)*tHat()*pow<5,1>(uHat())
		      -1312*pow<5,1>(M2)*sqr(tHat())*pow<5,1>(uHat())+1479*pow<4,1>(M2)*pow<3,1>(tHat())*pow<5,1>(uHat())
		      -1115*pow<3,1>(M2)*pow<4,1>(tHat())*pow<5,1>(uHat())+490*sqr(M2)*pow<5,1>(tHat())*pow<5,1>(uHat())
		      -24*M2*pow<6,1>(tHat())*pow<5,1>(uHat())+4*pow<7,1>(tHat())*pow<5,1>(uHat())
		      +180*pow<6,1>(M2)*pow<6,1>(uHat())-650*pow<5,1>(M2)*tHat()*pow<6,1>(uHat())
		      +760*pow<4,1>(M2)*sqr(tHat())*pow<6,1>(uHat())-626*pow<3,1>(M2)*pow<3,1>(tHat())*pow<6,1>(uHat())
		      +352*sqr(M2)*pow<4,1>(tHat())*pow<6,1>(uHat())-24*M2*pow<5,1>(tHat())*pow<6,1>(uHat())
		      +8*pow<6,1>(tHat())*pow<6,1>(uHat())-135*pow<5,1>(M2)*pow<7,1>(uHat())
		      +375*pow<4,1>(M2)*tHat()*pow<7,1>(uHat())-295*pow<3,1>(M2)*sqr(tHat())*pow<7,1>(uHat())
		      +161*sqr(M2)*pow<3,1>(tHat())*pow<7,1>(uHat())-4*M2*pow<4,1>(tHat())*pow<7,1>(uHat())
		      +4*pow<5,1>(tHat())*pow<7,1>(uHat())+60*pow<4,1>(M2)*pow<8,1>(uHat())
		      -126*pow<3,1>(M2)*tHat()*pow<8,1>(uHat())+72*sqr(M2)*sqr(tHat())*pow<8,1>(uHat())
		      -6*M2*pow<3,1>(tHat())*pow<8,1>(uHat())-12*pow<3,1>(M2)*pow<9,1>(uHat())
		      +18*sqr(M2)*tHat()*pow<9,1>(uHat())-6*M2*sqr(tHat())*pow<9,1>(uHat()))
      /(3.*sHat()*pow<4,1>(M2-tHat())*pow<4,1>(M2-uHat())*pow<4,1>(tHat()+uHat()));
  }
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 ||
	 diags[i]->id() == -2 ||
	 diags[i]->id() == -3 ) sel.insert(1.0, i);
    else
      sel.insert(save[abs(diags[i]->id())-4],i);
  return sel;
}

Selector<const ColourLines *>
MEPPto1D2Jet::colourGeometries(tcDiagPtr diag) const {
  // g q -> 1D2 q
  static ColourLines cgq   ("1 2  5, -1 -2  3");
  // g qbar -> 1D2 qbar
  static ColourLines cgqbar("1 2 -3, -1 -2 -5");
  // q qbar -> 1D2 g
  static ColourLines cqqbar("1 3  5, -2 -3 -5");
  // g g -> 1D2 g
  static ColourLines cs[2]={ColourLines("1 3 5, -1 2, -2 -3 -5"),
			    ColourLines("1 -2, -1 -3 -5, 2 3 5")};
  static ColourLines ct[2]={ColourLines("1 2 5, -1 -2 3, -3 -5"),
			    ColourLines("1 2 -3, -1 -2 -5, 3 5")};
  static ColourLines cu[2]={ColourLines("1 5, -1 -2 3, -3 2 -5"),
			    ColourLines("1 2 -3, -1 -5, 3 -2 5")};
  // 4 point
  static ColourLines c4[2]={ColourLines("1 -2,  2  4, -1 -4"),
			    ColourLines("1  4, -4 -2,  2 -1")};
  // create the selector
  Selector<const ColourLines *> sel;
  if      (diag->id() == -1) sel.insert(1.0, &cgq   );
  else if (diag->id() == -2) sel.insert(1.0, &cgqbar);
  else if (diag->id() == -3) sel.insert(1.0, &cqqbar);
  else if (diag->id() == -4) {
    sel.insert(0.5, &cs[0]);
    sel.insert(0.5, &cs[1]);
  }
  else if (diag->id() == -5) {
    sel.insert(0.5, &ct[0]);
    sel.insert(0.5, &ct[1]);
  }
  else if (diag->id() == -6) {
    sel.insert(0.5, &cu[0]);
    sel.insert(0.5, &cu[1]);
  }
  else if (diag->id() == -7) {
    sel.insert(0.5, &c4[0]);
    sel.insert(0.5, &c4[1]);
  }
  return sel;
}

Energy2 MEPPto1D2Jet::scale() const {
  return sHat();
}

double MEPPto1D2Jet::me2() const {
  // return value
  double output(0.);
  // mass of the 1D2 state
  Energy  M  = meMomenta()[2].mass();
  Energy2 M2 = sqr(meMomenta()[2].mass());
  if(mePartonData()[0]->id()==ParticleID::g) {
    // g g -> 1D2 g
    if(mePartonData()[1]->id()==ParticleID::g) {
      output = 4.*O1_*pow(Constants::pi*standardModel()->alphaS(scale()),3)
	/(15.*pow<7,1>(M))/(3.*sHat()*pow<4,1>(M2-tHat())*tHat()*pow<4,1>(M2-uHat())*uHat()*pow<4,1>(tHat()+uHat()))*128*M2*
	(2*sqr(tHat())*sqr(uHat())*sqr(tHat()+uHat())*pow<4,1>(sqr(tHat())+tHat()*uHat()+sqr(uHat()))
	 +pow<10,1>(M2)*(sqr(tHat())+sqr(uHat()))*(2*sqr(tHat())+3*tHat()*uHat()+2*sqr(uHat()))
	 -4*M2*tHat()*uHat()*pow<3,1>(tHat()+uHat())*sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat()))*
	 (pow<4,1>(tHat())+4*pow<3,1>(tHat())*uHat()-7*sqr(tHat())*sqr(uHat())
	  +4*tHat()*pow<3,1>(uHat())+pow<4,1>(uHat()))-6*pow<9,1>(M2)*(tHat()+uHat())*
	 (2*pow<4,1>(tHat())+2*pow<3,1>(tHat())*uHat()+7*sqr(tHat())*sqr(uHat())+2*tHat()*pow<3,1>(uHat())+2*pow<4,1>(uHat()))
	 +pow<8,1>(M2)*(34*pow<6,1>(tHat())+91*pow<5,1>(tHat())*uHat()+260*pow<4,1>(tHat())*sqr(uHat())+330*pow<3,1>(tHat())*pow<3,1>(uHat())
			+260*sqr(tHat())*pow<4,1>(uHat())+91*tHat()*pow<5,1>(uHat())+34*pow<6,1>(uHat()))-pow<7,1>(M2)*(tHat()+uHat())*
	 (60*pow<6,1>(tHat())+155*pow<5,1>(tHat())*uHat()+561*pow<4,1>(tHat())*sqr(uHat())+574*pow<3,1>(tHat())*pow<3,1>(uHat())+561*sqr(tHat())*pow<4,1>(uHat())
	  +155*tHat()*pow<5,1>(uHat())+60*pow<6,1>(uHat()))-pow<5,1>(M2)*(tHat()+uHat())*
	 (60*pow<8,1>(tHat())+307*pow<7,1>(tHat())*uHat()+1241*pow<6,1>(tHat())*sqr(uHat())+2043*pow<5,1>(tHat())*pow<3,1>(uHat())+2340*pow<4,1>(tHat())*pow<4,1>(uHat())
	  +2043*pow<3,1>(tHat())*pow<5,1>(uHat())+1241*sqr(tHat())*pow<6,1>(uHat())+307*tHat()*pow<7,1>(uHat())+60*pow<8,1>(uHat()))+pow<6,1>(M2)*
	 (72*pow<8,1>(tHat())+340*pow<7,1>(tHat())*uHat()+1281*pow<6,1>(tHat())*sqr(uHat())+2425*pow<5,1>(tHat())*pow<3,1>(uHat())
	  +2882*pow<4,1>(tHat())*pow<4,1>(uHat())+2425*pow<3,1>(tHat())*pow<5,1>(uHat())+1281*sqr(tHat())*pow<6,1>(uHat())+340*tHat()*pow<7,1>(uHat())
	  +72*pow<8,1>(uHat()))+sqr(M2)*sqr(tHat()+uHat())*(2*pow<10,1>(tHat())+32*pow<9,1>(tHat())*uHat()+164*pow<8,1>(tHat())*sqr(uHat())+190*pow<7,1>(tHat())*pow<3,1>(uHat())
							    +133*pow<6,1>(tHat())*pow<4,1>(uHat())-4*pow<5,1>(tHat())*pow<5,1>(uHat())+133*pow<4,1>(tHat())*pow<6,1>(uHat())
							    +190*pow<3,1>(tHat())*pow<7,1>(uHat())+164*sqr(tHat())*pow<8,1>(uHat())+32*tHat()*pow<9,1>(uHat())+2*pow<10,1>(uHat()))
	 -pow<3,1>(M2)*(tHat()+uHat())*(12*pow<10,1>(tHat())+118*pow<9,1>(tHat())*uHat()+582*pow<8,1>(tHat())*sqr(uHat())
					+1033*pow<7,1>(tHat())*pow<3,1>(uHat())+1115*pow<6,1>(tHat())*pow<4,1>(uHat())
					+934*pow<5,1>(tHat())*pow<5,1>(uHat())+1115*pow<4,1>(tHat())*pow<6,1>(uHat())
					+1033*pow<3,1>(tHat())*pow<7,1>(uHat())+582*sqr(tHat())*pow<8,1>(uHat())+118*tHat()*pow<9,1>(uHat())+12*pow<10,1>(uHat()))
	 +pow<4,1>(M2)*(34*pow<10,1>(tHat())+270*pow<9,1>(tHat())*uHat()+1277*pow<8,1>(tHat())*sqr(uHat())+2868*pow<7,1>(tHat())*pow<3,1>(uHat())
			+3973*pow<6,1>(tHat())*pow<4,1>(uHat())+4220*pow<5,1>(tHat())*pow<5,1>(uHat())+3973*pow<4,1>(tHat())*pow<6,1>(uHat())
			+2868*pow<3,1>(tHat())*pow<7,1>(uHat())+1277*sqr(tHat())*pow<8,1>(uHat())+270*tHat()*pow<9,1>(uHat())+34*pow<10,1>(uHat())));
      // test vs PRD 45, 116
      // Energy7 R02 = params_->secondDerivativeRadialWaveFunctionSquared(state_,n_);
      // Energy6 Q(sHat()*tHat()*uHat());
      // Energy4 P(sHat()*tHat()+tHat()*uHat()+uHat()*sHat());
      // double test =-16.*Constants::pi*sqr(sHat())*
      // 	40.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/pow<5,1>(M)/Q/sqr(sHat())/pow<4,1>(Q-M2*P)*
      // 	(M2*sqr(P)*Q*(5*pow<6,1>(M2)-45*pow<3,1>(M2)*Q+48*sqr(Q)) -
      // 	 2*pow<4,1>(P)*(pow<6,1>(M2)-pow<3,1>(M2)*Q+sqr(Q)) + 
      // 	 pow<3,1>(M2)*P*sqr(Q)*(28*pow<3,1>(M2) - 31*Q)-
      // 	 sqr(M2*P)*P*(13*pow<3,1>(M2)-18*Q)*Q + 4*M2*pow<5,1>(P)*(pow<3,1>(M2)+Q) - 
      // 	 sqr(M2)*(2*pow<6,1>(P) - 33*pow<4,1>(Q)) - 2*pow<8,1>(M2)*sqr(Q)  + 43*pow<5,1>(M2)*pow<3,1>(Q));
      // cerr << "testing matrix element " << output << " " << test << " "
      // 	   << (output-test)/(output+test) << " " << output/test << "\n";
    }
    // g qbar -> 1D2 qbar
    else if(mePartonData()[1]->id()<0) {
      // helicity amplitude version of ME
      // VectorWaveFunction    g1w(meMomenta()[0],mePartonData()[0],incoming);
      // SpinorBarWaveFunction q2w(meMomenta()[1],mePartonData()[1],incoming);
      // TensorWaveFunction    t3w(meMomenta()[2],mePartonData()[2],outgoing);
      // SpinorWaveFunction    q4w(meMomenta()[3],mePartonData()[3],outgoing);
      // vector<VectorWaveFunction> g1;
      // vector<SpinorBarWaveFunction> q2;
      // vector<TensorWaveFunction> t3;
      // vector<SpinorWaveFunction> q4;
      // for(unsigned int ix=0;ix<2;++ix) {
      //   g1w.reset(2*ix);
      //   g1.push_back(g1w);
      //   q2w.reset(ix);
      //   q2.push_back(q2w);
      //   q4w.reset(ix);
      //   q4.push_back(q4w);
      // }
      // for(unsigned int ix=0;ix<5;++ix) {
      // 	t3w.reset(ix,tensor_phase);
      // 	t3.push_back(t3w);
      // }
      // ProductionMatrixElement me(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      // double phi = meMomenta()[2].phi();
      // Complex phase = exp(Complex(0.,phi));
      // Energy2 th(tHat()),uh(uHat()),sh(sHat()),sm(sHat()-M2),tm(tHat()-M2),um(uHat()-M2);
      // me(0,0,0,0)=(Complex(0,-8)*sqrt(2)*M*sqr(phase)*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
      // me(0,0,1,0)=(Complex(0,8)*sqrt(2)*phase*sh*sqrt(sh)*sqrt(-uh)*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
      // me(0,0,2,0)=(Complex(0,8)*sh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
      // me(0,0,3,0)=(Complex(0,-8)*sqrt(2)*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
      // me(0,0,4,0)=(Complex(0,-8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(sqr(phase)*sqr(sm)*sqr(tm));
      // me(0,1,0,1)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
      // me(0,1,1,1)=(Complex(0,-8)*sqrt(2)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
      // me(0,1,2,1)=(Complex(0,-8)*uh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(phase)*sqr(sm)*sqrt(-th)*sqr(tm));
      // me(0,1,3,1)=(Complex(0,8)*sqrt(2)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(pow(phase,3)*sqr(sm)*sqr(tm));
      // me(0,1,4,1)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(pow(phase,4)*sqr(sm)*sqr(tm));
      // me(2,0,0,0)=(Complex(0,8)*sqrt(2)*M*pow(phase,4)*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
      // me(2,0,1,0)=(Complex(0,-8)*sqrt(2)*pow(phase,3)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
      // me(2,0,2,0)=(Complex(0,-8)*sqr(phase)*uh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
      // me(2,0,3,0)=(Complex(0,8)*sqrt(2)*phase*sh*uh*sqrt(-(uh/sh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
      // me(2,0,4,0)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
      // me(2,1,0,1)=(Complex(0,-8)*sqrt(2)*M*sqr(phase)*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
      // me(2,1,1,1)=(Complex(0,8)*sqrt(2)*phase*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
      // me(2,1,2,1)=(Complex(0,8)*sh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
      // me(2,1,3,1)=(Complex(0,-8)*sqrt(2)*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
      // me(2,1,4,1)=(Complex(0,-8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(sqr(phase)*sqr(sm)*sqr(tm));
      // double totalB(0.);
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q4[ih4].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
      //  	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vp1Pre = t3[ih3].wave().preDot(meMomenta()[0]);
      // 	    complex<Energy2> d11 = vp1Pre*meMomenta()[0];
      // 	    for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	      auto eSub1 = epsilon(meMomenta()[0],meMomenta()[2],g1[ih1].wave());
      // 	      Complex amp = 32.*M*d11/sqr(tHat()-M2)*(fCurrent*eSub1)/tHat();
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      // 		cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << "\n";
      // 	      totalB+= norm(amp);
      // 	    }
      //     }
      //   }
      // }
      // spin sum version
      double total = -128.*(sqr(sHat())+sqr(uHat()))/3./M2/tHat();
      // final factors
      output = 16.*O1_*pow<3,1>(Constants::pi*standardModel()->alphaS(scale())/M)/(135.*sqr(tHat()-M2))*total;
      // analytic test
      // Energy7 R02 = params_->secondDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -2560.*sqr(Constants::pi)*R02*pow(standardModel()->alphaS(scale()),3)*
      // 	(sqr(sHat())+sqr(uHat()))/(9.*pow<5,1>(M)*tHat()*sqr(tHat()-M2));
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    // g q -> 1D2 q
    else if(mePartonData()[1]->id()<6) {
      // helicity amplitude version of ME
      // VectorWaveFunction      g1w(meMomenta()[0],mePartonData()[0],incoming);
      // SpinorWaveFunction      q2w(meMomenta()[1],mePartonData()[1],incoming);
      // TensorWaveFunction      t3w(meMomenta()[2],mePartonData()[2],outgoing);
      // SpinorBarWaveFunction   q4w(meMomenta()[3],mePartonData()[3],outgoing);
      // vector<VectorWaveFunction> g1;
      // vector<SpinorWaveFunction> q2;
      // vector<TensorWaveFunction> t3;
      // vector<SpinorBarWaveFunction> q4;
      // for(unsigned int ix=0;ix<2;++ix) {
      //   g1w.reset(2*ix);
      //   g1.push_back(g1w);
      //   q2w.reset(ix);
      //   q2.push_back(q2w);
      //   q4w.reset(ix);
      //   q4.push_back(q4w);
      // }
      // for(unsigned int ix=0;ix<5;++ix) {
      // 	t3w.reset(ix,tensor_phase);
      // 	t3.push_back(t3w);
      // }
      // ProductionMatrixElement me(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      // double phi = meMomenta()[2].phi();
      // Complex phase = exp(Complex(0.,phi));
      // me(0,0,0,0)=(Complex(0,8)*sqrt(2)*M*sqr(phase)*sqrt(-(pow<4,1>(sHat())*tHat()))*uHat())/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,0,1,0)=(Complex(0,-8)*sqrt(2)*phase*sHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,0,2,0)=(Complex(0,-8)*sHat()*(-2*M2*tHat()*(tHat()-2*uHat())*(tHat()+uHat())+sqr(tHat())*sqr(tHat()+uHat())+sqr(M2)*(sqr(tHat())-4*tHat()*uHat()+sqr(uHat()))))/(sqrt(3)*M*sqr(M2-tHat())*sqrt(-tHat())*sqr(tHat()+uHat()));
      // me(0,0,3,0)=(Complex(0,8)*sqrt(2)*sHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(phase*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,0,4,0)=(Complex(0,8)*sqrt(2)*M*sqrt(-(pow<4,1>(sHat())*tHat()))*uHat())/(sqr(phase)*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,1,0,1)=(Complex(0,-8)*sqrt(2)*M*sHat()*sqrt(-tHat())*sqr(uHat()))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,1,1,1)=(Complex(0,8)*sqrt(2)*uHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(phase*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,1,2,1)=(Complex(0,8)*uHat()*(-2*M2*tHat()*(tHat()-2*uHat())*(tHat()+uHat())+sqr(tHat())*sqr(tHat()+uHat())+sqr(M2)*(sqr(tHat())-4*tHat()*uHat()+sqr(uHat()))))/(sqrt(3)*M*sqr(phase)*sqr(M2-tHat())*sqrt(-tHat())*sqr(tHat()+uHat()));
      // me(0,1,3,1)=(Complex(0,-8)*sqrt(2)*uHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(pow(phase,3)*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(0,1,4,1)=(Complex(0,-8)*sqrt(2)*M*sHat()*sqrt(-tHat())*sqr(uHat()))/(pow(phase,4)*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,0,0,0)=(Complex(0,-8)*sqrt(2)*M*pow(phase,4)*sHat()*sqrt(-tHat())*sqr(uHat()))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,0,1,0)=(Complex(0,8)*sqrt(2)*pow(phase,3)*uHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,0,2,0)=(Complex(0,8)*sqr(phase)*uHat()*(-2*M2*tHat()*(tHat()-2*uHat())*(tHat()+uHat())+sqr(tHat())*sqr(tHat()+uHat())+sqr(M2)*(sqr(tHat())-4*tHat()*uHat()+sqr(uHat()))))/(sqrt(3)*M*sqr(M2-tHat())*sqrt(-tHat())*sqr(tHat()+uHat()));
      // me(2,0,3,0)=(Complex(0,-8)*sqrt(2)*phase*uHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,0,4,0)=(Complex(0,-8)*sqrt(2)*M*sHat()*sqrt(-tHat())*sqr(uHat()))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,1,0,1)=(Complex(0,8)*sqrt(2)*M*sqr(phase)*sqrt(-(pow<4,1>(sHat())*tHat()))*uHat())/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,1,1,1)=(Complex(0,-8)*sqrt(2)*phase*sHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,1,2,1)=(Complex(0,-8)*sHat()*(-2*M2*tHat()*(tHat()-2*uHat())*(tHat()+uHat())+sqr(tHat())*sqr(tHat()+uHat())+sqr(M2)*(sqr(tHat())-4*tHat()*uHat()+sqr(uHat()))))/(sqrt(3)*M*sqr(M2-tHat())*sqrt(-tHat())*sqr(tHat()+uHat()));
      // me(2,1,3,1)=(Complex(0,8)*sqrt(2)*sHat()*sqrt(-(sHat()*uHat()))*(M2*(-tHat()+uHat())+tHat()*(tHat()+uHat())))/(phase*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // me(2,1,4,1)=(Complex(0,8)*sqrt(2)*M*sqrt(-(pow<4,1>(sHat())*tHat()))*uHat())/(sqr(phase)*sqr(M2-tHat())*sqr(tHat()+uHat()));
      // double total(0.);
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      //  	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vp1Pre = t3[ih3].wave().preDot(meMomenta()[0]);
      // 	    complex<Energy2> d11 = vp1Pre*meMomenta()[0];
      // 	    for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	      auto eSub1 = epsilon(meMomenta()[0],meMomenta()[2],g1[ih1].wave());
      // 	      Complex amp = -32.*M*d11/sqr(tHat()-M2)*(fCurrent*eSub1)/tHat();
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      // 		cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << "\n";
      // 	      total+= norm(amp);
      // 	    }
      //     }
      //   }
      // }
      // spin averaged version
      double total = -128.*(sqr(sHat())+sqr(uHat()))/(3.*sqr(M)*tHat());
      // final factors
      output = 16.*O1_*pow<3,1>(Constants::pi*standardModel()->alphaS(scale())/M)/135./sqr(tHat()-M2)*total;
      // analytic test
      // Energy7 R02 = params_->secondDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -2560.*sqr(Constants::pi)*R02*pow(standardModel()->alphaS(scale()),3)*
      // 	(sqr(sHat())+sqr(uHat()))/(9.*pow<5,1>(M)*tHat()*sqr(tHat()-M2));
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    else assert(false);
  }
  // q qbar -> 1D2 g
  else if(mePartonData()[0]->id()==-mePartonData()[1]->id()) {
    // helicity amplitude version of matrix element
    // SpinorWaveFunction    q1w(meMomenta()[0],mePartonData()[0],incoming);
    // SpinorBarWaveFunction q2w(meMomenta()[1],mePartonData()[1],incoming);
    // TensorWaveFunction    t3w(meMomenta()[2],mePartonData()[2],outgoing);
    // VectorWaveFunction    g4w(meMomenta()[3],mePartonData()[3],outgoing);
    // vector<VectorWaveFunction> g4;
    // vector<SpinorWaveFunction> q1;
    // vector<TensorWaveFunction> t3;
    // vector<SpinorBarWaveFunction> q2;
    // for(unsigned int ix=0;ix<2;++ix) {
    //   g4w.reset(2*ix,vector_phase);
    //   g4.push_back(g4w);
    //   q1w.reset(ix);
    //   q1.push_back(q1w);
    //   q2w.reset(ix);
    //   q2.push_back(q2w);
    // }
    // for(unsigned int ix=0;ix<5;++ix) {
    //   t3w.reset(ix,tensor_phase);
    //   t3.push_back(t3w);
    // }
    // ProductionMatrixElement me(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin2,PDT::Spin1);
    // double phi = meMomenta()[2].phi();
    // Complex phase = exp(Complex(0.,phi));
    // Energy2 sh(sHat()),th(tHat()),uh(uHat());
    // me(0,1,2,0)=(Complex(0,8)*th)/(sqrt(3)*M*sqrt(sh));
    // me(0,1,2,2)=(Complex(0,-8)*uh)/(sqrt(3)*M*sqr(phase)*sqrt(sh));
    // me(1,0,2,0)=(Complex(0,-8)*sqr(phase)*uh)/(sqrt(3)*M*sqrt(sh));
    // me(1,0,2,2)=(Complex(0,8)*th)/(sqrt(3)*M*sqrt(sh));
    // double totalB(0.);
    // for(unsigned int ih1=0;ih1<2;++ih1) {
    //   for(unsigned int ih2=0;ih2<2;++ih2) {
    // 	LorentzPolarizationVectorE fCurrent = q1[ih1].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
    // 	for(unsigned int ih3=0;ih3<5;++ih3) {
    // 	  auto vp1Pre = t3[ih3].wave().preDot(meMomenta()[3]);
    // 	  complex<Energy2> d11 = vp1Pre*meMomenta()[3];
    // 	  for(unsigned int ih4=0;ih4<2;++ih4) {
    // 	    auto eSub1 = epsilon(meMomenta()[3],meMomenta()[2],g4[ih4].wave());
    // 	    Complex amp = 32.*M*d11/sqr(sHat()-M2)*(fCurrent*eSub1)/sHat();
    // 	    double test = norm(amp/me(ih1,ih2,ih3,2*ih4)-1.);
    // 	    if(norm(me(ih1,ih2,ih3,2*ih4))>1e-10 && test>1e-10)
    // 	      cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << 2*ih4 << " "
    // 		   << amp << " " << me(ih1,ih2,ih3,2*ih4) << " " << test << "\n";
    // 	    totalB+= norm(amp);
    // 	  }
    // 	}
    //   }
    // }
    // spin sum version
    double total = 128.*(sqr(tHat())+sqr(uHat()))/3./M2/sHat();
    // final factors
    output = 128.*O1_*pow<3,1>(Constants::pi*standardModel()->alphaS(scale())/M)/(405.*sqr(sHat()-M2))*total;
    // analytic test
    // Energy7 R02 = params_->secondDerivativeRadialWaveFunctionSquared(state_,n_);
    // double test = 20480.*sqr(Constants::pi)*R02*pow(standardModel()->alphaS(scale()),3)*
    //    	(sqr(tHat())+sqr(uHat()))/(27.*pow<5,1>(M)*sHat()*sqr(sHat()-M2));
    // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
  }
  else
    assert(false);
  return output;
}

void MEPPto1D2Jet::constructVertex(tSubProPtr sub) {
  // extract the particles in the hard process
  ParticleVector hard;
  hard.reserve(4);
  hard.push_back(sub->incoming().first);
  hard.push_back(sub->incoming().second);
  hard.push_back(sub->outgoing()[0]);
  hard.push_back(sub->outgoing()[1]);
  // get them in the right order
  bool swapped(false);
  if(hard[0]->id()==-hard[1]->id()) {
    if(hard[0]->id()<0) swapped = true;
  }
  else if(hard[0]->id()!=ParticleID::g) {
    swapped=true;
  }
  if(swapped) {
    swap(hard[0],hard[1]);
    swap(hard[2],hard[3]);
  }
  // boost to partonic CMS
  Lorentz5Momentum pcms = hard[0]->momentum()+hard[1]->momentum();
  LorentzRotation boost(-pcms.boostVector());
  for(PPtr part : hard) part->transform(boost);
  // extract kinematic variables
  Energy  M  = hard[2]->mass();
  Energy2 M2 = sqr(M);
  double phi = hard[2]->momentum().phi();
  Energy2 sh = (hard[0]->momentum()+hard[1]->momentum()).m2();
  Energy2 th = (hard[0]->momentum()-hard[2]->momentum()).m2();
  Energy2 uh = (hard[0]->momentum()-hard[3]->momentum()).m2();
  Energy2 um(uh-M2),tm(th-M2),sm(sh-M2);
  Complex phase = exp(Complex(0.,phi));
  // set basis states and compute the matrix element
  ProductionMatrixElement me;
  vector<TensorWaveFunction> twave;
  TensorWaveFunction(twave,hard[2],outgoing,true, false,true,tensor_phase);
  if(hard[0]->id()==ParticleID::g) {
    // g g -> 1D2 g
    if(hard[1]->id()==ParticleID::g) {
      vector<VectorWaveFunction> g1,g2,g4;
      VectorWaveFunction( g1,hard[0],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g2,hard[1],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g4,hard[3],outgoing,true , true,true,vector_phase);
      ProductionMatrixElement me(PDT::Spin1,PDT::Spin1,PDT::Spin2,PDT::Spin1);
      auto pre = 1./pow<3,1>((M2-sh)*(M2-th)*(M2-uh));
      Energy10 f1 = pow<5,1>(th)+pow<4,1>(th)*uh+th*pow<4,1>(uh)+pow<5,1>(uh)
	-pow<3,1>(M2)*(sqr(th)-th*uh+sqr(uh))+3*sqr(M2)*(pow<3,1>(th)+pow<3,1>(uh))
	-M2*(3*pow<4,1>(th)+2*pow<3,1>(th)*uh-sqr(th)*sqr(uh)+2*th*pow<3,1>(uh)+3*pow<4,1>(uh));
      
      me(0,0,0,0)=Complex(pre*Complex(0,8)*sqrt(2)*pow<3,1>(M)*pow(phase,3)*sh*sqrt(sh)*sqrt(th*uh)*f1);
      me(0,0,0,2)=Complex(pre*Complex(0,8)*sqrt(2)*pow<7,1>(M)*phase*sqrt(sh)*sqrt(th*uh)*(pow<4,1>(sh)+3*pow<3,1>(sh)*uh+sqr(M2)*sqr(uh)+4*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+pow<4,1>(uh)-M2*(pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+2*pow<3,1>(uh))));
      me(0,0,1,0)=Complex(pre*Complex(0,-4)*sqrt(2)*M2*sqr(phase)*sh*(th-uh)*(pow<4,1>(M2)*sqr(sh+uh)-sqr(sh)*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+pow<3,1>(uh))-pow<3,1>(M2)*(3*pow<3,1>(sh)+7*sqr(sh)*uh+6*sh*sqr(uh)+2*pow<3,1>(uh))+sqr(M2)*(4*pow<4,1>(sh)+12*pow<3,1>(sh)*uh+9*sqr(sh)*sqr(uh)+6*sh*pow<3,1>(uh)+pow<4,1>(uh))-M2*sh*(2*pow<4,1>(sh)+5*pow<3,1>(sh)*uh+7*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+2*pow<4,1>(uh))));
      me(0,0,1,2)=Complex(pre*Complex(0,-4)*sqrt(2)*pow<3,1>(M2)*(th-uh)*(pow<3,1>(M2)*uh*(sh+uh)-2*sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+sh*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+pow<3,1>(uh))+M2*(2*pow<4,1>(sh)+3*pow<3,1>(sh)*uh+4*sqr(sh)*sqr(uh)+pow<4,1>(uh))));
      me(0,0,2,0)=Complex(pre*(Complex(0,8)*M*phase*sqr(sh)*sqrt(sh)*(pow<4,1>(M2)*(pow<3,1>(th)-2*sqr(th)*uh-2*th*sqr(uh)+pow<3,1>(uh))+sqr(th)*sqr(uh)*(pow<3,1>(th)+2*sqr(th)*uh+2*th*sqr(uh)+pow<3,1>(uh))+pow<3,1>(M2)*(-2*pow<4,1>(th)+7*pow<3,1>(th)*uh+7*th*pow<3,1>(uh)-2*pow<4,1>(uh))+M2*th*uh*(4*pow<4,1>(th)-3*pow<3,1>(th)*uh-8*sqr(th)*sqr(uh)-3*th*pow<3,1>(uh)+4*pow<4,1>(uh))+sqr(M2)*(pow<5,1>(th)-9*pow<4,1>(th)*uh+4*pow<3,1>(th)*sqr(uh)+4*sqr(th)*pow<3,1>(uh)-9*th*pow<4,1>(uh)+pow<5,1>(uh))))/(sqrt(3)*sqrt(th*uh)));
      me(0,0,2,2)=Complex(pre*(Complex(0,8)*pow<5,1>(M)*(2*sqr(sh)*sqr(uh)*sqr(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))-pow<5,1>(M2)*(pow<3,1>(sh)+sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+pow<4,1>(M2)*(3*pow<4,1>(sh)+5*pow<3,1>(sh)*uh+7*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+3*pow<4,1>(uh))-pow<3,1>(M2)*(3*pow<5,1>(sh)+4*pow<4,1>(sh)*uh+6*sqr(sh)*pow<3,1>(uh)-2*sh*pow<4,1>(uh)+3*pow<5,1>(uh))+M2*sh*uh*(3*pow<5,1>(sh)+12*pow<4,1>(sh)*uh+19*pow<3,1>(sh)*sqr(uh)+10*sqr(sh)*pow<3,1>(uh)+3*sh*pow<4,1>(uh)+3*pow<5,1>(uh))+sqr(M2)*(pow<6,1>(sh)-3*pow<5,1>(sh)*uh-20*pow<4,1>(sh)*sqr(uh)-20*pow<3,1>(sh)*pow<3,1>(uh)-5*sqr(sh)*pow<4,1>(uh)-6*sh*pow<5,1>(uh)+pow<6,1>(uh))))/(sqrt(3)*phase*sqrt(sh)*sqrt(th*uh)));
      me(0,0,3,0)=Complex(pre*Complex(0,-4)*sqrt(2)*M2*sqr(sh)*(th-uh)*(pow<3,1>(M2)*uh*(sh+uh)-2*sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+sh*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+pow<3,1>(uh))+M2*(2*pow<4,1>(sh)+3*pow<3,1>(sh)*uh+4*sqr(sh)*sqr(uh)+pow<4,1>(uh))));
      me(0,0,3,2)=Complex(pre*(Complex(0,-4)*sqrt(2)*pow<3,1>(M2)*sh*(th-uh)*(pow<3,1>(M2)*(th+uh)-9*M2*th*uh*(th+uh)-sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*th*uh*(2*sqr(th)+3*th*uh+2*sqr(uh))))/sqr(phase));
      me(0,0,4,0)=Complex(pre*(Complex(0,-8)*sqrt(2)*pow<3,1>(M)*sqr(sh)*sqrt(sh)*sqrt(th*uh)*(pow<4,1>(sh)+3*pow<3,1>(sh)*uh+sqr(M2)*sqr(uh)+4*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+pow<4,1>(uh)-M2*(pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+2*pow<3,1>(uh))))/phase);
      me(0,0,4,2)=Complex(pre*(Complex(0,-8)*sqrt(2)*pow<5,1>(M)*sh*sqrt(sh)*th*uh*sqrt(th*uh)*(3*sqr(M2)+sqr(th)+th*uh+sqr(uh)-3*M2*(th+uh)))/pow(phase,3));
      me(0,2,0,0)=Complex(pre*Complex(0,-8)*sqrt(2)*pow<3,1>(M)*phase*sqrt(sh)*th*(-(sh*pow<4,1>(th))+pow<3,1>(M2)*th*(sh+th)-sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*th+5*sh*sqr(th)+2*pow<3,1>(th))+M2*(pow<4,1>(sh)+3*pow<3,1>(sh)*th+4*sqr(sh)*sqr(th)+5*sh*pow<3,1>(th)+pow<4,1>(th)))*sqrt(th*uh));
      me(0,2,0,2)=Complex(pre*(Complex(0,-8)*sqrt(2)*pow<3,1>(M)*sh*sqrt(sh)*sqr(uh)*sqrt(th*uh)*(pow<3,1>(sh)+2*sqr(sh)*uh+M2*uh*(-M2+uh)+sh*uh*(-M2+2*uh)))/phase);
      me(0,2,1,0)=Complex(pre*Complex(0,-4)*sqrt(2)*M2*th*(-(pow<4,1>(sh)*pow<3,1>(th))+sqr(sh)*pow<5,1>(th)+pow<5,1>(M2)*sqr(sh+th)-pow<4,1>(M2)*(4*pow<3,1>(sh)+11*sqr(sh)*th+11*sh*sqr(th)+4*pow<3,1>(th))-M2*sh*th*(2*pow<4,1>(sh)+4*pow<3,1>(sh)*th+6*sqr(sh)*sqr(th)+7*sh*pow<3,1>(th)-pow<4,1>(th))+pow<3,1>(M2)*(5*pow<4,1>(sh)+19*pow<3,1>(sh)*th+23*sqr(sh)*sqr(th)+18*sh*pow<3,1>(th)+5*pow<4,1>(th))-sqr(M2)*(2*pow<5,1>(sh)+8*pow<4,1>(sh)*th+13*pow<3,1>(sh)*sqr(th)+7*sqr(sh)*pow<3,1>(th)+10*sh*pow<4,1>(th)+2*pow<5,1>(th))));
      me(0,2,1,2)=Complex(pre*(Complex(0,-4)*sqrt(2)*M2*sh*sqr(uh)*(pow<4,1>(M2)*(sh+uh)+sh*sqr(uh)*(sqr(sh)-sqr(uh))-pow<3,1>(M2)*(sqr(sh)-sh*uh+2*sqr(uh))-sqr(M2)*sh*(4*sqr(sh)+9*sh*uh+13*sqr(uh))+M2*(4*pow<4,1>(sh)+11*pow<3,1>(sh)*uh+14*sqr(sh)*sqr(uh)+12*sh*pow<3,1>(uh)+pow<4,1>(uh))))/sqr(phase));
      me(0,2,2,0)=Complex(pre*(Complex(0,-8)*M*sqr(th)*(sqr(sh)*sqr(uh)*sqr(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))-pow<5,1>(M2)*(pow<3,1>(sh)+sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+pow<4,1>(M2)*(3*pow<4,1>(sh)+7*pow<3,1>(sh)*uh+11*sqr(sh)*sqr(uh)+4*sh*pow<3,1>(uh)+3*pow<4,1>(uh))+M2*sh*uh*(4*pow<5,1>(sh)+12*pow<4,1>(sh)*uh+11*pow<3,1>(sh)*sqr(uh)-sqr(sh)*pow<3,1>(uh)-6*sh*pow<4,1>(uh)-2*pow<5,1>(uh))-pow<3,1>(M2)*(3*pow<5,1>(sh)+10*pow<4,1>(sh)*uh+15*pow<3,1>(sh)*sqr(uh)+24*sqr(sh)*pow<3,1>(uh)+7*sh*pow<4,1>(uh)+3*pow<5,1>(uh))+sqr(M2)*(pow<6,1>(sh)-2*pow<4,1>(sh)*sqr(uh)+7*pow<3,1>(sh)*pow<3,1>(uh)+19*sqr(sh)*pow<4,1>(uh)+6*sh*pow<5,1>(uh)+pow<6,1>(uh))))/(sqrt(3)*phase*sqrt(sh)*sqrt(th*uh)));
      me(0,2,2,2)=Complex(pre*(Complex(0,-8)*M*(sqr(sh)*sqr(th)*sqr(sh+th)*(sqr(sh)+sh*th+sqr(th))-pow<5,1>(M2)*(pow<3,1>(sh)+sqr(sh)*th+sh*sqr(th)+pow<3,1>(th))+pow<4,1>(M2)*(3*pow<4,1>(sh)+7*pow<3,1>(sh)*th+11*sqr(sh)*sqr(th)+4*sh*pow<3,1>(th)+3*pow<4,1>(th))+M2*sh*th*(4*pow<5,1>(sh)+12*pow<4,1>(sh)*th+11*pow<3,1>(sh)*sqr(th)-sqr(sh)*pow<3,1>(th)-6*sh*pow<4,1>(th)-2*pow<5,1>(th))-pow<3,1>(M2)*(3*pow<5,1>(sh)+10*pow<4,1>(sh)*th+15*pow<3,1>(sh)*sqr(th)+24*sqr(sh)*pow<3,1>(th)+7*sh*pow<4,1>(th)+3*pow<5,1>(th))+sqr(M2)*(pow<6,1>(sh)-2*pow<4,1>(sh)*sqr(th)+7*pow<3,1>(sh)*pow<3,1>(th)+19*sqr(sh)*pow<4,1>(th)+6*sh*pow<5,1>(th)+pow<6,1>(th)))*sqr(uh))/(sqrt(3)*pow(phase,3)*sqrt(sh)*sqrt(th*uh)));
      me(0,2,3,0)=Complex(pre*(Complex(0,-4)*sqrt(2)*M2*sh*sqr(th)*(pow<4,1>(M2)*(sh+th)+sh*sqr(th)*(sqr(sh)-sqr(th))-pow<3,1>(M2)*(sqr(sh)-sh*th+2*sqr(th))-sqr(M2)*sh*(4*sqr(sh)+9*sh*th+13*sqr(th))+M2*(4*pow<4,1>(sh)+11*pow<3,1>(sh)*th+14*sqr(sh)*sqr(th)+12*sh*pow<3,1>(th)+pow<4,1>(th))))/sqr(phase));
      me(0,2,3,2)=Complex(pre*(Complex(0,-4)*sqrt(2)*M2*uh*(-(pow<4,1>(sh)*pow<3,1>(uh))+sqr(sh)*pow<5,1>(uh)+pow<5,1>(M2)*sqr(sh+uh)-pow<4,1>(M2)*(4*pow<3,1>(sh)+11*sqr(sh)*uh+11*sh*sqr(uh)+4*pow<3,1>(uh))-M2*sh*uh*(2*pow<4,1>(sh)+4*pow<3,1>(sh)*uh+6*sqr(sh)*sqr(uh)+7*sh*pow<3,1>(uh)-pow<4,1>(uh))+pow<3,1>(M2)*(5*pow<4,1>(sh)+19*pow<3,1>(sh)*uh+23*sqr(sh)*sqr(uh)+18*sh*pow<3,1>(uh)+5*pow<4,1>(uh))-sqr(M2)*(2*pow<5,1>(sh)+8*pow<4,1>(sh)*uh+13*pow<3,1>(sh)*sqr(uh)+7*sqr(sh)*pow<3,1>(uh)+10*sh*pow<4,1>(uh)+2*pow<5,1>(uh))))/pow(phase,4));
      me(0,2,4,0)=Complex(pre*(Complex(0,-8)*sqrt(2)*pow<3,1>(M)*sh*sqrt(sh)*sqr(th)*sqrt(th*uh)*(pow<3,1>(sh)+2*sqr(sh)*uh+M2*uh*(-M2+uh)+sh*uh*(-M2+2*uh)))/pow(phase,3));
      me(0,2,4,2)=Complex(pre*(Complex(0,-8)*sqrt(2)*pow<3,1>(M)*sqrt(sh)*uh*sqrt(th*uh)*(-(sh*pow<4,1>(uh))+pow<3,1>(M2)*uh*(sh+uh)-sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*uh+5*sh*sqr(uh)+2*pow<3,1>(uh))+M2*(pow<4,1>(sh)+3*pow<3,1>(sh)*uh+4*sqr(sh)*sqr(uh)+5*sh*pow<3,1>(uh)+pow<4,1>(uh))))/pow(phase,5));
      me(2,0,0,0)=Complex(pre*Complex(0,-8)*sqrt(2)*pow<3,1>(M)*pow(phase,5)*sqrt(sh)*uh*sqrt(th*uh)*(-(sh*pow<4,1>(uh))+pow<3,1>(M2)*uh*(sh+uh)-sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*uh+5*sh*sqr(uh)+2*pow<3,1>(uh))+M2*(pow<4,1>(sh)+3*pow<3,1>(sh)*uh+4*sqr(sh)*sqr(uh)+5*sh*pow<3,1>(uh)+pow<4,1>(uh))));
      me(2,0,0,2)=Complex(pre*Complex(0,-8)*sqrt(2)*pow<3,1>(M)*pow(phase,3)*sh*sqrt(sh)*sqr(th)*sqrt(th*uh)*(pow<3,1>(sh)+2*sqr(sh)*uh+M2*uh*(-M2+uh)+sh*uh*(-M2+2*uh)));
      me(2,0,1,0)=Complex(pre*Complex(0,4)*sqrt(2)*M2*pow(phase,4)*uh*(-(pow<4,1>(sh)*pow<3,1>(uh))+sqr(sh)*pow<5,1>(uh)+pow<5,1>(M2)*sqr(sh+uh)-pow<4,1>(M2)*(4*pow<3,1>(sh)+11*sqr(sh)*uh+11*sh*sqr(uh)+4*pow<3,1>(uh))-M2*sh*uh*(2*pow<4,1>(sh)+4*pow<3,1>(sh)*uh+6*sqr(sh)*sqr(uh)+7*sh*pow<3,1>(uh)-pow<4,1>(uh))+pow<3,1>(M2)*(5*pow<4,1>(sh)+19*pow<3,1>(sh)*uh+23*sqr(sh)*sqr(uh)+18*sh*pow<3,1>(uh)+5*pow<4,1>(uh))-sqr(M2)*(2*pow<5,1>(sh)+8*pow<4,1>(sh)*uh+13*pow<3,1>(sh)*sqr(uh)+7*sqr(sh)*pow<3,1>(uh)+10*sh*pow<4,1>(uh)+2*pow<5,1>(uh))));
      me(2,0,1,2)=Complex(pre*Complex(0,4)*sqrt(2)*M2*sqr(phase)*sh*sqr(th)*(pow<4,1>(M2)*(sh+th)+sh*sqr(th)*(sqr(sh)-sqr(th))-pow<3,1>(M2)*(sqr(sh)-sh*th+2*sqr(th))-sqr(M2)*sh*(4*sqr(sh)+9*sh*th+13*sqr(th))+M2*(4*pow<4,1>(sh)+11*pow<3,1>(sh)*th+14*sqr(sh)*sqr(th)+12*sh*pow<3,1>(th)+pow<4,1>(th))));
      me(2,0,2,0)=Complex(pre*(Complex(0,-8)*M*pow(phase,3)*(sqr(sh)*sqr(th)*sqr(sh+th)*(sqr(sh)+sh*th+sqr(th))-pow<5,1>(M2)*(pow<3,1>(sh)+sqr(sh)*th+sh*sqr(th)+pow<3,1>(th))+pow<4,1>(M2)*(3*pow<4,1>(sh)+7*pow<3,1>(sh)*th+11*sqr(sh)*sqr(th)+4*sh*pow<3,1>(th)+3*pow<4,1>(th))+M2*sh*th*(4*pow<5,1>(sh)+12*pow<4,1>(sh)*th+11*pow<3,1>(sh)*sqr(th)-sqr(sh)*pow<3,1>(th)-6*sh*pow<4,1>(th)-2*pow<5,1>(th))-pow<3,1>(M2)*(3*pow<5,1>(sh)+10*pow<4,1>(sh)*th+15*pow<3,1>(sh)*sqr(th)+24*sqr(sh)*pow<3,1>(th)+7*sh*pow<4,1>(th)+3*pow<5,1>(th))+sqr(M2)*(pow<6,1>(sh)-2*pow<4,1>(sh)*sqr(th)+7*pow<3,1>(sh)*pow<3,1>(th)+19*sqr(sh)*pow<4,1>(th)+6*sh*pow<5,1>(th)+pow<6,1>(th)))*sqr(uh))/(sqrt(3)*sqrt(sh)*sqrt(th*uh)));
      me(2,0,2,2)=Complex(pre*(Complex(0,-8)*M*phase*sqr(th)*(sqr(sh)*sqr(uh)*sqr(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))-pow<5,1>(M2)*(pow<3,1>(sh)+sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+pow<4,1>(M2)*(3*pow<4,1>(sh)+7*pow<3,1>(sh)*uh+11*sqr(sh)*sqr(uh)+4*sh*pow<3,1>(uh)+3*pow<4,1>(uh))+M2*sh*uh*(4*pow<5,1>(sh)+12*pow<4,1>(sh)*uh+11*pow<3,1>(sh)*sqr(uh)-sqr(sh)*pow<3,1>(uh)-6*sh*pow<4,1>(uh)-2*pow<5,1>(uh))-pow<3,1>(M2)*(3*pow<5,1>(sh)+10*pow<4,1>(sh)*uh+15*pow<3,1>(sh)*sqr(uh)+24*sqr(sh)*pow<3,1>(uh)+7*sh*pow<4,1>(uh)+3*pow<5,1>(uh))+sqr(M2)*(pow<6,1>(sh)-2*pow<4,1>(sh)*sqr(uh)+7*pow<3,1>(sh)*pow<3,1>(uh)+19*sqr(sh)*pow<4,1>(uh)+6*sh*pow<5,1>(uh)+pow<6,1>(uh))))/(sqrt(3)*sqrt(sh)*sqrt(th*uh)));
      me(2,0,3,0)=Complex(pre*Complex(0,4)*sqrt(2)*M2*sqr(phase)*sh*sqr(uh)*(pow<4,1>(M2)*(sh+uh)+sh*sqr(uh)*(sqr(sh)-sqr(uh))-pow<3,1>(M2)*(sqr(sh)-sh*uh+2*sqr(uh))-sqr(M2)*sh*(4*sqr(sh)+9*sh*uh+13*sqr(uh))+M2*(4*pow<4,1>(sh)+11*pow<3,1>(sh)*uh+14*sqr(sh)*sqr(uh)+12*sh*pow<3,1>(uh)+pow<4,1>(uh))));
      me(2,0,3,2)=Complex(pre*Complex(0,4)*sqrt(2)*M2*th*(-(pow<4,1>(sh)*pow<3,1>(th))+sqr(sh)*pow<5,1>(th)+pow<5,1>(M2)*sqr(sh+th)-pow<4,1>(M2)*(4*pow<3,1>(sh)+11*sqr(sh)*th+11*sh*sqr(th)+4*pow<3,1>(th))-M2*sh*th*(2*pow<4,1>(sh)+4*pow<3,1>(sh)*th+6*sqr(sh)*sqr(th)+7*sh*pow<3,1>(th)-pow<4,1>(th))+pow<3,1>(M2)*(5*pow<4,1>(sh)+19*pow<3,1>(sh)*th+23*sqr(sh)*sqr(th)+18*sh*pow<3,1>(th)+5*pow<4,1>(th))-sqr(M2)*(2*pow<5,1>(sh)+8*pow<4,1>(sh)*th+13*pow<3,1>(sh)*sqr(th)+7*sqr(sh)*pow<3,1>(th)+10*sh*pow<4,1>(th)+2*pow<5,1>(th))));
      me(2,0,4,0)=Complex(pre*Complex(0,-8)*sqrt(2)*pow<3,1>(M)*phase*sh*sqrt(sh)*sqr(uh)*sqrt(th*uh)*(pow<3,1>(sh)+2*sqr(sh)*uh+M2*uh*(-M2+uh)+sh*uh*(-M2+2*uh)));
      me(2,0,4,2)=Complex(pre*(Complex(0,-8)*sqrt(2)*pow<3,1>(M)*sqrt(sh)*th*(-(sh*pow<4,1>(th))+pow<3,1>(M2)*th*(sh+th)-sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*th+5*sh*sqr(th)+2*pow<3,1>(th))+M2*(pow<4,1>(sh)+3*pow<3,1>(sh)*th+4*sqr(sh)*sqr(th)+5*sh*pow<3,1>(th)+pow<4,1>(th)))*sqrt(th*uh))/phase);
      me(2,2,0,0)=Complex(pre*Complex(0,-8)*sqrt(2)*pow<5,1>(M)*pow(phase,3)*sh*sqrt(sh)*th*uh*sqrt(th*uh)*(3*sqr(M2)+sqr(th)+th*uh+sqr(uh)-3*M2*(th+uh)));
      me(2,2,0,2)=Complex(pre*Complex(0,-8)*sqrt(2)*pow<3,1>(M)*phase*sqr(sh)*sqrt(sh)*sqrt(th*uh)*(pow<4,1>(sh)+3*pow<3,1>(sh)*uh+sqr(M2)*sqr(uh)+4*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+pow<4,1>(uh)-M2*(pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+2*pow<3,1>(uh))));
      me(2,2,1,0)=Complex(pre*Complex(0,4)*sqrt(2)*pow<3,1>(M2)*sqr(phase)*sh*(th-uh)*(pow<3,1>(M2)*(th+uh)-9*M2*th*uh*(th+uh)-sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*th*uh*(2*sqr(th)+3*th*uh+2*sqr(uh))));
      me(2,2,1,2)=Complex(pre*Complex(0,4)*sqrt(2)*M2*sqr(sh)*(th-uh)*(pow<3,1>(M2)*uh*(sh+uh)-2*sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+sh*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+pow<3,1>(uh))+M2*(2*pow<4,1>(sh)+3*pow<3,1>(sh)*uh+4*sqr(sh)*sqr(uh)+pow<4,1>(uh))));
      me(2,2,2,0)=Complex(pre*(Complex(0,8)*pow<5,1>(M)*phase*(2*sqr(sh)*sqr(uh)*sqr(sh+uh)*(sqr(sh)+sh*uh+sqr(uh))-pow<5,1>(M2)*(pow<3,1>(sh)+sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+pow<4,1>(M2)*(3*pow<4,1>(sh)+5*pow<3,1>(sh)*uh+7*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+3*pow<4,1>(uh))-pow<3,1>(M2)*(3*pow<5,1>(sh)+4*pow<4,1>(sh)*uh+6*sqr(sh)*pow<3,1>(uh)-2*sh*pow<4,1>(uh)+3*pow<5,1>(uh))+M2*sh*uh*(3*pow<5,1>(sh)+12*pow<4,1>(sh)*uh+19*pow<3,1>(sh)*sqr(uh)+10*sqr(sh)*pow<3,1>(uh)+3*sh*pow<4,1>(uh)+3*pow<5,1>(uh))+sqr(M2)*(pow<6,1>(sh)-3*pow<5,1>(sh)*uh-20*pow<4,1>(sh)*sqr(uh)-20*pow<3,1>(sh)*pow<3,1>(uh)-5*sqr(sh)*pow<4,1>(uh)-6*sh*pow<5,1>(uh)+pow<6,1>(uh))))/(sqrt(3)*sqrt(sh)*sqrt(th*uh)));
      me(2,2,2,2)=Complex(pre*(Complex(0,8)*M*sqr(sh)*sqrt(sh)*(pow<4,1>(M2)*(pow<3,1>(th)-2*sqr(th)*uh-2*th*sqr(uh)+pow<3,1>(uh))+sqr(th)*sqr(uh)*(pow<3,1>(th)+2*sqr(th)*uh+2*th*sqr(uh)+pow<3,1>(uh))+pow<3,1>(M2)*(-2*pow<4,1>(th)+7*pow<3,1>(th)*uh+7*th*pow<3,1>(uh)-2*pow<4,1>(uh))+M2*th*uh*(4*pow<4,1>(th)-3*pow<3,1>(th)*uh-8*sqr(th)*sqr(uh)-3*th*pow<3,1>(uh)+4*pow<4,1>(uh))+sqr(M2)*(pow<5,1>(th)-9*pow<4,1>(th)*uh+4*pow<3,1>(th)*sqr(uh)+4*sqr(th)*pow<3,1>(uh)-9*th*pow<4,1>(uh)+pow<5,1>(uh))))/(sqrt(3)*phase*sqrt(th*uh)));
      me(2,2,3,0)=Complex(pre*Complex(0,4)*sqrt(2)*pow<3,1>(M2)*(th-uh)*(pow<3,1>(M2)*uh*(sh+uh)-2*sqr(M2)*(pow<3,1>(sh)+3*sqr(sh)*uh+sh*sqr(uh)+pow<3,1>(uh))+sh*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+pow<3,1>(uh))+M2*(2*pow<4,1>(sh)+3*pow<3,1>(sh)*uh+4*sqr(sh)*sqr(uh)+pow<4,1>(uh))));
      me(2,2,3,2)=Complex(pre*(Complex(0,4)*sqrt(2)*M2*sh*(th-uh)*(pow<4,1>(M2)*sqr(sh+uh)-sqr(sh)*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+pow<3,1>(uh))-pow<3,1>(M2)*(3*pow<3,1>(sh)+7*sqr(sh)*uh+6*sh*sqr(uh)+2*pow<3,1>(uh))+sqr(M2)*(4*pow<4,1>(sh)+12*pow<3,1>(sh)*uh+9*sqr(sh)*sqr(uh)+6*sh*pow<3,1>(uh)+pow<4,1>(uh))-M2*sh*(2*pow<4,1>(sh)+5*pow<3,1>(sh)*uh+7*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+2*pow<4,1>(uh))))/sqr(phase));
      me(2,2,4,0)=Complex(pre*(Complex(0,8)*sqrt(2)*pow<7,1>(M)*sqrt(sh)*sqrt(th*uh)*(pow<4,1>(sh)+3*pow<3,1>(sh)*uh+sqr(M2)*sqr(uh)+4*sqr(sh)*sqr(uh)+2*sh*pow<3,1>(uh)+pow<4,1>(uh)-M2*(pow<3,1>(sh)+3*sqr(sh)*uh+2*sh*sqr(uh)+2*pow<3,1>(uh))))/phase);
      me(2,2,4,2)=Complex(pre*(Complex(0,8)*sqrt(2)*pow<3,1>(M)*sh*sqrt(sh)*sqrt(th*uh)*f1)/pow(phase,3));

      // test the average result
      // double aver = me.average();
      // Energy6 Q(sh*th*uh);
      // Energy4 P(sh*th+th*uh+uh*sh);
      // double test =-128.*M2/3./Q/pow<4,1>(Q-M2*P)*
      // 	(M2*sqr(P)*Q*(5*pow<6,1>(M2)-45*pow<3,1>(M2)*Q+48*sqr(Q)) -
      // 	 2*pow<4,1>(P)*(pow<6,1>(M2)-pow<3,1>(M2)*Q+sqr(Q)) + 
      // 	 pow<3,1>(M2)*P*sqr(Q)*(28*pow<3,1>(M2) - 31*Q)-
      // 	 sqr(M2*P)*P*(13*pow<3,1>(M2)-18*Q)*Q + 4*M2*pow<5,1>(P)*(pow<3,1>(M2)+Q) - 
      // 	 sqr(M2)*(2*pow<6,1>(P) - 33*pow<4,1>(Q)) - 2*pow<8,1>(M2)*sqr(Q)  + 43*pow<5,1>(M2)*pow<3,1>(Q));
      // cerr << "testing spin correlations " << test << " " << me.average() << " "
      // 	   << abs(test-aver)/(test+aver) << "\n";
    }
    // g qbar -> 1D2 qbar
    else if(hard[1]->id()<0) {
      vector<VectorWaveFunction>    g1;
      vector<SpinorBarWaveFunction> q2;
      vector<SpinorWaveFunction>    q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
      SpinorWaveFunction(   q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0)=(Complex(0,-8)*sqrt(2)*M*sqr(phase)*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
	me(0,0,1,0)=(Complex(0,8)*sqrt(2)*phase*sh*sqrt(sh)*sqrt(-uh)*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(0,0,2,0)=(Complex(0,8)*sh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,0,3,0)=(Complex(0,-8)*sqrt(2)*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
	me(0,0,4,0)=(Complex(0,-8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(sqr(phase)*sqr(sm)*sqr(tm));
	me(0,1,0,1)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(0,1,1,1)=(Complex(0,-8)*sqrt(2)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
	me(0,1,2,1)=(Complex(0,-8)*uh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(phase)*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,1,3,1)=(Complex(0,8)*sqrt(2)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(pow(phase,3)*sqr(sm)*sqr(tm));
	me(0,1,4,1)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(pow(phase,4)*sqr(sm)*sqr(tm));
	me(2,0,0,0)=(Complex(0,8)*sqrt(2)*M*pow(phase,4)*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(2,0,1,0)=(Complex(0,-8)*sqrt(2)*pow(phase,3)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(2,0,2,0)=(Complex(0,-8)*sqr(phase)*uh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,0,3,0)=(Complex(0,8)*sqrt(2)*phase*sh*uh*sqrt(-(uh/sh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(2,0,4,0)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(2,1,0,1)=(Complex(0,-8)*sqrt(2)*M*sqr(phase)*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
	me(2,1,1,1)=(Complex(0,8)*sqrt(2)*phase*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(2,1,2,1)=(Complex(0,8)*sh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,1,3,1)=(Complex(0,-8)*sqrt(2)*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
	me(2,1,4,1)=(Complex(0,-8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(sqr(phase)*sqr(sm)*sqr(tm));
      }
      else {
	phase*=-1.;
	me(0,0,0,0)=(Complex(0,8)*sqrt(2)*M*pow(phase,3)*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
	me(0,0,1,0)=(Complex(0,8)*sqrt(2)*sqr(phase)*sh*sqrt(-(sh/uh))*uh*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqr(tm));
	me(0,0,2,0)=(Complex(0,-8)*phase*sh*(sqr(th)*sqr(sm)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,0,3,0)=(Complex(0,8)*sqrt(2)*sqr(sh)*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(0,0,4,0)=(Complex(0,8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(phase*sqr(sm)*sqr(tm));
	me(0,1,0,1)=(Complex(0,-8)*sqrt(2)*M*pow(phase,3)*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(0,1,1,1)=(Complex(0,8)*sqrt(2)*sqr(phase)*sh*uh*sqrt(-(uh/sh))*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqr(tm));
	me(0,1,2,1)=(Complex(0,8)*phase*uh*(sqr(th)*sqr(sm)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,1,3,1)=(Complex(0,-8)*sqrt(2)*sh*uh*sqrt(-(uh/sh))*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqr(tm));
	me(0,1,4,1)=(Complex(0,-8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(phase*sqr(sm)*sqr(tm));
	me(2,0,0,0)=(Complex(0,-8)*sqrt(2)*M*phase*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(2,0,1,0)=(Complex(0,8)*sqrt(2)*sh*uh*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,0,2,0)=(Complex(0,8)*uh*(sqr(th)*sqr(sm)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*phase*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,0,3,0)=(Complex(0,-8)*sqrt(2)*sh*uh*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(phase)*sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,0,4,0)=(Complex(0,-8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(pow(phase,3)*sqr(sm)*sqr(tm));
	me(2,1,0,1)=(Complex(0,8)*sqrt(2)*M*phase*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
	me(2,1,1,1)=(Complex(0,-8)*sqrt(2)*sqr(sh)*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,1,2,1)=(Complex(0,-8)*sh*(sqr(th)*sqr(sm)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*phase*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,1,3,1)=(Complex(0,8)*sqrt(2)*sqr(sh)*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(phase)*sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,1,4,1)=(Complex(0,8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(pow(phase,3)*sqr(sm)*sqr(tm));
      }
      // helicity version
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q4[ih4].dimensionedWave().vectorCurrent(q2[ih4].dimensionedWave());
      //  	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vp1Pre = twave[ih3].wave().preDot(hard[0]->momentum());
      //  	    complex<Energy2> d11 = vp1Pre*hard[0]->momentum();
      //  	    for(unsigned int ih1=0;ih1<2;++ih1) {
      //  	      auto eSub1 = epsilon(hard[0]->momentum(),hard[2]->momentum(),g1[ih1].wave());
      //  	      Complex amp = 32.*M*d11/sqr(tHat()-M2)*(fCurrent*eSub1)/tHat();
      //  	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      //  	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      //  		cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      //  		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << "\n";
      //  	    }
      // 	  }
      // 	}
      // }      
    }
    // g q -> 1D2 q
    else if(hard[1]->id()<6) {
      vector<VectorWaveFunction> g1;
      vector<SpinorWaveFunction> q2;
      vector<SpinorBarWaveFunction> q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorWaveFunction(   q2,hard[1],incoming,false,true);
      SpinorBarWaveFunction(q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0)=(Complex(0,8)*sqrt(2)*M*sqr(phase)*sqrt(-(pow<4,1>(sh)*th))*uh)/(sqr(sm)*sqr(tm));
	me(0,0,1,0)=(Complex(0,-8)*sqrt(2)*phase*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(0,0,2,0)=(Complex(0,-8)*sh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,0,3,0)=(Complex(0,8)*sqrt(2)*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
	me(0,0,4,0)=(Complex(0,8)*sqrt(2)*M*sqrt(-(pow<4,1>(sh)*th))*uh)/(sqr(phase)*sqr(sm)*sqr(tm));
	me(0,1,0,1)=(Complex(0,-8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(0,1,1,1)=(Complex(0,8)*sqrt(2)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
	me(0,1,2,1)=(Complex(0,8)*uh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(phase)*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,1,3,1)=(Complex(0,-8)*sqrt(2)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(pow(phase,3)*sqr(sm)*sqr(tm));
	me(0,1,4,1)=(Complex(0,-8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(pow(phase,4)*sqr(sm)*sqr(tm));
	me(2,0,0,0)=(Complex(0,-8)*sqrt(2)*M*pow(phase,4)*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(2,0,1,0)=(Complex(0,8)*sqrt(2)*pow(phase,3)*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(2,0,2,0)=(Complex(0,8)*sqr(phase)*uh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,0,3,0)=(Complex(0,-8)*sqrt(2)*phase*uh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(2,0,4,0)=(Complex(0,-8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(2,1,0,1)=(Complex(0,8)*sqrt(2)*M*sqr(phase)*sqrt(-(pow<4,1>(sh)*th))*uh)/(sqr(sm)*sqr(tm));
	me(2,1,1,1)=(Complex(0,-8)*sqrt(2)*phase*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(sqr(sm)*sqr(tm));
	me(2,1,2,1)=(Complex(0,-8)*sh*(sqr(sm)*sqr(th)+2*M2*sm*th*(th-2*uh)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,1,3,1)=(Complex(0,8)*sqrt(2)*sh*sqrt(-(sh*uh))*(-(sm*th)+M2*(-th+uh)))/(phase*sqr(sm)*sqr(tm));
	me(2,1,4,1)=(Complex(0,8)*sqrt(2)*M*sqrt(-(pow<4,1>(sh)*th))*uh)/(sqr(phase)*sqr(sm)*sqr(tm));
      }
      else {
	phase *=-1.;me(0,0,0,0)=(Complex(0,-8)*sqrt(2)*M*pow(phase,3)*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
	me(0,0,1,0)=(Complex(0,8)*sqrt(2)*sqr(phase)*sh*sqrt(sh)*sqrt(-uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqr(tm));
	me(0,0,2,0)=(Complex(0,8)*phase*sh*(sqr(th)*sqr(sh-M2)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,0,3,0)=(Complex(0,-8)*sqrt(2)*sqr(sh)*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(0,0,4,0)=(Complex(0,-8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(phase*sqr(sm)*sqr(tm));
	me(0,1,0,1)=(Complex(0,8)*sqrt(2)*M*pow(phase,3)*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(0,1,1,1)=(Complex(0,-8)*sqrt(2)*sqr(phase)*sh*uh*sqrt(-(uh/sh))*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqr(tm));
	me(0,1,2,1)=(Complex(0,-8)*phase*uh*(sqr(th)*sqr(sh-M2)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*sqr(sm)*sqrt(-th)*sqr(tm));
	me(0,1,3,1)=(Complex(0,8)*sqrt(2)*sh*uh*sqrt(-(uh/sh))*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqr(tm));
	me(0,1,4,1)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(phase*sqr(sm)*sqr(tm));
	me(2,0,0,0)=(Complex(0,8)*sqrt(2)*M*phase*sh*sqrt(-th)*sqr(uh))/(sqr(sm)*sqr(tm));
	me(2,0,1,0)=(Complex(0,-8)*sqrt(2)*sh*uh*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,0,2,0)=(Complex(0,-8)*uh*(sqr(th)*sqr(sh-M2)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*phase*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,0,3,0)=(Complex(0,8)*sqrt(2)*sh*uh*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(phase)*sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,0,4,0)=(Complex(0,8)*sqrt(2)*M*sh*sqrt(-th)*sqr(uh))/(pow(phase,3)*sqr(sm)*sqr(tm));
	me(2,1,0,1)=(Complex(0,-8)*sqrt(2)*M*phase*sqr(sh)*sqrt(-th)*uh)/(sqr(sm)*sqr(tm));
	me(2,1,1,1)=(Complex(0,8)*sqrt(2)*sqr(sh)*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,1,2,1)=(Complex(0,8)*sh*(sqr(th)*sqr(sh-M2)+sqr(M2)*(sqr(th)-4*th*uh+sqr(uh))+2*M2*th*(-sqr(th)+th*uh+2*sqr(uh))))/(sqrt(3)*M*phase*sqr(sm)*sqrt(-th)*sqr(tm));
	me(2,1,3,1)=(Complex(0,-8)*sqrt(2)*sqr(sh)*sqrt(th*uh)*(M2*(-th+uh)+th*(th+uh)))/(sqr(phase)*sqr(sm)*sqrt(-(sh*th))*sqr(tm));
	me(2,1,4,1)=(Complex(0,-8)*sqrt(2)*M*sqr(sh)*sqrt(-th)*uh)/(pow(phase,3)*sqr(sm)*sqr(tm));
      }
      // Helicity code version
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      //  	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vp1Pre = twave[ih3].wave().preDot(hard[0]->momentum());
      //  	    complex<Energy2> d11 = vp1Pre*hard[0]->momentum();
      //  	    for(unsigned int ih1=0;ih1<2;++ih1) {
      //  	      auto eSub1 = epsilon(hard[0]->momentum(),hard[2]->momentum(),g1[ih1].wave());
      //  	      Complex amp = -32.*M*d11/sqr(tHat()-M2)*(fCurrent*eSub1)/tHat();
      //  	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      //  	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      //  		cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      //  		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << "\n";
      //  	    }
      // 	  }
      // 	}
      // }
    }
    else
      assert(false);
  }
  else if(hard[0]->id()==-hard[1]->id()) {
    vector<SpinorWaveFunction>    q1;
    vector<SpinorBarWaveFunction> q2;
    vector<VectorWaveFunction>    g4;
    SpinorWaveFunction(   q1,hard[0],incoming,false,true);
    SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
    VectorWaveFunction(   g4,hard[3],outgoing,true,true,true,vector_phase);
    g4[1]=g4[2];
    // matrix element
    me = ProductionMatrixElement(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin2,PDT::Spin1);
    if(!swapped) {
      me(0,1,2,0)=(Complex(0,8)*th)/(sqrt(3)*M*sqrt(sh));
      me(0,1,2,2)=(Complex(0,-8)*uh)/(sqrt(3)*M*sqr(phase)*sqrt(sh));
      me(1,0,2,0)=(Complex(0,-8)*sqr(phase)*uh)/(sqrt(3)*M*sqrt(sh));
      me(1,0,2,2)=(Complex(0,8)*th)/(sqrt(3)*M*sqrt(sh));
    }
    else {
      me(0,1,2,0)=(Complex(0,-8)*sqr(phase)*th)/(sqrt(3)*M*sqrt(sh));
      me(0,1,2,2)=(Complex(0,8)*uh)/(sqrt(3)*M*sqrt(sh));
      me(1,0,2,0)=(Complex(0,8)*uh)/(sqrt(3)*M*sqrt(sh));
      me(1,0,2,2)=(Complex(0,-8)*th)/(sqrt(3)*M*sqr(phase)*sqrt(sh));
    }
    // Helicity code version
    // for(unsigned int ih1=0;ih1<2;++ih1) {
    //   for(unsigned int ih2=0;ih2<2;++ih2) {
    // 	LorentzPolarizationVectorE fCurrent = q1[ih1].dimensionedWave().
    // 	  vectorCurrent(q2[ih2].dimensionedWave());
    // 	for(unsigned int ih3=0;ih3<5;++ih3) {
    // 	  auto vp1Pre = twave[ih3].wave().preDot(hard[3]->momentum());
    // 	  complex<Energy2> d11 = vp1Pre*hard[3]->momentum();
    // 	  for(unsigned int ih4=0;ih4<2;++ih4) {
    //    auto eSub1 = epsilon(hard[3]->momentum(),hard[2]->momentum(),g4[ih4].wave());
    //    Complex amp = 32.*M*d11/sqr(sHat()-M2)*(fCurrent*eSub1)/sHat();
    //    double test = norm(amp/me(ih1,ih2,ih3,2*ih4)-1.);
    //    if(norm(me(ih1,ih2,ih3,2*ih4))>1e-10 && test>1e-10)
    //      cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << 2*ih4 << " "
    // 	      << amp << " " << me(ih1,ih2,ih3,2*ih4) << " " << test << "\n";
    // 	  }
    // 	}
    //   }
    // }
  }
  else
    assert(false);
  // construct the vertex
  HardVertexPtr hardvertex = new_ptr(HardVertex());
  // set the matrix element for the vertex
  hardvertex->ME(me);
  // set the pointers and to and from the vertex
  for(unsigned int i = 0; i < hard.size(); ++i)
    hard[i]->spinInfo()->productionVertex(hardvertex);
  // boost back to lab
  boost = LorentzRotation(pcms.boostVector());
  for(PPtr part : hard)
    part->transform(boost);
}
