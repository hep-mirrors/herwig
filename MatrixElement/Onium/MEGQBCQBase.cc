// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEGQBCQBase class.
//

#include "MEGQBCQBase.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Cuts/Cuts.h"
#include "ThePEG/Utilities/SimplePhaseSpace.h"
#include "Herwig/MatrixElement/HardVertex.h"
#include "ThePEG/Helicity/WaveFunction/ScalarWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorBarWaveFunction.h"

using namespace Herwig;

// The following static variable is needed for the type
// description system in ThePEG.
DescribeAbstractClass<MEGQBCQBase,HwMEBase>
describeHerwigMEGQBCQBase("Herwig::MEGQBCQBase", "HwOniumParameters.so HwMEHadronOnium.so");

void MEGQBCQBase::Init() {
  
  static ClassDocumentation<MEGQBCQBase> documentation
    ("The MEGQBCQBase class is the base class fpr g c -> B_c b processes");
  
  static Parameter<MEGQBCQBase,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEGQBCQBase::n_, 1, 1, 10,
     false, false, Interface::limited);
  
  static Switch<MEGQBCQBase,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 3P1 mass",
     &MEGQBCQBase::mOpt_, 1, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 3P1 state.",
     1);

  static Reference<MEGQBCQBase,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEGQBCQBase::params_, false, false, true, false, false);

}

void MEGQBCQBase::doinit() {
  HwMEBase::doinit();
  long pid = 100000*(n_-1)+id_;
  state_ = getParticleData(pid);
  if(!state_)
    throw Exception() << "No B_c state with pid = " << pid << "in MEGQBCQBase::doinit()" << Exception::runerror;
  massGen_ = dynamic_ptr_cast<GenericMassGeneratorPtr>(state_->massGenerator());
}

void MEGQBCQBase::persistentOutput(PersistentOStream & os) const {
  os << n_ << mOpt_ << params_ << state_ << massGen_;
}

void MEGQBCQBase::persistentInput(PersistentIStream & is, int) {
  is >> n_ >> mOpt_ >> params_ >> state_ >> massGen_;
}

void MEGQBCQBase::getDiagrams() const {
  tcPDPtr g = getParticleData(ParticleID::g);
  tcPDPtr c = getParticleData(4);
  tcPDPtr b = getParticleData(5);
  // c initiated
  add(new_ptr((Tree2toNDiagram(3), g, c, c, 2, state_, 1, b,     -1)));
  add(new_ptr((Tree2toNDiagram(2), g, c, 1, c , 3, state_, 3, b, -2)));
  // cbar initiated
  add(new_ptr((Tree2toNDiagram(3), g, c->CC(), c->CC(), 2, state_->CC(), 1, b->CC(),     -3)));
  add(new_ptr((Tree2toNDiagram(2), g, c->CC(), 1, c->CC() , 3, state_->CC(), 3, b->CC(), -4)));
}

int MEGQBCQBase::nDim() const {
  if(mOpt_==1 && massGen_) return 2;
  else return 1;
}

Selector<const ColourLines *>
MEGQBCQBase::colourGeometries(tcDiagPtr diag) const {
  static ColourLines c[4] = {ColourLines("1 5, 3 2 -1"),
			     ColourLines("1 3 5, 2 -1"),
			     ColourLines("-1 -5, -3 -2 1"),
			     ColourLines("-1 -3 -5, -2 1")};
  Selector<const ColourLines *> sel;
  sel.insert(1.0, &c[abs(diag->id())-1]);
  return sel;
}

Selector<MEBase::DiagramIndex>
MEGQBCQBase::diagrams(const DiagramVector & diags) const {
  Selector<DiagramIndex> sel;
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 || diags[i]->id()==-3)
      sel.insert(meInfo()[0], i);
    else
      sel.insert(meInfo()[1], i);
  return sel;
}

bool MEGQBCQBase::generateKinematics(const double * r) {
  jacobian(1.);
  Energy ecm = sqrt(sHat());
  Energy mBc(ZERO);
  Energy mb = mePartonData()[3]->hardProcessMass();
  if(mOpt_==0 || !massGen_) {
    mBc=state_->mass();
  }
  else {
    Energy mmin = state_->massMin(), mmax = min(state_->massMax(),ecm-mb);
    double jtemp(0.);
    mBc = massGen_->mass(jtemp,*state_,mmin,mmax,r[1]);
    jacobian(jacobian()*jtemp);
  }
  // set the masses
  meMomenta()[2].setMass(mBc);
  meMomenta()[3].setMass(mb );

  double ctmin = -1.0, ctmax = 1.0;
  Energy q = ZERO;
  try {
    q = SimplePhaseSpace::
      getMagnitude(sHat(), meMomenta()[2].mass(), meMomenta()[3].mass());
  } 
  catch ( ImpossibleKinematics & e) {
    return false;
  }

  Energy e = sqrt(sHat())/2.0;
     	    
  Energy2 m22 = meMomenta()[2].mass2();
  Energy2 m32 = meMomenta()[3].mass2();
  Energy2 e0e2 = 2.0*e*sqrt(sqr(q) + m22);
  Energy2 e1e2 = 2.0*e*sqrt(sqr(q) + m22);
  Energy2 e0e3 = 2.0*e*sqrt(sqr(q) + m32);
  Energy2 e1e3 = 2.0*e*sqrt(sqr(q) + m32);
  Energy2 pq = 2.0*e*q;

  Energy2 thmin = lastCuts().minTij(mePartonData()[0], mePartonData()[2]);
  if ( thmin > ZERO ) ctmax = min(ctmax, (e0e2 - m22 - thmin)/pq);

  thmin = lastCuts().minTij(mePartonData()[1], mePartonData()[2]);
  if ( thmin > ZERO ) ctmin = max(ctmin, (thmin + m22 - e1e2)/pq);

  thmin = lastCuts().minTij(mePartonData()[1], mePartonData()[3]);
  if ( thmin > ZERO ) ctmax = min(ctmax, (e1e3 - m32 - thmin)/pq);

  thmin = lastCuts().minTij(mePartonData()[0], mePartonData()[3]);
  if ( thmin > ZERO ) ctmin = max(ctmin, (thmin + m32 - e0e3)/pq);

  Energy ptmin = max(lastCuts().minKT(mePartonData()[2]),
   		     lastCuts().minKT(mePartonData()[3]));
  if ( ptmin > ZERO ) {
    double ctm = 1.0 - sqr(ptmin/q);
    if ( ctm <= 0.0 ) return false;
    ctmin = max(ctmin, -sqrt(ctm));
    ctmax = min(ctmax, sqrt(ctm));
  }

  double ymin2 = lastCuts().minYStar(mePartonData()[2]);
  double ymax2 = lastCuts().maxYStar(mePartonData()[2]);
  double ymin3 = lastCuts().minYStar(mePartonData()[3]);
  double ymax3 = lastCuts().maxYStar(mePartonData()[3]);
  double ytot = lastCuts().Y() + lastCuts().currentYHat();
  if ( ymin2 + ytot > -0.9*Constants::MaxRapidity )
    ctmin = max(ctmin, sqrt(sqr(q) +  m22)*tanh(ymin2)/q);
  if ( ymax2 + ytot < 0.9*Constants::MaxRapidity )
    ctmax = min(ctmax, sqrt(sqr(q) +  m22)*tanh(ymax2)/q);
  if ( ymin3 + ytot > -0.9*Constants::MaxRapidity )
    ctmax = min(ctmax, sqrt(sqr(q) +  m32)*tanh(-ymin3)/q);
  if ( ymax3 + ytot < 0.9*Constants::MaxRapidity )
    ctmin = max(ctmin, sqrt(sqr(q) +  m32)*tanh(-ymax3)/q);

  if ( ctmin >= ctmax ) return false;

  double cth = getCosTheta(ctmin, ctmax, r[0]);
  Energy pt = q*sqrt(1.0-sqr(cth));
  phi(rnd(2.0*Constants::pi));
  meMomenta()[2].setVect(Momentum3( pt*sin(phi()),  pt*cos(phi()),  q*cth));
  meMomenta()[3].setVect(Momentum3(-pt*sin(phi()), -pt*cos(phi()), -q*cth));

  meMomenta()[2].rescaleEnergy();
  meMomenta()[3].rescaleEnergy();

  vector<LorentzMomentum> out(2);
  out[0] = meMomenta()[2];
  out[1] = meMomenta()[3];
  tcPDVector tout(2);
  tout[0] = mePartonData()[2];
  tout[1] = mePartonData()[3];
  if ( !lastCuts().passCuts(tout, out, mePartonData()[0], mePartonData()[1]) )
    return false;

  tHat(pq*cth + m22 - e0e2);
  uHat(m22 + m32 - sHat() - tHat());
  jacobian((pq/sHat())*Constants::pi*jacobian());
  // now compute the rescaled momenta we need for the ME
  double rr = mePartonData()[1]->mass()/mePartonData()[3]->mass();
  vector<Lorentz5Momentum> rescaled(4);
  // masses
  rescaled[0].setMass(          ZERO);
  rescaled[1].setMass(rr/(1.+rr)*mBc);
  rescaled[2].setMass(           mBc);
  rescaled[3].setMass(1./(1.+rr)*mBc);
  // incoming
  Energy pin = 0.5*(sHat()-sqr(rescaled[1].mass()))/ecm;
  rescaled[0].setZ(pin); rescaled[1].setZ(-pin);
  rescaled[0].setT(pin); rescaled[1].setT(0.5*(sHat()+sqr(rescaled[1].mass()))/ecm);
  // outgoing
  try {
    q = SimplePhaseSpace::
      getMagnitude(sHat(), rescaled[2].mass(), rescaled[3].mass());
  } 
  catch ( ImpossibleKinematics & e) {
    return false;
  }
  pt = q*sqrt(1.0-sqr(cth));
  rescaled[2].setVect(Momentum3( pt*sin(phi()),  pt*cos(phi()),  q*cth));
  rescaled[3].setVect(Momentum3(-pt*sin(phi()), -pt*cos(phi()), -q*cth));
  rescaled[2].rescaleEnergy();
  rescaled[3].rescaleEnergy();
  rescaledMomenta(rescaled);
  return true;
}

CrossSection MEGQBCQBase::dSigHatDR() const {
  return me2()*jacobian()/(16.0*sqr(Constants::pi)*sHat())*sqr(hbarc);
}

void MEGQBCQBase::setKinematics() {
  HwMEBase::setKinematics();
}

Energy2 MEGQBCQBase::scale() const {
  return sHat();
}

void MEGQBCQBase::constructVertex(tSubProPtr sub) {
  // extract the particles in the hard process
  ParticleVector hard;
  hard.reserve(4);
  hard.push_back(sub->incoming().first);
  hard.push_back(sub->incoming().second);
  hard.push_back(sub->outgoing()[0]);
  hard.push_back(sub->outgoing()[1]);
  // get them in the right order
  bool swapped(false);
  if(hard[0]->id()!=ParticleID::g) {
    swapped=true;
  }
  if(swapped) {
    swap(hard[0],hard[1]);
    swap(hard[2],hard[3]);
  }
  // boost to partonic CMS
  Lorentz5Momentum pcms = hard[0]->momentum()+hard[1]->momentum();
  LorentzRotation boost(-pcms.boostVector());
  for(PPtr part : hard) part->transform(boost);
  // set basis states and compute the matrix element
  // B_c state
  if(hard[2]->dataPtr()->iSpin()==PDT::Spin0) {
    ScalarWaveFunction(      hard[2],outgoing,true);
  }
  else
    assert(false);
  // gluon
  vector<VectorWaveFunction> g1;
  VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
  g1[1]=g1[2];
  // other particles
  if(hard[1]->id()>0) {
    vector<SpinorWaveFunction> q2;
    vector<SpinorBarWaveFunction> q4;
    SpinorWaveFunction(   q2,hard[1],incoming,false,true);
    SpinorBarWaveFunction(q4,hard[3],outgoing,true ,true);
  }
  else {
    vector<SpinorBarWaveFunction> q2;
    vector<SpinorWaveFunction>    q4;
    SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
    SpinorWaveFunction(   q4,hard[3],outgoing,true ,true);
  }
  // rescale the momenta
  double rr = hard[1]->dataPtr()->mass()/hard[3]->dataPtr()->mass();
  Energy mBc = hard[2]->mass();
  Energy ecm=sqrt(sHat());
  vector<Lorentz5Momentum> rescaled(4);
  // masses
  rescaled[0].setMass(          ZERO);
  rescaled[1].setMass(rr/(1.+rr)*mBc);
  rescaled[2].setMass(           mBc);
  rescaled[3].setMass(1./(1.+rr)*mBc);
  // incoming
  Energy pin = 0.5*(sHat()-sqr(rescaled[1].mass()))/ecm;
  if(hard[0]->momentum().z()>ZERO) {
    rescaled[0].setZ(pin); rescaled[1].setZ(-pin);
  }
  else {
    rescaled[0].setZ(-pin); rescaled[1].setZ(pin);
  }
  rescaled[0].setT(pin); rescaled[1].setT(0.5*(sHat()+sqr(rescaled[1].mass()))/ecm);
  // outgoing
  Energy q;
  try {
    q = SimplePhaseSpace::
      getMagnitude(sHat(), rescaled[2].mass(), rescaled[3].mass());
  } 
  catch ( ImpossibleKinematics & e) {
    assert(false);
  }
  rescaled[2].setVect(hard[2]->momentum().vect().unit()*q);
  rescaled[3].setVect(hard[3]->momentum().vect().unit()*q);
  rescaled[2].rescaleEnergy();
  rescaled[3].rescaleEnergy();
  rescaledMomenta(rescaled);
  // calculate the matrix element
  me2();
  // construct the vertex
  HardVertexPtr hardvertex = new_ptr(HardVertex());
  // // set the matrix element for the vertex
  hardvertex->ME(me_);
  // set the pointers and to and from the vertex
  for(unsigned int i = 0; i < hard.size(); ++i)
    hard[i]->spinInfo()->productionVertex(hardvertex);
  // boost back to lab
  boost = LorentzRotation(pcms.boostVector());
  for(PPtr part : hard)
    part->transform(boost);
}










