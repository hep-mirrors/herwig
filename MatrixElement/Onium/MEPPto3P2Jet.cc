// -*- C++ -*-
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MEPPto3P2Jet class.
//

#include "MEPPto3P2Jet.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/PDT/EnumParticles.h"
#include "ThePEG/MatrixElement/Tree2toNDiagram.h"
#include "ThePEG/Utilities/EnumIO.h"
#include "ThePEG/Helicity/WaveFunction/TensorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/VectorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorWaveFunction.h"
#include "ThePEG/Helicity/WaveFunction/SpinorBarWaveFunction.h"
#include "ThePEG/StandardModel/StandardModelBase.h"
#include "Herwig/MatrixElement/ProductionMatrixElement.h"
#include "Herwig/MatrixElement/HardVertex.h"

using namespace Herwig;

void MEPPto3P2Jet::doinit() {
  HwMEBase::doinit();
  // get the non-perturbative ME
  O1_ = params_->singletMEProduction<1>(state_,n_,1,2);
  // set the mass option
  massOption(vector<unsigned int>({mOpt_+1,0}));
}

IBPtr MEPPto3P2Jet::clone() const {
  return new_ptr(*this);
}

IBPtr MEPPto3P2Jet::fullclone() const {
  return new_ptr(*this);
}

void MEPPto3P2Jet::persistentOutput(PersistentOStream & os) const {
  os << params_ << ounit(O1_,GeV*GeV2*GeV2) << oenum(state_) << n_ << process_ << mOpt_;
}

void MEPPto3P2Jet::persistentInput(PersistentIStream & is, int) {
  is >> params_ >> iunit(O1_,GeV*GeV2*GeV2) >> ienum(state_) >> n_ >> process_ >> mOpt_;
}

// The following static variable is needed for the type
// description system in ThePEG.
DescribeClass<MEPPto3P2Jet,HwMEBase>
describeHerwigMEPPto3P2Jet("Herwig::MEPPto3P2Jet",
			   "HwOniumParameters.so HwMEHadronOnium.so");

void MEPPto3P2Jet::Init() {

  static ClassDocumentation<MEPPto3P2Jet> documentation
    ("The MEPPto3P2Jet class implements the q qbar -> 3P2 g, g q to 3P2 q"
     " and g g to 3P2 g processes");

  static Reference<MEPPto3P2Jet,OniumParameters> interfaceParameters
    ("Parameters",
     "Quarkonium parameters",
     &MEPPto3P2Jet::params_, false, false, true, false, false);
  
  static Switch<MEPPto3P2Jet,OniumState> interfaceState
    ("State",
     "The type of onium state",
     &MEPPto3P2Jet::state_, ccbar, false, false);
  static SwitchOption interfaceStateccbar
    (interfaceState,
     "ccbar",
     "Charmonium state",
     ccbar);
  static SwitchOption interfaceStatebbbar
    (interfaceState,
     "bbbar",
     "Bottomonium state",
     bbbar);
  
  static Parameter<MEPPto3P2Jet,unsigned int> interfacePrincipalQuantumNumber
    ("PrincipalQuantumNumber",
     "The principle quantum number of the states",
     &MEPPto3P2Jet::n_, 1, 1, 10,
     false, false, Interface::limited);

  static Switch<MEPPto3P2Jet,unsigned int> interfaceProcess
    ("Process",
     "Which processes to generate",
     &MEPPto3P2Jet::process_, 0, false, false);
  static SwitchOption interfaceProcessAll
    (interfaceProcess,
     "All",
     "Generate all the processes",
     0);
  static SwitchOption interfaceProcessGQto3P2Q
    (interfaceProcess,
     "GQto3P2Q",
     "The g q -> 3P2 q process",
     1);
  static SwitchOption interfaceProcessGQbarto3P2Qbar
    (interfaceProcess,
     "GQbarto3P2Qbar",
     "The g qbar -> 3P2 qbar process",
     2);
  static SwitchOption interfaceProcessQQbarto3P2G
    (interfaceProcess,
     "QQbarto3P2G",
     "The q qbar -> 3P2 g process",
     3);
  static SwitchOption interfaceProcessGGto3P2G
    (interfaceProcess,
     "GGto3P2G",
     "The g g -> 3P2 g process",
     4);

  static Switch<MEPPto3P2Jet,unsigned int> interfaceMassOption
    ("MassOption",
     "Mass of the treatment of the 3P2 mass",
     &MEPPto3P2Jet::mOpt_, 0, false, false);
  static SwitchOption interfaceMassOptionOnShell
    (interfaceMassOption,
     "OnShell",
     "Use the on-shell mass",
     0);
  static SwitchOption interfaceMassOptionOffShell
    (interfaceMassOption,
     "OffShell",
     "Use an off-shell mass generated by the MassGenerator object for the 3P2 state.",
     1);

}

void MEPPto3P2Jet::getDiagrams() const {
  // construct the meson PDG code from quark ids
  unsigned int iq = 4+state_;
  tcPDPtr ps = getParticleData(long(iq*110 + 5 + (n_-1)*100000));
  tcPDPtr g = getParticleData(ParticleID::g);
  // processes involving quarks
  for ( int i = 1; i <= 3; ++i ) {
    tcPDPtr q = getParticleData(i);
    tcPDPtr qb = q->CC();
    if(process_ == 0 || process_ == 1)
      add(new_ptr((Tree2toNDiagram(3), g, g, q , 1, ps, 2, q , -1)));
    if(process_ == 0 || process_ == 2)
      add(new_ptr((Tree2toNDiagram(3), g, g, qb, 1, ps, 2, qb, -2)));
    if(process_ == 0 || process_ == 3)
      add(new_ptr((Tree2toNDiagram(2), q, qb, 1, g, 3, ps, 3, g, -3)));
  }
  // g g -> 3P2 g (s,t,u 4-point)
  if(process_ == 0 || process_ == 4) {
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, g, 3, ps, 3, g , -4)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 1, ps, 2, g , -5)));
    add(new_ptr((Tree2toNDiagram(3), g, g, g, 2, ps, 1, g , -6)));
    add(new_ptr((Tree2toNDiagram(2), g, g, 1, ps, 1, g , -7)));
  }
}

Selector<MEBase::DiagramIndex>
MEPPto3P2Jet::diagrams(const DiagramVector & diags) const {
  Energy M=meMomenta()[3].mass();
  Energy2 M2(sqr(M));
  Selector<DiagramIndex> sel;
  DVector save(4);
  if(mePartonData()[1]->id()==ParticleID::g &&
     mePartonData()[1]->id()==ParticleID::g ) {
    save[0]=16*M2*(3*M2*sHat()*sqr(tHat()-uHat())+12*sqr(M2)*tHat()*uHat()+2*sqr(sHat())*tHat()*uHat())/(3.*pow<4,1>(M2-sHat())*sHat());
    save[1]=16*M2*(2*sqr(sHat())*tHat()*sqr(sHat()+tHat())*(2*sqr(sHat())+2*sHat()*tHat()+sqr(tHat()))
		   +pow<4,1>(M2)*(3*pow<3,1>(sHat())+20*sqr(sHat())*tHat()+29*sHat()*sqr(tHat())+14*pow<3,1>(tHat()))
		   -pow<3,1>(M2)*(9*pow<4,1>(sHat())+59*pow<3,1>(sHat())*tHat()+97*sqr(sHat())*sqr(tHat())+55*sHat()*pow<3,1>(tHat())+4*pow<4,1>(tHat()))
		   -M2*sHat()*(sHat()+tHat())*(3*pow<4,1>(sHat())+24*pow<3,1>(sHat())*tHat()+59*sqr(sHat())*sqr(tHat())+38*sHat()*pow<3,1>(tHat())+8*pow<4,1>(tHat()))
		   +sqr(M2)*(9*pow<5,1>(sHat())+74*pow<4,1>(sHat())*tHat()+163*pow<3,1>(sHat())*sqr(tHat())
			     +132*sqr(sHat())*pow<3,1>(tHat())+34*sHat()*pow<4,1>(tHat())+2*pow<5,1>(tHat())))
      /(3.*sqr(M2-sHat())*sHat()*pow<4,1>(M2-uHat())*uHat());
    save[2]=16*M2*(2*sqr(sHat())*uHat()*sqr(sHat()+uHat())*(2*sqr(sHat())+2*sHat()*uHat()+sqr(uHat()))
		   +pow<4,1>(M2)*(3*pow<3,1>(sHat())+20*sqr(sHat())*uHat()+29*sHat()*sqr(uHat())+14*pow<3,1>(uHat()))
		   -pow<3,1>(M2)*(9*pow<4,1>(sHat())+59*pow<3,1>(sHat())*uHat()+97*sqr(sHat())*sqr(uHat())+55*sHat()*pow<3,1>(uHat())+4*pow<4,1>(uHat()))
		   -M2*sHat()*(sHat()+uHat())*(3*pow<4,1>(sHat())+24*pow<3,1>(sHat())*uHat()+59*sqr(sHat())*sqr(uHat())+38*sHat()*pow<3,1>(uHat())+8*pow<4,1>(uHat()))
		   +sqr(M2)*(9*pow<5,1>(sHat())+74*pow<4,1>(sHat())*uHat()+163*pow<3,1>(sHat())*sqr(uHat())
			     +132*sqr(sHat())*pow<3,1>(uHat())+34*sHat()*pow<4,1>(uHat())+2*pow<5,1>(uHat())))
      /(3.*sqr(M2-sHat())*sHat()*pow<4,1>(M2-tHat())*tHat());
    save[3]=16*M2*(4*sqr(sHat())*pow<5,1>(tHat())*pow<5,1>(uHat())+6*pow<9,1>(M2)*sHat()*(4*sqr(tHat())+9*tHat()*uHat()+4*sqr(uHat()))
		   -pow<10,1>(M2)*(21*sqr(tHat())+46*tHat()*uHat()+21*sqr(uHat()))
		   -pow<8,1>(M2)*(72*pow<4,1>(tHat())+311*pow<3,1>(tHat())*uHat()
				  +440*sqr(tHat())*sqr(uHat())+311*tHat()*pow<3,1>(uHat())+72*pow<4,1>(uHat()))
		   +pow<7,1>(M2)*sHat()*(153*pow<4,1>(tHat())+649*pow<3,1>(tHat())*uHat()
					 +962*sqr(tHat())*sqr(uHat())+649*tHat()*pow<3,1>(uHat())+153*pow<4,1>(uHat()))
		   +2*M2*sHat()*sqr(tHat())*sqr(uHat())*(3*pow<6,1>(tHat())+6*pow<5,1>(tHat())*uHat()+16*pow<4,1>(tHat())*sqr(uHat())
							 +14*pow<3,1>(tHat())*pow<3,1>(uHat())+16*sqr(tHat())*pow<4,1>(uHat())
							 +6*tHat()*pow<5,1>(uHat())+3*pow<6,1>(uHat()))
		   +pow<6,1>(M2)*(45*pow<6,1>(tHat())+308*pow<5,1>(tHat())*uHat()+808*pow<4,1>(tHat())*sqr(uHat())
				  +1174*pow<3,1>(tHat())*pow<3,1>(uHat())+808*sqr(tHat())*pow<4,1>(uHat())
				  +308*tHat()*pow<5,1>(uHat())+45*pow<6,1>(uHat()))
		   +pow<5,1>(M2)*sHat()*(135*pow<6,1>(tHat())+819*pow<5,1>(tHat())*uHat()+1941*pow<4,1>(tHat())*sqr(uHat())
					 +2444*pow<3,1>(tHat())*pow<3,1>(uHat())+1941*sqr(tHat())*pow<4,1>(uHat())+819*tHat()*pow<5,1>(uHat())+135*pow<6,1>(uHat()))
		   +pow<3,1>(M2)*sHat()*(12*pow<8,1>(tHat())+120*pow<7,1>(tHat())*uHat()+419*pow<6,1>(tHat())*sqr(uHat())
					 +805*pow<5,1>(tHat())*pow<3,1>(uHat())+938*pow<4,1>(tHat())*pow<4,1>(uHat())
					 +805*pow<3,1>(tHat())*pow<5,1>(uHat())+419*sqr(tHat())*pow<6,1>(uHat())
					 +120*tHat()*pow<7,1>(uHat())+12*pow<8,1>(uHat()))
		   +sqr(M2)*tHat()*uHat()*(18*pow<8,1>(tHat())+84*pow<7,1>(tHat())*uHat()+229*pow<6,1>(tHat())*sqr(uHat())
					   +396*pow<5,1>(tHat())*pow<3,1>(uHat())+490*pow<4,1>(tHat())*pow<4,1>(uHat())
					   +396*pow<3,1>(tHat())*pow<5,1>(uHat())+229*sqr(tHat())*pow<6,1>(uHat())
					   +84*tHat()*pow<7,1>(uHat())+18*pow<8,1>(uHat()))
		   +pow<4,1>(M2)*(48*pow<8,1>(tHat())+355*pow<7,1>(tHat())*uHat()+1211*pow<6,1>(tHat())*sqr(uHat())
				  +2262*pow<5,1>(tHat())*pow<3,1>(uHat())+2778*pow<4,1>(tHat())*pow<4,1>(uHat())
				  +2262*pow<3,1>(tHat())*pow<5,1>(uHat())+1211*sqr(tHat())*pow<6,1>(uHat())
				  +355*tHat()*pow<7,1>(uHat())+48*pow<8,1>(uHat())))
      /(3.*pow<4,1>(M2-sHat())*sHat()*pow<4,1>(M2-tHat())*pow<4,1>(M2-uHat()));
  }
  for ( DiagramIndex i = 0; i < diags.size(); ++i ) 
    if ( diags[i]->id() == -1 ||
  	 diags[i]->id() == -2 ||
  	 diags[i]->id() == -3 ) sel.insert(1.0, i);
    else
      sel.insert(save[abs(diags[i]->id())-4],i);
  return sel;
}

Selector<const ColourLines *>
MEPPto3P2Jet::colourGeometries(tcDiagPtr diag) const {
  // g q -> 3P2 q
  static ColourLines cgq   ("1 2  5, -1 -2  3");
  // g qbar -> 3P2 qbar
  static ColourLines cgqbar("1 2 -3, -1 -2 -5");
  // q qbar -> 3P2 g
  static ColourLines cqqbar("1 3  5, -2 -3 -5");
  // g g -> 3P2 g
  static ColourLines cs[2]={ColourLines("1 3 5, -1 2, -2 -3 -5"),
  			    ColourLines("1 -2, -1 -3 -5, 2 3 5")};
  static ColourLines ct[2]={ColourLines("1 2 5, -1 -2 3, -3 -5"),
  			    ColourLines("1 2 -3, -1 -2 -5, 3 5")};
  static ColourLines cu[2]={ColourLines("1 5, -1 -2 3, -3 2 -5"),
  			    ColourLines("1 2 -3, -1 -5, 3 -2 5")};
  // 4 point
  static ColourLines c4[2]={ColourLines("1 -2,  2  4, -1 -4"),
  			    ColourLines("1  4, -4 -2,  2 -1")};
  // create the selector
  Selector<const ColourLines *> sel;
  if      (diag->id() == -1) sel.insert(1.0, &cgq   );
  else if (diag->id() == -2) sel.insert(1.0, &cgqbar);
  else if (diag->id() == -3) sel.insert(1.0, &cqqbar);
  else if (diag->id() == -4) {
    sel.insert(0.5, &cs[0]);
    sel.insert(0.5, &cs[1]);
  }
  else if (diag->id() == -5) {
    sel.insert(0.5, &ct[0]);
    sel.insert(0.5, &ct[1]);
  }
  else if (diag->id() == -6) {
    sel.insert(0.5, &cu[0]);
    sel.insert(0.5, &cu[1]);
  }
  else if (diag->id() == -7) {
    sel.insert(0.5, &c4[0]);
    sel.insert(0.5, &c4[1]);
  }
  return sel;
}

Energy2 MEPPto3P2Jet::scale() const {
  return sHat();
}

double MEPPto3P2Jet::me2() const {
  // return value
  double output(0.);
  // mass of the 3P2 state
  Energy  M  = meMomenta()[2].mass();
  Energy2 M2 = sqr(meMomenta()[2].mass());
  if(mePartonData()[0]->id()==ParticleID::g) {
    // g qbar -> 3P2 qbar
    if(mePartonData()[1]->id()==ParticleID::g) {
      // matrix element
      output = 8.*O1_*pow(Constants::pi*standardModel()->alphaS(scale()),3)/(15.*sqr(M2)*M)*
	(16*M2*(12*pow<10,1>(M2)*pow<4,1>(tHat()+uHat())+2*sqr(tHat())*sqr(uHat())*sqr(tHat()+uHat())*pow<4,1>(sqr(tHat())+tHat()*uHat()+sqr(uHat()))-24*pow<9,1>(M2)*pow<3,1>(tHat()+uHat())*(3*sqr(tHat())+5*tHat()*uHat()+3*sqr(uHat()))+pow<8,1>(M2)*sqr(tHat()+uHat())*(204*pow<4,1>(tHat())+651*pow<3,1>(tHat())*uHat()+880*sqr(tHat())*sqr(uHat())+651*tHat()*pow<3,1>(uHat())+204*pow<4,1>(uHat()))-M2*tHat()*uHat()*(tHat()+uHat())*sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat()))*(12*pow<6,1>(tHat())+48*pow<5,1>(tHat())*uHat()+43*pow<4,1>(tHat())*sqr(uHat())+6*pow<3,1>(tHat())*pow<3,1>(uHat())+43*sqr(tHat())*pow<4,1>(uHat())+48*tHat()*pow<5,1>(uHat())+12*pow<6,1>(uHat()))-pow<7,1>(M2)*(tHat()+uHat())*(360*pow<6,1>(tHat())+1635*pow<5,1>(tHat())*uHat()+3314*pow<4,1>(tHat())*sqr(uHat())+4114*pow<3,1>(tHat())*pow<3,1>(uHat())+3314*sqr(tHat())*pow<4,1>(uHat())+1635*tHat()*pow<5,1>(uHat())+360*pow<6,1>(uHat()))-pow<5,1>(M2)*(tHat()+uHat())*(360*pow<8,1>(tHat())+1914*pow<7,1>(tHat())*uHat()+4376*pow<6,1>(tHat())*sqr(uHat())+6271*pow<5,1>(tHat())*pow<3,1>(uHat())+6914*pow<4,1>(tHat())*pow<4,1>(uHat())+6271*pow<3,1>(tHat())*pow<5,1>(uHat())+4376*sqr(tHat())*pow<6,1>(uHat())+1914*tHat()*pow<7,1>(uHat())+360*pow<8,1>(uHat()))+pow<6,1>(M2)*(432*pow<8,1>(tHat())+2526*pow<7,1>(tHat())*uHat()+6652*pow<6,1>(tHat())*sqr(uHat())+10877*pow<5,1>(tHat())*pow<3,1>(uHat())+12640*pow<4,1>(tHat())*pow<4,1>(uHat())+10877*pow<3,1>(tHat())*pow<5,1>(uHat())+6652*sqr(tHat())*pow<6,1>(uHat())+2526*tHat()*pow<7,1>(uHat())+432*pow<8,1>(uHat()))-pow<3,1>(M2)*(tHat()+uHat())*(72*pow<10,1>(tHat())+543*pow<9,1>(tHat())*uHat()+1542*pow<8,1>(tHat())*sqr(uHat())+2336*pow<7,1>(tHat())*pow<3,1>(uHat())+2412*pow<6,1>(tHat())*pow<4,1>(uHat())+2266*pow<5,1>(tHat())*pow<5,1>(uHat())+2412*pow<4,1>(tHat())*pow<6,1>(uHat())+2336*pow<3,1>(tHat())*pow<7,1>(uHat())+1542*sqr(tHat())*pow<8,1>(uHat())+543*tHat()*pow<9,1>(uHat())+72*pow<10,1>(uHat()))+pow<4,1>(M2)*(204*pow<10,1>(tHat())+1455*pow<9,1>(tHat())*uHat()+4328*pow<8,1>(tHat())*sqr(uHat())+7504*pow<7,1>(tHat())*pow<3,1>(uHat())+9232*pow<6,1>(tHat())*pow<4,1>(uHat())+9614*pow<5,1>(tHat())*pow<5,1>(uHat())+9232*pow<4,1>(tHat())*pow<6,1>(uHat())+7504*pow<3,1>(tHat())*pow<7,1>(uHat())+4328*sqr(tHat())*pow<8,1>(uHat())+1455*tHat()*pow<9,1>(uHat())+204*pow<10,1>(uHat()))+sqr(M2)*(12*pow<12,1>(tHat())+144*pow<11,1>(tHat())*uHat()+616*pow<10,1>(tHat())*sqr(uHat())+1345*pow<9,1>(tHat())*pow<3,1>(uHat())+1824*pow<8,1>(tHat())*pow<4,1>(uHat())+1806*pow<7,1>(tHat())*pow<5,1>(uHat())+1688*pow<6,1>(tHat())*pow<6,1>(uHat())+1806*pow<5,1>(tHat())*pow<7,1>(uHat())+1824*pow<4,1>(tHat())*pow<8,1>(uHat())+1345*pow<3,1>(tHat())*pow<9,1>(uHat())+616*sqr(tHat())*pow<10,1>(uHat())+144*tHat()*pow<11,1>(uHat())+12*pow<12,1>(uHat()))))/(3.*sHat()*pow<4,1>(M2-tHat())*tHat()*pow<4,1>(M2-uHat())*uHat()*pow<4,1>(tHat()+uHat()));
      // test vs NPB 291 731
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // Energy6 Q(sHat()*tHat()*uHat());
      // Energy4 P(sHat()*tHat()+tHat()*uHat()+uHat()*sHat());
      // Energy8 M8(pow<4,1>(M2));
      // double test = 16.*Constants::pi*sqr(sHat())*
      // 	4.*Constants::pi*R02*pow(standardModel()->alphaS(scale()),3)/(M*M2*sqr(sHat())*Q*pow<4,1>(Q-M2*P))*
      // 	(12.*sqr(M2)*pow<4,1>(P)*(M8 - 2*sqr(M2)*P + sqr(P))
      // 	 -3.*M2*P*sqr(P)*(8*M8 - sqr(M2)*P + 4*sqr(P))*Q
      // 	 - 2*sqr(P*Q)*(7*M8 - 43*sqr(M2)*P - sqr(P))
      // 	 + M2*P*Q*sqr(Q)*(16*sqr(M2) - 61*P) + 12*sqr(M2*sqr(Q)));
      // cerr << "testing matrix element " << output << " " << test << " "
      // 	   << (output-test)/(output+test) << " " << output/test << "\n";
    }
    // g qbar -> 3P2 qbar
    else if(mePartonData()[1]->id()<0) {
      // // helicity amplitude version of ME
      // VectorWaveFunction      g1w(meMomenta()[0],mePartonData()[0],incoming);
      // SpinorBarWaveFunction   q2w(meMomenta()[1],mePartonData()[1],incoming);
      // TensorWaveFunction      t3w(meMomenta()[2],mePartonData()[2],outgoing);
      // SpinorWaveFunction      q4w(meMomenta()[3],mePartonData()[3],outgoing);
      // vector<VectorWaveFunction> g1;
      // vector<SpinorBarWaveFunction> q2;
      // vector<TensorWaveFunction> t3;
      // vector<SpinorWaveFunction> q4;
      // for(unsigned int ix=0;ix<2;++ix) {
      // 	g1w.reset(2*ix);
      // 	g1.push_back(g1w);
      // 	q2w.reset(ix);
      // 	q2.push_back(q2w);
      // 	q4w.reset(ix);
      // 	q4.push_back(q4w);
      // }
      // for(unsigned int ix=0;ix<5;++ix) {
      // 	t3w.reset(ix,tensor_phase);
      // 	t3.push_back(t3w);
      // }
      // double total(0.);
      // ProductionMatrixElement me(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      // Complex phase = exp(Complex(0.,meMomenta()[2].phi()));
      // me(0,0,0,0)=(2.*sqrt(2)*sqr(phase)*sqrt(-tHat())*uHat())/pow<3,1>(M);
      // me(0,0,1,0)=(2.*sqrt(2)*phase*sHat()*tHat()*sqrt(-(uHat()/sHat())))/sqr(M2);
      // me(0,0,2,0)=(2.*sHat()*sqrt(-tHat())*tHat())/(sqrt(3)*pow<5,1>(M));
      // me(0,1,0,1)=(-2.*sqrt(2)*sHat()*sqrt(-tHat())*sqr(uHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
      // me(0,1,1,1)=(-2.*sqrt(2)*(M2+sHat())*tHat()*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*phase*sqr(tHat()+uHat()));
      // me(0,1,2,1)=(2.*(sqr(M2)+4*M2*sHat()+sqr(sHat()))*(-tHat())*sqrt(-tHat())*uHat())/(sqrt(3)*pow<5,1>(M)*sqr(phase)*sqr(tHat()+uHat()));
      // me(0,1,3,1)=(-2.*sqrt(2)*(M2+sHat())*sqr(tHat())*sqrt(-(sHat()*uHat())))/(sqr(M2)*pow(phase,3)*sqr(tHat()+uHat()));
      // me(0,1,4,1)=(-2.*sqrt(2)*sHat()*sqr(tHat())*sqrt(-tHat()))/(pow<3,1>(M)*pow(phase,4)*sqr(tHat()+uHat()));
      // me(2,0,0,0)=(2.*sqrt(2)*pow(phase,4)*sHat()*sqr(tHat())*sqrt(-tHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
      // me(2,0,1,0)=(-2.*sqrt(2)*pow(phase,3)*(M2+sHat())*sqr(tHat())*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(tHat()+uHat()));
      // me(2,0,2,0)=(2.*sqr(phase)*(sqr(M2)+4*M2*sHat()+sqr(sHat()))*sqrt(-tHat())*tHat()*uHat())/(sqrt(3)*pow<5,1>(M)*sqr(tHat()+uHat()));
      // me(2,0,3,0)=(-2.*sqrt(2)*phase*(M2+sHat())*tHat()*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(tHat()+uHat()));
      // me(2,0,4,0)=(2.*sqrt(2)*sHat()*sqrt(-tHat())*sqr(uHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
      // me(2,1,2,1)=(2.*sHat()*(-tHat())*sqrt(-tHat()))/(sqrt(3)*pow<5,1>(M));
      // me(2,1,3,1)=(2.*sqrt(2)*sHat()*tHat()*sqrt(-(uHat()/sHat())))/(sqr(M2)*phase);
      // me(2,1,4,1)=(-2.*sqrt(2)*sqrt(-tHat())*uHat())/(pow<3,1>(M)*sqr(phase));
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q4[ih4].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
      // 	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vfPre  = t3[ih3].wave().preDot(fCurrent);
      // 	    auto vfPost = t3[ih3].wave().postDot(fCurrent);
      // 	    auto vp1Pre = t3[ih3].wave().preDot(meMomenta()[0]);
      // 	    auto vp1Post = t3[ih3].wave().postDot(meMomenta()[0]);
      // 	    complex<Energy2> d11 = vp1Pre*meMomenta()[0];
      // 	    for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	      complex<Energy> d3=meMomenta()[2]*g1[ih1].wave();
      // 	      Complex amp =-1./sqr(M2)/M*(-2.*M2*(vfPre*meMomenta()[0]*d3 + tHat()*vfPre*g1[ih1].wave()
      // 						  +2.*d11*(fCurrent*g1[ih1].wave()))
      // 					  +(fCurrent*meMomenta()[2])*(2.*(M2+tHat())*(vp1Pre*g1[ih1].wave())
      // 								      -2.*(tHat()-M2)*(vp1Post*g1[ih1].wave()))
      // 					  -(tHat()+M2)*((tHat()-M2)*(vfPost*g1[ih1].wave())+2.*vfPost*meMomenta()[0]*d3)
      // 					  +sqr(M2)*(vfPre*g1[ih1].wave())+tHat()*(2.*(vfPre*meMomenta()[0])*d3+tHat()*vfPre*g1[ih1].wave())
      // 					  );
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      // 		cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << "\n";
      // 	      total+= norm(amp);
      // 	    }
      //     }
      //   }
      // }
      // spin sum version
      double total = -8*tHat()*(pow<4,1>(M2)*sqr(tHat())*sqr(uHat())
      				+2*pow<3,1>(M2)*sHat()*tHat()*uHat()*(3*sqr(tHat())+4*tHat()*uHat()+3*sqr(uHat()))
      				+sqr(sHat())*sqr(tHat())*(pow<4,1>(tHat())+4*pow<3,1>(tHat())*uHat()
      							  +(sqr(sHat())+6*sqr(tHat()))*sqr(uHat())
      							  +4*tHat()*pow<3,1>(uHat())+pow<4,1>(uHat()))
      				+6*sqr(M2)*(sqr(uHat())*pow<4,1>(tHat()+uHat())+sqr(sHat())*sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat())))
      				+2*M2*sHat()*tHat()*uHat()*(3*pow<4,1>(tHat()+uHat())+sqr(sHat())*(3*sqr(tHat())+4*tHat()*uHat()+3*sqr(uHat()))))
      	/(3.*pow<5,1>(M2)*pow<4,1>(tHat()+uHat()));
      // final factors
      output = 64.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))*sqr(M2)/(135.*sqr(tHat())*pow<4,1>(tHat()-M2))*total;
      // analytic test
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -16.*Constants::pi*sqr(sHat())*
      // 	16.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/(9.*M*M2*sqr(sHat())*tHat()*pow<4,1>(tHat()-M2))*
      // 	(sqr(tHat()-M2)*(sqr(tHat())+6.*sqr(M2))  -2.*sHat()*uHat()*(sqr(tHat())-6.*M2*(tHat()-M2)));
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    // g q -> 3P2 q
    else if(mePartonData()[1]->id()<6) {
      // helicity amplitude version of ME
      // VectorWaveFunction      g1w(meMomenta()[0],mePartonData()[0],incoming);
      // SpinorWaveFunction      q2w(meMomenta()[1],mePartonData()[1],incoming);
      // TensorWaveFunction      t3w(meMomenta()[2],mePartonData()[2],outgoing);
      // SpinorBarWaveFunction   q4w(meMomenta()[3],mePartonData()[3],outgoing);
      // vector<VectorWaveFunction> g1;
      // vector<SpinorWaveFunction> q2;
      // vector<TensorWaveFunction> t3;
      // vector<SpinorBarWaveFunction> q4;
      // for(unsigned int ix=0;ix<2;++ix) {
      //   g1w.reset(2*ix);
      //   g1.push_back(g1w);
      //   q2w.reset(ix);
      //   q2.push_back(q2w);
      //   q4w.reset(ix);
      //   q4.push_back(q4w);
      // }
      // for(unsigned int ix=0;ix<5;++ix) {
      // 	t3w.reset(ix,tensor_phase);
      // 	t3.push_back(t3w);
      // }
      // double total(0.);
      // ProductionMatrixElement me(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      // Complex phase = exp(Complex(0.,meMomenta()[2].phi()));
      // me(0,0,0,0)=(-2.*sqrt(2)*sqr(phase)*sqrt(-tHat())*uHat())/pow<3,1>(M);
      // me(0,0,1,0)=(-2.*sqrt(2)*phase*sHat()*tHat()*sqrt(-(uHat()/sHat())))/sqr(M2);
      // me(0,0,2,0)=(2.*sHat()*(-tHat())*sqrt(-tHat()))/(sqrt(3)*pow<5,1>(M));
      // me(0,1,0,1)=(2.*sqrt(2)*sHat()*sqrt(-tHat())*sqr(uHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
      // me(0,1,1,1)=(2.*sqrt(2)*(M2+sHat())*tHat()*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*phase*sqr(tHat()+uHat()));
      // me(0,1,2,1)=(2.*(sqr(M2)+4*M2*sHat()+sqr(sHat()))*sqrt(-tHat())*tHat()*uHat())/(sqrt(3)*pow<5,1>(M)*sqr(phase)*sqr(tHat()+uHat()));
      // me(0,1,3,1)=(2.*sqrt(2)*(M2+sHat())*sqr(tHat())*sqrt(-(sHat()*uHat())))/(sqr(M2)*pow(phase,3)*sqr(tHat()+uHat()));
      // me(0,1,4,1)=(2.*sqrt(2)*sHat()*sqr(tHat())*sqrt(-tHat()))/(pow<3,1>(M)*pow(phase,4)*sqr(tHat()+uHat()));
      // me(2,0,0,0)=(-2.*sqrt(2)*pow(phase,4)*sHat()*sqr(tHat())*sqrt(-tHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
      // me(2,0,1,0)=(2.*sqrt(2)*pow(phase,3)*(M2+sHat())*sqr(tHat())*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(tHat()+uHat()));
      // me(2,0,2,0)=(2.*sqr(phase)*(sqr(M2)+4*M2*sHat()+sqr(sHat()))*(-tHat())*sqrt(-tHat())*uHat())/(sqrt(3)*pow<5,1>(M)*sqr(tHat()+uHat()));
      // me(2,0,3,0)=(2.*sqrt(2)*phase*(M2+sHat())*tHat()*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(tHat()+uHat()));
      // me(2,0,4,0)=(-2.*sqrt(2)*sHat()*sqrt(-tHat())*sqr(uHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
      // me(2,1,2,1)=(2.*sHat()*sqrt(-tHat())*tHat())/(sqrt(3)*pow<5,1>(M));
      // me(2,1,3,1)=(-2.*sqrt(2)*sHat()*tHat()*sqrt(-(uHat()/sHat())))/(sqr(M2)*phase);
      // me(2,1,4,1)=(2.*sqrt(2)*sqrt(-tHat())*uHat())/(pow<3,1>(M)*sqr(phase));
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      // 	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vfPre  = t3[ih3].wave().preDot(fCurrent);
      // 	    auto vfPost = t3[ih3].wave().postDot(fCurrent);
      // 	    auto vp1Pre = t3[ih3].wave().preDot(meMomenta()[0]);
      // 	    auto vp1Post = t3[ih3].wave().postDot(meMomenta()[0]);
      // 	    complex<Energy2> d11 = vp1Pre*meMomenta()[0];
      // 	    for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	      complex<Energy> d3=meMomenta()[2]*g1[ih1].wave();
      // 	      Complex amp = 1./sqr(M2)/M*(-2.*M2*(vfPre*meMomenta()[0]*d3 + tHat()*vfPre*g1[ih1].wave()
      // 						  +2.*d11*(fCurrent*g1[ih1].wave()))
      // 					  +(fCurrent*meMomenta()[2])*(2.*(M2+tHat())*(vp1Pre*g1[ih1].wave())
      // 								      -2.*(tHat()-M2)*(vp1Post*g1[ih1].wave()))
      // 					  -(tHat()+M2)*((tHat()-M2)*(vfPost*g1[ih1].wave())+2.*vfPost*meMomenta()[0]*d3)
      // 					  +sqr(M2)*(vfPre*g1[ih1].wave())+tHat()*(2.*(vfPre*meMomenta()[0])*d3+tHat()*vfPre*g1[ih1].wave())
      // 					  );
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      // 		cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << "\n";
      // 	      total+= norm(amp);
      // 	    }
      //     }
      //   }
      // }
      // spin sum version
      double total = -8*tHat()*(pow<4,1>(M2)*sqr(tHat())*sqr(uHat())
      				+2*pow<3,1>(M2)*sHat()*tHat()*uHat()*(3*sqr(tHat())+4*tHat()*uHat()+3*sqr(uHat()))
      				+sqr(sHat())*sqr(tHat())*(pow<4,1>(tHat())+4*pow<3,1>(tHat())*uHat()
      							  +(sqr(sHat())+6*sqr(tHat()))*sqr(uHat())
      							  +4*tHat()*pow<3,1>(uHat())+pow<4,1>(uHat()))
      				+6*sqr(M2)*(sqr(uHat())*pow<4,1>(tHat()+uHat())+sqr(sHat())*sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat())))
      				+2*M2*sHat()*tHat()*uHat()*(3*pow<4,1>(tHat()+uHat())+sqr(sHat())*(3*sqr(tHat())+4*tHat()*uHat()+3*sqr(uHat()))))
      	/(3.*pow<5,1>(M2)*pow<4,1>(tHat()+uHat()));
      // final factors
      output = 64.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))*sqr(M2)/(135.*sqr(tHat())*pow<4,1>(tHat()-M2))*total;
      // analytic test
      // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
      // double test = -16.*Constants::pi*sqr(sHat())*
      // 	16.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02/(9.*M*M2*sqr(sHat())*tHat()*pow<4,1>(tHat()-M2))*
      // 	(sqr(tHat()-M2)*(sqr(tHat())+6.*sqr(M2))  -2.*sHat()*uHat()*(sqr(tHat())-6.*M2*(tHat()-M2)));
      // cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
    }
    else assert(false);
  }
  // q qbar -> 3P2 g
  else if(mePartonData()[0]->id()==-mePartonData()[1]->id()) {
    // // helicity amplitude version of ME
    // // SpinorWaveFunction      q1w(meMomenta()[0],mePartonData()[1],incoming);
    // // SpinorBarWaveFunction   q2w(meMomenta()[1],mePartonData()[0],incoming);
    // // VectorWaveFunction      g4w(meMomenta()[3],mePartonData()[3],outgoing);
    // // vector<SpinorWaveFunction> q1;
    // // vector<SpinorBarWaveFunction> q2;
    // // vector<VectorWaveFunction> g4;
    // // for(unsigned int ix=0;ix<2;++ix) {
    // //   g4w.reset(2*ix,vector_phase);
    // //   g4.push_back(g4w);
    // //   q1w.reset(ix);
    // //   q1.push_back(q1w);
    // //   q2w.reset(ix);
    // //   q2.push_back(q2w);
    // // }
    // // double total(0.);
    // // ProductionMatrixElement me(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin2,PDT::Spin1);
    // // double phi = meMomenta()[2].phi();
    // // me(0,1,0,0) = -sqrt(2.*sHat())*tHat()/M2/M;
    // // me(0,1,0,2) = -exp(Complex(0.,-2.*phi))*sqrt(2.*sHat())*uHat()/M2/M;
    // // me(1,0,0,0) =  exp(Complex(0., 2.*phi))*sqrt(2.*sHat())*uHat()/M2/M;
    // // me(1,0,0,2) =  sqrt(2.*sHat())*tHat()/M2/M;
    // // for(unsigned int ih1=0;ih1<2;++ih1) {
    // //   for(unsigned int ih2=0;ih2<2;++ih2) {
    // //     LorentzPolarizationVectorE fCurrent = q1[ih1].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
    // // 	for(unsigned int ih4=0;ih4<2;++ih4) {
    // // 	  Complex amp = ((sHat()-M2)*(fCurrent*g4[ih4].wave())-2.*(meMomenta()[2]*g4[ih4].wave())*(fCurrent*meMomenta()[3]))/M2/M;
    // // 	  if(norm(me(ih1,ih2,0,2*ih4))>1e-10)
    // // 	    cerr << "testing in hel loop A " << ih1 << " " << ih2 << " " << ih4 << " "
    // // 		 << amp << " " << me(ih1,ih2,0,2*ih4) << " " << amp/me(ih1,ih2,0,2*ih4) << " " << norm(amp/me(ih1,ih2,0,2*ih4)) << "\n";
    // // 	  total+= norm(amp);
    // //     }
    // //   }
    // // }
    // // spin sum version
    // double total = 4.*sHat()*(sqr(tHat())+sqr(uHat()))/pow<3,1>(M2);
    // // final factors
    // output = 512.*O1_*pow<3,1>(M*Constants::pi*standardModel()->alphaS(scale()))*sqr(sHat()-3.*M2)/(243.*sqr(sHat())*pow<4,1>(sHat()-M2))*total;
    // // analytic test
    // // Energy5 R02 = params_->firstDerivativeRadialWaveFunctionSquared(state_,n_);
    // // double test = 16.*Constants::pi*8./3.*8.*Constants::pi*pow(standardModel()->alphaS(scale()),3)*R02*(sqr(tHat())+sqr(uHat()))
    // //   	/9./M/M2/sHat()/pow<4,1>(sHat()-M2)*sqr(sHat()-3.*sqr(M));
    // //   cerr << "testing matrix element " << output << " " << test << " " << (output-test)/(output+test) << " " << output/test << "\n";
  }
  else
    assert(false);
  return output;
}

void MEPPto3P2Jet::constructVertex(tSubProPtr sub) {
  // extract the particles in the hard process
  ParticleVector hard;
  hard.reserve(4);
  hard.push_back(sub->incoming().first);
  hard.push_back(sub->incoming().second);
  hard.push_back(sub->outgoing()[0]);
  hard.push_back(sub->outgoing()[1]);
  // get them in the right order
  bool swapped(false);
  if(hard[0]->id()==-hard[1]->id()) {
    if(hard[0]->id()<0) swapped = true;
  }
  else if(hard[0]->id()!=ParticleID::g) {
    swapped=true;
  }
  if(swapped) {
    swap(hard[0],hard[1]);
    swap(hard[2],hard[3]);
  }
  // boost to partonic CMS
  Lorentz5Momentum pcms = hard[0]->momentum()+hard[1]->momentum();
  LorentzRotation boost(-pcms.boostVector());
  for(PPtr part : hard) part->transform(boost);
  // extract kinematic variables
  Energy  M  = hard[2]->mass();
  Energy2 M2 = sqr(M);
  double phi = hard[2]->momentum().phi();
  Energy2 sh = (hard[0]->momentum()+hard[1]->momentum()).m2();
  Energy2 th = (hard[0]->momentum()-hard[2]->momentum()).m2();
  Energy2 uh = (hard[0]->momentum()-hard[3]->momentum()).m2();
  Complex phase = exp(Complex(0.,phi));
  // set basis states and compute the matrix element
  ProductionMatrixElement me;
  vector<TensorWaveFunction> t3;
  TensorWaveFunction(t3,hard[2],outgoing,true,false,true,tensor_phase);
  if(hard[0]->id()==ParticleID::g) {
    // g g -> 3P2 g
    if(hard[1]->id()==ParticleID::g) {
      vector<VectorWaveFunction> g1,g2,g4;
      VectorWaveFunction( g1,hard[0],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g2,hard[1],incoming,false, true,true,vector_phase);
      VectorWaveFunction( g4,hard[3],outgoing,true , true,true,vector_phase);
      ProductionMatrixElement me(PDT::Spin1,PDT::Spin1,PDT::Spin2,PDT::Spin1);
      Complex phase = exp(Complex(0.,phi));
      Energy2 um(uh-M2),tm(th-M2),sm(sh-M2);
      me(0,0,0,0)=(-4*pow<3,1>(M)*pow(phase,3)*(sqr(M2)*sm*sqr(th-uh)-pow<3,1>(M2)*th*uh+sm*(pow<4,1>(th)+pow<4,1>(uh))+M2*(2*pow<4,1>(th)+pow<3,1>(th)*uh-sqr(th)*sqr(uh)+th*pow<3,1>(uh)+2*pow<4,1>(uh))))/(sqrt(sh)*sm*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(0,0,1,0)=(2*M2*sqr(phase)*sh*(th-uh)*(-2*sqr(sh)-sh*uh-sqr(uh)+M2*(sh+uh)))/(sm*sqr(tm)*sqr(um));
      me(0,0,2,0)=(-2*sqrt(2./3.)*M*phase*sh*sqrt(sh)*sqrt(th*uh)*(sqr(sh)+sh*uh+uh*(-M2+uh)))/(sm*sqr(tm)*sqr(um));
      me(0,2,0,0)=(-4*pow<3,1>(M)*phase*(pow<3,1>(M2)*sqr(sh+th)-sh*sqr(th)*(sqr(sh)+sh*th+sqr(th))-sqr(M2)*(sh+th)*(sqr(sh)+2*sh*th+2*sqr(th))+M2*th*(pow<3,1>(sh)+2*sqr(sh)*th+3*sh*sqr(th)+pow<3,1>(th)))*sqr(uh))/(sqrt(sh)*pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(0,2,0,2)=(-4*pow<3,1>(M)*sqr(sh)*sqrt(sh)*sqr(uh)*(M2*sm+sqr(th)+sqr(uh)))/(phase*pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(0,2,1,0)=(2*M2*(pow<3,1>(M2)*(sh+th)*(4*sh+3*th)-2*sh*sqr(th)*(sqr(sh)+sh*th+sqr(th))+M2*th*(2*pow<3,1>(sh)+3*sqr(sh)*th+7*sh*sqr(th)+2*pow<3,1>(th))-sqr(M2)*(4*pow<3,1>(sh)+9*sqr(sh)*th+12*sh*sqr(th)+5*pow<3,1>(th)))*uh)/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(0,2,1,2)=(-2*M2*sh*uh*(sh*sqr(uh)*(-sh+uh)+sqr(M2)*(4*sqr(sh)+7*sh*uh+sqr(uh))-M2*(4*pow<3,1>(sh)+7*sqr(sh)*uh+8*sh*sqr(uh)+pow<3,1>(uh))))/(sqr(phase)*pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(0,2,2,0)=(-2*sqrt(2./3.)*M*sqrt(sh)*(-(sh*sqr(th)*(sqr(sh)+sh*th+sqr(th)))+pow<3,1>(M2)*(6*sqr(sh)+10*sh*th+3*sqr(th))+M2*th*(pow<3,1>(sh)+5*sh*sqr(th)+pow<3,1>(th))-sqr(M2)*(6*pow<3,1>(sh)+11*sqr(sh)*th+14*sh*sqr(th)+4*pow<3,1>(th)))*sqrt(th*uh))/(phase*pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(0,2,2,2)=(2*sqrt(2./3.)*M*sqrt(sh)*sqrt(th*uh)*(-(sh*sqr(uh)*(sqr(sh)+sh*uh+sqr(uh)))+pow<3,1>(M2)*(6*sqr(sh)+10*sh*uh+3*sqr(uh))+M2*uh*(pow<3,1>(sh)+5*sh*sqr(uh)+pow<3,1>(uh))-sqr(M2)*(6*pow<3,1>(sh)+11*sqr(sh)*uh+14*sh*sqr(uh)+4*pow<3,1>(uh))))/(pow(phase,3)*pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(0,2,3,0)=(2*M2*sh*th*(sh*sqr(th)*(-sh+th)+sqr(M2)*(4*sqr(sh)+7*sh*th+sqr(th))-M2*(4*pow<3,1>(sh)+7*sqr(sh)*th+8*sh*sqr(th)+pow<3,1>(th))))/(sqr(phase)*pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(0,2,3,2)=(-2*M2*th*(pow<3,1>(M2)*(sh+uh)*(4*sh+3*uh)-2*sh*sqr(uh)*(sqr(sh)+sh*uh+sqr(uh))+M2*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+7*sh*sqr(uh)+2*pow<3,1>(uh))-sqr(M2)*(4*pow<3,1>(sh)+9*sqr(sh)*uh+12*sh*sqr(uh)+5*pow<3,1>(uh))))/(pow(phase,4)*pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(0,2,4,0)=(4*pow<3,1>(M)*sqr(sh)*sqrt(sh)*sqr(th)*(M2*sm+sqr(th)+sqr(uh)))/(pow(phase,3)*pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(0,2,4,2)=(4*pow<3,1>(M)*sqr(th)*(pow<3,1>(M2)*sqr(sh+uh)-sh*sqr(uh)*(sqr(sh)+sh*uh+sqr(uh))-sqr(M2)*(sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh))+M2*uh*(pow<3,1>(sh)+2*sqr(sh)*uh+3*sh*sqr(uh)+pow<3,1>(uh))))/(pow(phase,5)*sqrt(sh)*pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(2,0,0,0)=(-4*pow<3,1>(M)*pow(phase,5)*sqr(th)*(pow<3,1>(M2)*sqr(sh+uh)-sh*sqr(uh)*(sqr(sh)+sh*uh+sqr(uh))-sqr(M2)*(sh+uh)*(sqr(sh)+2*sh*uh+2*sqr(uh))+M2*uh*(pow<3,1>(sh)+2*sqr(sh)*uh+3*sh*sqr(uh)+pow<3,1>(uh))))/(sqrt(sh)*pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(2,0,0,2)=(-4*pow<3,1>(M)*pow(phase,3)*sqr(sh)*sqrt(sh)*sqr(th)*(M2*sm+sqr(th)+sqr(uh)))/(pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(2,0,1,0)=(-2*M2*pow(phase,4)*th*(pow<3,1>(M2)*(sh+uh)*(4*sh+3*uh)-2*sh*sqr(uh)*(sqr(sh)+sh*uh+sqr(uh))+M2*uh*(2*pow<3,1>(sh)+3*sqr(sh)*uh+7*sh*sqr(uh)+2*pow<3,1>(uh))-sqr(M2)*(4*pow<3,1>(sh)+9*sqr(sh)*uh+12*sh*sqr(uh)+5*pow<3,1>(uh))))/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(2,0,1,2)=(2*M2*sqr(phase)*sh*th*(sh*sqr(th)*(-sh+th)+sqr(M2)*(4*sqr(sh)+7*sh*th+sqr(th))-M2*(4*pow<3,1>(sh)+7*sqr(sh)*th+8*sh*sqr(th)+pow<3,1>(th))))/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(2,0,2,0)=(-2*sqrt(2./3.)*M*pow(phase,3)*sqrt(sh)*sqrt(th*uh)*(-(sh*sqr(uh)*(sqr(sh)+sh*uh+sqr(uh)))+pow<3,1>(M2)*(6*sqr(sh)+10*sh*uh+3*sqr(uh))+M2*uh*(pow<3,1>(sh)+5*sh*sqr(uh)+pow<3,1>(uh))-sqr(M2)*(6*pow<3,1>(sh)+11*sqr(sh)*uh+14*sh*sqr(uh)+4*pow<3,1>(uh))))/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(2,0,2,2)=(2*sqrt(2./3.)*M*phase*sqrt(sh)*(-(sh*sqr(th)*(sqr(sh)+sh*th+sqr(th)))+pow<3,1>(M2)*(6*sqr(sh)+10*sh*th+3*sqr(th))+M2*th*(pow<3,1>(sh)+5*sh*sqr(th)+pow<3,1>(th))-sqr(M2)*(6*pow<3,1>(sh)+11*sqr(sh)*th+14*sh*sqr(th)+4*pow<3,1>(th)))*sqrt(th*uh))/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(2,0,3,0)=(-2*M2*sqr(phase)*sh*uh*(sh*sqr(uh)*(-sh+uh)+sqr(M2)*(4*sqr(sh)+7*sh*uh+sqr(uh))-M2*(4*pow<3,1>(sh)+7*sqr(sh)*uh+8*sh*sqr(uh)+pow<3,1>(uh))))/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(2,0,3,2)=(2*M2*(pow<3,1>(M2)*(sh+th)*(4*sh+3*th)-2*sh*sqr(th)*(sqr(sh)+sh*th+sqr(th))+M2*th*(2*pow<3,1>(sh)+3*sqr(sh)*th+7*sh*sqr(th)+2*pow<3,1>(th))-sqr(M2)*(4*pow<3,1>(sh)+9*sqr(sh)*th+12*sh*sqr(th)+5*pow<3,1>(th)))*uh)/(pow<3,1>(sm)*sqr(tm)*sqr(um));
      me(2,0,4,0)=(4*pow<3,1>(M)*phase*sqr(sh)*sqrt(sh)*sqr(uh)*(M2*sm+sqr(th)+sqr(uh)))/(pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(2,0,4,2)=(4*pow<3,1>(M)*(pow<3,1>(M2)*sqr(sh+th)-sh*sqr(th)*(sqr(sh)+sh*th+sqr(th))-sqr(M2)*(sh+th)*(sqr(sh)+2*sh*th+2*sqr(th))+M2*th*(pow<3,1>(sh)+2*sqr(sh)*th+3*sh*sqr(th)+pow<3,1>(th)))*sqr(uh))/(phase*sqrt(sh)*pow<3,1>(sm)*sqr(tm)*sqrt(th*uh)*sqr(um));
      me(2,2,2,2)=(2*sqrt(2./3.)*M*sh*sqrt(sh)*sqrt(th*uh)*(sqr(sh)+sh*uh+uh*(-M2+uh)))/(phase*sm*sqr(tm)*sqr(um));
      me(2,2,3,2)=(2*M2*sh*(th-uh)*(-2*sqr(sh)-sh*uh-sqr(uh)+M2*(sh+uh)))/(sqr(phase)*sm*sqr(tm)*sqr(um));
      me(2,2,4,2)=(4*pow<3,1>(M)*(sqr(M2)*sm*sqr(th-uh)-pow<3,1>(M2)*th*uh+sm*(pow<4,1>(th)+pow<4,1>(uh))+M2*(2*pow<4,1>(th)+pow<3,1>(th)*uh-sqr(th)*sqr(uh)+th*pow<3,1>(uh)+2*pow<4,1>(uh))))/(pow(phase,3)*sqrt(sh)*sm*sqr(tm)*sqrt(th*uh)*sqr(um));
      // test the average result
      // double aver = me.average();
      // double test = (16*M2*(12*pow<10,1>(M2)*pow<4,1>(tHat()+uHat())+2*sqr(tHat())*sqr(uHat())*sqr(tHat()+uHat())*pow<4,1>(sqr(tHat())+tHat()*uHat()+sqr(uHat()))-24*pow<9,1>(M2)*pow<3,1>(tHat()+uHat())*(3*sqr(tHat())+5*tHat()*uHat()+3*sqr(uHat()))+pow<8,1>(M2)*sqr(tHat()+uHat())*(204*pow<4,1>(tHat())+651*pow<3,1>(tHat())*uHat()+880*sqr(tHat())*sqr(uHat())+651*tHat()*pow<3,1>(uHat())+204*pow<4,1>(uHat()))-M2*tHat()*uHat()*(tHat()+uHat())*sqr(sqr(tHat())+tHat()*uHat()+sqr(uHat()))*(12*pow<6,1>(tHat())+48*pow<5,1>(tHat())*uHat()+43*pow<4,1>(tHat())*sqr(uHat())+6*pow<3,1>(tHat())*pow<3,1>(uHat())+43*sqr(tHat())*pow<4,1>(uHat())+48*tHat()*pow<5,1>(uHat())+12*pow<6,1>(uHat()))-pow<7,1>(M2)*(tHat()+uHat())*(360*pow<6,1>(tHat())+1635*pow<5,1>(tHat())*uHat()+3314*pow<4,1>(tHat())*sqr(uHat())+4114*pow<3,1>(tHat())*pow<3,1>(uHat())+3314*sqr(tHat())*pow<4,1>(uHat())+1635*tHat()*pow<5,1>(uHat())+360*pow<6,1>(uHat()))-pow<5,1>(M2)*(tHat()+uHat())*(360*pow<8,1>(tHat())+1914*pow<7,1>(tHat())*uHat()+4376*pow<6,1>(tHat())*sqr(uHat())+6271*pow<5,1>(tHat())*pow<3,1>(uHat())+6914*pow<4,1>(tHat())*pow<4,1>(uHat())+6271*pow<3,1>(tHat())*pow<5,1>(uHat())+4376*sqr(tHat())*pow<6,1>(uHat())+1914*tHat()*pow<7,1>(uHat())+360*pow<8,1>(uHat()))+pow<6,1>(M2)*(432*pow<8,1>(tHat())+2526*pow<7,1>(tHat())*uHat()+6652*pow<6,1>(tHat())*sqr(uHat())+10877*pow<5,1>(tHat())*pow<3,1>(uHat())+12640*pow<4,1>(tHat())*pow<4,1>(uHat())+10877*pow<3,1>(tHat())*pow<5,1>(uHat())+6652*sqr(tHat())*pow<6,1>(uHat())+2526*tHat()*pow<7,1>(uHat())+432*pow<8,1>(uHat()))-pow<3,1>(M2)*(tHat()+uHat())*(72*pow<10,1>(tHat())+543*pow<9,1>(tHat())*uHat()+1542*pow<8,1>(tHat())*sqr(uHat())+2336*pow<7,1>(tHat())*pow<3,1>(uHat())+2412*pow<6,1>(tHat())*pow<4,1>(uHat())+2266*pow<5,1>(tHat())*pow<5,1>(uHat())+2412*pow<4,1>(tHat())*pow<6,1>(uHat())+2336*pow<3,1>(tHat())*pow<7,1>(uHat())+1542*sqr(tHat())*pow<8,1>(uHat())+543*tHat()*pow<9,1>(uHat())+72*pow<10,1>(uHat()))+pow<4,1>(M2)*(204*pow<10,1>(tHat())+1455*pow<9,1>(tHat())*uHat()+4328*pow<8,1>(tHat())*sqr(uHat())+7504*pow<7,1>(tHat())*pow<3,1>(uHat())+9232*pow<6,1>(tHat())*pow<4,1>(uHat())+9614*pow<5,1>(tHat())*pow<5,1>(uHat())+9232*pow<4,1>(tHat())*pow<6,1>(uHat())+7504*pow<3,1>(tHat())*pow<7,1>(uHat())+4328*sqr(tHat())*pow<8,1>(uHat())+1455*tHat()*pow<9,1>(uHat())+204*pow<10,1>(uHat()))+sqr(M2)*(12*pow<12,1>(tHat())+144*pow<11,1>(tHat())*uHat()+616*pow<10,1>(tHat())*sqr(uHat())+1345*pow<9,1>(tHat())*pow<3,1>(uHat())+1824*pow<8,1>(tHat())*pow<4,1>(uHat())+1806*pow<7,1>(tHat())*pow<5,1>(uHat())+1688*pow<6,1>(tHat())*pow<6,1>(uHat())+1806*pow<5,1>(tHat())*pow<7,1>(uHat())+1824*pow<4,1>(tHat())*pow<8,1>(uHat())+1345*pow<3,1>(tHat())*pow<9,1>(uHat())+616*sqr(tHat())*pow<10,1>(uHat())+144*tHat()*pow<11,1>(uHat())+12*pow<12,1>(uHat()))))/(3.*sHat()*pow<4,1>(M2-tHat())*tHat()*pow<4,1>(M2-uHat())*uHat()*pow<4,1>(tHat()+uHat()));
      // cerr << "testing spin correlations " << test << " " << me.average() << " "
      //      << abs(test-aver)/(test+aver) << "\n";
    }
    // g qbar -> 3P2 qbar
    else if(hard[1]->id()<0) {
      vector<VectorWaveFunction>    g1;
      vector<SpinorBarWaveFunction> q2;
      vector<SpinorWaveFunction>    q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
      SpinorWaveFunction(   q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0)=(2.*sqrt(2)*sqr(phase)*sqrt(-th)*uh)/pow<3,1>(M);
	me(0,0,1,0)=(2.*sqrt(2)*phase*sh*th*sqrt(-(uh/sh)))/sqr(M2);
	me(0,0,2,0)=(2.*sh*sqrt(-th)*th)/(sqrt(3)*pow<5,1>(M));
	me(0,1,0,1)=(-2.*sqrt(2)*sh*sqrt(-th)*sqr(uh))/(pow<3,1>(M)*sqr(th+uh));
	me(0,1,1,1)=(-2.*sqrt(2)*(M2+sh)*th*uh*sqrt(-(sh*uh)))/(sqr(M2)*phase*sqr(th+uh));
	me(0,1,2,1)=(2.*(sqr(M2)+4*M2*sh+sqr(sh))*(-th)*sqrt(-th)*uh)/(sqrt(3)*pow<5,1>(M)*sqr(phase)*sqr(th+uh));
	me(0,1,3,1)=(-2.*sqrt(2)*(M2+sh)*sqr(th)*sqrt(-(sh*uh)))/(sqr(M2)*pow(phase,3)*sqr(th+uh));
	me(0,1,4,1)=(-2.*sqrt(2)*sh*sqr(th)*sqrt(-th))/(pow<3,1>(M)*pow(phase,4)*sqr(th+uh));
	me(2,0,0,0)=(2.*sqrt(2)*pow(phase,4)*sh*sqr(th)*sqrt(-th))/(pow<3,1>(M)*sqr(th+uh));
	me(2,0,1,0)=(-2.*sqrt(2)*pow(phase,3)*(M2+sh)*sqr(th)*sqrt(-(sh*uh)))/(sqr(M2)*sqr(th+uh));
	me(2,0,2,0)=(2.*sqr(phase)*(sqr(M2)+4*M2*sh+sqr(sh))*sqrt(-th)*th*uh)/(sqrt(3)*pow<5,1>(M)*sqr(th+uh));
	me(2,0,3,0)=(-2.*sqrt(2)*phase*(M2+sh)*th*uh*sqrt(-(sh*uh)))/(sqr(M2)*sqr(th+uh));
	me(2,0,4,0)=(2.*sqrt(2)*sh*sqrt(-th)*sqr(uh))/(pow<3,1>(M)*sqr(th+uh));
	me(2,1,2,1)=(2.*sh*(-th)*sqrt(-th))/(sqrt(3)*pow<5,1>(M));
	me(2,1,3,1)=(2.*sqrt(2)*sh*th*sqrt(-(uh/sh)))/(sqr(M2)*phase);
	me(2,1,4,1)=(-2.*sqrt(2)*sqrt(-th)*uh)/(pow<3,1>(M)*sqr(phase));
      }
      else {
	me(0,0,0,0)=(-2.*sqrt(2)*pow(phase,3)*sqrt(-tHat())*uHat())/pow<3,1>(M);
	me(0,0,1,0)=(-2.*sqrt(2)*sqr(phase)*sqr(M2-sHat())*tHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(tHat()+uHat()));
	me(0,0,2,0)=(2.*phase*sqr(M2-sHat())*sHat()*(-tHat())*sqrt(-tHat()))/(sqrt(3)*pow<5,1>(M)*sqr(tHat()+uHat()));
	me(0,1,0,1)=(-2.*sqrt(2)*pow(phase,3)*sqrt(-tHat())*sqr(uHat())*(-M2+tHat()+uHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
	me(0,1,1,1)=(2.*sqrt(2)*sqr(phase)*(M2+sHat())*tHat()*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(tHat()+uHat()));
	me(0,1,2,1)=(2.*phase*(sqr(M2)+4*M2*sHat()+sqr(sHat()))*sqrt(-tHat())*tHat()*uHat())/(sqrt(3)*pow<5,1>(M)*sqr(tHat()+uHat()));
	me(0,1,3,1)=(-2.*sqrt(2)*sqr(tHat())*sqrt(-(uHat()/((M2-sHat())*sHat()*(tHat()+uHat()))))*(sqr(M2)+sqr(sHat())-M2*(tHat()+uHat())))/(sqr(M2)*(tHat()+uHat()));
	me(0,1,4,1)=(-2.*sqrt(2)*sqr(tHat())*sqrt(-tHat())*(-M2+tHat()+uHat()))/(pow<3,1>(M)*phase*sqr(tHat()+uHat()));
	me(2,0,0,0)=(2.*sqrt(2)*phase*sqr(tHat())*sqrt(-tHat())*(-M2+tHat()+uHat()))/(pow<3,1>(M)*sqr(tHat()+uHat()));
	me(2,0,1,0)=(-2.*sqrt(2)*sqr(tHat())*sqrt(-(uHat()/((M2-sHat())*sHat()*(tHat()+uHat()))))*(sqr(M2)+sqr(sHat())-M2*(tHat()+uHat())))/(sqr(M2)*(tHat()+uHat()));
	me(2,0,2,0)=(2.*(sqr(M2)+4*M2*sHat()+sqr(sHat()))*(-tHat())*sqrt(-tHat())*uHat())/(sqrt(3)*pow<5,1>(M)*phase*sqr(tHat()+uHat()));
	me(2,0,3,0)=(2.*sqrt(2)*(M2+sHat())*tHat()*uHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(phase)*sqr(tHat()+uHat()));
	me(2,0,4,0)=(2.*sqrt(2)*sqrt(-tHat())*sqr(uHat())*(-M2+tHat()+uHat()))/(pow<3,1>(M)*pow(phase,3)*sqr(tHat()+uHat()));
	me(2,1,2,1)=(2.*sqr(M2-sHat())*sHat()*sqrt(-tHat())*tHat())/(sqrt(3)*pow<5,1>(M)*phase*sqr(tHat()+uHat()));
	me(2,1,3,1)=(-2.*sqrt(2)*sqr(M2-sHat())*tHat()*sqrt(-(sHat()*uHat())))/(sqr(M2)*sqr(phase)*sqr(tHat()+uHat()));
	me(2,1,4,1)=(2.*sqrt(2)*sqrt(-tHat())*uHat())/(pow<3,1>(M)*pow(phase,3));
      }
      // Helicity code version
      for(unsigned int ih2=0;ih2<2;++ih2) {
	for(unsigned int ih4=0;ih4<2;++ih4) {
	  LorentzPolarizationVectorE fCurrent = q4[ih4].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
	  for(unsigned int ih3=0;ih3<5;++ih3) {
	    auto vfPre  = t3[ih3].wave().preDot(fCurrent);
	    auto vfPost = t3[ih3].wave().postDot(fCurrent);
	    auto vp1Pre = t3[ih3].wave().preDot(hard[0]->momentum());
	    auto vp1Post = t3[ih3].wave().postDot(hard[0]->momentum());
	    complex<Energy2> d11 = vp1Pre*hard[0]->momentum();
	    for(unsigned int ih1=0;ih1<2;++ih1) {
	      complex<Energy> d3=hard[2]->momentum()*g1[ih1].wave();
	      Complex amp =-1./sqr(M2)/M*(-2.*M2*(vfPre*hard[0]->momentum()*d3 + th*vfPre*g1[ih1].wave()
						  +2.*d11*(fCurrent*g1[ih1].wave()))
					  +(fCurrent*hard[2]->momentum())*(2.*(M2+th)*(vp1Pre*g1[ih1].wave())
									   -2.*(th-M2)*(vp1Post*g1[ih1].wave()))
					  -(th+M2)*((th-M2)*(vfPost*g1[ih1].wave())+2.*vfPost*hard[0]->momentum()*d3)
					  +sqr(M2)*(vfPre*g1[ih1].wave())+th*(2.*(vfPre*hard[0]->momentum())*d3+th*vfPre*g1[ih1].wave())
					  );
	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
		cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << " " << amp/me(2*ih1,ih2,ih3,ih4) << "\n";
	    }
	  }
	}
      }
    }
    // g q -> 3P2 q
    else if(hard[1]->id()<6) {
      vector<VectorWaveFunction> g1;
      vector<SpinorWaveFunction> q2;
      vector<SpinorBarWaveFunction> q4;
      VectorWaveFunction(   g1,hard[0],incoming,false,true,true,vector_phase);
      SpinorWaveFunction(   q2,hard[1],incoming,false,true);
      SpinorBarWaveFunction(q4,hard[3],outgoing,true ,true);
      g1[1]=g1[2];
      // matrix element
      me = ProductionMatrixElement(PDT::Spin1,PDT::Spin1Half,PDT::Spin2,PDT::Spin1Half);
      if(!swapped) {
	me(0,0,0,0)=(-2.*sqrt(2)*sqr(phase)*sqrt(-th)*uh)/pow<3,1>(M);
	me(0,0,1,0)=(-2.*sqrt(2)*phase*sh*th*sqrt(-(uh/sh)))/sqr(M2);
	me(0,0,2,0)=(2.*sh*(-th)*sqrt(-th))/(sqrt(3)*pow<5,1>(M));
	me(0,1,0,1)=(2.*sqrt(2)*sh*sqrt(-th)*sqr(uh))/(pow<3,1>(M)*sqr(th+uh));
	me(0,1,1,1)=(2.*sqrt(2)*(M2+sh)*th*uh*sqrt(-(sh*uh)))/(sqr(M2)*phase*sqr(th+uh));
	me(0,1,2,1)=(2.*(sqr(M2)+4*M2*sh+sqr(sh))*sqrt(-th)*th*uh)/(sqrt(3)*pow<5,1>(M)*sqr(phase)*sqr(th+uh));
	me(0,1,3,1)=(2.*sqrt(2)*(M2+sh)*sqr(th)*sqrt(-(sh*uh)))/(sqr(M2)*pow(phase,3)*sqr(th+uh));
	me(0,1,4,1)=(2.*sqrt(2)*sh*sqr(th)*sqrt(-th))/(pow<3,1>(M)*pow(phase,4)*sqr(th+uh));
	me(2,0,0,0)=(-2.*sqrt(2)*pow(phase,4)*sh*sqr(th)*sqrt(-th))/(pow<3,1>(M)*sqr(th+uh));
	me(2,0,1,0)=(2.*sqrt(2)*pow(phase,3)*(M2+sh)*sqr(th)*sqrt(-(sh*uh)))/(sqr(M2)*sqr(th+uh));
	me(2,0,2,0)=(2.*sqr(phase)*(sqr(M2)+4*M2*sh+sqr(sh))*(-th)*sqrt(-th)*uh)/(sqrt(3)*pow<5,1>(M)*sqr(th+uh));
	me(2,0,3,0)=(2.*sqrt(2)*phase*(M2+sh)*th*uh*sqrt(-(sh*uh)))/(sqr(M2)*sqr(th+uh));
	me(2,0,4,0)=(-2.*sqrt(2)*sh*sqrt(-th)*sqr(uh))/(pow<3,1>(M)*sqr(th+uh));
	me(2,1,2,1)=(2.*sh*sqrt(-th)*th)/(sqrt(3)*pow<5,1>(M));
	me(2,1,3,1)=(-2.*sqrt(2)*sh*th*sqrt(-(uh/sh)))/(sqr(M2)*phase);
	me(2,1,4,1)=(2.*sqrt(2)*sqrt(-th)*uh)/(pow<3,1>(M)*sqr(phase));
      }
      else {
	phase*=-1;
	me(0,0,0,0)=(2.*sqrt(2)*pow(phase,3)*sqrt(-th)*uh)/pow<3,1>(M);
	me(0,0,1,0)=(2.*sqrt(2)*sqr(phase)*sqr(M2-sh)*th*sqrt(-(sh*uh)))/(sqr(M2)*sqr(th+uh));
	me(0,0,2,0)=(2.*phase*sqr(M2-sh)*sh*sqrt(-th)*th)/(sqrt(3)*pow<5,1>(M)*sqr(th+uh));
	me(0,1,0,1)=(2.*sqrt(2)*pow(phase,3)*sqrt(-th)*sqr(uh)*(-M2+th+uh))/(pow<3,1>(M)*sqr(th+uh));
	me(0,1,1,1)=(-2.*sqrt(2)*sqr(phase)*(M2+sh)*th*uh*sqrt(-(sh*uh)))/(sqr(M2)*sqr(th+uh));
	me(0,1,2,1)=(2.*phase*(sqr(M2)+4*M2*sh+sqr(sh))*(-th)*sqrt(-th)*uh)/(sqrt(3)*pow<5,1>(M)*sqr(th+uh));
	me(0,1,3,1)=(2.*sqrt(2)*sqr(th)*sqrt(-(uh/((M2-sh)*sh*(th+uh))))*(sqr(M2)+sqr(sh)-M2*(th+uh)))/(sqr(M2)*(th+uh));
	me(0,1,4,1)=(2.*sqrt(2)*sqr(th)*sqrt(-th)*(-M2+th+uh))/(pow<3,1>(M)*phase*sqr(th+uh));
	me(2,0,0,0)=(-2.*sqrt(2)*phase*sqr(th)*sqrt(-th)*(-M2+th+uh))/(pow<3,1>(M)*sqr(th+uh));
	me(2,0,1,0)=(2.*sqrt(2)*sqr(th)*sqrt(-(uh/((M2-sh)*sh*(th+uh))))*(sqr(M2)+sqr(sh)-M2*(th+uh)))/(sqr(M2)*(th+uh));
	me(2,0,2,0)=(2.*(sqr(M2)+4*M2*sh+sqr(sh))*sqrt(-th)*th*uh)/(sqrt(3)*pow<5,1>(M)*phase*sqr(th+uh));
	me(2,0,3,0)=(-2.*sqrt(2)*(M2+sh)*th*uh*sqrt(-(sh*uh)))/(sqr(M2)*sqr(phase)*sqr(th+uh));
	me(2,0,4,0)=(-2.*sqrt(2)*sqrt(-th)*sqr(uh)*(-M2+th+uh))/(pow<3,1>(M)*pow(phase,3)*sqr(th+uh));
	me(2,1,2,1)=(2.*sqr(M2-sh)*sh*(-th)*sqrt(-th))/(sqrt(3)*pow<5,1>(M)*phase*sqr(th+uh));
	me(2,1,3,1)=(2.*sqrt(2)*sqr(M2-sh)*th*sqrt(-(sh*uh)))/(sqr(M2)*sqr(phase)*sqr(th+uh));
	me(2,1,4,1)=(-2.*sqrt(2)*sqrt(-th)*uh)/(pow<3,1>(M)*pow(phase,3));
      }
      // Helicity code version
      // for(unsigned int ih2=0;ih2<2;++ih2) {
      //   for(unsigned int ih4=0;ih4<2;++ih4) {
      //     LorentzPolarizationVectorE fCurrent = q2[ih2].dimensionedWave().vectorCurrent(q4[ih4].dimensionedWave());
      // 	  for(unsigned int ih3=0;ih3<5;++ih3) {
      // 	    auto vfPre  = t3[ih3].wave().preDot(fCurrent);
      // 	    auto vfPost = t3[ih3].wave().postDot(fCurrent);
      // 	    auto vp1Pre = t3[ih3].wave().preDot(hard[0]->momentum());
      // 	    auto vp1Post = t3[ih3].wave().postDot(hard[0]->momentum());
      // 	    complex<Energy2> d11 = vp1Pre*hard[0]->momentum();
      // 	    for(unsigned int ih1=0;ih1<2;++ih1) {
      // 	      complex<Energy> d3=hard[2]->momentum()*g1[ih1].wave();
      // 	      Complex amp = 1./sqr(M2)/M*(-2.*M2*(vfPre*hard[0]->momentum()*d3 + th*vfPre*g1[ih1].wave()
      // 						  +2.*d11*(fCurrent*g1[ih1].wave()))
      // 					  +(fCurrent*hard[2]->momentum())*(2.*(M2+th)*(vp1Pre*g1[ih1].wave())
      // 								      -2.*(th-M2)*(vp1Post*g1[ih1].wave()))
      // 					  -(th+M2)*((th-M2)*(vfPost*g1[ih1].wave())+2.*vfPost*hard[0]->momentum()*d3)
      // 					  +sqr(M2)*(vfPre*g1[ih1].wave())+th*(2.*(vfPre*hard[0]->momentum())*d3+th*vfPre*g1[ih1].wave())
      // 					  );
      // 	      double test = norm(amp/me(2*ih1,ih2,ih3,ih4)-1.);
      // 	      if(norm(me(2*ih1,ih2,ih3,ih4))>1e-10 && test>1e-10)
      // 		cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih3 << " " << ih4 << " "
      // 		     << amp << " " << me(2*ih1,ih2,ih3,ih4) << " " << test << " " << amp/me(2*ih1,ih2,ih3,ih4) << "\n";
      // 	    }
      //     }
      //   }
      // }
    }
    else
      assert(false);
  }
  else if(hard[0]->id()==-hard[1]->id()) {
    vector<SpinorWaveFunction>    q1;
    vector<SpinorBarWaveFunction> q2;
    vector<VectorWaveFunction>    g4;
    SpinorWaveFunction(   q1,hard[0],incoming,false,true);
    SpinorBarWaveFunction(q2,hard[1],incoming,false,true);
    VectorWaveFunction(   g4,hard[3],outgoing,true,true,true,vector_phase);
    g4[1]=g4[2];
    // matrix element
    me = ProductionMatrixElement(PDT::Spin1Half,PDT::Spin1Half,PDT::Spin2,PDT::Spin1);
    //   if(!swapped) {
    //     me(0,1,0,0) = -sqrt(2.*sh)*th/M2/M;
    //     me(0,1,0,2) = -exp(Complex(0.,-2.*phi))*sqrt(2.*sh)*uh/M2/M;
    //     me(1,0,0,0) =  exp(Complex(0., 2.*phi))*sqrt(2.*sh)*uh/M2/M;
    //     me(1,0,0,2) =  sqrt(2.*sh)*th/M2/M;
    //   }
    //   else {
    //     me(0,1,0,0) = -double(sqrt(2.*sh)*th/M2/M)*exp(Complex(0., 2.*phi));
    //     me(0,1,0,2) =  sqrt(2.*sh)*uh/M2/M;
    //     me(1,0,0,0) = -sqrt(2.*sh)*uh/M2/M;
    //     me(1,0,0,2) = -double(sqrt(2.*sh)*th/M2/M)*exp(Complex(0.,-2.*phi));
    //   }
    //   // Helicity code version
    //   // for(unsigned int ih1=0;ih1<2;++ih1) {
    //   //   for(unsigned int ih2=0;ih2<2;++ih2) {
    //   // 	LorentzPolarizationVectorE fCurrent = q1[ih1].dimensionedWave().vectorCurrent(q2[ih2].dimensionedWave());
    //   // 	for(unsigned int ih4=0;ih4<2;++ih4) {
    //   // 	  Complex amp = ((sh-M2)*(fCurrent*g4[ih4].wave())-2.*(hard[2]->momentum()*g4[ih4].wave())*(fCurrent*hard[3]->momentum()))/M2/M;
    //   // 	  if(norm(me(ih1,ih2,0,2*ih4))>1e-10)
    //   // 	    cerr << "testing in hel loop B " << ih1 << " " << ih2 << " " << ih4 << " "
    //   // 		 << amp << " " << me(ih1,ih2,0,2*ih4) << " " << amp/me(ih1,ih2,0,2*ih4)
    //   // 		 << " " << norm(amp/me(ih1,ih2,0,2*ih4)) << "\n";
    //   // 	}
    //   //   }
    //   // }
  }
  else
    assert(false);
  // construct the vertex
  HardVertexPtr hardvertex = new_ptr(HardVertex());
  // // set the matrix element for the vertex
  hardvertex->ME(me);
  // set the pointers and to and from the vertex
  for(unsigned int i = 0; i < hard.size(); ++i)
    hard[i]->spinInfo()->productionVertex(hardvertex);
  // boost back to lab
  boost = LorentzRotation(pcms.boostVector());
  for(PPtr part : hard)
    part->transform(boost);
}
