// -*- C++ -*-
//
// MEQCD2to2Fast.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the MEQCD2to2Fast class.
//

namespace Herwig {

inline MEQCD2to2Fast::MEQCD2to2Fast():_maxflavour(5),_process(0) {}

inline IBPtr MEQCD2to2Fast::clone() const {
  return new_ptr(*this);
}

inline IBPtr MEQCD2to2Fast::fullclone() const {
  return new_ptr(*this);
}

inline double MEQCD2to2Fast::gg2qqbarME() const {
  Energy2 u(uHat()),t(tHat()),s(sHat());
  Energy4 u2(sqr(u)),t2(sqr(t)),s2(sqr(s));
  double output =(1./6./u/t-3./8./s2)*(t2+u2);
  double flow[2]={u2/(u2+t2),t2/(u2+t2)};
  _flow = 1+UseRandom::rnd2(flow[0],flow[1]);
  _diagram=3+_flow;
  return output;
}

inline double MEQCD2to2Fast::qqbar2ggME() const {
  Energy2 u(uHat()),t(tHat()),s(sHat());
  Energy4 s2(sqr(s)),u2(sqr(u)),t2(sqr(t));
  double output = 0.5*(32./27./u/t-8./3./s2)*(t2+u2);
  double flow[2] = {u2/(u2+t2),t2/(t2+u2)};
  _flow=1+UseRandom::rnd2(flow[0],flow[1]);
  _diagram=6+_flow;
  return output;
}

inline double MEQCD2to2Fast::qg2qgME() const{
  Energy2 u(uHat()),t(tHat()),s(sHat());
  Energy4 s2(sqr(s)),u2(sqr(u)),t2(sqr(t));
  double output = (-4./9./s/u+1./t2)*(s2+u2);
  double flow[2]={u2/(s2+u2),s2/(s2+u2)};
  _flow=1+UseRandom::rnd2(flow[0],flow[1]);
  _diagram=9+_flow;
  return output;
}

inline double MEQCD2to2Fast::gg2ggME() const {
  Energy2 u(uHat()),t(tHat()),s(sHat());
  double output = 9./4.*(3.-t*u/s/s-s*u/t/t-s*t/u/u);
  double flow[3]={(1.-u*t/s/s-s*t/u/u+t*t/s/u),
		  (1.-t*u/s/s-s*u/t/t+u*u/s/t),
		  (1.-t*s/u/u-u*s/t/t+s*s/u/t)};
  _flow = 1+UseRandom::rnd3(flow[0],flow[1],flow[2]);
  double diag[3]={(sqr(u)+sqr(t))/sqr(s),
		  (sqr(s)+sqr(u))/sqr(t),
		  (sqr(s)+sqr(t))/sqr(u)};
  if(_flow==1)      diag[1]=0;
  else if(_flow==2) diag[2]=0;
  else if(_flow==3) diag[0]=0;
  _diagram=1+UseRandom::rnd3(diag[0],diag[1],diag[2]);
  return output;
}

inline double MEQCD2to2Fast::qbarg2qbargME() const {
  // scale
  Energy2 u(uHat()),t(tHat()),s(sHat());
  Energy4 u2(sqr(u)),s2(sqr(s)); // t2(sqr(t))
  double flow[2]={u2/(s2+u2),s2/(s2+u2)};
  _flow=1+UseRandom::rnd2(flow[0],flow[1]);
  _diagram=12+_flow;
  return (-4./9./s/u+1./t/t)*(s*s+u*u);
}

inline double MEQCD2to2Fast::qq2qqME() const {
  Energy2 u(uHat()),t(tHat());
  Energy4 s2(sqr(sHat())),u2(sqr(u)),t2(sqr(t));
  double output;
  if(mePartonData()[0]->id()==mePartonData()[1]->id()) {
    output = 0.5*(4./9.*((s2+u2)/t2+(s2+t2)/u2)
		  -8./27.*s2/u/t);
    double flow[2]={(s2+u2)/t2,(s2+t2)/u2}; 
    _flow=1+UseRandom::rnd2(flow[0],flow[1]);
  }
  else {
    output = 4./9.*(s2+u2)/t2;
    _flow=2;
  }
  _diagram = 15+_flow;
  return output;
}

inline double MEQCD2to2Fast::qbarqbar2qbarqbarME() const {
  Energy2 u(uHat()),t(tHat());
  Energy4 u2(sqr(u)),t2(sqr(t)),s2(sqr(sHat()));
  double output;
  if(mePartonData()[0]->id()==mePartonData()[1]->id()) {
    output = 0.5*(4./9.*((s2+u2)/t2+(s2+t2)/u2)
		  -8./27.*s2/u/t);
    double flow[2]={(s2+u2)/t2,(s2+t2)/u2};
    _flow=1+UseRandom::rnd2(flow[0],flow[1]);
  }
  else {
    output = 4./9.*(s2+u2)/t2;
    _flow = 2;
  }
  _diagram = 17+_flow;
  // final part of colour and spin factors
  return output;
}

inline double MEQCD2to2Fast::qqbar2qqbarME() const {
  // type of process
  bool diagon[2]={mePartonData()[0]->id()== -mePartonData()[1]->id(),
		  mePartonData()[0]->id()==  mePartonData()[2]->id()};
  // scale
  Energy2 u(uHat()),t(tHat()),s(sHat());
  Energy4 s2(sqr(s)),t2(sqr(t)),u2(sqr(u));
  double output;
  if(diagon[0]&&diagon[1]) {
    output= (4./9.*((s2+u2)/t2+(u2+t2)/s2)
	     -8./27.*u2/s/t);
    double flow[2]={(t2+u2)/s2,(s2+u2)/t2};
    _flow=1+UseRandom::rnd2(flow[0],flow[1]);
  }
  else if(diagon[0]) {
    output = (4./9.*(t2+u2)/s2);
    _flow=1;
  }
  else {
    output = (4./9.*(s2+u2)/t2);
    _flow=2;
  }
  _diagram=19+_flow;
  return output;
}

}
