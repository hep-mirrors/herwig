// Template MadGraph process file for 2->2 process
// Replace process-specific marked values with values 
// taken from CPPProcess.cc file generated by MadGraph

#include "MG_process.h"
#include "HelAmps_mssm.h"
#include <iostream>

using namespace MG5_mssm; 

//--------------------------------------------------------------------------
// Initialize process.

void MG_process::initProc(string param_card_name) 
{
  // Instantiate the model class and set parameters using param_card
  pars = Parameters_mssm::getInstance(); 
  SLHAReader slha(param_card_name); 
  pars->setIndependentParameters(slha); 
  pars->setIndependentCouplings(); 

  // Set external particle masses for this matrix element
  // order depends on the ordering of particles in MB amplitude

  // ** Replace pars->ZERO with particle mass (also stored in pars)
  mME.push_back(pars->ZERO); 
  mME.push_back(pars->ZERO); 
  mME.push_back(pars->ZERO); 
  mME.push_back(pars->ZERO); 
}

void MG_process::initProc(map<string, double> & MGParams) 
{
  // Instantiate the model class and set parameters using Herwig++ values
  pars = Parameters_mssm::getInstance(); 
  pars->setIndependentParameters(MGParams); 
  pars->setIndependentCouplings(); 

  // Set external particle masses for this matrix element
  // order depends on the ordering of particles in MB amplitude

  // ** Replace pars->ZERO with particle mass (also stored in pars)
  mME.push_back(pars->ZERO); 
  mME.push_back(pars->ZERO); 
  mME.push_back(pars->ZERO); 
  mME.push_back(pars->ZERO); 
  
}


//--------------------------------------------------------------------------
// Evaluate helicity amplitudes

void MG_process::sigmaKin(vector<complex<double> >& amps, const vector<int>& hel) 
{
  // Set the parameters which change event by event
  pars->setDependentParameters(); 
  pars->setDependentCouplings(); 

  // Reset the matrix elements
  for(int i = 0; i < namplitudes; i++ )
    amp[i] = 0.; 
 
  int helicities[1][nexternal] = {{hel[0], hel[1], hel[2], hel[3]}};

  calculate_wavefunctions(helicities[0]);   
  for (int ir=0; ir<namplitudes; ++ir)
    amps.push_back(amp[ir]);
    
  return;
    
}


//==========================================================================
// Private class member functions

//--------------------------------------------------------------------------
// Evaluate amplitude for each subprocess

void MG_process::calculate_wavefunctions(const int hel[])
{

  // ** Replace entire function 

  // Calculate all wavefunctions
  // switch order of momenta and helicities to account for order of particles in MB
  // eg for q q_bar -> stop stop_bar
  ixxxxx(p[2], mME[2], hel[2], +1, w[0]); 
  oxxxxx(p[3], mME[3], hel[3], -1, w[1]); 
  sxxxxx(p[0], +1, w[2]); 
  sxxxxx(p[1], +1, w[3]); 
  swap(w[0],w[1]);

  // use helicity amplitudes in HelAmps_mssm to evaluate amp
  FFV1_3(w[0], w[1], pars->GC_7, pars->ZERO, pars->ZERO, w[4]); 
  VSS1_0(w[4], w[3], w[2], pars->GC_55, amp[0]); 

}

// matrix_process() not used but has info about colour flows 
// needed in MatchboxAmplitudeTemplate::evaluate

// double MG_process::matrix_process() 
// {
//   int i, j; 
//   // Local variables
//   const int ngraphs = 1; 
//   const int ncolor = 2; 
//   std::complex<double> ztemp; 
//   std::complex<double> jamp[ncolor]; 
//   // The color matrix;
//   static const double denom[ncolor] = {1, 1}; 
//   static const double cf[ncolor][ncolor] = {{9, 3}, {3, 9}}; 

//   // Calculate color flows
//   jamp[0] = +1./2. * (-1./3. * amp[0]); 
//   jamp[1] = +1./2. * (+amp[0]); 

//   // Sum and square the color flows to get the matrix element
//   double matrix = 0; 
//   for(i = 0; i < ncolor; i++ )
//   {
//     ztemp = 0.; 
//     for(j = 0; j < ncolor; j++ )
//       ztemp = ztemp + cf[i][j] * jamp[j]; 
//     matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
//   }

//   // Store the leading color flows for choice of color
//   //for(i = 0; i < ncolor; i++ )
//   //jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 

//   return matrix; 
// }
