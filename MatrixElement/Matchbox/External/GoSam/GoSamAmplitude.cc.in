// -*- C++ -*-
//
// GoSamAmplitude.cc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2012 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the non-inlined, non-templated member
// functions of the GoSamAmplitude class.
//

#include "GoSamAmplitude.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/RefVector.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/Interface/Command.h"

#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"
#include "ThePEG/Utilities/StringUtils.h"

#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>

using namespace Herwig;

GoSamAmplitude::GoSamAmplitude() {theCodeExists=false;isitDR=false;thePrintParameter=true;theFormOpt=true;theNinja=true;
}

GoSamAmplitude::~GoSamAmplitude() {
}

IBPtr GoSamAmplitude::clone() const {
	return new_ptr(*this);
}

IBPtr GoSamAmplitude::fullclone() const {
	return new_ptr(*this);
}

extern "C" void OLP_Start(const char*, int* i);
extern "C" void OLP_Polvec(double*, double*, double*);
extern "C" void OLP_SetParameter(char*, double*, double*, int*);
extern "C" void OLP_PrintParameter(char*);
extern "C" void OLP_EvalSubProcess2(int*, double*, double*, double*, double*);

void GoSamAmplitude::signOLP(const string& order, const string& contract) {
	if(!theCodeExists){
	  generator()->log() << "\n>>> generating GoSam amplitudes. This may take some time, please be patient.\n"
			     << ">>> see gosam-amplitudes.log for details.\n" << flush;
	  string cmd = "@GOSAMPREFIX@/bin/gosam.py --olp  -o " + contract + "  --config=" + 
	    gosamSetupInFileName + " --destination=" + gosamSourcePath + " " + order + " > gosam-amplitudes.log 2>&1";
	  std::system(cmd.c_str());
	}
}

bool GoSamAmplitude::buildGoSam() {
	if(!theCodeExists){
	  generator()->log() << "\n>>> compiling GoSam amplitudes. This may take some time, please be patient.\n"
			     << ">>> see " + gosamSourcePath + "/gosam-build.log for details\n\n" << flush;
	  string cmd = "cd " + gosamSourcePath + " && sh autogen.sh FCFLAGS=-g --prefix=" + 
	    gosamInstallPath + " > gosam-build.log 2>&1";
	  std::system(cmd.c_str());
	  if (!gosamBuildScript.empty()) {
		  cmd = "cd " + gosamSourcePath + " && " + gosamBuildScript + " >> gosam-build.log 2>&1";
		  std::system(cmd.c_str());
	  }
	  std::system(cmd.c_str());
	  cmd = "cd " + gosamSourcePath + " && make install >> gosam-build.log 2>&1";
	  std::system(cmd.c_str());
	}
	theCodeExists=true;
	return 1;
}

void GoSamAmplitude::startOLP(const string& contract, int& status) {
	string tempcontract = contract;
	if (gosamPathInterface==""){
	  if ( !( DynamicLoader::load("GoSam/build/lib/libgolem_olp.so") || DynamicLoader::load("GoSam/build/lib64/libgolem_olp.so") ) ) assert(0);
	  tempcontract = "GoSam/" + tempcontract;
	}
	else {
	  if ( !( DynamicLoader::load(gosamPathInterface+"/build/lib/libgolem_olp.so") || DynamicLoader::load(gosamPathInterface+"/build/lib64/libgolem_olp.so") ) ) assert(0);
		tempcontract = gosamPathInterface + "/" + tempcontract;
	}
	OLP_Start(tempcontract.c_str(), &status);

	// hand over input parameters for EW scheme considered
	
	int pStatus = 0;
	double zero = 0.0;
	if ( SM().ewScheme() == 0 || SM().ewScheme() == 6 ) { // EW/Scheme Default and EW/Scheme Independent
	  throw Exception() << "`Best value' schemes are not supported by GoSam"
			    << Exception::abortnow;
	} else if ( SM().ewScheme() == 4 ) { // EW/Scheme mW (uses mW,GF,sin2thetaW) seems not to be supported by GoSam
	  throw Exception() << "`mW' scheme is not supported by GoSam"
			    << Exception::abortnow;
	} else if ( SM().ewScheme() == 1 ) { // EW/Scheme GMuScheme (uses mW,mZ,GF)
	  double in1=getParticleData(ParticleID::Z0)->mass()/GeV;
	  double in2=getParticleData(ParticleID::Wplus)->mass()/GeV;
	  double in3=SM().fermiConstant()*GeV2;
	  OLP_SetParameter((char *)"mass(23)",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"mass(24)",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"Gf",&in3,&zero,&pStatus);
	} else if ( SM().ewScheme() == 2 ) { // EW/Scheme alphaMZScheme (uses mW,mZ,alpha(mZ))
	  double in1=getParticleData(ParticleID::Z0)->mass()/GeV;
	  double in2=getParticleData(ParticleID::Wplus)->mass()/GeV;
	  double in3=SM().alphaEMMZ();
	  OLP_SetParameter((char *)"mass(23)",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"mass(24)",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"alpha",&in3,&zero,&pStatus);
	} else if ( SM().ewScheme() == 3 ) { // EW/Scheme NoMass (uses alpha(mZ),GF,sin2thetaW)
	  double in1=SM().fermiConstant()*GeV2;
	  double in2=SM().alphaEMMZ();
	  double in3=SM().sin2ThetaW();
	  OLP_SetParameter((char *)"Gf",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"alpha",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"sw2",&in3,&zero,&pStatus);
	} else if ( SM().ewScheme() == 5 ) { // EW/Scheme mZ (uses mZ,alphaEM,sin2thetaW)
	  double in1=getParticleData(ParticleID::Z0)->mass()/GeV;
	  double in2=SM().alphaEMMZ();
	  double in3=SM().sin2ThetaW();
	  OLP_SetParameter((char *)"mass(23)",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"alpha",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"sw2",&in3,&zero,&pStatus);
	}
	
	// hand over input parameter for alphaS

	double as = SM().alphaS();
	OLP_SetParameter((char *)"alphaS", &as, &zero, &pStatus);

        // hand over quark masses and widths (iff massive)

	string mstr;
	string wstr;
	if (massiveParticles.empty())
	  for (int i=1; i<=6; ++i) 
	    if (getParticleData(i)->mass()/GeV > 0.0) massiveParticles.push_back(i);
	
	if ( massiveParticles.size() != 0 ) {
	  for ( vector<int>::const_iterator mID = massiveParticles.begin(); mID != massiveParticles.end(); ++mID ) {
	    int mInt = *mID;
	    double mass=getParticleData(mInt)->mass()/GeV;
	    double width=getParticleData(mInt)->width()/GeV;
	    std::stringstream ss;
	    ss << mInt;
	    string str = ss.str();
	    mstr="mass("+str+")";
	    wstr="width("+str+")";
	    char * mchar = new char[mstr.size()+1];
	    char * wchar = new char[wstr.size()+1];
	    std::copy(mstr.begin(),mstr.end(),mchar);
	    std::copy(wstr.begin(),wstr.end(),wchar);
	    mchar[mstr.size()] = '\0';
	    wchar[wstr.size()] = '\0';
	    OLP_SetParameter( mchar, &mass, &zero, &pStatus );
	    OLP_SetParameter( wchar, &width, &zero, &pStatus );
	    delete[] mchar;
	    delete[] wchar;
          }
	}

//         // hand over b- and t-quark widths
//         double wB = getParticleData(5)->width()/GeV;
//         double wT = getParticleData(6)->width()/GeV;
//         OLP_SetParameter((char*)"width(5)",&wB,&zero,&pStatus);
//         OLP_SetParameter((char*)"width(6)",&wT,&zero,&pStatus);

        // Note: In the GoSam input file, the standard is to set the parameter 
	// 'symmetries' for quark families and lepton generations, which allow
	// for flavour changing only between families/generations. If this pa-
	// rameter is set, GoSam won't allow to set electron and muon mass and
	// width via the interface. Also setting mass and width for the tau is 
	// not yet considered.

        // print OLP parameters

	if (thePrintParameter) {
	  char char_cwd[256];
	  getcwd(char_cwd, sizeof(char_cwd));
	  gosamPath = gosamPathInterface == "" ? string(char_cwd) + "/GoSam" : gosamPathInterface;
	  string ppstr = gosamPath + "/" + name() + ".OLPParameters.lh";
	  char * ppchar = new char[ppstr.size()+1];
	  std::copy(ppstr.begin(),ppstr.end(),ppchar);
	  ppchar[ppstr.size()] = '\0';
	  OLP_PrintParameter(ppchar);
	  delete[] ppchar;
	}

}

void GoSamAmplitude::fillOrderFile(const map<pair<Process, int>, int>& procs, string orderFileName) {

  for ( map<pair<Process, int>, int>::const_iterator p = procs.begin() ; p != procs.end() ; ++p ) {
    std::stringstream Processstr;
    std::stringstream Typestr;
    int partonlegs = 0;
    for ( PDVector::const_iterator o = (*p).first.first.legs.begin(); o != (*p).first.first.legs.end() ; ++o )
      if ( (**o).coloured() ) partonlegs += 1;
    int totcplpow = (*p).first.first.orderInAlphaS + (*p).first.first.orderInAlphaEW;
    int totnumleg = (*p).first.first.legs.size();
    int nonpartonlegs = totnumleg - partonlegs;
    Processstr << (*p).first.first.legs[0]->id() << " " << (*p).first.first.legs[1]->id() << " -> ";
    for ( PDVector::const_iterator o = (*p).first.first.legs.begin() + 2 ; o != (*p).first.first.legs.end() ; ++o )
      Processstr << (**o).id() << " ";
      // if ( (*p).first.second == ProcessType::treeME2 ) {
      //   Typestr << "Tree";
    if ( (*p).first.second == ProcessType::treeME2 && totcplpow != totnumleg ) {
      Typestr << "Tree";
    } else if ( (*p).first.second == ProcessType::treeME2 && totcplpow == totnumleg ) {
      Typestr << "LoopInduced";
    } else if ( (*p).first.second == ProcessType::colourCorrelatedME2 ) {
      Typestr << "ccTree";
    } else if ( (*p).first.second == ProcessType::spinColourCorrelatedME2 ) {
      Typestr << "scTree";
    } else if ( (*p).first.second == ProcessType::oneLoopInterference ) {
      Typestr << "Loop";
    }
    gosamprocinfo pro = gosamprocinfo((*p).second, -1, Processstr.str(), Typestr.str());
    pro.setOAs(p->first.first.orderInAlphaS);
    pro.setOAew(p->first.first.orderInAlphaEW);
    pro.setPartonLegs(partonlegs);
    pro.setNonPartonLegs(nonpartonlegs);
    processmap[(*p).second] = pro;
  }

  ifstream oldOrderFileStream(orderFileName.c_str());
  if (oldOrderFileStream){
    oldOrderFileStream.close();
    return;
  }
	ofstream orderFile(orderFileName.c_str());
	int asPower = 100;
	int minlegs = 100;
	int maxlegs = -1;
	int maxasPower = -1;
	int aewPower = 100;
	int maxaewPower = -1;

	for ( map<pair<Process, int>, int>::const_iterator t = procs.begin() ; t != procs.end() ; ++t ) {
	  asPower = min(asPower, static_cast<int>(t->first.first.orderInAlphaS));
	  minlegs = min(minlegs, static_cast<int>(t->first.first.legs.size()));
	  maxlegs = max(maxlegs, static_cast<int>(t->first.first.legs.size()));
	  maxasPower = max(maxasPower, static_cast<int>(t->first.first.orderInAlphaS));
	  aewPower = min(aewPower, static_cast<int>(t->first.first.orderInAlphaEW));
	  maxaewPower = max(maxaewPower, static_cast<int>(t->first.first.orderInAlphaEW));
	}

	orderFile << "# OLP order file created by Herwig++/Matchbox for GoSam\n\n";
	orderFile << "InterfaceVersion         BLHA2\n";
	orderFile << "MatrixElementSquareType  CHsummed\n";
	orderFile << "CorrectionType           QCD\n";
	orderFile << "IRregularisation         " << (isDR() ? "DRED" : "CDR") << "\n";
  // loop over quarks to check if they have non-zero masses
  for (int i=1; i<=6; ++i) if (getParticleData(i)->mass()/GeV > 0.0) massiveParticles.push_back(i);
	if ( massiveParticles.size() != 0 ) {
	  orderFile << "MassiveParticles         ";
	  for ( vector<int>::const_iterator mID = massiveParticles.begin(); mID != massiveParticles.end(); ++mID ) {
	    int mInt = *mID;
	    orderFile << mInt << " ";
      }
	  orderFile << "\n";
    }
	orderFile << "\n";

	vector < string > types;
	types.push_back("Tree");
	types.push_back("LoopInduced");
	types.push_back("ccTree");
	types.push_back("scTree");
	types.push_back("Loop");

	// for ( int i = asPower ; i != asPower + maxlegs - minlegs + 1 ; i++ ) {
	for ( int i = asPower ; i != maxasPower + 1 ; i++ ) {
	for ( int j = aewPower ; j != maxaewPower + 1 ; j++ ) {
	  // orderFile << "\n\nAlphasPower              " << i;
	  orderFile << "\nAlphasPower              " << i << "\n";
	  orderFile << "AlphaPower              " << j << "\n";
	  for ( vector<string>::iterator it = types.begin() ; it != types.end() ; it++ ) {
	    if ( *it == "LoopInduced" ) continue;
	    for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; ++p )
	      // if ( (*p).second.Tstr() == *it && i == (*p).second.orderAs() ) {
	      if ( (*p).second.Tstr() == *it && i == (*p).second.orderAs() && j == (*p).second.orderAew() ) {
	        orderFile << "\nAmplitudeType " << *it << "\n";
		break;
	      }
	    for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; ++p )
	      // if ( (*p).second.Tstr() == *it && i == (*p).second.orderAs() ) {
	      if ( (*p).second.Tstr() == *it && i == (*p).second.orderAs() && j == (*p).second.orderAew() ) {
	        orderFile << (*p).second.Pstr() << "\n";
	      }
	  }
	}
	}

        // Write out the loop induced processes separately
        int asPowerLI = 100;
        int aewPowerLI = 100;
        bool qcdLI=false;
        bool qedLI=false;
        for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; ++p ) {
          if ( (*p).second.Tstr() != "LoopInduced" ) continue;
          if ( (*p).second.getPartonLegs() == (*p).second.orderAs() ) qcdLI = true;
          // else if ( (*p).second.getNonPartonLegs() == (*p).second.orderAew() ) qedLI = true;
          if ( (*p).second.getNonPartonLegs() == (*p).second.orderAew() ) qedLI = true;
          if ( (*p).second.orderAs() != asPowerLI || (*p).second.orderAs() != asPowerLI ) {
            asPowerLI = (*p).second.orderAs();
            aewPowerLI = (*p).second.orderAew();
            // At the moment GoSam requires for loop induced processes the coupling power 
	    // which would correspond to an associated  fictitious Born process
            orderFile << "\nAlphasPower              " << (qcdLI ? (asPowerLI-2) : asPowerLI) << "\n";
            orderFile << "AlphaPower              " << (qedLI ? (aewPowerLI-2) : aewPowerLI) << "\n";
            orderFile << "\nAmplitudeType " << "LoopInduced" << "\n";
          }
          orderFile << (*p).second.Pstr() << "\n";
        }

	orderFile << flush;

}

bool GoSamAmplitude::checkOLPContract(string contractFileName) {
	ifstream infile(contractFileName.c_str());
	string line;
	vector < string > contractfile;
	while (std::getline(infile, line)) {
		contractfile.push_back(line);
	}
	for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; p++ ) {
	  bool righttype = false;
	  for ( vector<string>::iterator linex = contractfile.begin() ; linex != contractfile.end() ; ++linex ) {
	    if ( (*linex).find("AmplitudeType ")!= std::string::npos ) {
	      if ( (*linex).find(" " + (*p).second.Tstr() + " ")!= std::string::npos ) {
	        righttype = true;
	      } else {
	        righttype = false;
	      }
	    }
	    if ( righttype ) {
	      if ( (*linex).find((*p).second.Pstr()) != std::string::npos && (*p).second.Pstr().length() == (*linex).find("|") ) {
	        string sub = (*linex).substr((*linex).find("|") + 1, (*linex).find("#") - (*linex).find("|") - 1); // | 1 23 # buggy??
		if ( sub.find(" 1 ") != 0 ) assert(0);
		string subx = sub.substr(3);
		int subint;
		istringstream(subx) >> subint;
		(*p).second.setGID(subint);
	      }
	    }
	  }
	}
	string ids = "GoSam_ids.dat";
	ofstream IDS(ids.c_str());

	for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; p++ ) {
	    idpair.insert ( std::pair<int,int>((*p).second.HID(),(*p).second.GID()) );
	    // IDS << (*p).second.HID() << " " << (*p).second.GID() << "\n";
	    IDS << (*p).second.HID() << " " << (*p).second.GID() << " " << (*p).second.Tstr() << "\n";
	    if ( (*p).second.GID() == -1 ) return 0;
	}
	IDS << flush;

	return 1;

}

void GoSamAmplitude::getids() const {
	string line = "GoSam_ids.dat";
	ifstream infile(line.c_str());
	int hid;
	int gid;
	string type;
	while (std::getline(infile, line)) {
	 // istringstream(line) >> hid>>gid;
	 istringstream(line) >> hid>>gid>>type;
	 idpair.insert ( std::pair<int,int>(hid,gid) );
	 idtypepair.insert ( std::pair<int,string>(hid,type) );
	}
}


bool GoSamAmplitude::startOLP(const map<pair<Process, int>, int>& procs) {
  //cout << "\nWriting the olp-order file." << flush;

  string cmd = "";
  char char_cwd[256];
  getcwd(char_cwd, sizeof(char_cwd));
  string cwd = string(char_cwd);

  // set all necessary path and file names
  gosamPath = gosamPathInterface == "" ? cwd + "/GoSam" : gosamPathInterface;
  gosamSourcePath = gosamPath + "/source";
  gosamInstallPath = gosamPath + "/build";

  // create all the directories
  std::system(("mkdir " + gosamPath).c_str());
  std::system(("mkdir " + gosamSourcePath).c_str());
  std::system(("mkdir " + gosamInstallPath).c_str());

	contractFileTitle = name() + ".OLPContract.lh";
	parametersFileTitle = name() + ".OLPParameters.lh";
  string orderFileName = gosamPath + "/" + name() + ".OLPOrder.lh";
	contractFileName = gosamPath  + "/" + contractFileTitle;
  gosamSetupInFileName = gosamSetupInFilenameInterface == "" ? gosamPath + "/setup.gosam.in" : gosamSetupInFilenameInterface;

	// check for old order file and create it if it doesn't already exist
	fillOrderFile(procs, orderFileName);

  // check if setup.gosam.in exists
  ifstream infile(gosamSetupInFileName.c_str());
  if (!infile) {
    // if it doesn't get it from src/defaults
    string cmd = "cp @prefix@/share/Herwig++/defaults/setup.gosam.in " + gosamSetupInFileName;
    std::system(cmd.c_str());
    // set form's tempdir to the current working directory
    cmd = "sed -i 's/@FORMTEMPDIR@/" + StringUtils::replace(gosamSourcePath, string("/"), string("\\/")) + "/g' " + gosamSetupInFileName;
    std::system(cmd.c_str());
    cmd = "sed -i 's/@REDUCTIONPROGRAMS@/" + (theNinja ? string("ninja, golem95") : string("samurai, golem95")) + "/g' " + gosamSetupInFileName;
    std::system(cmd.c_str());
    if (theNinja) generator()->log() << "\nGoSam will use Ninja as reduction program.\n" << flush;
    else if (!theNinja) generator()->log() << "\nGoSam will use Samurai as reduction program.\n" << flush;
    if (theFormOpt) generator()->log() << "Form optimization switched on.\n" << flush;
    else if (!theFormOpt) generator()->log() << "Form optimization switched off.\n" << flush;
    if (theNinja && !theFormOpt) throw Exception() << "Ninja reduction needs form optimization!\n" << Exception::abortnow;
    cmd = "sed -i 's/@FORMOPT@/" + (theFormOpt ? string("") : string(", noformopt")) + "/g' " + gosamSetupInFileName;
    std::system(cmd.c_str());
  }
  infile.close();

  ifstream ifile(contractFileName.c_str());
  if(!ifile){
    //cout << "\nGoSam: Sign the order file." << flush;
    signOLP(orderFileName, contractFileName);
	}
	
	if ( !checkOLPContract(contractFileName) ) {
	  throw Exception() << "failed to start GoSam" << Exception::abortnow;
	}
	
	if (!( DynamicLoader::load(gosamInstallPath+"/lib/libgolem_olp.so") || DynamicLoader::load(gosamInstallPath+"/lib64/libgolem_olp.so"))) buildGoSam();
	
	int status = -1;
	startOLP(contractFileTitle, status);

	if ( status != 1 ) return false;

	return true;

}

LorentzVector<Complex> GoSamAmplitude::plusPolarization(const Lorentz5Momentum& p, const Lorentz5Momentum& n, int inc) const {

	double pvec[4] = {p.t()/GeV,p.x()/GeV,p.y()/GeV,p.z()/GeV};
	double nvec[4] = {n.t()/GeV,n.x()/GeV,n.y()/GeV,n.z()/GeV};
	double out[8] ={ };
	OLP_Polvec(pvec,nvec,out);

	LorentzVector<Complex> res;
	Complex a(out[0],out[1]);
	res.setT(a);
	Complex b(out[2],out[3]);
	res.setX(b);
	Complex c(out[4],out[5]);
	res.setY(c);
	Complex d(out[6],out[7]);
	res.setZ(d);
	
	if (inc<2)
	  return res.conjugate();
	else 
	  return res;

}

void GoSamAmplitude::evalSubProcess() const {
  useMe();
	double units = pow(lastSHat() / GeV2, mePartonData().size() - 4.);
	fillOLPMomenta(lastXComb().meMomenta());

	double scale = sqrt(mu2() / GeV2);

	double out[7] = { };
	if ( idpair.size() == 0 ) {
	  getids();
	}
	int id = olpId()[ProcessType::oneLoopInterference] ? olpId()[ProcessType::oneLoopInterference] : olpId()[ProcessType::treeME2];
         //cout<<"\n"<<id<<" "<<idpair[id];
	 int callid(idpair.find(id)->second); // If id denotes the Herwig ID, this returns the GoSam ID
	 string calltype(idtypepair.find(id)->second); // If id denotes the Herwig ID, this returns the amplitude type
         double acc;
	OLP_EvalSubProcess2(&(callid), olpMomenta(), &scale, out, &acc);

	if ( olpId()[ProcessType::oneLoopInterference] ) {
	  if(calculateTreeME2())lastTreeME2(out[3] * units);
	  lastOneLoopInterference((out[2])* units);
	  lastOneLoopPoles(pair<double, double>(out[0] * units, out[1] * units));
	// } else if ( olpId()[ProcessType::treeME2] ) {
	//   lastTreeME2(out[3] * units);
	// }
	} else if ( olpId()[ProcessType::treeME2] && calltype=="Tree" ) {
	  lastTreeME2(out[3] * units);
	} else if ( olpId()[ProcessType::treeME2] && calltype=="LoopInduced" ) {
	  lastTreeME2(out[2] * units);
	}

}

void GoSamAmplitude::evalColourCorrelator(pair<int, int> ) const {
	double units = pow(lastSHat() / GeV2, mePartonData().size() - 4.);
	fillOLPMomenta(lastXComb().meMomenta());

	double scale = sqrt(mu2() / GeV2);

	int n = lastXComb().meMomenta().size();
	colourCorrelatorResults.resize(n * (n - 1) / 2);
	if ( idpair.size() == 0 ) {
	  getids();
	}
	int callid((*(idpair.find(olpId()[ProcessType::colourCorrelatedME2]))).second);
    double acc;
	OLP_EvalSubProcess2(&(callid), olpMomenta(), &scale, &colourCorrelatorResults[0], &acc);

	cPDVector particles = lastXComb().matrixElement()->mePartonData();
	
	for ( int i = 0 ; i < n ; ++i ) {
	  for ( int j = i + 1 ; j < n ; ++j ) {
	    lastColourCorrelator(make_pair(i, j), colourCorrelatorResults[i+j*(j-1)/2] * units);
          }
	}

}

void GoSamAmplitude::evalSpinColourCorrelator(pair<int , int > ) const {
	double units = pow(lastSHat() / GeV2, mePartonData().size() - 4.);
	fillOLPMomenta(lastXComb().meMomenta());

	double scale = sqrt(mu2() / GeV2);

	int n = lastXComb().meMomenta().size();
	spinColourCorrelatorResults.resize(2*n*n);
	if ( idpair.size() == 0 ) {
	  getids();
	}
    double acc;
	int callid((*(idpair.find(olpId()[ProcessType::spinColourCorrelatedME2]))).second);
	OLP_EvalSubProcess2(&(callid), olpMomenta(), &scale, &spinColourCorrelatorResults[0], &acc);

        for ( int i = 0; i < n; ++i )
        for ( int j = 0; j < n; ++j ) {
       	  Complex scc(spinColourCorrelatorResults[2*i+2*n*j]*units, spinColourCorrelatorResults[2*i+2*n*j+1]*units);
	  lastColourSpinCorrelator(make_pair(i,j),scc);
        }

}

void GoSamAmplitude::doinit() {
  HandlerBase::standardModel()->ewScheme(1);
  HandlerBase::standardModel()->init();
  MatchboxOLPME::doinit();
}

void GoSamAmplitude::doinitrun() {
  MatchboxOLPME::doinitrun();
}


// If needed, insert default implementations of virtual function defined
// in the InterfacedBase class here (using ThePEG-interfaced-impl in Emacs).


void GoSamAmplitude::persistentOutput(PersistentOStream & os) const {
	os << idpair << theCodeExists << massiveParticles << thePrintParameter << gosamPathInterface << gosamSetupInFilenameInterface << gosamBuildScript << theFormOpt << theNinja;
}

void GoSamAmplitude::persistentInput(PersistentIStream & is, int) {
	is >> idpair >> theCodeExists >> massiveParticles >> thePrintParameter >> gosamPathInterface >> gosamSetupInFilenameInterface >> gosamBuildScript >> theFormOpt >> theNinja;
}

// *** Attention *** The following static variable is needed for the type
// description system in ThePEG. Please check that the template arguments
// are correct (the class and its base class), and that the constructor
// arguments are correct (the class name and the name of the dynamically
// loadable library where the class implementation can be found).
DescribeClass<GoSamAmplitude, MatchboxOLPME> describeHerwigGoSamAmplitude("Herwig::GoSamAmplitude", "HwMatchboxGoSam.so");

void GoSamAmplitude::Init() {

  static ClassDocumentation<GoSamAmplitude> documentation("GoSamAmplitude implements an interface to GoSam.", "Matrix elements have been calculated using GoSam");

  static Parameter<GoSamAmplitude,string> interfacePath
       ("Path",
        "Prefix for the source code, include files and library produced by GoSam.",
        &GoSamAmplitude::gosamPathInterface, "",
        false, false);

  static Parameter<GoSamAmplitude,string> interfaceSetupInFilename
       ("SetupInFilename",
        "File name of the GoSam infile (typically setup.gosam.in) to be used. If left empty a new setup.gosam.in is created in the location specified in Path",
        &GoSamAmplitude::gosamSetupInFilenameInterface, "",
        false, false);

  static Switch<GoSamAmplitude,bool> interfaceCodeExists
         ("CodeExists",
          "Switch on or off if Code already exists/not exists.",
          &GoSamAmplitude::theCodeExists, true, false, false);

  static SwitchOption interfaceCodeExistsOn
         (interfaceCodeExists,
          "True",
          "Switch True if Code already exists.",
          true);

  static SwitchOption interfaceCodeExistsOff
         (interfaceCodeExists,
          "False",
          "Switch False if Code has to be build.",
          false);

  static Switch<GoSamAmplitude,bool> interfaceisitDR
         ("isDR",
          "Switch on or off DR.",
          &GoSamAmplitude::isitDR, false, false, false);
  static SwitchOption interfaceisitDROn
         (interfaceisitDR,
          "True",
          "Switch True.",
          true);
  static SwitchOption interfaceisitDROff
         (interfaceisitDR,
          "False",
          "Switch False.",
          false);
  
  static Switch<GoSamAmplitude,bool> interfacePrintParameter
         ("PrintParameter",
          "Switch On if OLP parameters are to be printed into an output file"
	  "'GoSamAmplitude'.OLPParameters.lh, otherwise Off. Default is Off.",
          &GoSamAmplitude::thePrintParameter, false, false, false);
  static SwitchOption interfacePrintParameterOn
         (interfacePrintParameter,
          "On",
          "On",
          true);
  static SwitchOption interfacePrintParameterOff
         (interfacePrintParameter,
          "Off",
          "Off",
          false);

  static Switch<GoSamAmplitude,bool> interfaceFormOpt
         ("FormOpt",
          "Switch On/Off formopt",
          &GoSamAmplitude::theFormOpt, true, false, false);
  static SwitchOption interfaceFormOptOn
         (interfaceFormOpt,
          "On",
          "On",
          true);
  static SwitchOption interfaceFormOptOff
         (interfaceFormOpt,
          "Off",
          "Off",
          false);

  static Switch<GoSamAmplitude,bool> interfaceNinja
         ("Ninja",
          "Switch On/Off for reduction with Ninja. If Off then Samurai is used.",
          &GoSamAmplitude::theNinja, true, false, false);
  static SwitchOption interfaceNinjaOn
         (interfaceNinja,
          "On",
          "On",
          true);
  static SwitchOption interfaceNinjaOff
         (interfaceNinja,
          "Off",
          "Off",
          false);

  static Parameter<GoSamAmplitude,string> interfaceBuildScript
       ("BuildScript",
        "File name of a custom build script, which is called between 'autogen.sh' and 'make install'. It can be used for parallelization.",
        &GoSamAmplitude::gosamBuildScript, "",
        false, false);

}

