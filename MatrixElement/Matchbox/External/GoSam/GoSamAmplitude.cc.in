// -*- C++ -*-
//
// GoSamAmplitude.cc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2012 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the non-inlined, non-templated member
// functions of the GoSamAmplitude class.
//

#include "GoSamAmplitude.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "ThePEG/Interface/Reference.h"
#include "ThePEG/Interface/RefVector.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/Interface/Command.h"

#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"

#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>

using namespace Herwig;

GoSamAmplitude::GoSamAmplitude() {theCodeExists=false;isitDR=false;
}

GoSamAmplitude::~GoSamAmplitude() {
}

IBPtr GoSamAmplitude::clone() const {
	return new_ptr(*this);
}

IBPtr GoSamAmplitude::fullclone() const {
	return new_ptr(*this);
}

extern "C" void OLP_Start(const char*, int* i);
extern "C" void OLP_Polvec(double*, double*, double*);
extern "C" void OLP_SetParameter(char*, double*, double*, int*);
extern "C" void OLP_PrintParameter(char*);
extern "C" void OLP_EvalSubProcess2(int*, double*, double*, double*, double*);

void GoSamAmplitude::signOLP(const string& order, const string& contract) {
	if(!theCodeExists){
	  string cmd = "@GOSAMPREFIX@/bin/gosam.py --olp  -o " + contract + "  --config=../setup.in  " + order;
	  std::system(cmd.c_str());
	}
}

bool GoSamAmplitude::buildGoSam() {
	if(!theCodeExists){
	  char cwd[256];
	  string cmd = "sh autogen.sh FCFLAGS=-g --prefix=";
	  if (gosamInstallPath=="")cmd+= string(getcwd(cwd, sizeof(cwd)));
	  else cmd +=  gosamInstallPath;
	  std::system(cmd.c_str());
	  cmd = "make install";
	  std::system(cmd.c_str());
	}
	theCodeExists=true;
	return 1;
}

void GoSamAmplitude::startOLP(const string& contract, int& status) {
	string tempcontract = contract;
	if (gosamInstallPath==""){
	  if ( !( DynamicLoader::load("lib/libgolem_olp.so") || DynamicLoader::load("lib64/libgolem_olp.so") ) ) assert(0);
	}
	else {
	  if ( !( DynamicLoader::load(gosamInstallPath+"/lib/libgolem_olp.so") || DynamicLoader::load(gosamInstallPath+"/lib64/libgolem_olp.so") ) ) assert(0);
		tempcontract = gosamInstallPath + "/" + tempcontract;
	}

	OLP_Start(tempcontract.c_str(), &status);

	// hand over input parameters for EW scheme considered
	
	int pStatus = 0;
	double zero = 0.0;
	if ( SM().ewScheme() == 0 || SM().ewScheme() == 6 ) { // EW/Scheme Default and EW/Scheme Independent
	  throw Exception() << "`Best value' schemes are not supported by GoSam"
			    << Exception::abortnow;
	} else if ( SM().ewScheme() == 4 ) { // EW/Scheme mW (uses mW,GF,sin2thetaW) seems not to be supported by GoSam
	  throw Exception() << "`mW' scheme is not supported by GoSam"
			    << Exception::abortnow;
	} else if ( SM().ewScheme() == 1 ) { // EW/Scheme GMuScheme (uses mW,mZ,GF)
	  double in1=getParticleData(ParticleID::Z0)->mass()/GeV;
	  double in2=getParticleData(ParticleID::Wplus)->mass()/GeV;
	  double in3=SM().fermiConstant()*GeV2;
	  OLP_SetParameter((char *)"mass(23)",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"mass(24)",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"Gf",&in3,&zero,&pStatus);
	} else if ( SM().ewScheme() == 2 ) { // EW/Scheme alphaMZScheme (uses mW,mZ,alpha(mZ))
	  double in1=getParticleData(ParticleID::Z0)->mass()/GeV;
	  double in2=getParticleData(ParticleID::Wplus)->mass()/GeV;
	  double in3=SM().alphaEMMZ();
	  OLP_SetParameter((char *)"mass(23)",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"mass(24)",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"alpha",&in3,&zero,&pStatus);
	} else if ( SM().ewScheme() == 3 ) { // EW/Scheme NoMass (uses alpha(mZ),GF,sin2thetaW)
	  double in1=SM().fermiConstant()*GeV2;
	  double in2=SM().alphaEMMZ();
	  double in3=SM().sin2ThetaW();
	  OLP_SetParameter((char *)"Gf",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"alpha",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"sw2",&in3,&zero,&pStatus);
	} else if ( SM().ewScheme() == 5 ) { // EW/Scheme mZ (uses mZ,alphaEM,sin2thetaW)
	  double in1=getParticleData(ParticleID::Z0)->mass()/GeV;
	  double in2=SM().alphaEMMZ();
	  double in3=SM().sin2ThetaW();
	  OLP_SetParameter((char *)"mass(23)",&in1,&zero,&pStatus);
	  OLP_SetParameter((char *)"alpha",&in2,&zero,&pStatus);
	  OLP_SetParameter((char *)"sw2",&in3,&zero,&pStatus);
	}
	
	// hand over input parameter for alphaS

	double as = SM().alphaS();
	OLP_SetParameter((char *)"alphaS", &as, &zero, &pStatus);

    // hand over quark masses

	string mstr;
	if ( massiveParticles().size() != 0 ) {
	  for ( vector<int>::const_iterator mID = massiveParticles().begin(); mID != massiveParticles().end(); ++mID ) {
	    int mInt = *mID;
	    double mass=getParticleData(mInt)->mass()/GeV;
	    std::stringstream ss;
	    ss << mInt;
	    string str = ss.str();
	    mstr="mass("+str+")";
	    char * mchar = new char[mstr.size()+1];
	    std::copy(mstr.begin(),mstr.end(),mchar);
	    mchar[mstr.size()] = '\0';
	    OLP_SetParameter( mchar, &mass, &zero, &pStatus );
	    delete[] mchar;
      }
	}

    // print OLP parameters

	if (thePrintParameter) {
	  string ppstr = name() + ".OLPParameters.lh";
	  char * ppchar = new char[ppstr.size()+1];
	  std::copy(ppstr.begin(),ppstr.end(),ppchar);
	  ppchar[ppstr.size()] = '\0';
	  OLP_PrintParameter(ppchar);
	  delete[] ppchar;
	}

}

void GoSamAmplitude::fillOrderFile(const map<pair<Process, int>, int>& procs, string orderFileName) {

  for ( map<pair<Process, int>, int>::const_iterator p = procs.begin() ; p != procs.end() ; ++p ) {
    std::stringstream Processstr;
    std::stringstream Typestr;
    Processstr << (*p).first.first.legs[0]->id() << " " << (*p).first.first.legs[1]->id() << " -> ";
    for ( PDVector::const_iterator o = (*p).first.first.legs.begin() + 2 ; o != (*p).first.first.legs.end() ; ++o )
      Processstr << (**o).id() << " ";
    if ( (*p).first.second == ProcessType::treeME2 ) {
      Typestr << "Tree";
    } else if ( (*p).first.second == ProcessType::colourCorrelatedME2 ) {
      Typestr << "ccTree";
    } else if ( (*p).first.second == ProcessType::spinColourCorrelatedME2 ) {
      Typestr << "scTree";
    } else if ( (*p).first.second == ProcessType::oneLoopInterference ) {
      Typestr << "Loop";
    }
    gosamprocinfo pro = gosamprocinfo((*p).second, -1, Processstr.str(), Typestr.str());
    pro.setOAs(p->first.first.orderInAlphaS);
    processmap[(*p).second] = pro;
  }

  ifstream oldOrderFileStream(orderFileName.c_str());
  if (oldOrderFileStream){
    oldOrderFileStream.close();
    return;
  }
	ofstream orderFile(orderFileName.c_str());
	int asPower = 100;
	int minlegs = 100;
	int maxlegs = -1;

	for ( map<pair<Process, int>, int>::const_iterator t = procs.begin() ; t != procs.end() ; ++t ) {
	  asPower = min(asPower, static_cast<int>(t->first.first.orderInAlphaS));
	  minlegs = min(minlegs, static_cast<int>(t->first.first.legs.size()));
	  maxlegs = max(maxlegs, static_cast<int>(t->first.first.legs.size()));
	}

	orderFile << "# OLP order file created by Herwig++/Matchbox for GoSam\n\n";
	orderFile << "InterfaceVersion         BLHA2\n";
	orderFile << "MatrixElementSquareType  CHsummed\n";
	orderFile << "CorrectionType           QCD\n";
	orderFile << "IRregularisation         " << (isDR() ? "DRED" : "CDR") << "\n";
	if ( massiveParticles().size() != 0 ) {
	  orderFile << "MassiveParticles         ";
	  for ( vector<int>::const_iterator mID = massiveParticles().begin(); mID != massiveParticles().end(); ++mID ) {
	    int mInt = *mID;
	    orderFile << mInt << " ";
      }
	  orderFile << "\n";
    }
	orderFile << "\n";

	vector < string > types;
	types.push_back("Tree");
	types.push_back("ccTree");
	types.push_back("scTree");
	types.push_back("Loop");
	for ( int i = asPower ; i != asPower + maxlegs - minlegs + 1 ; i++ ) {
	  orderFile << "\n\nAlphasPower              " << i;
	  for ( vector<string>::iterator it = types.begin() ; it != types.end() ; it++ ) {
	    for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; ++p )
	      if ( (*p).second.Tstr() == *it && i == (*p).second.orderAs() ) {
	        orderFile << "\nAmplitudeType " << *it << "\n";
		break;
	      }
	    for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; ++p )
	      if ( (*p).second.Tstr() == *it && i == (*p).second.orderAs() ) {
	        orderFile << (*p).second.Pstr() << "\n";
	      }
	  }
	}
	orderFile << flush;

}

bool GoSamAmplitude::checkOLPContract(string contractFileName) {
	ifstream infile(contractFileName.c_str());
	string line;
	vector < string > contractfile;
	while (std::getline(infile, line)) {
		contractfile.push_back(line);
	}
	for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; p++ ) {
	  bool righttype = false;
	  for ( vector<string>::iterator linex = contractfile.begin() ; linex != contractfile.end() ; ++linex ) {
	    if ( (*linex).find("AmplitudeType ")!= std::string::npos ) {
	      if ( (*linex).find(" " + (*p).second.Tstr() + " ")!= std::string::npos ) {
	        righttype = true;
	      } else {
	        righttype = false;
	      }
	    }
	    if ( righttype ) {
	      if ( (*linex).find((*p).second.Pstr()) != std::string::npos && (*p).second.Pstr().length() == (*linex).find("|") ) {
	        string sub = (*linex).substr((*linex).find("|") + 1, (*linex).find("#") - (*linex).find("|") - 1); // | 1 23 # buggy??
		if ( sub.find(" 1 ") != 0 ) assert(0);
		string subx = sub.substr(3);
		int subint;
		istringstream(subx) >> subint;
		(*p).second.setGID(subint);
	      }
	    }
	  }
	}

	string ids = "ids.dat";
	ofstream IDS(ids.c_str());

	for ( map<int, gosamprocinfo>::iterator p = processmap.begin() ; p != processmap.end() ; p++ ) {
	    idpair.insert ( std::pair<int,int>((*p).second.HID(),(*p).second.GID()) );
	    IDS << (*p).second.HID() << " " << (*p).second.GID() << "\n";
	    if ( (*p).second.GID() == -1 ) return 0;
	}
	IDS << flush;
	
	ids = "installpath.dat";
	ofstream Install(ids.c_str());
	Install<<gosamInstallPath << flush;

	return 1;

}

void GoSamAmplitude::getids() const{
	string line = "ids.dat";
	ifstream infile(line.c_str());
	int hid;
	int gid;
	while (std::getline(infile, line)) {
	 istringstream(line) >> hid>>gid;
	 idpair.insert ( std::pair<int,int>(hid,gid) );
	}
	line ="installpath.dat";
	ifstream infile2(line.c_str());
	std::getline(infile2, line);
	gosamInstallPath=line;
}

bool GoSamAmplitude::startOLP(const map<pair<Process, int>, int>& procs) {
	cout << "\nWriting the olp-order file." << flush;
	if(gosamInstallPath != ""){
	  string cmd = "mkdir " + gosamInstallPath;
	  std::system(cmd.c_str());
	}
	string contractFileTitle = name() + ".OLPContract.lh";
	string contractFileName = gosamInstallPath == "" ? contractFileTitle : gosamInstallPath + "/" + contractFileTitle;
	string orderFileName = gosamInstallPath == "" ? name() + ".OLPOrder.lh" : gosamInstallPath + "/" + name() + ".OLPOrder.lh";
	fillOrderFile(procs, orderFileName);
	ifstream ifile(contractFileName.c_str());
  if(!ifile){
    cout << "\nGoSam: Sign the order file." << flush;
    signOLP(orderFileName, contractFileName);
	}
	
	if ( !checkOLPContract(contractFileName) ) {
	  cout << "\n\n!!!!!!!!!!!!!Checking the olp-contract failed!!!!!!!!!!!\n\n" << flush;
	  assert(0);
	} else cout << "\nChecked the olp-contract! Everything is OK! Let's build!\n" << flush;
	
	if (gosamInstallPath==""){
		if ( !( DynamicLoader::load("lib/libgolem_olp.so") || DynamicLoader::load("lib64/libgolem_olp.so") ) ) buildGoSam();;}
	else {
		if ( !( DynamicLoader::load(gosamInstallPath+"/lib/libgolem_olp.so") || DynamicLoader::load(gosamInstallPath+"/lib64/libgolem_olp.so") ) ) buildGoSam();
	}
	
	int status = -1;
	startOLP(contractFileTitle, status);

	if ( status != 1 ) return false;

	return true;

}

LorentzVector<Complex> GoSamAmplitude::plusPolarization(const Lorentz5Momentum& p, const Lorentz5Momentum& n, int inc) const {

	double pvec[4] = {p.t()/GeV,p.x()/GeV,p.y()/GeV,p.z()/GeV};
	double nvec[4] = {n.t()/GeV,n.x()/GeV,n.y()/GeV,n.z()/GeV};
	double out[8] ={ };
	OLP_Polvec(pvec,nvec,out);

	LorentzVector<Complex> res;
	Complex a(out[0],out[1]);
	res.setT(a);
	Complex b(out[2],out[3]);
	res.setX(b);
	Complex c(out[4],out[5]);
	res.setY(c);
	Complex d(out[6],out[7]);
	res.setZ(d);
	
	if (inc<2)
	  return res.conjugate();
	else 
	  return res;

}

void GoSamAmplitude::evalSubProcess() const {
	double units = pow(lastSHat() / GeV2, mePartonData().size() - 4.);
	fillOLPMomenta(lastXComb().meMomenta());

	double scale = sqrt(mu2() / GeV2);

	double out[7] = { };
	
	int id = olpId()[ProcessType::oneLoopInterference] ? olpId()[ProcessType::oneLoopInterference] : olpId()[ProcessType::treeME2];
        
	if ( idpair.size() == 0 ) {
	  getids();
	}

    double acc;
	OLP_EvalSubProcess2(&((*(idpair.find(id))).second), olpMomenta(), &scale, out, &acc);

	if ( olpId()[ProcessType::oneLoopInterference] ) {
	  lastTreeME2(out[3] * units);
	  lastOneLoopInterference((out[2])* units);
	  lastOneLoopPoles(pair<double, double>(out[0] * units, out[1] * units));
	} else if ( olpId()[ProcessType::treeME2] ) {
	  lastTreeME2(out[3] * units);
	}

}

void GoSamAmplitude::evalColourCorrelator(pair<int, int> ) const {
	double units = pow(lastSHat() / GeV2, mePartonData().size() - 4.);
	fillOLPMomenta(lastXComb().meMomenta());

	double scale = sqrt(mu2() / GeV2);

	int n = lastXComb().meMomenta().size();
	colourCorrelatorResults.resize(n * (n - 1) / 2);
	
	if ( idpair.size() == 0 ) {
	  getids();
	}

    double acc;
	OLP_EvalSubProcess2(&((*(idpair.find(olpId()[ProcessType::colourCorrelatedME2]))).second), olpMomenta(), &scale, &colourCorrelatorResults[0], &acc);

	cPDVector particles = lastXComb().matrixElement()->mePartonData();
	
	for ( int i = 0 ; i < n ; ++i ) {
	  for ( int j = i + 1 ; j < n ; ++j ) {
	    lastColourCorrelator(make_pair(i, j), colourCorrelatorResults[i+j*(j-1)/2] * units);
          }
	}

}

void GoSamAmplitude::evalSpinColourCorrelator(pair<int , int > ) const {
	double units = pow(lastSHat() / GeV2, mePartonData().size() - 4.);
	fillOLPMomenta(lastXComb().meMomenta());

	double scale = sqrt(mu2() / GeV2);

	int n = lastXComb().meMomenta().size();
	spinColourCorrelatorResults.resize(2*n*n);
	
	if ( idpair.size() == 0 ) {
	  getids();
	}

    double acc;
	OLP_EvalSubProcess2(&((*(idpair.find(olpId()[ProcessType::spinColourCorrelatedME2]))).second), olpMomenta(), &scale, &spinColourCorrelatorResults[0], &acc);

        for ( int i = 0; i < n; ++i )
        for ( int j = 0; j < n; ++j ) {
       	  Complex scc(spinColourCorrelatorResults[2*i+2*n*j]*units, spinColourCorrelatorResults[2*i+2*n*j+1]*units);
	  lastColourSpinCorrelator(make_pair(i,j),scc);
        }

}

string GoSamAmplitude::doMassiveParticles(string in) {
  istringstream ins(in);
  int first;
  ins >> first;
  theMassiveParticles.push_back(first);
  return "";
}


// If needed, insert default implementations of virtual function defined
// in the InterfacedBase class here (using ThePEG-interfaced-impl in Emacs).


void GoSamAmplitude::persistentOutput(PersistentOStream & os) const {
	os << idpair << theCodeExists << theMassiveParticles << thePrintParameter << gosamInstallPath;
}

void GoSamAmplitude::persistentInput(PersistentIStream & is, int) {
	is >> idpair >> theCodeExists >> theMassiveParticles >> thePrintParameter >> gosamInstallPath;
}

// *** Attention *** The following static variable is needed for the type
// description system in ThePEG. Please check that the template arguments
// are correct (the class and its base class), and that the constructor
// arguments are correct (the class name and the name of the dynamically
// loadable library where the class implementation can be found).
DescribeClass<GoSamAmplitude, MatchboxOLPME> describeHerwigGoSamAmplitude("Herwig::GoSamAmplitude", "HwMatchboxGoSam.so");

void GoSamAmplitude::Init() {

  static ClassDocumentation<GoSamAmplitude> documentation("GoSamAmplitude implements an interface to GoSam.");

  static Parameter<GoSamAmplitude,string> interfaceInstallPath
    	 ("InstallPath",
     	  "Prefix for the GoSam produced code.",
     	  &GoSamAmplitude::gosamInstallPath, "",
     	  false, false);

  static Switch<GoSamAmplitude,bool> interfaceCodeExists
         ("CodeExists",
          "Switch on or off if Code already exists/not exists.",
          &GoSamAmplitude::theCodeExists, true, false, false);

  static SwitchOption interfaceCodeExistsOn
         (interfaceCodeExists,
          "True",
          "Switch True if Code already exists.",
          true);

  static SwitchOption interfaceCodeExistsOff
         (interfaceCodeExists,
          "False",
          "Switch False if Code has to be build.",
          false);

  static Switch<GoSamAmplitude,bool> interfaceisitDR
         ("isDR",
          "Switch on or off DR.",
          &GoSamAmplitude::isitDR, false, false, false);
  static SwitchOption interfaceisitDROn
         (interfaceisitDR,
          "True",
          "Switch True.",
          true);
  static SwitchOption interfaceisitDROff
         (interfaceisitDR,
          "False",
          "Switch False.",
          false);
  
  static Command<GoSamAmplitude> interfaceMassiveParticles
    ("MassiveParticles",
     "Insert the PDG code of a quark with mass.",
     &GoSamAmplitude::doMassiveParticles, false);

  static Switch<GoSamAmplitude,bool> interfacePrintParameter
         ("PrintParameter",
          "Switch On if OLP parameters are to be printed into an output file"
	  "'GoSamAmplitude'.OLPParameters.lh, otherwise Off. Default is Off.",
          &GoSamAmplitude::thePrintParameter, false, false, false);
  static SwitchOption interfacePrintParameterOn
         (interfacePrintParameter,
          "On",
          "On",
          true);
  static SwitchOption interfacePrintParameterOff
         (interfacePrintParameter,
          "Off",
          "Off",
          false);

}

