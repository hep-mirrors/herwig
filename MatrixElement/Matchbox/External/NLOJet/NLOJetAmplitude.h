// -*- C++ -*-
//
// NLOJetAmplitude.h is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
#ifndef HERWIG_NLOJetAmplitude_H
#define HERWIG_NLOJetAmplitude_H
//
// This is the declaration of the NLOJetAmplitude class.
//

#include "Herwig++/MatrixElement/Matchbox/Base/MatchboxAmplitude.h"
#include "ThePEG/StandardModel/StandardModelBase.h"

#include "nlo++/bits/hep-lorentzvector.h"
#include "nlo++/bits/nlo-event.h"
#include "nlo++/bits/nlo-innerprod.h"

namespace Herwig {

using namespace ThePEG;

/**
 * \ingroup Matchbox
 * \author Simon Platzer, Jan Kotanski
 *
 * \brief NLOJetAmplitude provides an interface to 
 * nlojet's amplitude classes.
 *
 * @see \ref NLOJetAmplitudeInterfaces "The interfaces"
 * defined for NLOJetAmplitude.
 */
template<unsigned int N, unsigned int I, unsigned int F>
class NLOJetAmplitude: public Herwig::MatchboxAmplitude {

public:

  /** @name Standard constructors and destructors. */
  //@{
  /**
   * The default constructor.
   */
  NLOJetAmplitude();

  /**
   * The destructor.
   */
  virtual ~NLOJetAmplitude();
  //@}

public:

  /**
   * Define the event type.
   */
  typedef typename nlo::hadronic_event<nlo::lorentzvector<double>,
				       nlo::hadronic_event_traits<N,I,F> > NLOEvent;

  /**
   * Define the innerprod type.
   */
  typedef typename nlo::innerprod<nlo::lorentzvector<double> > NLOInvariants;

  /**
   * Calculate the amplitudes for the phasespace point stored in lastXComb.
   * Call this before a derived class's action takes place.
   */
  virtual void prepareAmplitudes(Ptr<MatchboxMEBase>::tcptr);

  /**
   * Calculate the amplitudes for the phasespace point stored in lastXComb.
   * Call this before a derived class's action takes place.
   */
  virtual void prepareOneLoopAmplitudes(Ptr<MatchboxMEBase>::tcptr) {}

  /**
   * Flush all cashes.
   */
  virtual void flushCaches();

  /**
   * Set the xcomb object.
   */
  virtual void setXComb(tStdXCombPtr xc) {
    theLastXComb = xc;
    lastMatchboxXComb(xc);
    fillCrossingMap(1);
  }

public:

  /**
   * Return the order in alpha_s
   */
  virtual unsigned int orderInAlphaS() const = 0;

  /**
   * Return the (tree-level) order in \f$g_S\f$ in which this matrix
   * element is given.
   */
  virtual unsigned int orderInGs() const { return orderInAlphaS(); }

  /**
   * Return the (tree-level) order in \f$g_{EM}\f$ in which this matrix
   * element is given.
   */
  virtual unsigned int orderInGem() const { return 0; }

  /**
   * Return the matrix element squared.
   */
  virtual double me2() const { 
    return 
      pow(4.*Constants::pi*SM().alphaS(),double(orderInAlphaS()))*
      pow(lastSHat()/GeV2,double(mePartonData().size()-4))*
      treeLevel2(crossingMap());
  }

  /**
   * Return the one-loop/tree interference.
   */
  virtual double oneLoopInterference() const { 
    // JK
    //    return 0.0;
    return 
      pow(4.*Constants::pi*SM().alphaS(),double(orderInAlphaS()))*
      (SM().alphaS()/(2.*Constants::pi))*
      pow(lastSHat()/GeV2,double(mePartonData().size()-4))*
      treeOneLoop(crossingMap());
  }

  /**
   * Return the colour correlated matrix element.
   */
  virtual double colourCorrelatedME2(pair<int,int> ij) const;

  /**
   * Return the colour and spin correlated matrix element.
   */
  virtual double spinColourCorrelatedME2(pair<int,int> ij,
					 const SpinCorrelationTensor& c) const;

  /**
   * Return true, if this amplitude is capable of calculating one-loop
   * (QCD) corrections.
   */
  virtual bool haveOneLoop() const { return true; }

  /**
   * Return true, if the virtual correction
   * has been calculated using dimensional reduction.
   * CDR is assumed otherwise.
   */
  virtual bool isDR() const { return true; }

  /**
   * Return true, if the virtual correction has been calculated in the
   * dipole convention.
   */
  virtual bool isBDK() const { return true; }

  /**
   * If the BDK convention is used, return the last value of the scale
   * used.
   */
  virtual Energy2 mu2() const { return 1.*GeV2; }

public:

  /**
   * Return true, if the colour basis is capable of assigning colour
   * flows.
   */
  virtual bool haveColourFlows() const { return false; }

  /**
   * Return the colour ordered subamplitude squared associated to the
   * colour structure identitfied by the given permutation of external
   * legs.
   */
  virtual double colourOrdered2(const int*, size_t) const = 0;

  /**
   * Return the last partonic_event as generated by the phasespace.
   */
  const NLOEvent& lastNLOEvent() const;

  /**
   * Return the last invariants calculated.
   */
  const NLOInvariants& lastInvariants() const { return theLastInvariants; }

protected:

  /**
   * Return the number of quark pairs of same flavour attached to the
   * process.
   */
  int identicalQuarks() const { return theIdenticalQuarks; }

  /**
   * Return the number of outgoing quark pairs of same flavour
   * attached to the process.
   */
  int outgoingIdenticalQuarks() const { return theOutgoingIdenticalQuarks; }

  /**
   * Return the tree-level matrix element squared.
   * Needs to dispatch to various su3_tree(...) calls
   */
  virtual double treeLevel2(const vector<int>&) const = 0;

  /**
   * Return the tree/oneloop interference.
   * Needs to dispatch to various su3_1loop(...) calls
   */
  virtual double treeOneLoop(const vector<int>&) const = 0;

  /**
   * Return the colour correlated amplitudes squared.
   * Needs to dispatch to various su3_cc(...) calls
   */
  virtual double treeLevelCC(pair<int,int>,const vector<int>&) const = 0;

  /**
   * Return the spin/colour correlated amplitude squared.
   */
  virtual pair<double,Complex> treeLevelSCC(pair<int,int>,const vector<int>&) const = 0;

public:

  /** @name Functions used by the persistent I/O system. */
  //@{
  /**
   * Function used to write out object persistently.
   * @param os the persistent output stream written to.
   */
  void persistentOutput(PersistentOStream & os) const;

  /**
   * Function used to read in object persistently.
   * @param is the persistent input stream read from.
   * @param version the version number of the object when written.
   */
  void persistentInput(PersistentIStream & is, int version);
  //@}

  /**
   * The standard Init function used to initialize the interfaces.
   * Called exactly once for each class by the class description system
   * before the main function starts or
   * when this class is dynamically loaded.
   */
  static void Init();


// If needed, insert declarations of virtual function defined in the
// InterfacedBase class here (using ThePEG-interfaced-decl in Emacs).

protected:

  /**
   * Count number of qqbar pairs and gluons to check processes
   */
  pair<unsigned int, unsigned int> countColoured(const PDVector&) const;

  /**
   * True, if last invariants have to be calculated.
   */
  bool calculateInvariants;

private:

  /**
   * The last invariants calculated.
   */
  NLOInvariants theLastInvariants;

  /**
   * A local NLOEvent to be filled from dependent XComb's
   */
  mutable NLOEvent theLastNLOEvent;

  /**
   * The number of quark pairs of same flavour attached to the
   * process.
   */
  int theIdenticalQuarks;

  /**
   * The number of outgoing quark pairs of same flavour attached to the
   * process.
   */
  int theOutgoingIdenticalQuarks;

private:

  /**
   * The assignment operator is private and must never be called.
   * In fact, it should not even be implemented.
   */
  NLOJetAmplitude & operator=(const NLOJetAmplitude &);

};

}

#include "NLOJetAmplitude.tcc"

#endif /* HERWIG_NLOJetAmplitude_H */
