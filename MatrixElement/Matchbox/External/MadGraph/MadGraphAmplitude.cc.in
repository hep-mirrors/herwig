// -*- C++ -*-
//
// MadGraphAmplitude.cc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2012 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the non-inlined, non-templated member
// functions of the MadGraphAmplitude class.
//

#include "MadGraphAmplitude.h"
#include "ThePEG/Interface/ClassDocumentation.h"
#include "ThePEG/EventRecord/Particle.h"
#include "ThePEG/Repository/UseRandom.h"
#include "ThePEG/Repository/EventGenerator.h"
#include "ThePEG/Utilities/DescribeClass.h"
#include "Herwig++/MatrixElement/Matchbox/MatchboxFactory.h"
#include "ThePEG/Interface/Parameter.h"
#include "ThePEG/Interface/Switch.h"
#include "ThePEG/Persistency/PersistentOStream.h"
#include "ThePEG/Persistency/PersistentIStream.h"

#include "ThePEG/PDT/EnumParticles.h"
#include <boost/lexical_cast.hpp>



#include <cstdlib>
#include <dlfcn.h>
#include <errno.h>

using namespace Herwig;


extern "C" void mginitproc_(char *i,int);
extern "C" void MG_Calculate_wavefunctions_virt(int* proc,double*,double*);
extern "C" void MG_Calculate_wavefunctions_born(int* proc,double*, int*);
extern "C" void MG_Jamp                        (int* proc,int*, double*);
extern "C" void MG_LNJamp                        (int* proc,int*, double*);
extern "C" void MG_Virt                        (int* proc,double*);
extern "C" void MG_NCol                        (int* proc,int*);
extern "C" void MG_vxxxxx                      (double* p,double* n,int* inc,double*  );
extern "C" void MG_Colour                      (int* proc,int* i,int* j ,int* color);




MadGraphAmplitude::MadGraphAmplitude()
  : theMGmodel("loop_sm"),keepinputtopmass(false) {}

MadGraphAmplitude::~MadGraphAmplitude() {

}

IBPtr MadGraphAmplitude::clone() const {
  return new_ptr(*this);
}

IBPtr MadGraphAmplitude::fullclone() const {
  return new_ptr(*this);
}

map<string,int>& MadGraphAmplitude::processmap() {
  static map<string,int> theProcessMap;
  return theProcessMap;
}

template<class ProcType>
string processId(const ProcType& p) {
  string orderFileName =  "";
  for (typename ProcType::const_iterator it=p.begin();it!=p.end();it++)
    orderFileName +=boost::lexical_cast<string>( (*it)->id());
  orderFileName+=".MG";
  return orderFileName;
}

bool initializedMad=false;


void MadGraphAmplitude::initProcess(const cPDVector& ) {
    
  if ( lastMatchboxXComb()->initialized() )
    return;

  string MGProcLibPath = theProcessPath == "" ? factory()->buildStorage()+"MadGraphAmplitudes" : theProcessPath;
  if (MGProcLibPath.at(MGProcLibPath.length()-1) != '/') MGProcLibPath.append("/");

  if ( !DynamicLoader::load(MGProcLibPath+"InterfaceMadGraph.so") )
    throw Exception() << "Failed to load MadGraph amplitudes\n"
                      << DynamicLoader::lastErrorMessage
                      << Exception::abortnow;

  if (!initializedMad){
    string mstr=(factory()->runStorage()+"MadGraphAmplitudes"+"/param_card"+((theMGmodel=="loop_sm")?"":("_"+theMGmodel))+".dat");
    size_t len = mstr.size();
    mginitproc_(const_cast<char*>(mstr.c_str()),len);
    initializedMad=true;
  }
  lastMatchboxXComb()->isInitialized();
}

bool ranMadGraphInitializeExternal = false;

bool MadGraphAmplitude::initializeExternal() {

  loadProcessMap();
  string MGProcLibPath = theProcessPath == "" ? factory()->buildStorage()+"MadGraphAmplitudes" : theProcessPath;
  if (MGProcLibPath.at(MGProcLibPath.length()-1) != '/') MGProcLibPath.append("/");
  
  std::system(("mkdir -p " + MGProcLibPath).c_str());
  std::system(("mkdir -p " + factory()->runStorage()+"/MadGraphAmplitudes").c_str());

  string born= MGProcLibPath+"BornAmplitudes.dat";
  ofstream borns(born.c_str());
  string virt= MGProcLibPath+"VirtAmplitudes.dat";
  ofstream virts(virt.c_str());
  
  for (vector<string>::iterator amps=BornAmplitudes.begin();amps!=BornAmplitudes.end();amps++)
    borns<<*amps<<endl;
  for (vector<string>::iterator amps=VirtAmplitudes.begin();amps!=VirtAmplitudes.end();amps++)
    virts<<*amps<<endl;
  borns.close();
  virts.close();
  
  Energy MW=getParticleData(ParticleID::Wplus)->mass();
  Energy MZ=getParticleData(ParticleID::Z0)->mass();

  if( MW!= sqrt(MZ*MZ/2.0+sqrt(MZ*MZ*MZ*MZ/4.0-Constants::pi*SM().alphaEMMZ()*MZ*MZ/ sqrt(2.0)/SM().fermiConstant()))){  
    cerr<<"\n\n-----!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-----";
    cerr << "\nYou are using a EW scheme which is inconsistent with the MadGraph parametisation:\n\n"     
                      <<MW/GeV<< " GeV==MW!= sqrt(MZ^2/2+sqrt(MZ^4/4.0-pi*alphaEMMZ*MZ^2/ sqrt(2)/G_f))=="<<
                      sqrt(MZ*MZ/2.0+sqrt(MZ*MZ*MZ*MZ/4.0-Constants::pi*SM().alphaEMMZ()*MZ*MZ/ sqrt(2.0)/SM().fermiConstant()))/GeV
                      <<" GeV\n\n-----!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!-----\n";
  }
  
  
  
  
   
  string para= factory()->runStorage()+"/MadGraphAmplitudes"+"/MG-Parameter.dat";
  ofstream params(para.c_str());
  params<<"$WZ$ "    <<std::setiosflags(ios::scientific)  <<getParticleData(ParticleID::Z0)->width()     /GeV;
  params<<"\n$WW$ "    <<std::setiosflags(ios::scientific)   <<getParticleData(ParticleID::Wplus)->width()/GeV;
  params<<"\n$alphas$ " <<std::setiosflags(ios::scientific)  <<SM().alphaS();
  params<<"\n$GF$ "     <<std::setiosflags(ios::scientific)  <<SM().fermiConstant()*GeV2   ;
  params<<"\n$alphaMZ$ " <<std::setiosflags(ios::scientific) <<1/SM().alphaEMMZ();
  params<<"\n$MZ$ "     <<std::setiosflags(ios::scientific)  <<getParticleData(ParticleID::Z0)->mass() /GeV<<flush;
  params<<"\n$MW$ "    <<std::setiosflags(ios::scientific)   <<getParticleData(ParticleID::Wplus)->mass() /GeV<<flush;
  params<<"\n$sw2$ "    <<std::setiosflags(ios::scientific)   << SM().sin2ThetaW() <<flush;
  if(theMGmodel=="heft"&&!keepinputtopmass){
      cerr<<"\n---------------------------------------------------------------";
      cerr<<"\n---------------------------------------------------------------";
      cerr<<"\nNote:    You are using the Higgs Effective model (heft) in     ";
      cerr<<"\n         Madgraph. We assume you try to calculate NLO with ";
      cerr<<"\n         the GoSam virtual amplitudes. To match the models we ";
      cerr<<"\n         therefore set the topmass to 10000000 GeV.";
      cerr<<"\n\n         For more information see the \\tau parameter in:";     
      cerr<<"\n         https://cp3.irmp.ucl.ac.be/projects/madgraph/wiki/Models/HiggsEffective";
      cerr<<"\n\n         The Effective Higgs model in Gosam is using mT=infinity";
      cerr<<"\n\n\n         If you want to use the LO matrixelements of MadGraph with finite' topmass you need to add:  ";
      cerr<<"\n\n             set Madgraph:KeepInputTopMass True";
      cerr<<"\n\n         to your input file.";
      cerr<<"\n---------------------------------------------------------------";
      cerr<<"\n---------------------------------------------------------------\n";
      params<<"\n$MT$ 10000000." <<flush;
  }else{
      params<<"\n$MT$ "    <<std::setiosflags(ios::scientific)   << getParticleData(ParticleID::t)->mass() /GeV <<flush;
  }
  params<<"\n$WT$ "    <<std::setiosflags(ios::scientific)   << getParticleData(ParticleID::t)->width() /GeV <<flush;
  params<<"\n$MB$ "    <<std::setiosflags(ios::scientific)   << getParticleData(ParticleID::b)->mass() /GeV <<flush;
  params<<"\n$MH$ "    <<std::setiosflags(ios::scientific)   << getParticleData(ParticleID::h0)->mass() /GeV <<flush;
  params<<"\n$WH$ "    <<std::setiosflags(ios::scientific)   << getParticleData(ParticleID::h0)->width() /GeV <<flush;
  params<<"\n$MTA$ "    <<std::setiosflags(ios::scientific)   << getParticleData(ParticleID::tauplus)->mass() /GeV <<flush;

  
  string cmd = "python @prefix@/bin/mg2Matchbox.py ";
  cmd +=" --buildpath "+MGProcLibPath;
  cmd +=" --model "+theMGmodel;
  cmd +=" --runpath "+factory()->runStorage()+"/MadGraphAmplitudes " ;  

  cmd +=" --orderas "+static_cast<ostringstream*>(&(ostringstream()<<(factory()->orderInAlphaS())))->str() ;  
  
  cmd +=" --orderew "+static_cast<ostringstream*>(&(ostringstream()<<(factory()->orderInAlphaEW())))->str();   
  
  // TODO move to boost::system
  
  if ( !processmap().empty() ){
    //set the parameters

    std::system(cmd.c_str());
    ranMadGraphInitializeExternal = true;
    return true;
  }
  char cwd[1024];
  if ( !getcwd(cwd,sizeof(cwd)) )
    throw Exception() << "failed to determine current working directory\n"
                      << Exception::abortnow;
     
  cmd +=" --madgraph @MADGRAPHPREFIX@/bin " ;
  cmd +="--build > ";
  cmd +=  MGProcLibPath+"MG.log 2>&1";
  
  
  generator()->log() << "\n\nCompiling MadGraph amplitudes. This may take some time -- please be patient.\n"
                     << "In case of problems see " << MGProcLibPath << "MG.log for details.\n\n"
                     << flush;
  std::system(cmd.c_str());
  
  
  cmd = "python @prefix@/bin/mg2Matchbox.py ";
  cmd +=" --buildpath "+MGProcLibPath;
  cmd +=" --model "+theMGmodel;
  cmd +=" --runpath "+factory()->runStorage()+"/MadGraphAmplitudes " ;

  cmd +=" --orderas "+static_cast<ostringstream*>(&(ostringstream()<<(factory()->orderInAlphaS())))->str() ;  
  
  cmd +=" --orderew "+static_cast<ostringstream*>(&(ostringstream()<<(factory()->orderInAlphaEW())))->str();  
  std::system(cmd.c_str());
    
  
  
  
  

  loadProcessMap();

  ranMadGraphInitializeExternal = true;

  return !processmap().empty();

}

int MadGraphAmplitude::externalId(const cPDVector& proc) {
    for (int i=0;i<100;i++){
    colourindex.push_back(-2);
  }
  assert(!BornAmplitudes.empty()||!VirtAmplitudes.empty());
  
  int res=0;
  string amp="";
  int k=0;
  for (cPDVector::const_iterator it=proc.begin();it!=proc.end();it++,k++){
    amp+=boost::lexical_cast<string>( (*it)->id())+" ";if (k==1)amp+=" > ";
  }

  
  for (vector<string>::iterator amps=BornAmplitudes.begin();amps!=BornAmplitudes.end();amps++,res++)
    if(amp==*amps)return res+1;
  for (vector<string>::iterator amps=VirtAmplitudes.begin();amps!=VirtAmplitudes.end();amps++,res++)
    if(amp==*amps)return res+1;
  
  throw Exception() << "One amplitude has no externalId. Please remove the MadGraphAmplitude-folder and rebuild.\n"     << Exception::abortnow;
  


  return res;
}

void MadGraphAmplitude::loadProcessMap() {
  if ( !processmap().empty() )
    return;
  string MGProcLibPath = theProcessPath == "" ? factory()->buildStorage()+"MadGraphAmplitudes" : theProcessPath;
  if (MGProcLibPath.at(MGProcLibPath.length()-1) != '/') MGProcLibPath.append("/");
  string line = MGProcLibPath+"processmap.dat";
  ifstream infile(line.c_str());
  if ( !infile )
    return;
  string process;
  int id;
  while (std::getline(infile, line)) {
    std::stringstream ss(line);
    getline( ss, process, ' ' );
    ss >> id;
    processmap().insert(make_pair(process,id));
  }
}

void MadGraphAmplitude::doinit() {
  if ( !ranMadGraphInitializeExternal ) {
    initializeExternal();
  }
  MatchboxAmplitude::doinit();
}

void MadGraphAmplitude::doinitrun() {
  if ( !ranMadGraphInitializeExternal ) {
    loadProcessMap();
    ranMadGraphInitializeExternal = true;
  }
  MatchboxAmplitude::doinitrun();
}

bool MadGraphAmplitude::canHandle(const PDVector& p,
                                  Ptr<MatchboxFactory>::tptr factory,
                                  bool virt) const {
  if ( factory->processData()->diagramMap().find(p) !=
       factory->processData()->diagramMap().end() )
    return true;
  vector<Ptr<Tree2toNDiagram>::ptr> diags =
    factory->diagramGenerator()->generate(p,orderInGs(),orderInGem());
  if ( diags.empty() )
    return false;
  factory->processData()->diagramMap()[p] = diags;
  string amp="";
  int k=0;
  for (PDVector::const_iterator it=p.begin();it!=p.end();it++,k++){
    amp+=boost::lexical_cast<string>( (*it)->id())+" ";if (k==1)amp+=" > ";
  }
   if (virt && factory->highestVirt()>=p.size()){
    VirtAmplitudes.push_back(amp);
  }else{
    BornAmplitudes.push_back(amp);
  }
  
  return true;
}

void MadGraphAmplitude::prepareAmplitudes(Ptr<MatchboxMEBase>::tcptr me) {

  useMe();

  if ( !calculateTreeAmplitudes() ) {
    MatchboxAmplitude::prepareAmplitudes(me);
    return;
  }
  lastMatchboxXComb()->clearheljamp();
  lastMatchboxXComb()->clearhelLNjamp();
  initProcess(mePartonData());
  MatchboxAmplitude::prepareAmplitudes(me);

}

Complex MadGraphAmplitude::evaluate(size_t i, const vector<int>& hel, Complex& largeN) {
  
  
  //find the colourline:
  int ii = -1;
  int xx=lastMatchboxXComb()->externalId();
  if(colourindex[i]!=-2){

    ii = colourindex[i];
    if (ii==-1) {
      largeN = Complex(0.0);
      return Complex(0.0);
    }
  } else {
    set<vector<size_t> > a = colourOrdering(i);
    int ncol=-1;
    MG_NCol(&xx,&ncol);
    assert(ncol!=-1);
    for( int it = 0; it < ncol; it++ ){
      int n = 0;
      for ( cPDVector::const_iterator nx = mePartonData().begin();
            nx != mePartonData().end(); nx++ )
        if ( (*nx)->coloured() ) n++;
      set<vector<size_t> > tmpset;
      vector<size_t> tmpvek;
      for ( int it2 = 0; it2 < n; it2++ ) {
        int ret=-2;
        MG_Colour(&xx,&it,&it2,&ret);
        assert(ret !=-2);
        if (ret== -1)
          break;
        if ( ret == 0 ) {
          n++;
          tmpset.insert(tmpvek);
          tmpvek.clear();
        } else {
          tmpvek.push_back(ret-1);
        }
        if( it2 == n-1 ) tmpset.insert(tmpvek);
      }
      bool found_all = true;
      for ( set<vector<size_t> >::iterator it3 = a.begin(); it3 != a.end(); it3++ ) {
        bool found_it3=false;
        for ( set<vector<size_t> >::iterator it4 = tmpset.begin(); it4 != tmpset.end(); it4++ ) {
          vector<size_t> it3tmp = gluonsFirst(*it3);
          vector<size_t> it4tmp = (*it4);
          if ( it3tmp.size() != it4tmp.size() ) continue;
          if ( it3tmp == it4tmp ) found_it3 = true;
        }
        found_all = found_all && found_it3;
      }

      if ( found_all ) {
        colourindex[i]=it;
      

        ii=it;
      }
    }
  }
  if ( ii == -1 ){

    colourindex[i]=ii;
    largeN = Complex(0.0);
    return Complex(0.0);
  }
  
  const map<vector<int>,vector < complex<double> > >& tmp = lastMatchboxXComb()->heljamp();
    const map<vector<int>,vector < complex<double> > >& tmpLN = lastMatchboxXComb()->helLNjamp();

  if( tmp.find(hel) != tmp.end()) {
    largeN = tmpLN.find(hel)->second[ii];
    return tmp.find(hel)->second[ii];;
  }

  double units = pow(sqrt(lastSHat())/GeV,int(hel.size())-4);


  
  for(size_t j=0;j<hel.size();j++){
    int cross=crossingMap()[j];
    if( (cross>1&&j<=1)||(cross<=1&&j>1)){
    heltmp[cross]=-1*hel[j];}
    else{heltmp[cross]=hel[j];}
  }


  size_t j=0;
  for (size_t i=0;i<mePartonData().size();i++){
    momenta[j]=abs(meMomenta()[i].e()/GeV)<1.e-13?0.:double(meMomenta()[i].e()/GeV);
    momenta[j+1]=abs(meMomenta()[i].x()/GeV)<1.e-13?0.:double(meMomenta()[i].x()/GeV);
    momenta[j+2]=abs(meMomenta()[i].y()/GeV)<1.e-13?0.:double(meMomenta()[i].y()/GeV);
    momenta[j+3]=abs(meMomenta()[i].z()/GeV)<1.e-13?0.:double(meMomenta()[i].z()/GeV);
    j+=4;
  }
  
  MG_Calculate_wavefunctions_born(&xx, &momenta[0],  &heltmp[0]);
  
  
  int ncol=-1;
  MG_NCol(&xx,&ncol);

  Complex res;
  Complex resLN;
  for( int it = 0; it < ncol; it++ ){
    double dd[2];
    MG_Jamp(&xx,&it,&dd[0]);
    Complex d(dd[0],dd[1]);
    if(it==ii)res=d*units;
    lastMatchboxXComb()->pushheljamp(hel,d*units);
    double ddLN[2];
    MG_LNJamp(&xx,&it,&ddLN[0]);
    Complex dLN(ddLN[0],ddLN[1]);
    if(it==ii)resLN=dLN*units;
    lastMatchboxXComb()->pushhelLNjamp(hel,dLN*units);
  }

  
  largeN = resLN;
  return res;

}

LorentzVector<Complex> MadGraphAmplitude::plusPolarization(const Lorentz5Momentum& p,
                                                           const Lorentz5Momentum& n,
                                                           int i) const {
                                                             
                                                             
                                                     

  int tmp=i;
  pg[0]=p.e()/GeV;pg[1]=p.x()/GeV;pg[2]=p.y()/GeV;pg[3]=p.z()/GeV;
  ng[0]=n.e()/GeV;ng[1]=n.x()/GeV;ng[2]=n.y()/GeV;ng[3]=n.z()/GeV;

  MG_vxxxxx(&pg[0],&ng[0],&tmp,&poltmp[0]);

  complex<double> pol[6];
  pol[0]=Complex(poltmp[0],poltmp[1]);
  pol[1]=Complex(poltmp[2],poltmp[3]);
  pol[2]=Complex(poltmp[4],poltmp[5]);
  pol[3]=Complex(poltmp[6],poltmp[7]);

  LorentzVector<Complex> polarization(pol[1],pol[2],pol[3],pol[0]);

  return polarization.conjugate();
}
 
bool equalsModulo(unsigned int i, const vector<int>& a, const vector<int>& b) {
  assert(a.size()==b.size());
  if ( a[i] == b[i] )
    return false;
  for ( unsigned int k = 0; k < a.size(); ++k ) {
    if ( k == i )
      continue;
    if ( a[k] != b[k] )
      return false;
  }
  return true;
}

vector<size_t> MadGraphAmplitude::gluonsFirst(vector<size_t> vec) {
  vector<size_t> vecout;
  for(vector<size_t>::iterator it= vec.begin();it!= vec.end();++it)
    if ( mePartonData()[crossingMap()[*it]]->id()==21)
      vecout.push_back(crossingMap()[*it]);

  for(vector<size_t>::iterator it= vec.begin();it!= vec.end();++it)
    if ( mePartonData()[crossingMap()[*it]]->id()!=21)
      vecout.push_back(crossingMap()[*it]);

  return vecout;
  
}

double MadGraphAmplitude::spinColourCorrelatedME2(pair<int,int> ij,
                                                  const SpinCorrelationTensor& c) const {

  Lorentz5Momentum p = meMomenta()[ij.first];
  Lorentz5Momentum n = meMomenta()[ij.second];

  LorentzVector<Complex> polarization = plusPolarization(p,n,ij.first);

  Complex pFactor = (polarization*c.momentum())/sqrt(abs(c.scale()));

  double avg =
    colourCorrelatedME2(ij)*(-c.diagonal()+ (c.scale() > ZERO ? 1. : -1.)*norm(pFactor));
  int iCrossed = crossingMap()[ij.first];
  iCrossed = ij.first;
  for ( unsigned int k = 0; k < crossingMap().size(); ++k )
    if ( crossingMap()[k] == ij.first ) {
      iCrossed = k;
      break;
    }   
  
  Complex csCorr = 0.0;

  if ( calculateColourSpinCorrelator(ij) ) {
    set<const CVector*> done;
    for ( AmplitudeConstIterator a = lastAmplitudes().begin();
          a != lastAmplitudes().end(); ++a ) {
      if ( done.find(&(a->second)) != done.end() )
        continue;
      AmplitudeConstIterator b = lastAmplitudes().begin();
      while ( !equalsModulo(iCrossed,a->first,b->first) )
        if ( ++b == lastAmplitudes().end() )
          break;
      if ( b == lastAmplitudes().end() || done.find(&(b->second)) != done.end() )
        continue;
      done.insert(&(a->second)); done.insert(&(b->second));
      if ( a->first[iCrossed] == 1 )
        swap(a,b);
      csCorr -= colourBasis()->colourCorrelatedInterference(ij,mePartonData(),a->second,b->second);
    }
    lastColourSpinCorrelator(ij,csCorr);
  } else {
    csCorr = lastColourSpinCorrelator(ij);
  }
  double corr =
    2.*real(csCorr*sqr(pFactor));

  double Nc = generator()->standardModel()->Nc();
  double cfac = 1.;
  if ( mePartonData()[ij.first]->iColour() == PDT::Colour8 ) {
    cfac = Nc;
  } else if ( mePartonData()[ij.first]->iColour() == PDT::Colour3 ||
              mePartonData()[ij.first]->iColour() == PDT::Colour3bar ) {
    cfac = (sqr(Nc)-1.)/(2.*Nc);
  } else assert(false);

  return
    ( avg +(c.scale() > ZERO ? 1. : -1.)*corr/cfac);

}




void MadGraphAmplitude::prepareOneLoopAmplitudes(Ptr<MatchboxMEBase>::tcptr){
  assert(false);
}


double MadGraphAmplitude::oneLoopInterference() const {
  if ( !calculateOneLoopInterference() )
    return lastOneLoopInterference();
  evaloneLoopInterference();
  return lastOneLoopInterference();
}


void MadGraphAmplitude::evaloneLoopInterference() const  {
  
  
      double units = pow(lastSHat()/GeV2,mePartonData().size()-4);



  size_t j=0;
  for (size_t i=0;i<mePartonData().size();i++){
    momenta[j]=abs(meMomenta()[i].e()/GeV)<1.e-13?0.:double(meMomenta()[i].e()/GeV);
    momenta[j+1]=abs(meMomenta()[i].x()/GeV)<1.e-13?0.:double(meMomenta()[i].x()/GeV);
    momenta[j+2]=abs(meMomenta()[i].y()/GeV)<1.e-13?0.:double(meMomenta()[i].y()/GeV);
    momenta[j+3]=abs(meMomenta()[i].z()/GeV)<1.e-13?0.:double(meMomenta()[i].z()/GeV);
    j+=4;
  }
  int xx=lastMatchboxXComb()->externalId();
  
  MG_Calculate_wavefunctions_virt(&xx,&momenta[0],&virt[0]);

    double ifact = 1.;

    ifact = 1./4.;
    if (lastMatchboxXComb()->matchboxME()->mePartonData()[0]->iColour() == PDT::Colour3 ||
        lastMatchboxXComb()->matchboxME()->mePartonData()[0]->iColour() == PDT::Colour3bar )
      ifact /= SM().Nc();
    else if ( lastMatchboxXComb()->matchboxME()->mePartonData()[0]->iColour() == PDT::Colour8 )
      ifact /= (SM().Nc()*SM().Nc()-1.);

    if ( lastMatchboxXComb()->matchboxME()->mePartonData()[1]->iColour() == PDT::Colour3 ||
         lastMatchboxXComb()->matchboxME()->mePartonData()[1]->iColour() == PDT::Colour3bar )
      ifact /= SM().Nc();
    else if ( mePartonData()[1]->iColour() == PDT::Colour8 )
      ifact /= (SM().Nc()*SM().Nc()-1.);
  

    ifact *= lastMatchboxXComb()->matchboxME()->finalStateSymmetry();
 

  lastOneLoopInterference(virt[1]/ifact*units);
}
 
void MadGraphAmplitude::persistentOutput(PersistentOStream & os) const {
  os << theOrderInGs << theOrderInGem << BornAmplitudes << VirtAmplitudes
     << colourindex<<crossing << theProcessPath << theMGmodel;
}
 
void MadGraphAmplitude::persistentInput(PersistentIStream & is, int) {
  is >> theOrderInGs >> theOrderInGem >> BornAmplitudes >> VirtAmplitudes
     >> colourindex>>crossing >> theProcessPath >> theMGmodel;
}
 
// *** Attention *** The following static variable is needed for the type
// description system in ThePEG. Please check that the template arguments
// are correct (the class and its base class), and that the constructor
// arguments are correct (the class name and the name of the dynamically
// loadable library where the class implementation can be found).
DescribeClass<MadGraphAmplitude,MatchboxAmplitude> 
describeHerwigMadGraphAmplitude("Herwig::MadGraphAmplitude", "HwMatchboxMadGraph.so");
 
void MadGraphAmplitude::Init() {
   
  static ClassDocumentation<MadGraphAmplitude> documentation  ("MadGraphAmplitude","Matrix elements have been calculated using MadGraph5");
   
  static Parameter<MadGraphAmplitude,string> interfaceProcessPath
    ("ProcessPath",
     "The Process Path.",
     &MadGraphAmplitude::theProcessPath, "",false, false);  

  static Parameter<MadGraphAmplitude,string> interfaceModel
    ("Model",
     "The MadGraph-Model.",
     &MadGraphAmplitude::theMGmodel, "loop_sm",false, false);
  
  static Switch<MadGraphAmplitude,bool> interfacekeepinputtopmass
         ("KeepInputTopMass",
          "Switch On/Off formopt",
          &MadGraphAmplitude::keepinputtopmass, false, false, false);
  static SwitchOption interfacekeepinputtopmassTrue
         (interfacekeepinputtopmass,
          "On",
          "On",
          true);
  static SwitchOption interfacekeepinputtopmassFalse
         (interfacekeepinputtopmass,
          "Off",
          "Off",
          false);  
    
    

}
 
 
