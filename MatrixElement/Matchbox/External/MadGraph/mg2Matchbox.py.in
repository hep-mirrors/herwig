#! /usr/bin/env python

import os,re,sys,fileinput,random,time,math,glob,functools,errno,shutil
from multiprocessing import Pool

def replacemachine(fileName, sourceText, replaceText):
    file = open(fileName, "r") 
    text = file.read() 
    file.close()
    file = open(fileName, "w")
    file.write(text.replace(sourceText, replaceText))
    file.close() 

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise   
 
def fillprocs():
  fileproc=open("proc.dat","w")
  fileproc.write("import model loop_sm\n")
  fileproc.write("define ubar =u~\n")
  fileproc.write("define dbar =d~\n")
  fileproc.write("define nu_mubar =vm~\n")
  fileproc.write("define nu_mu =vm\n")
  fileproc.write("define sbar =s~\n")
  fileproc.write("define cbar =c~\n")
  fileproc.write("define bbar =b~\n")
  fileproc.write("define tbar =t~\n")
  fileproc.write("define Z0 =z\n")
  fileproc.write("define h0 =h\n")
  fileproc.write("define gamma =a \n")
  fileproc.write("define nu_e =ve \n")
  fileproc.write("define nu_mu =vm \n")
  fileproc.write("define nu_tau =vt \n")
  fileproc.write("define nu_ebar =ve~ \n")
  fileproc.write("define nu_mubar =vm~ \n")
  fileproc.write("define nu_taubar =vt~ \n")
  fileproc.write("define tau- =ta- \n")
  fileproc.write("define tau+ =ta+ \n")
  files=glob.glob('*.MG')
  first=True
  processmap=""
  procnr=0
  virtlines=""
  bornlines=""
  for filei in files:
    
    file = open(filei, "r")
    for line in file:
      linetmp=line
      if "virt" in linetmp:
	continue
      procnr+=1
      processmap+=filei+" "
      processmap+=str(procnr) +"\n"
      if first:
	bornlines+="generate "+linetmp+"@"+str(procnr)+"\n"
	first=False
      else:
	bornlines+="add process "+linetmp+"@"+str(procnr)+"\n"
    file.close()
  first=True
  for filei in files:
    
    file = open(filei, "r")
    for line in file:
      linetmp=line
      if "virt" not in linetmp:
	continue
      procnr+=1
      processmap+=filei+" "
      processmap+=str(procnr) +"\n"
      if first:
	virtlines+="generate "+linetmp+"@"+str(procnr)+"\n"
	first=False
      else:
	virtlines+="add process "+linetmp+"@"+str(procnr)+"\n"
    file.close()

  fileproc.write(bornlines)
  if virtlines!="" and bornlines!="":
     fileproc.write("output matchbox MG5 --postpone_model\n") 
  fileproc.write(virtlines)
  fileproc.write("output matchbox MG5 -f\n")
  

  fileproc.close()
  fileprocessmap=open("processmap.dat","w")
  fileprocessmap.write(processmap)
  fileprocessmap.close()

def replacefromto(xfile, xfrom,xto,repltext):
    file = open(xfile, "r") 
    text=""
    replace=False
    for line in file:
      if not replace:
	text+=line
      if xfrom in line:
	replace=True
	text+=repltext
      if replace and (xto in line):
	replace=False
    file.close() 
    file = open(xfile, "w")
    file.write(text)
    file.close() 
  

  
  
  
file = open("@prefix@/share/Herwig++/MadGraphInterface/param_card.dat.in", "r") 
text = file.read() 
file.close()
file = open("param_card.dat", "w")
params=open("MG-Parameter.dat", "r")
for line in params:
  a=line.split()
  #print a[0],"-->",a[1]
  text=text.replace(a[0],a[1])
params.close()
file.write(text)
file.close()   
pwdxx=os.getcwd() 



if not os.path.isdir(sys.argv[2]):
   print "The MadGraph Install path was not existend. It has been created for you."
   print "Just start Herwig++ read again.."
   mkdir_p(sys.argv[2])
   exit()

os.chdir(sys.argv[2])
if os.path.isfile("InterfaceMadGraph.so"):
  files=glob.glob('*.MG')
  containsall=True
  for file in files:
     contains=False
     fileprocessmap=open("processmap.dat","r")
     for line in fileprocessmap:
       if file in line:
	 contains=True
     containsall=(containsall and contains)
  if containsall:
    exit()    
  
 
fillprocs()
os.system("python "+sys.argv[1]+"/mg5_aMC proc.dat")
Bornlist=[]
Virtlist=[]
procs=open("proc.dat","r")
for line in procs:
  if "@" in line:
    if "[ virt=QCD ]" in line:
      Virtlist+=[line.split("@")[1].replace("\n","")]
    else:
      Bornlist+=[line.split("@")[1].replace("\n","")]
TXTlist=[["","setpara('param_card.dat')"],
	 ["","BORN(momenta,hel)"],
	 ["","SLOOPMATRIX(momenta,virt)"],
	 ["","GET_JAMP(color,Jamp)"],
	 ["","GET_NCOL(color)"],
	 ["","GET_NCOLOR(i,j,color)"]]
for txt in TXTlist:
  for i in Bornlist + list(set(Virtlist) - set(Bornlist)):
    if txt[1]=="Virt(amp)" or txt[1]=="SLOOPMATRIX(momenta,virt)" and i not in  Virtlist:
      continue
   # if txt[1]=="BORN(momenta,hel)" and i not in  Bornlist:
   #   continue
    if txt[0]=="":
       txt[0]+="         IF (proc .EQ. "+i+") THEN\n            CALL "
       if "setpara" not in txt[1] :   
	  txt[0]+=   "P"+i+"_"
       txt[0]+=txt[1]+"\n"
    else:
       txt[0]+="         ELSE IF (proc .EQ. "+i+") THEN\n"\
               "            CALL "
       if "setpara" not in txt[1] :   
	  txt[0]+=   "P"+i+"_"
       txt[0]+=txt[1]+"\n"
  if txt[0]!="":	     
    txt[0]+="         ELSE\n"
    txt[0]+="             WRITE(*,*) '##W02A WARNING No id found '\n"
    txt[0]+="         ENDIF   \n"

shutil.copyfile("@prefix@/share/Herwig++/MadGraphInterface/InterfaceMadGraph.f.in", "InterfaceMadGraph.f")
replacemachine("InterfaceMadGraph.f","MG_InitProctxt", TXTlist[0][0])
replacemachine("InterfaceMadGraph.f","MG_CalculateBORNtxt",TXTlist[1][0])
replacemachine("InterfaceMadGraph.f","MG_CalculateVIRTtxt",TXTlist[2][0])
replacemachine("InterfaceMadGraph.f","MG_Jamptxt",     TXTlist[3][0])
replacemachine("InterfaceMadGraph.f","MG_NColtxt",     TXTlist[4][0])
replacemachine("InterfaceMadGraph.f","MG_ColourMattxt",TXTlist[5][0])

MG_vxxxxxtxt=""
if TXTlist[2][0]!="":
  MG_vxxxxxtxt="""       subroutine  MG_vxxxxx(p, n,inc,VC)
     $   bind(c, name='MG_vxxxxx')
         IMPLICIT NONE
         double precision p(0:3)
         double precision n(0:3)
         INTEGER inc
         double precision VC(0:7)
         double complex  VCtmp(0:4)
         double complex  Ninplus(8)
         double complex  Noutminus(8)
         double complex  Pinplus(8)
         double complex  Poutplus(8)
         double complex   denom
         double complex  IMAG1
         PARAMETER (IMAG1=(0D0,1D0))
         CALL IXXXXX(n, 0.0d0, +1, +1, Ninplus);  ! |n+>
         CALL OXXXXX(p, 0.0d0, +1, +1, Poutplus); ! <p+|
         CALL OXXXXX(n, 0.0d0, -1, +1, Noutminus);!  <n-|
         CALL IXXXXX(p, 0.0d0, +1, +1, Pinplus);  ! |p+>
         !<p+| gamma_mu |n+>
         VCtmp(0)=Ninplus(5)*Poutplus(7)+Ninplus(6)*Poutplus(8)+
     $             Ninplus(7)*Poutplus(5)+Ninplus(8)*Poutplus(6)
         VCtmp(1)=(Ninplus(7)*Poutplus(6)+Ninplus(8)*Poutplus(5)-
     $             Ninplus(5)*Poutplus(8)-Ninplus(6)*Poutplus(7))
         VCtmp(2)=(-IMAG1*(Ninplus(5)*Poutplus(8)+Ninplus(8) 
     $             * Poutplus(5))+IMAG1*(Ninplus(6)*Poutplus(7)
     $             + Ninplus(7)*Poutplus(6)));
         VCtmp(3)=(Ninplus(6)*Poutplus(8)+Ninplus(7)*Poutplus(5)-
     $              Ninplus(5)*Poutplus(7)-Ninplus(8)*Poutplus(6))
         denom= (Pinplus(5)*Noutminus(5)+Pinplus(6)
     $          *Noutminus(6)+Pinplus(7)*Noutminus(7)
     $          +Pinplus(8)*Noutminus(8))*sqrt(2.d0)
          if (inc.gt.1 )THEN
            denom=denom*-1.0d0
            if (abs(VCtmp(3)).ne.0.d0)THEN
             denom=denom* (VCtmp(3))/abs(VCtmp(3))
            endif
            if (abs(VCtmp(1)).ne.0.d0)THEN
              denom=denom* (VCtmp(1))/abs(VCtmp(1))
            endif
          endif
         VCtmp(0)=-1.0d0*VCtmp(0)/denom
         VCtmp(1)=-1.0d0*VCtmp(1)/denom
         VCtmp(2)=-1.0d0*VCtmp(2)/denom
         VCtmp(3)=-1.0d0*VCtmp(3)/denom
         VC(0)= real(VCtmp(0))
         VC(1)=aimag(VCtmp(0))  
         VC(2)= real(VCtmp(1))
         VC(3)=aimag(VCtmp(1))  
         VC(4)= real(VCtmp(2))
         VC(5)=aimag(VCtmp(2))  
         VC(6)= real(VCtmp(3))
         VC(7)=aimag(VCtmp(3))  
       END"""
else:
  MG_vxxxxxtxt="""       subroutine  MG_vxxxxx(p, n,inc,VC)
     $   bind(c, name='MG_vxxxxx')
         IMPLICIT NONE
         double precision p(0:3)
         double precision n(0:3)
         INTEGER inc
         double precision VC(0:7)
         double complex  VCtmp(0:4)
         double complex  Ninplus(6)
         double complex  Noutminus(6)
         double complex  Pinplus(6)
         double complex  Poutplus(6)
         double complex   denom
         double complex  IMAG1
         PARAMETER (IMAG1=(0D0,1D0))
         CALL IXXXXX(n, 0.0d0, +1, +1, Ninplus);  ! |n+>
         CALL OXXXXX(p, 0.0d0, +1, +1, Poutplus); ! <p+|
         CALL OXXXXX(n, 0.0d0, -1, +1, Noutminus);!  <n-|
         CALL IXXXXX(p, 0.0d0, +1, +1, Pinplus);  ! |p+>
         !<p+| gamma_mu |n+>
         VCtmp(0)=Ninplus(3)*Poutplus(5)+Ninplus(4)*Poutplus(6)+
     $             Ninplus(5)*Poutplus(3)+Ninplus(6)*Poutplus(4)
         VCtmp(1)=(Ninplus(5)*Poutplus(4)+Ninplus(6)*Poutplus(3)-
     $             Ninplus(3)*Poutplus(6)-Ninplus(4)*Poutplus(5))
         VCtmp(2)=(-IMAG1*(Ninplus(3)*Poutplus(6)+Ninplus(6) 
     $             * Poutplus(3))+IMAG1*(Ninplus(4)*Poutplus(5)
     $             + Ninplus(5)*Poutplus(4)));
         VCtmp(3)=(Ninplus(4)*Poutplus(6)+Ninplus(5)*Poutplus(3)-
     $              Ninplus(3)*Poutplus(5)-Ninplus(6)*Poutplus(4))
         denom= (Pinplus(3)*Noutminus(3)+Pinplus(4)
     $          *Noutminus(4)+Pinplus(5)*Noutminus(5)
     $          +Pinplus(6)*Noutminus(6))*sqrt(2.d0)
          if (inc.gt.1 )THEN
            denom=denom*-1.0d0
            if (abs(VCtmp(3)).ne.0.d0)THEN
             denom=denom* (VCtmp(3))/abs(VCtmp(3))
            endif
            if (abs(VCtmp(1)).ne.0.d0)THEN
              denom=denom* (VCtmp(1))/abs(VCtmp(1))
            endif
          endif
         VCtmp(0)=-1.0d0*VCtmp(0)/denom
         VCtmp(1)=-1.0d0*VCtmp(1)/denom
         VCtmp(2)=-1.0d0*VCtmp(2)/denom
         VCtmp(3)=-1.0d0*VCtmp(3)/denom
         VC(0)= real(VCtmp(0))
         VC(1)=aimag(VCtmp(0))  
         VC(2)= real(VCtmp(1))
         VC(3)=aimag(VCtmp(1))  
         VC(4)= real(VCtmp(2))
         VC(5)=aimag(VCtmp(2))  
         VC(6)= real(VCtmp(3))
         VC(7)=aimag(VCtmp(3))  
       END"""
replacemachine("InterfaceMadGraph.f","MG_vxxxxxtxt",MG_vxxxxxtxt)


make=" "
files1=glob.glob('*/*/*.f')
files2=glob.glob('*/*/*/*.f')
for i in files1+files2:
  if "check_sa" not in i:
   make += " "+i

files1=glob.glob('*/*/*.inc')
files2=glob.glob('*/*/*/*.inc')
coefdir=""
for i in files1+files2:
  if "nexternal.inc" in i:
   coefdir+=" -I"+i.replace("nexternal.inc"," ")
  #if "coupl.inc" in i:
   #INCLUDE=i.replace("coupl.inc"," ")
   #coefdir+=" -I"+INCLUDE.replace("coupl.inc"," ")   

file=open("makefile","w")
file.write("include MG5/Source/make_opts\n")
file.write("LIBDIR = MG5/lib\n")
if Virtlist!=[]:
    file.write("LINKLIBS =  -L$(LIBDIR) -lcts \n")
    file.write("LIBS =  $(LIBDIR)libcts.$(libext) \n")
file.write("PROCESS= InterfaceMadGraph.f "+make)
file.write("\n\nall:  \n\t gfortran  $(FFLAGS) -fPIC -fno-f2c -shared -s -o  InterfaceMadGraph.so -IMG5/SubProcesses/ ")
if coefdir != "":
   file.write(coefdir)
file.write("   $(PROCESS) $(LINKLIBS) ")
file.close()

os.system("make")

os.system("ln -s MadGraphAmplitudes/MG5/SubProcesses ../")
os.system("ln -s MadGraphAmplitudes/MG5/Cards ../")
os.system("cp $(find -name ident_card.dat) ../")
#os.system("cp $(find -name MadLoopParams.dat) ../")
#os.system("cp $(find -name ColorNumFactors.dat) ../")
#os.system("cp $(find -name ColorDenomFactors.dat) ../")
#os.system("cp $(find -name HelConfigs.dat) ../")
#ColorNumFactors.dat
#ColorDenomFactors.dat
#HelConfigs.dat

#replacefromto(sys.argv[2]+"/MGout/src/Parameters_sm.cc", "void Parameters_sm::setIndependentParameters(SLHAReader& slha)","void Parameters_sm::setIndependentCouplings()",parameterdat)
#replacemachine(sys.argv[2]+"/MGout/src/read_slha.cc","cout << \"Opened slha fil", "//cout << \"Opened slha fil")

#os.system("make")
#os.chdir(pwdxx)
#os.system("cp param_card.dat "+sys.argv[2]+"/MGout/Cards/")
