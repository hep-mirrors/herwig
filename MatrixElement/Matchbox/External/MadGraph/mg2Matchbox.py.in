#! /usr/bin/env python

import os,sys,glob,errno,shutil,argparse,time
 

#  helper to replace all sourceText in fileName with replaceText
def replacetext(fileName, sourceText, replaceText):
    file = open(fileName, "r") 
    text = file.read() 
    file.close()
    file = open(fileName, "w")
    file.write(text.replace(sourceText, replaceText))
    file.close() 

#  helper to build recursivly path
def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise   
      
#  helper to find all files of with name in path
def find(name, path):
    for root, dirs, files in os.walk(path):
        if name in files:
            return os.path.join(root, name)      
 
# fill the proc.dat file from BornAmplitudes.dat and VirtAmplitudes.dat.
def fillprocs(model,oras,orew):
  bornlist=[]
  virtlist=[]
  fileproc=open("proc.dat","w")
  fileproc.write("import model "+model+"\n")
  borns="BornAmplitudes.dat"
  virts="VirtAmplitudes.dat"
  first=True
  procnr=0
  virtlines=""
  bornlines=""
  


    
  minlegs=100
  legs=0
  for i in [borns, virts]:
    file = open(i, "r")
    for line in file:
      if (len(line.split(" "))<minlegs):
        minlegs=len(line.split(" "))
        for it in line.split(" "):
	  if it.replace("-","").isdigit():
	    legs+=1
      
    file.close()
  
   
    
  #conversion for heft model to go from (2QCD+1QED)->1HIG for each FS HIGGS.
  HIG=0
  if (model=="heft"):
    HIG=(int(oras)+int(orew)-legs+2)/2
    
    if (int(oras)+int(orew)-legs+2)%2!=0:
      print "Warning: No possible coupling power:(int(oras)+int(orew)-legs+2)%2!=0 "
      exit()
      return

  
  
  
  
  file = open(borns, "r")
  for line in file:
      #this assumes extra QCD emmissions
      addalphas=len(line.split(" "))-minlegs
      linetmp=line.rstrip()
      procnr+=1
      bornlist+=[str(procnr)]
      if first:
	if HIG ==0 :
	  bornlines+="generate "+linetmp+" QCD="+str(int(oras)+addalphas)+" QED="+str(orew)+" @"+str(procnr)+"\n"
	else:
	  bornlines+="generate "+linetmp+" HIG="+str(HIG)+" QCD="+str(int(oras)+addalphas-2*HIG)+" QED="+str(int(orew)-HIG)+" @"+str(procnr)+"\n"
	first=False
      else:
	if HIG ==0 :
	  bornlines+="add process "+linetmp+" QCD="+str(int(oras)+addalphas)+" QED="+str(orew)+" @"+str(procnr)+"\n"
	else:
	  bornlines+="add process "+linetmp+" HIG="+str(HIG)+" QCD="+str(int(oras)+addalphas-2*HIG)+" QED="+str(int(orew)-HIG)+" @"+str(procnr)+"\n"
	
  file.close()
  first=True
  file = open(virts, "r")
  for line in file:
      addalphas=len(line.split(" "))-minlegs
      linetmp=line.rstrip()+"  QED="+str(int(orew))+" [ virt=QCD ]"
      procnr+=1
      virtlist+=[str(procnr)]
      if first:
	virtlines+="generate "+linetmp+"  @"+str(procnr)+"\n"
	first=False
      else:
	virtlines+="add process "+linetmp+"  @"+str(procnr)+"\n"
  file.close()

  fileproc.write(bornlines)
  if virtlines!="" and bornlines!="":
     fileproc.write("output matchbox MG5 --postpone_model\n") 
  fileproc.write(virtlines)
  fileproc.write("output matchbox MG5 -f\n")
  fileproc.close()
  return bornlist,virtlist

def build_matchbox_tmp(pwd,buildpath):
   cwd=os.getcwd() 
   os.chdir(pwd)
   mkdir_p(pwd+"/Herwig/MG_tmp/")
   if not buildpath.startswith("/"):
     buildpath=pwd+"/"+buildpath.lstrip("./")
   resources=glob.glob(buildpath +"/MG5/SubProcesses/MadLoop5_resources/*")
   resources+=glob.glob(buildpath +"/MG5/Cards/*")
   resources+=glob.glob(buildpath +"/MG5/Cards/SubProcesses/*")
   for i in resources:
     if not os.path.isfile( pwd+"/Herwig/MG_tmp/"+os.path.basename(i)) \
       and not os.path.islink( pwd+"/Herwig/MG_tmp/"+os.path.basename(i)):
        os.symlink(i, pwd+"/Herwig/MG_tmp/"+os.path.basename(i))
   os.chdir(cwd)    


  
parser = argparse.ArgumentParser()
parser.add_argument('--buildpath', help='installpath')
parser.add_argument('--build', help='build', action="store_true")
parser.add_argument('--madgraph', help='madgraph_installpath')
parser.add_argument('--runpath', help='runpath')
parser.add_argument('--model', help='model')
parser.add_argument('--orderas', help='orderas')
parser.add_argument('--orderew', help='orderew')



args = parser.parse_args()






pwd=os.getcwd() 


param_card=""
mkdir_p(pwd+"/Herwig/MG_tmp/")






if args.model=="loop_sm" or args.model=="heft":

  if args.model=="loop_sm":
    param_card="param_card.dat"
  else:
    param_card="param_card_"+args.model+".dat"  
    
  file = open("@prefix@/share/Herwig++/MadGraphInterface/"+param_card+".in", "r") 
  paramcard = file.read() 
  file.close()
  file = open(args.runpath+"/"+param_card, "w")

  params=open(args.runpath+"/MG-Parameter.dat", "r")

  for line in params:
    a=line.split()
    paramcard=paramcard.replace(a[0],a[1])
  params.close()
  file.write(paramcard)
  file.close()   
else:
  print "---------------------------------------------------------------"
  print "---------------------------------------------------------------"
  print "Warning: The model set for the MadGraph Interface "
  print "         needs a parameter setting by hand."
  print "         Please fill the param_card_"+args.model+".dat"
  print "         with your favourite assumptions."
  print "         And make sure Herwig uses the same parameters."
  print "---------------------------------------------------------------"
  print "---------------------------------------------------------------"
  if os.path.isfile(args.buildpath +"/MG5/Cards/param_card.dat") and not os.path.isfile(args.runpath+"/"+"param_card_"+args.model+".dat"):
    shutil.copyfile(args.buildpath +"/MG5/Cards/param_card.dat", args.runpath+"/"+"param_card_"+args.model+".dat")
  time.sleep(1)

if not os.path.isdir(args.buildpath):
   print "The MadGraph Install path was not existend. It has been created for you."
   print "Just start Herwig++ read again.."
   mkdir_p(args.buildpath)
   exit()

os.chdir(args.buildpath)
if os.path.isfile("InterfaceMadGraph.so"):
  build_matchbox_tmp(pwd,args.buildpath)
  exit()
 
Bornlist,Virtlist=fillprocs(args.model,args.orderas,args.orderew)

if not args.madgraph and not os.path.isfile("InterfaceMadGraph.so"):
  print "*** warning *** MadGraph build failed, check logfile for details"
  exit()

os.system("python "+args.madgraph+"/mg5_aMC proc.dat")


routines=[["","BORN(momenta,hel)"],
	 ["","SLOOPMATRIX(momenta,virt)"],
	 ["","GET_JAMP(color,Jamp)"],
	 ["","GET_LNJAMP(color,Jamp)"],
	 ["","GET_NCOL(color)"],
	 ["","GET_NCOLOR(i,j,color)"]]
for routine in routines:
  for i in Bornlist + list(set(Virtlist) - set(Bornlist)):
    if routine[1]=="Virt(amp)" or routine[1]=="SLOOPMATRIX(momenta,virt)" and i not in  Virtlist:
      continue
    if routine[0]=="":
       routine[0]+="         IF (proc .EQ. "+i+") THEN\n            CALL "
       routine[0]+=   "MG5_"+i+"_"+routine[1]+"\n"
    else:
       routine[0]+="         ELSE IF (proc .EQ. "+i+") THEN\n"\
               "            CALL "
       routine[0]+=   "MG5_"+i+"_"+routine[1]+"\n"
  if routine[0]!="":	     
       routine[0]+="         ELSE\n"
       routine[0]+="             WRITE(*,*) '##W02A WARNING No id found '\n"
       routine[0]+="         ENDIF   \n"



shutil.copyfile("@prefix@/share/Herwig++/MadGraphInterface/InterfaceMadGraph.f.in", "InterfaceMadGraph.f")

replacetext("InterfaceMadGraph.f","MG_CalculateBORNtxt",routines[0][0])
replacetext("InterfaceMadGraph.f","MG_CalculateVIRTtxt",routines[1][0])
replacetext("InterfaceMadGraph.f","MG_Jamptxt",     routines[2][0])
replacetext("InterfaceMadGraph.f","MG_LNJamptxt",     routines[3][0])
replacetext("InterfaceMadGraph.f","MG_NColtxt",     routines[4][0])
replacetext("InterfaceMadGraph.f","MG_ColourMattxt",routines[5][0])

MG_vxxxxxtxt=""
if routines[1][0]!="":
  MG_vxxxxxtxt="""       subroutine  MG_vxxxxx(p, n,inc,VC)
     $   bind(c, name='MG_vxxxxx')
         IMPLICIT NONE
         double precision p(0:3)
         double precision n(0:3)
         INTEGER inc
         double precision VC(0:7)
         double complex  VCtmp(0:4)
         double complex  Ninplus(8)
         double complex  Noutminus(8)
         double complex  Pinplus(8)
         double complex  Poutplus(8)
         double complex   denom
         double complex  IMAG1
         PARAMETER (IMAG1=(0D0,1D0))
         CALL IXXXXX(n, 0.0d0, +1, +1, Ninplus);  ! |n+>
         CALL OXXXXX(p, 0.0d0, +1, +1, Poutplus); ! <p+|
         CALL OXXXXX(n, 0.0d0, -1, +1, Noutminus);!  <n-|
         CALL IXXXXX(p, 0.0d0, +1, +1, Pinplus);  ! |p+>
         !<p+| gamma_mu |n+>
         VCtmp(0)=Ninplus(5)*Poutplus(7)+Ninplus(6)*Poutplus(8)+
     $             Ninplus(7)*Poutplus(5)+Ninplus(8)*Poutplus(6)
         VCtmp(1)=(Ninplus(7)*Poutplus(6)+Ninplus(8)*Poutplus(5)-
     $             Ninplus(5)*Poutplus(8)-Ninplus(6)*Poutplus(7))
         VCtmp(2)=(-IMAG1*(Ninplus(5)*Poutplus(8)+Ninplus(8) 
     $             * Poutplus(5))+IMAG1*(Ninplus(6)*Poutplus(7)
     $             + Ninplus(7)*Poutplus(6)));
         VCtmp(3)=(Ninplus(6)*Poutplus(8)+Ninplus(7)*Poutplus(5)-
     $              Ninplus(5)*Poutplus(7)-Ninplus(8)*Poutplus(6))
         denom= (Pinplus(5)*Noutminus(5)+Pinplus(6)
     $          *Noutminus(6)+Pinplus(7)*Noutminus(7)
     $          +Pinplus(8)*Noutminus(8))*sqrt(2.d0)
          if (inc.gt.1 )THEN
            denom=denom*-1.0d0
            if (abs(VCtmp(3)).ne.0.d0)THEN
             denom=denom* (VCtmp(3))/abs(VCtmp(3))
            endif
            if (abs(VCtmp(1)).ne.0.d0)THEN
              denom=denom* (VCtmp(1))/abs(VCtmp(1))
            endif
          endif
         VCtmp(0)=-1.0d0*VCtmp(0)/denom
         VCtmp(1)=-1.0d0*VCtmp(1)/denom
         VCtmp(2)=-1.0d0*VCtmp(2)/denom
         VCtmp(3)=-1.0d0*VCtmp(3)/denom
         VC(0)= real(VCtmp(0))
         VC(1)=aimag(VCtmp(0))  
         VC(2)= real(VCtmp(1))
         VC(3)=aimag(VCtmp(1))  
         VC(4)= real(VCtmp(2))
         VC(5)=aimag(VCtmp(2))  
         VC(6)= real(VCtmp(3))
         VC(7)=aimag(VCtmp(3))  
       END"""
else:
  MG_vxxxxxtxt="""       subroutine  MG_vxxxxx(p, n,inc,VC)
     $   bind(c, name='MG_vxxxxx')
         IMPLICIT NONE
         double precision p(0:3)
         double precision n(0:3)
         INTEGER inc
         double precision VC(0:7)
         double complex  VCtmp(0:4)
         double complex  Ninplus(6)
         double complex  Noutminus(6)
         double complex  Pinplus(6)
         double complex  Poutplus(6)
         double complex   denom
         double complex  IMAG1
         PARAMETER (IMAG1=(0D0,1D0))
         CALL IXXXXX(n, 0.0d0, +1, +1, Ninplus);  ! |n+>
         CALL OXXXXX(p, 0.0d0, +1, +1, Poutplus); ! <p+|
         CALL OXXXXX(n, 0.0d0, -1, +1, Noutminus);!  <n-|
         CALL IXXXXX(p, 0.0d0, +1, +1, Pinplus);  ! |p+>
         !<p+| gamma_mu |n+>
         VCtmp(0)=Ninplus(3)*Poutplus(5)+Ninplus(4)*Poutplus(6)+
     $             Ninplus(5)*Poutplus(3)+Ninplus(6)*Poutplus(4)
         VCtmp(1)=(Ninplus(5)*Poutplus(4)+Ninplus(6)*Poutplus(3)-
     $             Ninplus(3)*Poutplus(6)-Ninplus(4)*Poutplus(5))
         VCtmp(2)=(-IMAG1*(Ninplus(3)*Poutplus(6)+Ninplus(6) 
     $             * Poutplus(3))+IMAG1*(Ninplus(4)*Poutplus(5)
     $             + Ninplus(5)*Poutplus(4)));
         VCtmp(3)=(Ninplus(4)*Poutplus(6)+Ninplus(5)*Poutplus(3)-
     $              Ninplus(3)*Poutplus(5)-Ninplus(6)*Poutplus(4))
         denom= (Pinplus(3)*Noutminus(3)+Pinplus(4)
     $          *Noutminus(4)+Pinplus(5)*Noutminus(5)
     $          +Pinplus(6)*Noutminus(6))*sqrt(2.d0)
          if (inc.gt.1 )THEN
            denom=denom*-1.0d0
            if (abs(VCtmp(3)).ne.0.d0)THEN
             denom=denom* (VCtmp(3))/abs(VCtmp(3))
            endif
            if (abs(VCtmp(1)).ne.0.d0)THEN
              denom=denom* (VCtmp(1))/abs(VCtmp(1))
            endif
          endif
         VCtmp(0)=-1.0d0*VCtmp(0)/denom
         VCtmp(1)=-1.0d0*VCtmp(1)/denom
         VCtmp(2)=-1.0d0*VCtmp(2)/denom
         VCtmp(3)=-1.0d0*VCtmp(3)/denom
         VC(0)= real(VCtmp(0))
         VC(1)=aimag(VCtmp(0))  
         VC(2)= real(VCtmp(1))
         VC(3)=aimag(VCtmp(1))  
         VC(4)= real(VCtmp(2))
         VC(5)=aimag(VCtmp(2))  
         VC(6)= real(VCtmp(3))
         VC(7)=aimag(VCtmp(3))  
       END"""
replacetext("InterfaceMadGraph.f","MG_vxxxxxtxt",MG_vxxxxxtxt)


make=" "
fortanfiles=glob.glob('*/*/*.f')+glob.glob('*/*/*/*.f')

for i in fortanfiles:
  if "check_sa" not in i:
    if not os.path.islink(i):
       make += " "+i+"\\\n                  "

incfiles=glob.glob('*/*/*.inc')+glob.glob('*/*/*/*.inc')

coefdir=""
for i in incfiles:
  if "nexternal.inc" in i:
   coefdir+=" -I"+i.replace("nexternal.inc"," ")


file=open("makefile","w")
file.write("include MG5/Source/make_opts  ")
if Virtlist!=[]:
    file.write("\nLIBDIR = MG5/lib\nLINKLIBS =  -L$(LIBDIR) -lcts  -liregi -L$(LIBDIR)/golem95_lib -lgolem") 
    file.write("\nLIBS = $(LIBDIR)libcts.$(libext) $(LIBDIR)libgolem.$(libext) $(LIBDIR)libiregi.$(libext)")
file.write("\nPROCESS= InterfaceMadGraph.f "+make+"\n\nall:  \n\t @FC@  @FFLAGS@ -w -fbounds-check -ffixed-line-length-132 -fPIC -fno-f2c -shared -s -o  InterfaceMadGraph.so -IMG5/SubProcesses/" )
if Virtlist!=[]:
  file.write(" -IMG5/lib/golem95_include ")

if coefdir != "":
   file.write(coefdir)
file.write("   $(PROCESS) $(LINKLIBS) ")
file.close()


os.chdir(pwd)
os.chdir(args.buildpath)
replacetext("MG5/Source/MODEL/lha_read.f", "ident_card.dat","Herwig/MG_tmp/ident_card.dat")
replacetext("MG5/Source/MODEL/lha_read.f", "param.log","Herwig/MG_tmp/param.log")
if Virtlist!=[]:
  replacetext("MG5/SubProcesses/MadLoopCommons.f", "PREFIX='./'","PREFIX='./Herwig/MG_tmp/'")

os.system("make")


build_matchbox_tmp(pwd,args.buildpath)

