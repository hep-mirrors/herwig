// -*- C++ -*-
//
// MEfv2vf.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the MEfv2vf class.
//

namespace Herwig {

inline MEfv2vf::MEfv2vf() {}

inline IBPtr MEfv2vf::clone() const {
  return new_ptr(*this);
}

inline IBPtr MEfv2vf::fullclone() const {
  return new_ptr(*this);
}

inline void MEfv2vf::doinit() throw(InitException) {
  GeneralHardME::doinit();
  HPCount ndiags = numberOfDiags();
  theFerm.resize(ndiags);
  theVec.resize(ndiags);
  for(HPCount ix = 0; ix < ndiags; ++ix) {
    HPDiagram diagram = getProcessInfo()[ix];
    PDT::Spin offspin = diagram.intermediate->iSpin();
    if(diagram.channelType == HPDiagram::sChannel ||
       ( diagram.channelType == HPDiagram::tChannel 
	 && offspin == PDT::Spin1Half)) {
      FFVVertexPtr vert1 = dynamic_ptr_cast<FFVVertexPtr>
		(diagram.vertices.first);
      FFVVertexPtr vert2 = dynamic_ptr_cast<FFVVertexPtr>
	(diagram.vertices.second);
      theFerm[ix] = make_pair(vert1, vert2);
    }
    else {
      if(offspin == PDT::Spin1) {
	FFVVertexPtr vert1 = dynamic_ptr_cast<FFVVertexPtr>
	  (diagram.vertices.first);
	VVVVertexPtr vert2 = dynamic_ptr_cast<VVVVertexPtr>
	  (diagram.vertices.second);
	theVec[ix] = make_pair(vert1, vert2);
      }
    }
  }
}


}
