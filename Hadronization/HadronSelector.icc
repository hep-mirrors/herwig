// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the HadronSelector class.
//

namespace Herwig {

inline HadronSelector::HadronTable & HadronSelector::table() {
  return _table;
}

inline vector<PDPtr> & HadronSelector::partons() {
  return _partons;
}

inline double HadronSelector::pwt(tcPDPtr p) {
  assert(p);
  if ( p->id() < 0 ) 
    p = p->CC();
  map<tcPDPtr,double>::iterator it = _pwt.find(p);
  assert( it != _pwt.end() );
  return it->second;
}

inline double HadronSelector::pwtDquark() const {
  return _pwtDquark;
}

inline double HadronSelector::pwtUquark() const { 
  return _pwtUquark;
}

inline double HadronSelector::pwtSquark() const { 
  return _pwtSquark;
}

inline double HadronSelector::pwtCquark() const { 
  return _pwtCquark;
}

inline double HadronSelector::pwtBquark() const { 
  return _pwtBquark;
}

inline double HadronSelector::pwtDIquark() const {
  return _pwtDIquark;
}

inline double HadronSelector::probabilityMixing(const double angleMix,
						const int order) {
  static double convert=Constants::pi/180.0;
  if (order == 1)      return sqr( cos( angleMix*convert + atan( sqrt(2.0) ) ) );
  else if (order == 2) return sqr( sin( angleMix*convert + atan( sqrt(2.0) ) ) );
  else                 return 1.;
}

inline HadronSelector::Kupco::Kupco(tcPDPtr inidQ,tcPDPtr inhad1,tcPDPtr inhad2,
				    Energy inwgt) 
  : idQ(inidQ),hadron1(inhad1),hadron2(inhad2),weight(inwgt)
{}

inline HadronSelector::HadronInfo::HadronInfo(long idin,tPDPtr datain,
					      double swtin,Energy massin) 
  : id(idin), ptrData(datain), swtef(swtin), wt(1.0), overallWeight(0.0),
    mass(massin)
{}

inline bool HadronSelector::HadronInfo::operator<(const HadronInfo &x) const {
  return mass < x.mass; 
}

inline Energy HadronSelector::massLightestHadronPair(tcPDPtr ptr1, tcPDPtr ptr2,
						     tcPDPtr ptr3)const {
  pair<tcPDPtr,tcPDPtr> pairData = lightestHadronPair(ptr1, ptr2, ptr3);
  if ( ! pairData.first || ! pairData.second ) return Energy();
  return ( pairData.first->mass() + pairData.second->mass() ); 
}

inline tcPDPtr HadronSelector::lightestHadron(tcPDPtr ptr1, tcPDPtr ptr2,
						     tcPDPtr ptr3) const {
  // The method assumes ptr3 == 0  
  // rest not implemented
  assert(ptr1 && ptr2);
  assert(!ptr3);

  // find entry in the table
  pair<long,long> ids = make_pair(abs(ptr1->id()),abs(ptr2->id()));
  HadronTable::const_iterator tit=_table.find(ids);
 // throw exception if flavours wrong
  if (tit==_table.end()) {
    /// \todo should we just leave the cluster in event record?
    throw Exception() << "Could not find " 
		      << ids.first << ' ' << ids.second 
		      << " in _table." << Exception::eventerror;
  }
  if(tit->second.empty()) {
    throw Exception() << "HadronSelector::lightestHadron "
		      << "could not find any hadrons containing " 
		      << ptr1->id() << ' ' << ptr2->id() << '\n'
		      << tit->first.first << ' ' 
		      << tit->first.second << Exception::eventerror;
  }

  // find the lightest hadron
  int sign = signHadron(ptr1,ptr2,tit->second.begin()->ptrData);
  tcPDPtr candidate = sign > 0 ? tit->second.begin()->ptrData : tit->second.begin()->ptrData->CC();

  /// \todo 20 GeV limit is temporary fudge to let SM particles go through. \todo Use isExotic instead?
  if (candidate->mass() > 20*GeV 
      && candidate->mass() < ptr1->constituentMass() + ptr2->constituentMass()) {
    cerr << "HadronSelector::lightestHadron: "
	 << "chosen candidate " << candidate->PDGName() 
	 << " is lighter than its constituents "
	 << ptr1->PDGName() << ", " << ptr2->PDGName() << '\n'
	 << candidate->mass()/GeV << " < " << ptr1->constituentMass()/GeV
	 << " + " << ptr2->constituentMass()/GeV << '\n'
	 << "Check your particle data tables.\n";
    assert(false);
  }

  return candidate;
}

inline Energy HadronSelector::massLightestHadron(tcPDPtr ptr1, tcPDPtr ptr2,
						     tcPDPtr ptr3) const {
  // The method assumes ptr3 == empty  
  assert(!(ptr3));
//  throw Exception() << "HadronSelector::massLightestHadron"
// 			     << "called with ptr3" << ptr3->id()
// 			     << "which is non-zero and not implemented"
// 			     << Exception::runerror;
  // find entry in the table
  pair<long,long> ids(abs(ptr1->id()),abs(ptr2->id()));
  HadronTable::const_iterator tit=_table.find(ids);
  // throw exception if flavours wrong
  assert(!(tit==_table.end()||tit->second.empty()));
//  {
//     throw Exception() <<  "HadronSelector::massLightestHadron "
//  		      << "failed for particle" << ptr1->id()  << " " << ptr2->id() 
//  		      << Exception::runerror;
//   }
  // return the mass
  return tit->second.begin()->mass;
}

}
