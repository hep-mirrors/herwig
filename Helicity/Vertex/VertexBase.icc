// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the VertexBase class.
//

namespace Herwig {
namespace Helicity{
using namespace ThePEG;
using namespace ThePEG::Helicity;

inline VertexBase::VertexBase()
{
  _npoint=0;
  _calckinematics=false;
}
    
inline VertexBase::VertexBase(const VertexBase & x)
  : Interfaced(x), _iparticlea(x._iparticlea),_iparticleb(x._iparticleb),
    _iparticlec(x._iparticlec),_iparticled(x._iparticled),_iparticlee(x._iparticlee),
    _particlea(x._particlea),_particleb(x._particleb),_particlec(x._particlec),
    _particled(x._particled),_particlee(x._particlee),_ispin(x._ispin),
    _npoint(x._npoint), _nsize(x._nsize), _inpart(x._inpart), _iinpart(x._iinpart),
    _outpart(x._outpart), _ioutpart(x._ioutpart), _calckinematics(x._calckinematics)
{}
    
inline void VertexBase::doupdate() throw(UpdateException) {
  Interfaced::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
  //  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
  //  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
  //  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
  //  touch()
  // Touch if anything has changed.
}
    
inline void VertexBase::doinit() throw(InitException) {
  Interfaced::doinit();
  // get the particle data points for the external particles
  if(_npoint>=3)
    {
      for(unsigned int ix=0;ix<size();++ix)
	{
	  _particlea.push_back(getParticleData(_iparticlea[ix]));
	  _particleb.push_back(getParticleData(_iparticleb[ix]));
	  _particlec.push_back(getParticleData(_iparticlec[ix]));
	}
    }
  if(_npoint>=4)
    {
      for(unsigned int ix=0;ix<size();++ix)
	{_particled.push_back(getParticleData(_iparticled[ix]));}
    }
  if(_npoint==5)
    {
      for(unsigned int ix=0;ix<size();++ix)
	{_particlee.push_back(getParticleData(_iparticlee[ix]));}
    }
  // set up the incoming and outgoing particles
  setIncoming();
  setOutgoing();
}
  
inline void VertexBase::dofinish() {
  Interfaced::dofinish();
}
  
inline void VertexBase::doinitrun() {
  Interfaced::doinitrun();
}
  
inline void VertexBase::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  Interfaced::rebind(trans);
}
    
inline IVector VertexBase::getReferences() {
  IVector ret = Interfaced::getReferences();
  // ret.push_back(dummy);
  return ret;
}

// constructors for three point vertices
inline VertexBase::VertexBase(int isa, int isb, int isc,
			      vector<int> ida,vector<int> idb,vector<int> idc,bool kine)
{
  // number of external particles
  _npoint = 3;
  // initialise the spins
  setSpin(isa,isb,isc);
  // and the particles;
  setList(ida,idb,idc);
  _calckinematics=kine;
}

// constructors for four  point vertices
inline VertexBase::VertexBase(int isa,int isb, int isc, int isd,
			      vector<int> ida, vector<int> idb,
			      vector<int> idc, vector<int> idd, bool kine)
{
  // number of external particles
  _npoint = 4;
  // initialise the spins
  setSpin(isa,isb,isc,isd);
  // and the particles
  setList(ida,idb,idc,idd);
  _calckinematics=kine;
}

// constructors for five point vertices
inline VertexBase::VertexBase(int ia, int ib, int ic, int id , int ie,
			      vector<int> ida,vector<int> idb,
			      vector<int> idc,vector<int> idd,
			      vector<int> ide,bool kine)
{
  // number of external particles
  _npoint = 5;
  // initialise the spins
  setSpin(ia,ib,ic,id,ie);
  // and the particles
  setList(ida,idb,idc,idd,ide);
  _calckinematics=kine;
}

// default constructor
inline VertexBase::VertexBase(unsigned int nin, bool kine) : _npoint(nin), _calckinematics(kine)
{;}


// setup the spins

// three point vertex
inline void VertexBase::setSpin(int ia,int ib,int ic){
  if(_ispin.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setSpin the spins have already "
				      << "been set" << Exception::warning;}
  else if(_npoint!=3)
    {throw HelicityConsistencyError() << "VertexBase::setSpin not a three point vertex" 
				      << Exception::abortnow;}
  else
    {_ispin.push_back(ia);_ispin.push_back(ib);_ispin.push_back(ic);}
}

// four point vertex
inline void VertexBase::setSpin(int ia,int ib,int ic, int id){
  if(_ispin.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setSpin the spins have already "
				      << "been set" << Exception::warning;}
  else if(_npoint!=4)
    {throw HelicityConsistencyError() << "VertexBase::setSpin not a four point vertex" 
				      << Exception::abortnow;}
  else
    {_ispin.push_back(ia);_ispin.push_back(ib);_ispin.push_back(ic);
    _ispin.push_back(id);}
}

// five point vertex
inline void VertexBase::setSpin(int ia,int ib,int ic, int id, int ie){
  if(_ispin.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setSpin the spins have already "
				      << "been set" << Exception::warning;}
  else if(_npoint!=5)
    {throw HelicityConsistencyError() << "VertexBase::setSpin not a five point vertex" 
				      << Exception::abortnow;}
    else
      {_ispin.push_back(ia);_ispin.push_back(ib);_ispin.push_back(ic);
      _ispin.push_back(id);_ispin.push_back(ie);}
}

// setup the lists of particles

// for a three point vertex
inline void VertexBase::setList(vector<int> ida ,vector<int> idb, vector<int> idc)
{
  // check not already set
  if(_iparticlea.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setList the Particles have already"
				      << " been set" << Exception::abortnow;}
  // check this is really a three point vertex
  else if(_npoint!=3)
    {throw HelicityConsistencyError() << "VertexBase::setList not a three point vertex" 
				      << Exception::abortnow;}
  // check all vectors have the same size
  else if(ida.size()!=ida.size()||ida.size()!=idc.size())
    {throw HelicityConsistencyError() << "VertexBase::setList Particle lists have " 
				      << "different sizes" << Exception::abortnow;}
  // set the arrays
  else{_iparticlea=ida; _iparticleb=idb; _iparticlec=idc;}
  _nsize = _iparticlea.size();
}

// for a four point vertex
inline void VertexBase::setList(vector<int> ida,vector<int> idb,
				vector<int> idc,vector<int> idd)
{
  // check not already set
  if(_iparticlea.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setList the Particles have already"
				      << " been set" << Exception::abortnow;}
  // check this is really a four point vertex
  else if(_npoint!=4)
    {throw HelicityConsistencyError() << "VertexBase::setList not a four point vertex" 
				      << Exception::abortnow;}
  // check all vectors have the same size
  else if(ida.size()!=ida.size()||ida.size()!=idc.size()||ida.size()!=idd.size())
    {throw HelicityConsistencyError() << "VertexBase::setList Particle lists have " 
				      << "different sizes" << Exception::abortnow;}
  // set the arrays
  else{_iparticlea=ida;_iparticleb=idb;_iparticlec=idc;_iparticled=idd;}
  _nsize = _iparticlea.size();
}

inline void VertexBase::setList(vector<int> ida,vector<int> idb, vector<int> idc,
				vector<int> idd,vector<int> ide)
{
  // check not already set
  if(_iparticlea.size()!=0)
    {throw HelicityConsistencyError() << "VertexBase::setList the Particles have already"
				      << " been set" << Exception::abortnow;}
  // check this is really a five point vertex
  else if(_npoint!=5)
    {throw HelicityConsistencyError() << "VertexBase::setList not a five point vertex" 
				      << Exception::abortnow;}
  // check all vectors have the same size
  else if(ida.size()!=ida.size()||ida.size()!=idc.size()||ida.size()!=idd.size()||
	  ida.size()!=ide.size())
    {throw HelicityConsistencyError() << "VertexBase::setList Particle lists have " 
				      << "different sizes" << Exception::abortnow;}
  // set the arrays
  else{_iparticlea=ida;_iparticleb=idb;_iparticlec=idc;_iparticled=idd;_iparticlee=ide;}
  _nsize = _iparticlea.size();
}

// number of different particle combinations allowed
inline unsigned int VertexBase::size(){return _nsize;}

// set and get functions for the number of external particles
inline unsigned int VertexBase::getNpoint(){return _npoint;}
inline void VertexBase::setNpoint(unsigned int in){_npoint=in;}

// is a particle allowed as an incoming particle
inline bool VertexBase::incoming(int id)
{
  if(_iinpart.size()==0){return false;}
  for(unsigned int ix=0;ix<_iinpart.size();++ix)
    {if(_iinpart[ix]==id){return true;}}
  return false;
}

// is a particle allowed as an outgoing particle
inline bool VertexBase::outgoing(int id)
{
  if(_outpart.size()==0){return false;}
  for(unsigned int ix=0;ix<_ioutpart.size();++ix)
    {if(_ioutpart[ix]==id){return true;}}
  return false;
}

// get the list of incoming particles
inline vector<PDPtr> VertexBase::getIncoming()
{return _inpart;}

// get the list of outgoing particles
inline vector<PDPtr> VertexBase::getOutgoing()
{return _outpart;}

// set the coupling
inline void VertexBase::setNorm(const Complex & in){_norm = in;}

// get the coupling
inline const Complex & VertexBase::getNorm(){return _norm;}

// calculate the propagator for a diagram
inline Complex VertexBase::propagator(int iopt, Energy2 p2,tcPDPtr part)
{
  Complex prop;
  Energy mass=part->mass();
  Energy2 mass2=mass*mass;
  Complex masswidth;
  if(p2<0.){masswidth=0.;}
  else if(iopt==1)
    {masswidth=Complex(0.,1.)*mass*part->width();}
  else if(iopt==2)
    {
      Energy p=sqrt(p2);
      masswidth=Complex(0.,1.)*mass*
	((part->widthGenerator())->width(*part,p));
    }
  else if(iopt==3)
    {masswidth=0.;}
  else if(iopt==4)
    {return 1.;}
  else if(iopt==5)
    {return 1./p2;}
  else
    {throw HelicityConsistencyError() << "Unknown option in VertexBase::Propagator" 
				      << Exception::abortnow;}
  return 1./(p2-mass2+masswidth);
}

// propagator times coupling for a diagram
inline Complex VertexBase::normPropagator(int iopt, Energy2 p2,tcPDPtr part)
{
  Complex prop;
  Energy mass=part->mass();
  Energy2 mass2=mass*mass;
  Complex masswidth;
  if(iopt==5)
    {return _norm/p2;}
  else if(p2<0.){masswidth=0.;}
  else if(iopt==1)
    {masswidth=Complex(0.,1.)*mass*part->width();}
  else if(iopt==2)
    {
      Energy p=sqrt(p2);
      masswidth=Complex(0.,1.)*mass*
	((part->widthGenerator())->width(*part,p));
    }
  else if(iopt==3)
    {masswidth=0.;}
  else if(iopt==4)
    {return _norm;}
  else
    {throw HelicityConsistencyError() << "Unknown option in VertexBase::normPropagator" 
				      << Exception::abortnow;}
  return _norm/(p2-mass2+masswidth);
}

inline bool VertexBase::kinematics(){ return _calckinematics;}

inline void VertexBase::kinematics(bool kine){_calckinematics=kine;}

inline void VertexBase::calculateKinematics(const Lorentz5Momentum & p0,
					    const Lorentz5Momentum &p2,
					    const Lorentz5Momentum & p1)
{
  _kine[0][0]=p0*p0;
  _kine[1][1]=p1*p1;
  _kine[2][2]=p2*p2;
  _kine[0][1]=p0*p1;_kine[1][0]=_kine[0][1];
  _kine[0][2]=p0*p2;_kine[2][0]=_kine[0][2];
  _kine[1][2]=p1*p2;_kine[2][1]=_kine[1][2];
}
 
inline void VertexBase::calculateKinematics(const Lorentz5Momentum & p0,
					    const Lorentz5Momentum & p1,
					    const Lorentz5Momentum & p2,
					    const Lorentz5Momentum & p3)
{
  _kine[0][0]=p0*p0;
  _kine[1][1]=p1*p1;
  _kine[2][2]=p2*p2;
  _kine[3][3]=p3*p3;
  _kine[0][1]=p0*p1;_kine[1][0]=_kine[0][1];
  _kine[0][2]=p0*p2;_kine[2][0]=_kine[0][2];
  _kine[0][3]=p0*p3;_kine[3][0]=_kine[0][3];
  _kine[1][2]=p1*p2;_kine[2][1]=_kine[1][2];
  _kine[1][3]=p1*p3;_kine[3][1]=_kine[1][3];
  _kine[2][3]=p2*p3;_kine[3][2]=_kine[2][3];
}

inline void VertexBase::calculateKinematics(const Lorentz5Momentum & p0,
					    const Lorentz5Momentum & p1,
					    const Lorentz5Momentum & p2,
					    const Lorentz5Momentum & p3,
					    const Lorentz5Momentum & p4)
{
  _kine[0][0]=p0*p0;
  _kine[1][1]=p1*p1;
  _kine[2][2]=p2*p2;
  _kine[3][3]=p3*p3;
  _kine[4][4]=p4*p4;
  _kine[0][1]=p0*p1;_kine[1][0]=_kine[0][1];
  _kine[0][2]=p0*p2;_kine[2][0]=_kine[0][2];
  _kine[0][3]=p0*p3;_kine[3][0]=_kine[0][3];
  _kine[0][4]=p0*p4;_kine[4][0]=_kine[0][4];
  _kine[1][2]=p1*p2;_kine[2][1]=_kine[1][2];
  _kine[1][3]=p1*p3;_kine[3][1]=_kine[1][3];
  _kine[1][4]=p1*p4;_kine[4][1]=_kine[1][4];
  _kine[2][3]=p2*p3;_kine[3][2]=_kine[2][3];
  _kine[2][4]=p2*p4;_kine[4][2]=_kine[2][4];
  _kine[3][4]=p3*p4;_kine[4][3]=_kine[3][4];
}
  
inline void VertexBase::calculateKinematics(const vector<Lorentz5Momentum> & p)
{
  unsigned int ix,iy;
  for(ix=0;ix<p.size();++ix)
    {
    for(iy=0;iy<=ix;++ix)
      {
	_kine[ix][iy]=p[ix]*p[iy];
	_kine[iy][ix]=_kine[ix][iy];
      }
    }
}

inline Energy2 VertexBase::invariant(unsigned int ix,unsigned int iy)
{
  if(ix>_npoint||iy>_npoint)
    {throw Exception() << "Invalid invariant requested in VertexBase::invariant() " 
		       << ix << " " << iy << Exception::abortnow;}
  return _kine[ix][iy];
}


}
}
