// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the RSSpinorWaveFunction class.
//
// Author: Peter Richardson
//

namespace Herwig {
using ThePEG::Helicity::LorentzRSSpinor;
namespace Helicity {
using namespace ThePEG;

// constructors

// use a 5-momentum and specify all components (specifiy Dirac representation)
inline RSSpinorWaveFunction::
RSSpinorWaveFunction(const Lorentz5Momentum &p, const tcPDPtr & part,
		     Complex xs1, Complex xs2, Complex xs3, Complex xs4,
		     Complex ys1, Complex ys2, Complex ys3, Complex ys4,
		     Complex zs1, Complex zs2, Complex zs3, Complex zs4,
		     Complex ts1, Complex ts2, Complex ts3, Complex ts4,
		     DiracRep dirac) 
{
  direction(intermediate);
  setMomentum(p);
  checkParticle(part);
  _wf = LorentzRSSpinor(xs1,xs2,xs3,xs4,ys1,ys2,ys3,ys4,
			zs1,zs2,zs3,zs4,ts1,ts2,ts3,ts4,dirac);
}	

// use a 5-momentum and a LorentzRSSpinor
inline RSSpinorWaveFunction::RSSpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,
					      LorentzRSSpinor & inspin)
{
  direction(intermediate);
  setMomentum(p);
  checkParticle(part); 
  _wf=inspin;
}

// use a 5-momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set all components of momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part); 
  calculateWaveFunction(ihel,dirac);
}

// set 4-momentum components (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set 4-momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzVector pin,
						  const tcPDPtr & part,unsigned int ihel,
						   Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set mass zero momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy mm, const tcPDPtr & part,
						  unsigned int ihel,
						  Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set 4 momentum and mass (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzVector pin,Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// default constructors (set the momentum and zero the Wavefunction)

// use a 5 momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Lorentz5Momentum p,
						  const tcPDPtr & part,
						  Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set all components of momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4-momentum components (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4-momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzVector pin, const tcPDPtr & part,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set mass zero momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy mm,const tcPDPtr & part,
					      Direction dir,DiracRep dirac)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4 momentum and mass
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzVector pin,Energy mm,
					      const tcPDPtr & part, Direction dir, 
					      DiracRep dirac) 
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// special setup constructor
inline RSSpinorWaveFunction::RSSpinorWaveFunction(vector<LorentzRSSpinor>& wave,
						  tPPtr part,Direction dir,bool time,
						  bool vertex,DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,part,time,vertex);
}

// special setup constructor
inline RSSpinorWaveFunction::RSSpinorWaveFunction(vector<LorentzRSSpinor>& wave,
						  RhoDMatrix& rho,
						  tPPtr part,Direction dir,bool time,
						  bool vertex,DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,rho,part,time,vertex);
}

// default constructor (specfiy Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(DiracRep dirac)
{
  direction(intermediate);
  setMomentum();
  zeroWaveFunction(dirac);
}

// descructor
inline RSSpinorWaveFunction::~RSSpinorWaveFunction(){;}

// subscript operator
inline Complex RSSpinorWaveFunction::operator ()(int i,int j) const
{
  if(i<0 || i>3 || j<0 || j>3)
    {ThePEG::Helicity::HelicityConsistencyError()
	<< "RSSpinorWaveFunction requested for invalid index" 
	<< i << " " << j<< Exception::abortnow;
    return 0.;}
  return _wf(i,j);
}
// Set components by index.
inline Complex & RSSpinorWaveFunction::operator () (int i, int j)
{
  static Complex dummy;
  if(i>=0 &&i<=3|| j<0 || j>3)
    {return _wf(i,j);}
  else
    {ThePEG::Helicity::HelicityConsistencyError()
	<< "Invalid index " << i << " " << j 
	<< " called for RSSpinorWaveFunction" << Exception::abortnow;
    return dummy;}
}

// Assignment. 
inline RSSpinorWaveFunction & 
RSSpinorWaveFunction::operator = (const RSSpinorWaveFunction & w)
{
  setPx(w.px());setPy(w.py());setPz(w.pz());setE(w.e());setMass(w.mass());
  _wf=w._wf;
  setParticle(w.getParticle());
  return *this;
}

// return the wavefunction as a LorentzRSSpinor
inline LorentzRSSpinor RSSpinorWaveFunction::Wave() const{return _wf;}

// Get components
inline Complex RSSpinorWaveFunction::xs1() const {return _wf.xs1();}
inline Complex RSSpinorWaveFunction::xs2() const {return _wf.xs2();}
inline Complex RSSpinorWaveFunction::xs3() const {return _wf.xs3();}
inline Complex RSSpinorWaveFunction::xs4() const {return _wf.xs4();}
inline Complex RSSpinorWaveFunction::ys1() const {return _wf.ys1();}
inline Complex RSSpinorWaveFunction::ys2() const {return _wf.ys2();}
inline Complex RSSpinorWaveFunction::ys3() const {return _wf.ys3();}
inline Complex RSSpinorWaveFunction::ys4() const {return _wf.ys4();}
inline Complex RSSpinorWaveFunction::zs1() const {return _wf.zs1();}
inline Complex RSSpinorWaveFunction::zs2() const {return _wf.zs2();}
inline Complex RSSpinorWaveFunction::zs3() const {return _wf.zs3();}
inline Complex RSSpinorWaveFunction::zs4() const {return _wf.zs4();}
inline Complex RSSpinorWaveFunction::ts1() const {return _wf.ts1();}
inline Complex RSSpinorWaveFunction::ts2() const {return _wf.ts2();}
inline Complex RSSpinorWaveFunction::ts3() const {return _wf.ts3();}
inline Complex RSSpinorWaveFunction::ts4() const {return _wf.ts4();}

// Set components
inline void RSSpinorWaveFunction::setXS1(Complex in){_wf.setXS1(in);}
inline void RSSpinorWaveFunction::setXS2(Complex in){_wf.setXS2(in);}
inline void RSSpinorWaveFunction::setXS3(Complex in){_wf.setXS3(in);}
inline void RSSpinorWaveFunction::setXS4(Complex in){_wf.setXS4(in);}
inline void RSSpinorWaveFunction::setYS1(Complex in){_wf.setYS1(in);}
inline void RSSpinorWaveFunction::setYS2(Complex in){_wf.setYS2(in);}
inline void RSSpinorWaveFunction::setYS3(Complex in){_wf.setYS3(in);}
inline void RSSpinorWaveFunction::setYS4(Complex in){_wf.setYS4(in);}
inline void RSSpinorWaveFunction::setZS1(Complex in){_wf.setZS1(in);}
inline void RSSpinorWaveFunction::setZS2(Complex in){_wf.setZS2(in);}
inline void RSSpinorWaveFunction::setZS3(Complex in){_wf.setZS3(in);}
inline void RSSpinorWaveFunction::setZS4(Complex in){_wf.setZS4(in);}
inline void RSSpinorWaveFunction::setTS1(Complex in){_wf.setTS1(in);}
inline void RSSpinorWaveFunction::setTS2(Complex in){_wf.setTS2(in);}
inline void RSSpinorWaveFunction::setTS3(Complex in){_wf.setTS3(in);}
inline void RSSpinorWaveFunction::setTS4(Complex in){_wf.setTS4(in);}

// reset functions

// momentum, particle type and direction
inline void RSSpinorWaveFunction::reset(const Lorentz5Momentum & pin,
					const tcPDPtr & part, Direction dir)
{
  direction(dir);
  checkParticle(part);
  setMomentum(pin);
}

// reset momentum and particle type
inline void RSSpinorWaveFunction::reset(const Lorentz5Momentum & pin, Direction dir)
{
  direction(dir);
  setMomentum(pin);
}

// reset momentum
inline void RSSpinorWaveFunction::reset(const Lorentz5Momentum & pin)
{
  setMomentum(pin);
}

// reset the helicity (calculates the new spinor (specify Dirac representation)
inline void RSSpinorWaveFunction::reset(unsigned int ihel,DiracRep dirac)
{calculateWaveFunction(ihel,dirac);}

// reset the particle type and direction
inline void RSSpinorWaveFunction::reset(const tcPDPtr & part,Direction dir)
{
  direction(dir);
  checkParticle(part);
}

// reset the particle type
inline void RSSpinorWaveFunction::reset(const tcPDPtr & part)
{checkParticle(part);}	

// zero the wavefunction (set specify Dirac representation)
inline void RSSpinorWaveFunction::zeroWaveFunction(DiracRep dirac)
{_wf=LorentzRSSpinor(dirac);}

// check the particles
inline void RSSpinorWaveFunction::checkParticle(const tcPDPtr & in)
{
  setParticle(in);
  if(iSpin()!=4)
    {ThePEG::Helicity::HelicityConsistencyError() 
	<< "Calculating RSSpinorWaveFunction for non-spin 3/2 Particle" 
	<< Exception::abortnow;}
}

// construct the spininfo object
inline void RSSpinorWaveFunction::constructSpinInfo(vector<LorentzRSSpinor>& wave,
						    tRSFermionSpinPtr spin,
						    bool vertex)
{
  wave.resize(4);
  for(unsigned int ix=0;ix<4;++ix)
    {
      // calculate the wavefunction for the first helicity
      reset(ix);
      // add to output array
      wave[ix] = _wf;
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,_wf);}
	  else{spin->setDecayState(ix,_wf);}
	}
    }
}

// construct the spininfo object
inline void RSSpinorWaveFunction::constructSpinInfo(vector<LorentzRSSpinor>& wave,
						    tPPtr part,bool time, bool vertex)
{
  tRSFermionSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getProductionBasisState(ix);}
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(RSFermionSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,vertex);
	}
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getDecayBasisState(ix);}
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "RSSpinorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(RSFermionSpinInfo(part->momentum(),true));
	      inspin= dynamic_ptr_cast<tRSFermionSpinPtr>(newspin);
	      inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  constructSpinInfo(wave,inspin,vertex);
	}
    }
}

// construct the spininfo object
inline void RSSpinorWaveFunction::constructSpinInfo(vector<LorentzRSSpinor>& wave,
						    RhoDMatrix& rho,tPPtr part,bool time,
						    bool vertex)
{
  tRSFermionSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getProductionBasisState(ix);}
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(RSFermionSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,vertex);
	}
      rho = RhoDMatrix(PDT::Spin3Half);rho.average();
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  rho = inspin->rhoMatrix();
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getDecayBasisState(ix);}
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "RSSpinorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(RSFermionSpinInfo(part->momentum(),true));
	      inspin= dynamic_ptr_cast<tRSFermionSpinPtr>(newspin);
	      inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  rho = RhoDMatrix(PDT::Spin3Half);rho.average();
	  constructSpinInfo(wave,inspin,vertex);
	}
    }
}
}
}
