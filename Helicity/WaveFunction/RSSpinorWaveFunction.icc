// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the RSSpinorWaveFunction class.
//
// Author: Peter Richardson
//

namespace Herwig {
using ThePEG::Helicity::LorentzRSSpinor;
namespace Helicity {
using namespace ThePEG;

// constructors

// use a 5-momentum and specify all components (specifiy Dirac representation)
inline RSSpinorWaveFunction::
RSSpinorWaveFunction(const Lorentz5Momentum &p, const tcPDPtr & part,
		     complex<double> xs1, complex<double> xs2, complex<double> xs3, complex<double> xs4,
		     complex<double> ys1, complex<double> ys2, complex<double> ys3, complex<double> ys4,
		     complex<double> zs1, complex<double> zs2, complex<double> zs3, complex<double> zs4,
		     complex<double> ts1, complex<double> ts2, complex<double> ts3, complex<double> ts4,
		     DiracRep dirac) 
{
  direction(intermediate);
  setMomentum(p);
  checkParticle(part);
  _wf = LorentzRSSpinor<double>(xs1,xs2,xs3,xs4,ys1,ys2,ys3,ys4,
			zs1,zs2,zs3,zs4,ts1,ts2,ts3,ts4,dirac);
}	

// use a 5-momentum and a LorentzRSSpinor
inline RSSpinorWaveFunction::RSSpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,
					      LorentzRSSpinor<double> & inspin)
{
  direction(intermediate);
  setMomentum(p);
  checkParticle(part); 
  _wf=inspin;
}

// use a 5-momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set all components of momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part); 
  calculateWaveFunction(ihel,dirac);
}

// set 4-momentum components (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set 4-momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzMomentum pin,
						  const tcPDPtr & part,unsigned int ihel,
						   Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set mass zero momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy mm, const tcPDPtr & part,
						  unsigned int ihel,
						  Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set 4 momentum and mass (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzMomentum pin,Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// default constructors (set the momentum and zero the Wavefunction)

// use a 5 momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Lorentz5Momentum p,
						  const tcPDPtr & part,
						  Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set all components of momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4-momentum components (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4-momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzMomentum pin, const tcPDPtr & part,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set mass zero momentum (specify Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(Energy mm,const tcPDPtr & part,
					      Direction dir,DiracRep dirac)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4 momentum and mass
inline RSSpinorWaveFunction::RSSpinorWaveFunction(LorentzMomentum pin,Energy mm,
					      const tcPDPtr & part, Direction dir, 
					      DiracRep dirac) 
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// special setup constructor
inline RSSpinorWaveFunction::RSSpinorWaveFunction(vector<LorentzRSSpinor<SqrtEnergy> >& wave,
						  tPPtr part,Direction dir,bool time,
						  bool vertex,DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,part,time,vertex);
}

// special setup constructor
inline RSSpinorWaveFunction::RSSpinorWaveFunction(vector<LorentzRSSpinor<SqrtEnergy> >& wave,
						  RhoDMatrix& rho,
						  tPPtr part,Direction dir,bool time,
						  bool vertex,DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,rho,part,time,vertex);
}

// default constructor (specfiy Dirac representation)
inline RSSpinorWaveFunction::RSSpinorWaveFunction(DiracRep dirac)
{
  direction(intermediate);
  setMomentum();
  zeroWaveFunction(dirac);
}

// descructor
inline RSSpinorWaveFunction::~RSSpinorWaveFunction(){;}

// subscript operator
inline complex<double> RSSpinorWaveFunction::operator ()(int i,int j) const
{
  if(i<0 || i>3 || j<0 || j>3)
    {ThePEG::Helicity::HelicityConsistencyError()
	<< "RSSpinorWaveFunction requested for invalid index" 
	<< i << " " << j<< Exception::abortnow;
    return complex<double>();}
  return _wf(i,j);
}
// Set components by index.
inline complex<double> & RSSpinorWaveFunction::operator () (int i, int j)
{
  static complex<double> dummy;
  if(i>=0 &&i<=3|| j<0 || j>3)
    {return _wf(i,j);}
  else
    {ThePEG::Helicity::HelicityConsistencyError()
	<< "Invalid index " << i << " " << j 
	<< " called for RSSpinorWaveFunction" << Exception::abortnow;
    return dummy;}
}

// Assignment. 
inline RSSpinorWaveFunction & 
RSSpinorWaveFunction::operator = (const RSSpinorWaveFunction & w)
{
  setPx(w.px());setPy(w.py());setPz(w.pz());setE(w.e());setMass(w.mass());
  _wf=w._wf;
  setParticle(w.getParticle());
  direction(w.direction());
  return *this;
}

// return the wavefunction as a LorentzRSSpinor
inline LorentzRSSpinor<double> RSSpinorWaveFunction::wave() const{return _wf;}

// Get components
inline complex<double> RSSpinorWaveFunction::xs1() const {return _wf.xs1();}
inline complex<double> RSSpinorWaveFunction::xs2() const {return _wf.xs2();}
inline complex<double> RSSpinorWaveFunction::xs3() const {return _wf.xs3();}
inline complex<double> RSSpinorWaveFunction::xs4() const {return _wf.xs4();}
inline complex<double> RSSpinorWaveFunction::ys1() const {return _wf.ys1();}
inline complex<double> RSSpinorWaveFunction::ys2() const {return _wf.ys2();}
inline complex<double> RSSpinorWaveFunction::ys3() const {return _wf.ys3();}
inline complex<double> RSSpinorWaveFunction::ys4() const {return _wf.ys4();}
inline complex<double> RSSpinorWaveFunction::zs1() const {return _wf.zs1();}
inline complex<double> RSSpinorWaveFunction::zs2() const {return _wf.zs2();}
inline complex<double> RSSpinorWaveFunction::zs3() const {return _wf.zs3();}
inline complex<double> RSSpinorWaveFunction::zs4() const {return _wf.zs4();}
inline complex<double> RSSpinorWaveFunction::ts1() const {return _wf.ts1();}
inline complex<double> RSSpinorWaveFunction::ts2() const {return _wf.ts2();}
inline complex<double> RSSpinorWaveFunction::ts3() const {return _wf.ts3();}
inline complex<double> RSSpinorWaveFunction::ts4() const {return _wf.ts4();}

// Set components
inline void RSSpinorWaveFunction::setXS1(complex<double> in){_wf.setXS1(in);}
inline void RSSpinorWaveFunction::setXS2(complex<double> in){_wf.setXS2(in);}
inline void RSSpinorWaveFunction::setXS3(complex<double> in){_wf.setXS3(in);}
inline void RSSpinorWaveFunction::setXS4(complex<double> in){_wf.setXS4(in);}
inline void RSSpinorWaveFunction::setYS1(complex<double> in){_wf.setYS1(in);}
inline void RSSpinorWaveFunction::setYS2(complex<double> in){_wf.setYS2(in);}
inline void RSSpinorWaveFunction::setYS3(complex<double> in){_wf.setYS3(in);}
inline void RSSpinorWaveFunction::setYS4(complex<double> in){_wf.setYS4(in);}
inline void RSSpinorWaveFunction::setZS1(complex<double> in){_wf.setZS1(in);}
inline void RSSpinorWaveFunction::setZS2(complex<double> in){_wf.setZS2(in);}
inline void RSSpinorWaveFunction::setZS3(complex<double> in){_wf.setZS3(in);}
inline void RSSpinorWaveFunction::setZS4(complex<double> in){_wf.setZS4(in);}
inline void RSSpinorWaveFunction::setTS1(complex<double> in){_wf.setTS1(in);}
inline void RSSpinorWaveFunction::setTS2(complex<double> in){_wf.setTS2(in);}
inline void RSSpinorWaveFunction::setTS3(complex<double> in){_wf.setTS3(in);}
inline void RSSpinorWaveFunction::setTS4(complex<double> in){_wf.setTS4(in);}

// reset functions

// momentum, particle type and direction
inline void RSSpinorWaveFunction::reset(const Lorentz5Momentum & pin,
					const tcPDPtr & part, Direction dir)
{
  direction(dir);
  checkParticle(part);
  setMomentum(pin);
}

// reset momentum and particle type
inline void RSSpinorWaveFunction::reset(const Lorentz5Momentum & pin, Direction dir)
{
  direction(dir);
  setMomentum(pin);
}

// reset momentum
inline void RSSpinorWaveFunction::reset(const Lorentz5Momentum & pin)
{
  setMomentum(pin);
}

// reset the helicity (calculates the new spinor (specify Dirac representation)
inline void RSSpinorWaveFunction::reset(unsigned int ihel,DiracRep dirac)
{calculateWaveFunction(ihel,dirac);}

// reset the particle type and direction
inline void RSSpinorWaveFunction::reset(const tcPDPtr & part,Direction dir)
{
  direction(dir);
  checkParticle(part);
}

// reset the particle type
inline void RSSpinorWaveFunction::reset(const tcPDPtr & part)
{checkParticle(part);}	

// zero the wavefunction (set specify Dirac representation)
inline void RSSpinorWaveFunction::zeroWaveFunction(DiracRep dirac)
{_wf=LorentzRSSpinor<double>(dirac);}

// check the particles
inline void RSSpinorWaveFunction::checkParticle(const tcPDPtr & in)
{
  setParticle(in);
  if(iSpin()!=4)
    {ThePEG::Helicity::HelicityConsistencyError() 
	<< "Calculating RSSpinorWaveFunction for non-spin 3/2 Particle" 
	<< Exception::abortnow;}
}

// construct the spininfo object
inline void RSSpinorWaveFunction::constructSpinInfo(vector<LorentzRSSpinor<SqrtEnergy> >& wave,
						    tRSFermionSpinPtr spin,
						    bool vertex)
{
  wave.resize(4);
  for(unsigned int ix=0;ix<4;++ix)
    {
      // calculate the wavefunction for the first helicity
      reset(ix);
      // add to output array
      wave[ix] = dimensionedWf();
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,dimensionedWf());}
	  else{spin->setDecayState(ix,dimensionedWf());}
	}
    }
}

// construct the spininfo object
inline void RSSpinorWaveFunction::constructSpinInfo(vector<LorentzRSSpinor<SqrtEnergy> >& wave,
						    tPPtr part,bool time, bool vertex)
{
  tRSFermionSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getProductionBasisState(ix);}
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(RSFermionSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,vertex);
	}
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getDecayBasisState(ix);}
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "RSSpinorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(RSFermionSpinInfo(part->momentum(),time));
	      inspin= dynamic_ptr_cast<tRSFermionSpinPtr>(newspin);
	      if(time) inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  constructSpinInfo(wave,inspin,vertex);
	}
    }
}

// construct the spininfo object
inline void RSSpinorWaveFunction::constructSpinInfo(vector<LorentzRSSpinor<SqrtEnergy> >& wave,
						    RhoDMatrix& rho,tPPtr part,bool time,
						    bool vertex)
{
  tRSFermionSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getProductionBasisState(ix);}
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(RSFermionSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tRSFermionSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,vertex);
	}
      rho = RhoDMatrix(PDT::Spin3Half);rho.average();
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  rho = inspin->rhoMatrix();
	  wave.resize(4);
	  for(unsigned int ix=0;ix<4;++ix){wave[ix]=inspin->getDecayBasisState(ix);}
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "RSSpinorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(RSFermionSpinInfo(part->momentum(),time));
	      inspin= dynamic_ptr_cast<tRSFermionSpinPtr>(newspin);
	      if(time) inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  rho = RhoDMatrix(PDT::Spin3Half);rho.average();
	  constructSpinInfo(wave,inspin,vertex);
	}
    }
}
}
}
