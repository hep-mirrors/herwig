// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the TensorWaveFunction class.
//
// Author: Peter Richardson
//

namespace Herwig {
namespace Helicity {
using namespace ThePEG;

// default constructors (set the momentum and Wavefunction)
inline TensorWaveFunction::TensorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,
					      Complex xx,Complex xy,Complex xz,
					      Complex xt,Complex yx,Complex yy,
					      Complex yz,Complex yt,Complex zx,
					      Complex zy,Complex zz,Complex zt,
					      Complex tx,Complex ty,Complex tz,
					      Complex tt)
{
  direction(intermediate);setMomentum(p);checkParticle(part);
  setXX(xx);setXY(xy);setXZ(xz);setXT(xt);
  setYX(yx);setYY(yy);setYZ(yz);setYT(yt);
  setZX(zx);setZY(zy);setZZ(zz);setZT(zt);
  setTX(tx);setTY(ty);setTZ(tz);setTT(tt);
}
			    
// Use a 5-momentum (specify phase choice)
inline TensorWaveFunction::TensorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, TensorPhase phase)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set all components of momentum (specify phase choice)
inline TensorWaveFunction::TensorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, TensorPhase phase)
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set 4-momentum components  (specify phase choice)
inline TensorWaveFunction::TensorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, TensorPhase phase)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set 4-momentum  (specify phase choice)
inline TensorWaveFunction::TensorWaveFunction(LorentzMomentum pin,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, TensorPhase phase)
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set mass zero momentum (specify phase choice)
inline TensorWaveFunction::TensorWaveFunction(Energy mm, const tcPDPtr & part,
					      unsigned int ihel, Direction dir,
					      TensorPhase phase)
{
  direction(dir);
  setMomentum(mm); 
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set 4 momentum and mass (specify phase choice)
inline TensorWaveFunction::TensorWaveFunction(LorentzMomentum pin,Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, TensorPhase phase)
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// default constructors (set the momentum and zero the Wavefunction)

// use 5 momentum
inline TensorWaveFunction::TensorWaveFunction(Lorentz5Momentum p,
					      const tcPDPtr & part, Direction dir)
{
  direction(dir);
  setMomentum(p); 
  checkParticle(part); 
  zeroWaveFunction();
}

// set all components of momentum
inline TensorWaveFunction::TensorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part, Direction dir)
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  zeroWaveFunction();
}

// set 4-momentum components 
inline TensorWaveFunction::TensorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part, Direction dir)
{
  direction(dir);
  setMomentum(px,py,pz,ee); 
  checkParticle(part);
  zeroWaveFunction();
}

// set 4-momentum 
inline TensorWaveFunction::TensorWaveFunction(LorentzMomentum pin,
					      const tcPDPtr & part, Direction dir) 
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  zeroWaveFunction();
}

// set mass zero momentum
inline TensorWaveFunction::TensorWaveFunction(Energy mm,
					      const tcPDPtr & part,Direction dir)
{
  direction(dir);
  setMomentum(mm); 
  checkParticle(part);
  zeroWaveFunction();
}

// set 4 momentum and mass
inline TensorWaveFunction::TensorWaveFunction(LorentzMomentum pin,Energy mm,
					      const tcPDPtr & part, Direction dir) 
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  zeroWaveFunction();
}

// default constructor
inline TensorWaveFunction::TensorWaveFunction()
{
  direction(intermediate);
  setMomentum();
  zeroWaveFunction();
}

// destructor
inline TensorWaveFunction::~TensorWaveFunction(){;}

// subscript operator
inline Complex TensorWaveFunction::operator ()(int i, int j) const
{
  if(i<0 || i >3 || j<0 || j>3)
    {
      ThePEG::Helicity::HelicityConsistencyError() 
	<< "TensorWaveFunction requested for invalid index" 
	<< i << " " << j << Exception::abortnow;
      return 0.;
    }
  return _wf(i,j);
}

// Set components by index.
inline Complex & TensorWaveFunction::operator () (int i,int j)
{
  static Complex dummy;
  if(i>=0 &&i<=3 && j>=0 && j<=3)
    {return _wf(i,j);}
  else
    {
      ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid index " << i << "," << j 
	<< " called for TensorWaveFunction" << Exception::abortnow;
      return dummy;
    }
}

// Assignment
inline TensorWaveFunction  & TensorWaveFunction::operator = 
(const TensorWaveFunction & w) {
  setPx(w.px());setPy(w.py());setPz(w.pz());setE(w.e());setMass(w.mass());
  _wf=w.wave();
  setParticle(w.getParticle());
  direction(w.direction());
  return *this;
}

// return wavefunction as polarization vector
inline LorentzTensor<double> TensorWaveFunction::wave() const{return _wf;}

// Get components
inline Complex TensorWaveFunction::xx() const{return _wf.xx();}
inline Complex TensorWaveFunction::yx() const{return _wf.yx();}
inline Complex TensorWaveFunction::zx() const{return _wf.zx();}
inline Complex TensorWaveFunction::tx() const{return _wf.tx();}
inline Complex TensorWaveFunction::xy() const{return _wf.xy();}
inline Complex TensorWaveFunction::yy() const{return _wf.yy();}
inline Complex TensorWaveFunction::zy() const{return _wf.zy();}
inline Complex TensorWaveFunction::ty() const{return _wf.ty();}
inline Complex TensorWaveFunction::xz() const{return _wf.xz();}
inline Complex TensorWaveFunction::yz() const{return _wf.yz();}
inline Complex TensorWaveFunction::zz() const{return _wf.zz();}
inline Complex TensorWaveFunction::tz() const{return _wf.tz();}
inline Complex TensorWaveFunction::xt() const{return _wf.xt();}
inline Complex TensorWaveFunction::yt() const{return _wf.yt();}
inline Complex TensorWaveFunction::zt() const{return _wf.zt();}
inline Complex TensorWaveFunction::tt() const{return _wf.tt();}

// Set Components
inline void TensorWaveFunction::setXX(Complex in){_wf.setXX(in);}
inline void TensorWaveFunction::setYX(Complex in){_wf.setYX(in);}
inline void TensorWaveFunction::setZX(Complex in){_wf.setZX(in);}
inline void TensorWaveFunction::setTX(Complex in){_wf.setTX(in);}
inline void TensorWaveFunction::setXY(Complex in){_wf.setXY(in);}
inline void TensorWaveFunction::setYY(Complex in){_wf.setYY(in);}
inline void TensorWaveFunction::setZY(Complex in){_wf.setZY(in);}
inline void TensorWaveFunction::setTY(Complex in){_wf.setTY(in);}
inline void TensorWaveFunction::setXZ(Complex in){_wf.setXZ(in);}
inline void TensorWaveFunction::setYZ(Complex in){_wf.setYZ(in);}
inline void TensorWaveFunction::setZZ(Complex in){_wf.setZZ(in);}
inline void TensorWaveFunction::setTZ(Complex in){_wf.setTZ(in);}
inline void TensorWaveFunction::setXT(Complex in){_wf.setXT(in);}
inline void TensorWaveFunction::setYT(Complex in){_wf.setYT(in);}
inline void TensorWaveFunction::setZT(Complex in){_wf.setZT(in);}
inline void TensorWaveFunction::setTT(Complex in){_wf.setTT(in);}


// reset functions

// reset momentum, particle type and direction
inline void TensorWaveFunction::reset(const Lorentz5Momentum & pin, const tcPDPtr & part,
				 Direction dir)
{direction(dir);checkParticle(part);setMomentum(pin);}

// reset momentum and direction
inline void TensorWaveFunction::reset(const Lorentz5Momentum & pin, Direction dir)
{direction(dir);setMomentum(pin);}

// reset momentum
inline void TensorWaveFunction::reset(const Lorentz5Momentum & pin)
{setMomentum(pin);}

// reset helicity (recalculate the tensor )
inline void TensorWaveFunction::reset(unsigned int ihel,TensorPhase phase)
{calculateWaveFunction(ihel,phase);}

// reset particle type and direction
inline void TensorWaveFunction::reset(const tcPDPtr & part,Direction dir)
{direction(dir);checkParticle(part);}

// reset particle type
inline void TensorWaveFunction::reset(const tcPDPtr & part)
{checkParticle(part);}	

// zero the wavefunction
inline void TensorWaveFunction::zeroWaveFunction()
{for(int i=0;i<4;++i){for(int j=0;j<4;++j){_wf(i,j)=0.;}}}

// check particle spin and set pointer
inline void TensorWaveFunction::checkParticle(const tcPDPtr & in)
{
  setParticle(in);
  if(iSpin()!=PDT::Spin2)
    {
      ThePEG::Helicity::HelicityConsistencyError() 
	<< "Calculating Tensor WaveFunction for non-spin 2 Particle" 
	<< Exception::abortnow;}
}

// special setup constructor
inline TensorWaveFunction::TensorWaveFunction(vector<LorentzTensor<double> >& wave,tPPtr part,
					      Direction dir,bool time,bool massless,
					      bool vertex, TensorPhase phase)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction();
  constructSpinInfo(wave,part,time,massless,phase,vertex);
}

// special setup constructor
inline TensorWaveFunction::TensorWaveFunction(vector<LorentzTensor<double> >& wave,RhoDMatrix&rho,
					      tPPtr part,Direction dir,bool time,
					      bool massless,bool vertex,
					      TensorPhase phase)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction();
  constructSpinInfo(wave,rho,part,time,massless,phase,vertex);
}

// construct the spininfo object
inline void TensorWaveFunction::constructSpinInfo(vector<LorentzTensor<double> >& wave,
						  tTensorSpinPtr spin,bool massless,
						  TensorPhase phase,bool vertex)
{
  wave.resize(5);
  for(unsigned int ix=0;ix<5;++ix)
    {
      // calculate the wavefunction for the first helicity
      if(massless&&ix==2){_wf=LorentzTensor<double>();}
      else{reset(ix,phase);}
      // add to output array
      wave[ix] = _wf;
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,_wf);}
	  else{spin->setBasisState(ix,_wf.conjugate());}
	}
    }
}

// construct the spininfo object
inline void TensorWaveFunction::constructSpinInfo(vector<LorentzTensor<double> >& wave,tPPtr part,
						  bool time,bool massless,
						  TensorPhase phase,bool vertex)
{
  tTensorSpinPtr tspin;
  if(part->spinInfo())
    {tspin=dynamic_ptr_cast<tTensorSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(tspin)
	{
	  wave.resize(5);
	  for(unsigned int ix=0;ix<5;++ix){wave[ix]=tspin->getProductionBasisState(ix);}
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(TensorSpinInfo(part->momentum(),time));
	      tspin=dynamic_ptr_cast<tTensorSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,tspin,massless,phase,vertex);
	}
    }
  else
    {
      if(tspin)
	{
	  tspin->decay();
	  wave.resize(5);
	  for(unsigned int ix=0;ix<5;++ix){wave[ix]=tspin->getDecayBasisState(ix);}
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "TensorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(TensorSpinInfo(part->momentum(),time));
	      tspin= dynamic_ptr_cast<tTensorSpinPtr>(newspin);
	      if(time) tspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  constructSpinInfo(wave,tspin,massless,phase,vertex);
	}
    }
}

// construct the spininfo object
inline void TensorWaveFunction::constructSpinInfo(vector<LorentzTensor<double> >& wave,
						  RhoDMatrix& rho,tPPtr part,
						  bool time,bool massless,
						  TensorPhase phase,bool vertex)
{
  tTensorSpinPtr tspin;
  if(part->spinInfo())
    {tspin=dynamic_ptr_cast<tTensorSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(tspin)
	{
	  wave.resize(5);
	  for(unsigned int ix=0;ix<5;++ix){wave[ix]=tspin->getProductionBasisState(ix);}
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(TensorSpinInfo(part->momentum(),time));
	      tspin=dynamic_ptr_cast<tTensorSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,tspin,massless,phase,vertex);
	}
      rho =RhoDMatrix(PDT::Spin2);rho.average();
    }
  else
    {
      if(tspin)
	{
	  tspin->decay();
	  wave.resize(5);
	  rho = tspin->rhoMatrix();
	  for(unsigned int ix=0;ix<5;++ix){wave[ix]=tspin->getDecayBasisState(ix);}
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "TensorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(TensorSpinInfo(part->momentum(),time));
	      tspin= dynamic_ptr_cast<tTensorSpinPtr>(newspin);
	      if(time) tspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  rho =RhoDMatrix(PDT::Spin2);rho.average();
	  constructSpinInfo(wave,tspin,massless,phase,vertex);
	}
    }
}
}
}
