// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the VectorWaveFunction class.
//
// Author: Peter Richardson
//

namespace Herwig {
namespace Helicity {
using namespace ThePEG;

// default constructors (set the momentum and Wavefunction)
// use a 5-mometum and a polarization vector
inline VectorWaveFunction::VectorWaveFunction(const Lorentz5Momentum & p,tcPDPtr part,
					      const LorentzPolarizationVector &vec,
					      Direction dir)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  _wf=vec;
}

// use a 5-momentum and specify all components
inline VectorWaveFunction::VectorWaveFunction(const Lorentz5Momentum & p,tcPDPtr part,
					      const Complex & s1, const Complex & s2,
					      const Complex & s3, const Complex & s4)
{
  direction(intermediate);
  setMomentum(p);
  checkParticle(part);
  setX(s1);setY(s2);setZ(s3);setT(s4);
}

// use a 5 momentum (specify phase choice)
inline VectorWaveFunction::VectorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, VectorPhase phase)  
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set all components of momentum (specify phase choice)
inline VectorWaveFunction::VectorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir,VectorPhase phase) 
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set 4-momentum components (specify phase choice)
inline VectorWaveFunction::VectorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part,unsigned int ihel, 
					      Direction dir, VectorPhase phase)
{
  direction(dir);
  setMomentum(px,py,pz,ee); 
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set 4-momentum (specify phase choice)
inline VectorWaveFunction::VectorWaveFunction(LorentzVector pin,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, VectorPhase phase)
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set mass zero momentum (specify phase choice)
inline VectorWaveFunction::VectorWaveFunction(Energy mm, const tcPDPtr & part,
					      unsigned int ihel,
					      Direction dir, VectorPhase phase)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  calculateWaveFunction(ihel,phase);
}

// set 4 momentum and mass (specify phase choice)
inline VectorWaveFunction::VectorWaveFunction(LorentzVector pin,Energy mm,
					      const tcPDPtr & part,
					      unsigned int ihel,
					      Direction dir, VectorPhase phase)
{
  direction(dir);
  setMomentum(pin,mm); 
  checkParticle(part); 
  calculateWaveFunction(ihel,phase);
}

// default constructors (set the momentum and zero the Wavefunction)

// use a 5 momentum
inline VectorWaveFunction::VectorWaveFunction(Lorentz5Momentum p,
					      const tcPDPtr & part, Direction dir)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  zeroWaveFunction();
}

// set all components of momentum
inline VectorWaveFunction::VectorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part, Direction dir)
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  zeroWaveFunction();
}

// set 4-momentum components 
inline VectorWaveFunction::VectorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part, Direction dir)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  zeroWaveFunction();
}

// set 4-momentum 
inline VectorWaveFunction::VectorWaveFunction(LorentzVector pin,
					      const tcPDPtr & part, Direction dir) 
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  zeroWaveFunction();
}

// set mass zero momentum
inline VectorWaveFunction::VectorWaveFunction(Energy mm,
					      const tcPDPtr & part,Direction dir)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  zeroWaveFunction();
}

// set 4 momentum and mass
inline VectorWaveFunction::VectorWaveFunction(LorentzVector pin,Energy mm,
					      const tcPDPtr & part, Direction dir) 
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  zeroWaveFunction();
}

// default constructor
inline VectorWaveFunction::VectorWaveFunction()
{
  direction(intermediate);
  setMomentum();
  zeroWaveFunction();
}

// descructor
inline VectorWaveFunction::~VectorWaveFunction(){;}

// subscript operator
inline Complex VectorWaveFunction::operator ()(int i) const
{
  if(i<0 || i>3)
    {
      ThePEG::Helicity::HelicityConsistencyError()
	<< "VectorWaveFunction requested for invalid index" << Exception::abortnow;
      return 0.;
    }
  return _wf[i];
}

// Set components by index.
inline Complex & VectorWaveFunction::operator () (int i)
{
  static Complex dummy;
  if(i>=0 &&i<=3)
    {return _wf(i);}
  else
    {
      ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid index " << i << " called for VectorWaveFunction" 
	<< Exception::abortnow;
    return dummy;}
}

// Assignment. 
inline VectorWaveFunction & VectorWaveFunction::operator = (const VectorWaveFunction & w)
{
  setPx(w.px());setPy(w.py());setPz(w.pz());setE(w.e());setMass(w.mass());
  _wf=w._wf;
  setParticle(w.getParticle());
  direction(w.direction());
  return *this;
}

// return wavefunction as polarization vector
inline const LorentzPolarizationVector & VectorWaveFunction::wave() const{return _wf;}

// Get position and time.
inline Complex VectorWaveFunction::x() const {return _wf.x();}
inline Complex VectorWaveFunction::y() const {return _wf.y();}
inline Complex VectorWaveFunction::z() const {return _wf.z();}
inline Complex VectorWaveFunction::t() const {return _wf.t();}

// Set position and time.
inline void VectorWaveFunction::setX(const Complex &in){_wf.setX(in);}
inline void VectorWaveFunction::setY(const Complex &in){_wf.setY(in);}
inline void VectorWaveFunction::setZ(const Complex &in){_wf.setZ(in);}
inline void VectorWaveFunction::setT(const Complex &in){_wf.setT(in);}

// reset functions


// reset the momentum, particle type and direction
inline void VectorWaveFunction::reset(const Lorentz5Momentum & pin, const tcPDPtr & part,
				      Direction dir)
{direction(dir);checkParticle(part);setMomentum(pin);}

// reset the momentum and direction
inline void VectorWaveFunction::reset(const Lorentz5Momentum & pin, Direction dir)
{direction(dir);setMomentum(pin);}

// reset the momentum
inline void VectorWaveFunction::reset(const Lorentz5Momentum & pin)
{setMomentum(pin);}

// reset the helicity (recalculation the polarization vector)
inline void VectorWaveFunction::reset(unsigned int ihel, VectorPhase phase)
{calculateWaveFunction(ihel,phase);}

// reset the particle type and direction
inline void VectorWaveFunction::reset(const tcPDPtr & part,Direction dir)
{direction(dir);checkParticle(part);}

// reset the particle type
inline void VectorWaveFunction::reset(const tcPDPtr & part)
{checkParticle(part);}	

// zero the wavefunction
inline void VectorWaveFunction::zeroWaveFunction(){_wf=LorentzPolarizationVector();}

// check the particles
inline void VectorWaveFunction::checkParticle(const tcPDPtr & in)
{
  setParticle(in);
  if(iSpin()!=3)
    {
      ThePEG::Helicity::HelicityConsistencyError()
	<< "Calculating Vector WaveFunction for non-spin 1 Particle" 
	<< Exception::abortnow;
    }
}

// special setup constructor
VectorWaveFunction::VectorWaveFunction(vector<LorentzPolarizationVector>& wave,
					      tPPtr part,Direction dir,bool time,
					      bool massless,
					      bool vertex, VectorPhase phase)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction();
  constructSpinInfo(wave,part,time,massless,phase,vertex);
}

// special setup constructor
inline VectorWaveFunction::VectorWaveFunction(vector<LorentzPolarizationVector>& wave,
					      RhoDMatrix &rho,tPPtr part,Direction dir,
					      bool time,bool massless,
					      bool vertex, VectorPhase phase)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction();
  constructSpinInfo(wave,rho,part,time,massless,phase,vertex);
}

// special setup constructor
VectorWaveFunction::VectorWaveFunction(vector<VectorWaveFunction>& wave,
					      tPPtr part,Direction dir,bool time,
					      bool massless,
					      bool vertex, VectorPhase phase)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction();
  constructSpinInfo(wave,part,time,massless,phase,vertex);
}

// special setup constructor
inline VectorWaveFunction::VectorWaveFunction(vector<VectorWaveFunction>& wave,
					      RhoDMatrix &rho,tPPtr part,Direction dir,
					      bool time,bool massless,
					      bool vertex, VectorPhase phase)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction();
  constructSpinInfo(wave,rho,part,time,massless,phase,vertex);
}

// construct the spininfo object
inline void VectorWaveFunction::constructSpinInfo(vector<LorentzPolarizationVector>& wave,
						  tVectorSpinPtr spin,bool massless,
						  VectorPhase phase,bool vertex)
{
  wave.resize(3);
  for(unsigned int ix=0;ix<3;++ix)
    {
      // calculate the wavefunction for the first helicity
      if(massless&&ix==1){_wf=LorentzPolarizationVector();}
      else{reset(ix,phase);}
      // add to output array
      wave[ix] = _wf;
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,_wf);}
	  else{spin->setDecayState(ix,_wf.conjugate());}
	}
    }
}

// construct the spininfo object
inline void VectorWaveFunction::constructSpinInfo(vector<LorentzPolarizationVector>& wave,
						  tPPtr part,bool time,
						  bool massless,VectorPhase phase,
						  bool vertex)
{
  tVectorSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tVectorSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(3);
	  wave[0]=inspin->getProductionBasisState(0);
	  wave[1]=inspin->getProductionBasisState(1);
	  wave[2]=inspin->getProductionBasisState(2);
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tVectorSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  wave.resize(3);
	  wave[0]=inspin->getDecayBasisState(0);
	  wave[1]=inspin->getDecayBasisState(1);
	  wave[2]=inspin->getDecayBasisState(2);
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "VectorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin= dynamic_ptr_cast<tVectorSpinPtr>(newspin);
	      if(time) inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
    }
}

// construct the spininfo object
inline void VectorWaveFunction::constructSpinInfo(vector<LorentzPolarizationVector>& wave,
						  RhoDMatrix& rho,tPPtr part,bool time,
						  bool massless,VectorPhase phase,
						  bool vertex)
{
  tVectorSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tVectorSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(3);
	  wave[0]=inspin->getProductionBasisState(0);
	  wave[1]=inspin->getProductionBasisState(1);
	  wave[2]=inspin->getProductionBasisState(2);
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tVectorSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
      rho = RhoDMatrix(PDT::Spin1);rho.average();
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  rho = inspin->rhoMatrix();
	  wave.resize(3);
	  wave[0]=inspin->getDecayBasisState(0);
	  wave[1]=inspin->getDecayBasisState(1);
	  wave[2]=inspin->getDecayBasisState(2);
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "VectorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin= dynamic_ptr_cast<tVectorSpinPtr>(newspin);
	      if(time) inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  rho = RhoDMatrix(PDT::Spin1);rho.average();
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
    }
}

// construct the spininfo object
inline void VectorWaveFunction::constructSpinInfo(vector<VectorWaveFunction>& wave,
						  tVectorSpinPtr spin,bool massless,
						  VectorPhase phase,bool vertex)
{
  wave.resize(3);
  for(unsigned int ix=0;ix<3;++ix)
    {
      // calculate the wavefunction for the first helicity
      if(massless&&ix==1){_wf=LorentzPolarizationVector();}
      else{reset(ix,phase);}
      // add to output array
      wave[ix] = VectorWaveFunction(*this);
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,_wf);}
	  else{spin->setDecayState(ix,_wf.conjugate());}
	}
    }
}

// construct the spininfo object
inline void VectorWaveFunction::constructSpinInfo(vector<VectorWaveFunction>& wave,
						  tPPtr part,bool time,
						  bool massless,VectorPhase phase,
						  bool vertex)
{
  tVectorSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tVectorSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(3);
	  wave[0]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getProductionBasisState(0),direction());
	  wave[1]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getProductionBasisState(1),direction());
	  wave[2]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getProductionBasisState(2),direction());
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tVectorSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  wave.resize(3);
	  wave[0]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getDecayBasisState(0),direction());
	  wave[1]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getDecayBasisState(1),direction());
	  wave[2]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getDecayBasisState(2),direction());
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "VectorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin= dynamic_ptr_cast<tVectorSpinPtr>(newspin);
	      if(time) inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
    }
}

// construct the spininfo object
inline void VectorWaveFunction::constructSpinInfo(vector<VectorWaveFunction>& wave,
						  RhoDMatrix& rho,tPPtr part,bool time,
						  bool massless,VectorPhase phase,
						  bool vertex)
{
  tVectorSpinPtr inspin;
  if(part->spinInfo())
    {inspin=dynamic_ptr_cast<tVectorSpinPtr>(part->spinInfo());}
  if(direction()==outgoing)
    {
      if(inspin)
	{
	  wave.resize(3);
	  wave[0]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getProductionBasisState(0),direction());
	  wave[1]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getProductionBasisState(1),direction());
	  wave[2]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getProductionBasisState(2),direction());
	}
      else
	{
	  if(vertex)
	    {
	      SpinPtr temp = new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin=dynamic_ptr_cast<tVectorSpinPtr>(temp);
	      part->spinInfo(temp);
	    }
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
      rho = RhoDMatrix(PDT::Spin1);rho.average();
    }
  else
    {
      if(inspin)
	{
	  inspin->decay();
	  rho = inspin->rhoMatrix();
	  wave.resize(3);
	  wave[0]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getDecayBasisState(0),direction());
	  wave[1]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getDecayBasisState(1),direction());
	  wave[2]=VectorWaveFunction(getMomentum(),getParticle(),
				     inspin->getDecayBasisState(2),direction());
	}
      else
	{
	  if(part->spinInfo())
	    {throw ThePEG::Helicity::HelicityConsistencyError() 
		<< "Wrong type of SpinInfo for the incoming particle in "
		<< "VectorWaveFunction::constructSpinInfo() "
		<< Exception::warning;}
	  if(vertex)
	    {
	      SpinPtr newspin=new_ptr(VectorSpinInfo(part->momentum(),time));
	      inspin= dynamic_ptr_cast<tVectorSpinPtr>(newspin);
	      if(time) inspin->decayed(true);
	      part->spinInfo(newspin);
	    }
	  rho = RhoDMatrix(PDT::Spin1);rho.average();
	  constructSpinInfo(wave,inspin,massless,phase,vertex);
	}
    }
}
}
}
