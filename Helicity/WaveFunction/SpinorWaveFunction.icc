// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the SpinorWaveFunction class.
//
// Author: Peter Richardson
//

namespace Herwig {
using ThePEG::Helicity::LorentzSpinor;
namespace Helicity {
using namespace ThePEG;

// constructors

// use a 5-momentum and specify all components (specifiy Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(const Lorentz5Momentum &p,
					      const tcPDPtr & part,
					      complex<double> s1, complex<double> s2,
					      complex<double> s3, complex<double> s4, DiracRep dirac) 
{
  direction(intermediate);
  setMomentum(p);
  checkParticle(part);
  _wf = LorentzSpinor<double>(s1,s2,s3,s4,dirac);
}	

// use a 5-momentum and a LorentzSpinor
inline SpinorWaveFunction::SpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,
					      const LorentzSpinor<double> & inspin,
					      Direction dir)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part); 
  _wf=inspin;
}
inline SpinorWaveFunction::SpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,
					      const LorentzSpinor<SqrtEnergy> & inspin,
					      DummyType,
					      Direction dir)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part); 
  _wf = LorentzSpinor<double>(inspin.Type(), inspin.Rep());
  for (unsigned int i=0; i<4; ++i)
    _wf[i]=inspin[i]*UnitRemoval::InvSqrtE;
}

// use a 5-momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(const Lorentz5Momentum & p,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, 
					      DiracRep dirac) 
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set all components of momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part); 
  calculateWaveFunction(ihel,dirac);
}

// set 4-momentum components (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part,unsigned int ihel,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set 4-momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(LorentzMomentum pin, const tcPDPtr & part,
					      unsigned int ihel, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set mass zero momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Energy mm, const tcPDPtr & part,
					      unsigned int ihel, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// set 4 momentum and mass (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(LorentzMomentum pin,Energy mm,
					      const tcPDPtr & part, unsigned int ihel,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  calculateWaveFunction(ihel,dirac);
}

// default constructors (set the momentum and zero the Wavefunction)

// use a 5 momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Lorentz5Momentum p, const tcPDPtr & part,
					      Direction dir, DiracRep dirac)
{
  direction(dir);
  setMomentum(p);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set all components of momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee, Energy mm,
					      const tcPDPtr & part, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee,mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4-momentum components (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Energy px, Energy py,
					      Energy pz, Energy ee,
					      const tcPDPtr & part, Direction dir,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(px,py,pz,ee);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4-momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(LorentzMomentum pin, const tcPDPtr & part,
					      Direction dir, DiracRep dirac) 
{
  direction(dir);
  setMomentum(pin);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set mass zero momentum (specify Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(Energy mm,const tcPDPtr & part,
					      Direction dir,DiracRep dirac)
{
  direction(dir);
  setMomentum(mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// set 4 momentum and mass
inline SpinorWaveFunction::SpinorWaveFunction(LorentzMomentum pin,Energy mm,
					      const tcPDPtr & part, Direction dir, 
					      DiracRep dirac) 
{
  direction(dir);
  setMomentum(pin,mm);
  checkParticle(part);
  zeroWaveFunction(dirac);
}

// default constructor (specfiy Dirac representation)
inline SpinorWaveFunction::SpinorWaveFunction(DiracRep dirac)
{
  direction(intermediate);
  setMomentum();
  zeroWaveFunction(dirac);
}

// descructor
inline SpinorWaveFunction::~SpinorWaveFunction(){;}

// subscript operator
inline complex<double> SpinorWaveFunction::operator ()(int i) const
{
  if(i<0 || i>3)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "SpinorWaveFunction requested for invalid index" << Exception::abortnow;
      return complex<double>();
    }
  return _wf[i];
}
// Set components by index.
inline complex<double> & SpinorWaveFunction::operator () (int i)
{
  static complex<double> dummy;
  if(i>=0 &&i<=3)
    {return _wf(i);}
  else
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid index " << i << " called for SpinorWaveFunction" 
	<< Exception::abortnow;
      return dummy;
    }
}

// Assignment. 
inline SpinorWaveFunction & SpinorWaveFunction::operator = (const SpinorWaveFunction & w)
{
  setPx(w.px());setPy(w.py());setPz(w.pz());setE(w.e());setMass(w.mass());
  _wf=w._wf;
  setParticle(w.getParticle());
  direction(w.direction());
  return *this;
}

// return the wavefunction as a LorentzSpinor
inline LorentzSpinor<double> SpinorWaveFunction::wave() const{return _wf;}
inline LorentzSpinor<SqrtEnergy> SpinorWaveFunction::dimensionedWave() const {
  return dimensionedWf();
}

// Get components
inline complex<double> SpinorWaveFunction::s1() const {return _wf.s1();}
inline complex<double> SpinorWaveFunction::s2() const {return _wf.s2();}
inline complex<double> SpinorWaveFunction::s3() const {return _wf.s3();}
inline complex<double> SpinorWaveFunction::s4() const {return _wf.s4();}

// Set components
inline void SpinorWaveFunction::setS1(complex<double> in){_wf.setS1(in);}
inline void SpinorWaveFunction::setS2(complex<double> in){_wf.setS2(in);}
inline void SpinorWaveFunction::setS3(complex<double> in){_wf.setS3(in);}
inline void SpinorWaveFunction::setS4(complex<double> in){_wf.setS4(in);}


// reset functions

// momentum, particle type and direction
inline void SpinorWaveFunction::reset(const Lorentz5Momentum & pin, const tcPDPtr & part,
				      Direction dir)
{
  direction(dir);
  checkParticle(part);
  setMomentum(pin);
}

// reset momentum and particle type
inline void SpinorWaveFunction::reset(const Lorentz5Momentum & pin, Direction dir)
{
  direction(dir);
  setMomentum(pin);
}

// reset momentum
inline void SpinorWaveFunction::reset(const Lorentz5Momentum & pin)
{
  setMomentum(pin);
}

// reset the helicity (calculates the new spinor (specify Dirac representation)
inline void SpinorWaveFunction::reset(unsigned int ihel,DiracRep dirac)
{calculateWaveFunction(ihel,dirac);}

// reset the particle type and direction
inline void SpinorWaveFunction::reset(const tcPDPtr & part,Direction dir)
{
  direction(dir);
  checkParticle(part);
}

// reset the particle type
inline void SpinorWaveFunction::reset(const tcPDPtr & part)
{checkParticle(part);}	

// zero the wavefunction (set specify Dirac representation)
inline void SpinorWaveFunction::zeroWaveFunction(DiracRep dirac)
{_wf=LorentzSpinor<double>(dirac);}

// check the particles
inline void SpinorWaveFunction::checkParticle(const tcPDPtr & in)
{
  setParticle(in);
  if(iSpin()!=2)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Calculating Spinor WaveFunction for non-spin 1/2 Particle" 
	<< Exception::warning;
    }
}

// special setup constructor
inline SpinorWaveFunction::SpinorWaveFunction(vector<LorentzSpinor<SqrtEnergy> >& wave, tPPtr part,
					      Direction dir,bool time, bool vertex,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,part,time,vertex);
}

// special setup constructor
inline SpinorWaveFunction::SpinorWaveFunction(vector<LorentzSpinor<SqrtEnergy> >& wave,
					      RhoDMatrix& rho,
					      tPPtr part,Direction dir,bool time,
					      bool vertex,DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,rho,part,time,vertex);
}


// special setup constructor
inline SpinorWaveFunction::SpinorWaveFunction(vector<SpinorWaveFunction>& wave,
					      tPPtr part,
					      Direction dir,bool time, bool vertex,
					      DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,part,time,vertex);
}

// special setup constructor
inline SpinorWaveFunction::SpinorWaveFunction(vector<SpinorWaveFunction>& wave,
					      RhoDMatrix& rho,
					      tPPtr part,Direction dir,bool time,
					      bool vertex,DiracRep dirac)
{
  direction(dir);
  setMomentum(part->momentum());
  checkParticle(part->dataPtr());
  zeroWaveFunction(dirac);
  constructSpinInfo(wave,rho,part,time,vertex);
}

// construct the spininfo object
inline void SpinorWaveFunction::constructSpinInfo(vector<LorentzSpinor<SqrtEnergy> >& wave,
						  tFermionSpinPtr spin,bool vertex)
{
  wave.resize(2);
  for(unsigned int ix=0;ix<2;++ix)
    {
      // calculate the wavefunction for the first helicity
      reset(ix);
      // add to output array
      wave[ix] = dimensionedWf();
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,dimensionedWf());}
	  else{spin->setDecayState(ix,dimensionedWf());}
	}
    }
}

// construct the spininfo object
inline void SpinorWaveFunction::constructSpinInfo(vector<SpinorWaveFunction>& wave,
						  tFermionSpinPtr spin,bool vertex)
{
  wave.resize(2);
  for(unsigned int ix=0;ix<2;++ix)
    {
      // calculate the wavefunction for the first helicity
      reset(ix);
      // add to output array
      wave[ix] = SpinorWaveFunction(*this);
      // setup the spininfo object
      if(vertex)
	{
	  if(direction()==outgoing){spin->setBasisState(ix,dimensionedWf());}
	  else{spin->setDecayState(ix,dimensionedWf());}
	}
    }
}

}
}
