// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ProductionMatrixElement class.
//
// Author: Peter Richardson
//

namespace Herwig {
namespace Helicity {

using namespace ThePEG;

// default constructor  
inline ProductionMatrixElement::ProductionMatrixElement() {}

// constructor for 2-1 scattering
inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1,PDT::Spin in2,
							PDT::Spin out1)
{
  _nout=2;
  _inspin.resize(2);
  _inspin[0]=in1; _inspin[1]=in2;
  _outspin.push_back(out1);
  setMESize();
}
// constructor for 2-2 scattering
inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1,PDT::Spin in2,
							PDT::Spin out1,PDT::Spin out2)
{
  _nout=2;
  _inspin.resize(2);
  _inspin[0]=in1; _inspin[1]=in2;
  _outspin.push_back(out1);_outspin.push_back(out2);
  setMESize();
}

// constructor for 2-3 scattering
inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1, PDT::Spin in2, 
							PDT::Spin out1,PDT::Spin out2,
							PDT::Spin out3)
{
  _inspin.resize(2);
  _nout=3; _inspin[0]=in1; _inspin[1]=in2;
  _outspin.push_back(out1);_outspin.push_back(out2);_outspin.push_back(out3);
  setMESize();
}

// constructor for 2-4 scattering
  inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1, PDT::Spin in2,
							  PDT::Spin out1,PDT::Spin out2,
							  PDT::Spin out3,PDT::Spin out4)
{
  _nout=4;
  _inspin.resize(2);
  _inspin[0]=in1; _inspin[1]=in2;
  _outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);_outspin.push_back(out4);
  setMESize();
}

// constructor for 2-5 scattering
inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1, PDT::Spin in2,
							PDT::Spin out1,PDT::Spin out2,
							PDT::Spin out3,PDT::Spin out4,
							PDT::Spin out5)
{
  _nout=5;
  _inspin.resize(2);
  _inspin[0]=in1; _inspin[1]=in2;
  _outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);_outspin.push_back(out4);_outspin.push_back(out5);
  setMESize();
}

// constructor for 2-6 scattering
inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1, PDT::Spin in2,
							PDT::Spin out1,PDT::Spin out2,
							PDT::Spin out3,PDT::Spin out4,
							PDT::Spin out5,PDT::Spin out6)
{
  _nout=6;
  _inspin.resize(2);
  _inspin[0]=in1; _inspin[1]=in2;
  _outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);_outspin.push_back(out4);
  _outspin.push_back(out5);_outspin.push_back(out6);
  setMESize();
}

// constructor for 2-n scattering
inline ProductionMatrixElement::ProductionMatrixElement(PDT::Spin in1, PDT::Spin in2,
							vector<PDT::Spin> out)
{
  _inspin.resize(2);
  _nout=out.size(); _inspin[0]=in1; _inspin[1]=in2;
  _outspin=out;setMESize();
}

// set the size of the vector containing the matrix element
inline void ProductionMatrixElement::setMESize()
{
  unsigned int ix;
  int isize=_inspin[0]*_inspin[1];
  for(ix=0;ix<_outspin.size();++ix){isize*=_outspin[ix];}
  // zero the matrix element
  _matrixelement.resize(isize,0.);
  // set up the constants for the mapping of helicity to vectro index
  _constants.resize(_outspin.size()+3);
  unsigned int temp=1;
  for(ix=_outspin.size()+1;ix>1;--ix){temp*=_outspin[ix-2];_constants[ix]=temp;}
  temp*=_inspin[1];_constants[1]=temp;
  temp*=_inspin[0];_constants[0]=temp;
  _constants[_outspin.size()+2]=1;
}

// get the spins of the incoming particles particle
inline vector<PDT::Spin> ProductionMatrixElement::inspin(){return _inspin;}

// get the spins of the outgoing particles
inline vector<PDT::Spin> ProductionMatrixElement::outspin(){return _outspin;}

// access to the individual helicity components (2-2 scattering)
inline Complex   ProductionMatrixElement::operator () 
  (unsigned int in1,unsigned int in2,unsigned int out1) const
{
  // check this is really a 2-2 matrix element
  if(_outspin.size()!=1)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-1 matrix element"
	<< " but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow;
      return 0.;
    }
  unsigned int iloc(0);
  iloc+=in1*_constants[1];
  iloc+=in2*_constants[2];
  iloc+=out1*_constants[3];
  if(iloc>=_matrixelement.size())
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid component of 2-1 matrix element requested" 
	<< Exception::abortnow;
      return 0.;
    }
  return _matrixelement[iloc];
}

// access to the individual helicity components (2-2 scattering)
inline Complex   ProductionMatrixElement::operator () 
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2) const
{
  // check this is really a 2-2 matrix element
  if(_outspin.size()!=2)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-2 matrix element but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow; 
      return 0.;
    }
  unsigned int iloc(0);
  iloc+=in1*_constants[1];
  iloc+=in2*_constants[2];
  iloc+=out1*_constants[3];
  iloc+=out2*_constants[4];
  if(iloc>=_matrixelement.size())
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid component of 2-2 matrix element requested" 
	<< Exception::abortnow; 
      return 0.;
    }
  return _matrixelement[iloc];
}

// access to the individual helicity components (2-3 scattering)
inline Complex   ProductionMatrixElement::operator () 
  (unsigned int in1,unsigned int in2,
   unsigned int out1,unsigned int out2,unsigned int out3) const
{
  if(_outspin.size()!=3)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-3 matrix element but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow;
      return 0.;
    }
  // map the indices to the location in the vector
  vector<unsigned int> ivec(5);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  return (*this)(ivec);
}

// access to the individual helicity components (2-4 scattering)
inline Complex   ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3,unsigned int out4) const
{
  if(_outspin.size()!=4)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
      << "Requested component of 2-4 matrix element but matrix element is 2-"
      << _outspin.size() << Exception::abortnow;
      return 0.;
    }
  vector<unsigned int> ivec(6);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  ivec[5]=out4;
  return (*this)(ivec);
}


// access to the individual helicity components (2-5 scattering)
inline Complex   ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3,unsigned int out4, unsigned int out5) const
{
  if(_outspin.size()!=5)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-4 matrix element but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow;
      return 0.;
    }
  vector<unsigned int> ivec(7);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  ivec[5]=out4;ivec[6]=out5;
  return (*this)(ivec);
}


// access to the individual helicity components (2-6 scattering)
inline Complex   ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3,unsigned int out4, unsigned int out5, unsigned int out6) const
{
  if(_outspin.size()!=6)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-6 matrix element but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow;
      return 0.;
    }
  vector<unsigned int> ivec(8);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  ivec[5]=out4;ivec[6]=out5;ivec[7]=out6;
  return (*this)(ivec);
}


// access to the individual helicity components (2-n scattering)
inline Complex   ProductionMatrixElement::operator () 
  (vector<unsigned int> in) const
{
  if(_outspin.size()!=in.size()-2)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-" << in.size() 
	<< " matrix element but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow;
      return 0.;
    }
  unsigned int iloc(0),ix;
  // incoming and outgoing particles
  for(ix=0;ix<in.size();++ix){iloc+=in[ix]*_constants[ix+1];}
  if(iloc>=_matrixelement.size())
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid component of 2-n matrix element requested" 
	<< Exception::abortnow;
      return 0.;
    }
  return _matrixelement[iloc];
}

// set the individual helicity components (2-1 scattering)
inline Complex & ProductionMatrixElement::operator () (unsigned int in1,unsigned int in2,
						       unsigned int out1)
{
  static Complex dummy=0.;
  unsigned int iloc(0);
  iloc+= in1*_constants[1];
  iloc+= in2*_constants[2];
  iloc+=out1*_constants[3];
  if(iloc>=_matrixelement.size())
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid component of 2-1 matrix element requested" 
	<< Exception::abortnow;
      return dummy;
    }
  return _matrixelement[iloc];
}

// set the individual helicity components (2-2 scattering)
inline Complex & ProductionMatrixElement::operator () (unsigned int in1,
						       unsigned int in2,
						       unsigned int out1,
						       unsigned int out2)
{
  static Complex dummy=0.;
  unsigned int iloc(0);
  iloc+= in1*_constants[1];
  iloc+= in2*_constants[2];
  iloc+=out1*_constants[3];
  iloc+=out2*_constants[4];
  if(iloc>=_matrixelement.size())
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid component of 2-2 matrix element requested" 
	<< Exception::abortnow;
      return dummy;
    }
  return _matrixelement[iloc];
}

// set the individual helicity components (2-3 scattering)
inline Complex & ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3)
{
  vector<unsigned int> ivec(5);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  return (*this)(ivec);
}

// set the individual helicity components (2-4 scattering)
inline Complex & ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3, unsigned int out4)
{
  vector<unsigned int> ivec(6);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  ivec[5]=out4;
  return (*this)(ivec);
}

// set the individual helicity components (2-5 scattering)
inline Complex & ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3, unsigned int out4, unsigned int out5)
{
  vector<unsigned int> ivec(7);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  ivec[5]=out4; ivec[6]=out5;
  return (*this)(ivec);
}

// set the individual helicity components (2-6 scattering)
inline Complex & ProductionMatrixElement::operator ()
  (unsigned int in1,unsigned int in2,unsigned int out1,unsigned int out2,
   unsigned int out3, unsigned int out4, unsigned int out5, unsigned int out6)
{
  vector<unsigned int> ivec(8);
  ivec[0]=in1;ivec[1]=in2;ivec[2]=out1;ivec[3]=out2;ivec[4]=out3;
  ivec[5]=out4; ivec[6]=out5; ivec[7]=out6;
  return (*this)(ivec);
}

inline Complex & ProductionMatrixElement::operator ()
  (vector<unsigned int> in)
{
  static Complex dummy=0;
  if(_outspin.size()!=in.size()-2)
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Requested component of 2-" << in.size() 
	<< " matrix element but matrix element is 2-"
	<< _outspin.size() << Exception::abortnow; 
      return dummy;
    }
  unsigned int iloc=0;
  // incoming particles
  for(unsigned int ix=0;ix<in.size();++ix){iloc+=in[ix]*_constants[ix+1];}
  if(iloc>=_matrixelement.size())
    {
      throw ThePEG::Helicity::HelicityConsistencyError() 
	<< "Invalid component of 2-n matrix element requested" 
	<< Exception::abortnow;
      return dummy;
    }
  return _matrixelement[iloc];
}

// reset the matrix element
inline void ProductionMatrixElement::reset(const ProductionMatrixElement & x) const
{
  _nout = x._nout;
  _inspin = x._inspin;
  _outspin =x._outspin;
  _matrixelement=x._matrixelement;
  _constants=x._constants;
}

}
}
