// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DecayMatrixElement class.
//
// Author: Peter Richardson
//

namespace Herwig {
namespace Helicity {

using namespace ThePEG;

// default constructor    
inline DecayMatrixElement::DecayMatrixElement() {}
    
// copy constructor
inline DecayMatrixElement::DecayMatrixElement(const DecayMatrixElement & x)
  : Base(x), _nout(x._nout) ,_inspin(x._inspin), _outspin(x._outspin),
    _matrixelement(x._matrixelement), _constants(x._constants) {}
  
// constructor for two body decay
inline DecayMatrixElement::DecayMatrixElement(int in,int out1,int out2)
{
  _nout=2; _inspin=in;_outspin.push_back(out1);_outspin.push_back(out2);
  setMESize();
}

// constructor for three body decay
inline DecayMatrixElement::DecayMatrixElement(int in,int out1,int out2,int out3)
{
  _nout=3; _inspin=in;_outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);
  setMESize();
}

// constructor for four body decay
inline DecayMatrixElement::DecayMatrixElement(int in,int out1,int out2,int out3,
					      int out4)
{
  _nout=4; _inspin=in;_outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);_outspin.push_back(out4);
  setMESize();
}

// constructor for five body decay
inline DecayMatrixElement::DecayMatrixElement(int in,int out1,int out2,int out3,
					      int out4,int out5)
{
  _nout=5; _inspin=in;_outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);_outspin.push_back(out4);_outspin.push_back(out5);
  setMESize();
}

// constructor for six body decay
inline DecayMatrixElement::DecayMatrixElement(int in,int out1,int out2,int out3,
					      int out4,int out5,int out6)
{
  _nout=6; _inspin=in;_outspin.push_back(out1);_outspin.push_back(out2);
  _outspin.push_back(out3);_outspin.push_back(out4);_outspin.push_back(out5);
  _outspin.push_back(out6);
  setMESize();
}

// constructor for arbitary body decay
inline DecayMatrixElement::DecayMatrixElement(int in,vector<int> out)
{_nout=out.size(); _inspin=in;_outspin=out;setMESize();}

// constructor for arbitray body decay
inline DecayMatrixElement::DecayMatrixElement(vector<int> out)
{
  _nout=out.size();
  _inspin=out[0];
  _outspin=vector<int>(out.begin()+1,out.end());
  setMESize();
}  

// set the size of the vector containing the matrix element
inline void DecayMatrixElement::setMESize()
{
  int isize=_inspin;
  for(unsigned int ix=0;ix<_outspin.size();++ix)
    {
      isize*=_outspin[ix];
    }
  // zero the matrix element
  _matrixelement.resize(isize,0.);
  // set up the constants for the mapping of helicity to vectro index
  _constants.resize(_outspin.size()+2);
  int temp=1;
  for(unsigned int ix=_outspin.size();ix>0;--ix)
    {
      temp*=_outspin[ix-1];_constants[ix]=temp;
    }
  temp*=_inspin;_constants[0]=temp;
  _constants[_outspin.size()+1]=1;
}

// reset the matrix element
inline void DecayMatrixElement::reset(const DecayMatrixElement & x) const
{
  _nout = x._nout;
  _inspin = x._inspin;
  _outspin =x._outspin;
  _matrixelement=x._matrixelement;
  _constants=x._constants;
}

// get the spins of the incoming particles 
inline int DecayMatrixElement::inspin(){return _inspin;}

// get the spins of the outgoing particles
inline vector<int> DecayMatrixElement::outspin(){return _outspin;}

// access a component for a two body decay
inline Complex DecayMatrixElement::operator() (int ia,int ib,int ic) const
{
  vector<int> itemp(3);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;
  return (*this)(itemp);
}

// access a component of a three body decay
inline Complex DecayMatrixElement::operator() (int ia,int ib,int ic,int id) const
{
  vector<int> itemp(4);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;itemp[3]=id;
  return (*this)(itemp);
}

// access a component of a four body decay
inline Complex DecayMatrixElement::operator() (int ia,int ib,int ic,int id,
						       int ie) const
{
  vector<int> itemp(5);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;itemp[3]=id;itemp[4]=ie;
  return (*this)(itemp);
}

// access a component of a five body decay
inline Complex DecayMatrixElement::operator() (int ia,int ib,int ic,int id,
						       int ie,int ig) const
{
  vector<int> itemp(6);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;
  itemp[3]=id;itemp[4]=ie;itemp[5]=ig;
  return (*this)(itemp);
}

// access a component of a six body decay
inline Complex DecayMatrixElement::operator() (int ia,int ib,int ic,int id,
						       int ie,int ig, int ih) const
{
  vector<int> itemp(7);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;
  itemp[3]=id;itemp[4]=ie;itemp[5]=ig;itemp[6]=ih;
  return (*this)(itemp);
}

// access a component 
inline Complex DecayMatrixElement::operator () (vector<int> in) const
{
  if(in.size()!=_outspin.size()+1)
    {cerr << "Requested the components of a " << in.size()-1 
	  << " body decay but this decay is " << _outspin.size() << endl; return 0.;}
  unsigned int iloc=0,itemp;
  // contribution  for the incoming particle
  itemp = _inspin/2+ in[0]-int( _inspin%2==0&& in[0]>0);
  iloc+=itemp*_constants[1];
  // contributions for the outgoing particles
  for(unsigned int ix=1;ix<in.size();++ix)
    {
      itemp =  (_outspin[ix-1]+1)/2+in[ix]-int(_outspin[ix-1]%2==0&&in[ix]>0);
      iloc+=itemp*_constants[ix+1];
    }
  if(iloc>=_matrixelement.size())
    {cerr << "Invalid component of decay matrix element requested " << iloc << endl;
    return 0.;}
  return _matrixelement[iloc];
}

// set a component for a two body decay
inline Complex & DecayMatrixElement::operator() (int ia,int ib,int ic) 
{
  vector<int> itemp(3);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;
  return (*this)(itemp);
}

// set a component of a three body decay
inline Complex & DecayMatrixElement::operator() (int ia,int ib,int ic,int id) 
{
  vector<int> itemp(4);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;itemp[3]=id;
  return (*this)(itemp);
}

// set a component of a four body decay
inline Complex & DecayMatrixElement::operator() (int ia,int ib,int ic,int id,
 int ie) 
{
  vector<int> itemp(5);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;itemp[3]=id;itemp[4]=ie;
  return (*this)(itemp);
}

// set a component of a five body decay
inline Complex & DecayMatrixElement::operator() (int ia,int ib,int ic,int id,
							 int ie,int ig) 
{
  vector<int> itemp(6);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;
  itemp[3]=id;itemp[4]=ie;itemp[5]=ig;
  return (*this)(itemp);
}

// set a component of a six body decay
inline Complex & DecayMatrixElement::operator() (int ia,int ib,int ic,int id,
							 int ie,int ig, int ih) 
{
  vector<int> itemp(7);itemp[0]=ia;itemp[1]=ib;itemp[2]=ic;
  itemp[3]=id;itemp[4]=ie;itemp[5]=ig;itemp[6]=ih;
  return (*this)(itemp);
}

// set a component
inline Complex & DecayMatrixElement::operator () (vector<int> in)
{
  static Complex dummy=0.;
  if(in.size()!=_outspin.size()+1)
    {cerr << "Requested the components of a " << in.size()-1 
	  << " body decay but this decay is " << _outspin.size() << endl; return dummy;}
  unsigned int iloc=0,itemp;
  // contribution  for the incoming particle
  itemp = _inspin/2+ in[0]-int( _inspin%2==0&& in[0]>0);
  iloc+=itemp*_constants[1];
  // contributions for the outgoing particles
  for(unsigned int ix=1;ix<in.size();++ix)
    {
      itemp =  _outspin[ix-1]/2+in[ix]-int(_outspin[ix-1]%2==0&&in[ix]>0);
      iloc+=itemp*_constants[ix+1];
    }
  if(iloc>=_matrixelement.size())
    {cerr << "Invalid component of decay matrix element requested " << iloc << endl;
    return dummy;}
  return _matrixelement[iloc];
}

// contract the matrix element with the rho matrix of the incoming particle
inline Complex DecayMatrixElement::contract(RhoDMatrix &in)
{
  Complex me=0.; int in1,in2;
  for(int ix=0;ix<_constants[1];++ix)
    {
      in1=0;
      for(int inhel1=-_inspin/2;inhel1<_inspin/2+1;++inhel1)
	{
	  if(inhel1==0&&_inspin%2==0){++inhel1;}
	  in2=0;
	  for(int inhel2=-_inspin/2;inhel2<_inspin/2+1;++inhel2)
	    {
	      if(inhel2==0&&_inspin%2==0){++inhel2;}
	      // compute the term
	      me+=_matrixelement[in1*_constants[1]+ix]*
		conj(_matrixelement[in2*_constants[1]+ix])*in(inhel1,inhel2);
	      ++in2;
	    }
	  ++in1;
	}
    }
  return me;
}

}
}

