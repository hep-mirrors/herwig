// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the EventShapes class.
//

namespace Herwig {

inline EventShapes::EventShapes() {}

inline EventShapes::EventShapes(const EventShapes & x)
  : Interfaced(x) {}

inline IBPtr EventShapes::clone() const {
  return new_ptr(*this);
}

inline IBPtr EventShapes::fullclone() const {
  return new_ptr(*this);
}

inline void EventShapes::doupdate() throw(UpdateException) {
  Interfaced::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void EventShapes::doinit() throw(InitException) {
  Interfaced::doinit();
}

inline void EventShapes::dofinish() {
  Interfaced::dofinish();
}

inline void EventShapes::doinitrun() {
  Interfaced::doinitrun();
}

inline void EventShapes::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  Interfaced::rebind(trans);
}

inline IVector EventShapes::getReferences() {
  IVector ret = Interfaced::getReferences();
  // ret.push_back(dummy);
  return ret;
}


inline double EventShapes::thrust() {
  checkThrust(); 
  return _thrust[0];
}

inline double EventShapes::thrustMajor() {
  checkThrust(); 
  return _thrust[1];
}

inline double EventShapes::thrustMinor() {
  checkThrust(); 
  return _thrust[2];
}

inline double EventShapes::oblateness() {
  checkThrust(); 
  return _thrust[1]-_thrust[2];
}

inline Vector3 EventShapes::thrustAxis() {
  checkThrust(); 
  return _thrustAxis[0];
}

inline Vector3 EventShapes::majorAxis() {
  checkThrust(); 
  return _thrustAxis[1];
}

inline Vector3 EventShapes::minorAxis() {
  checkThrust(); 
  return _thrustAxis[2];
}

inline void EventShapes::reset(const tPVector &part)
{
  _pv.resize(part.size());
  for(unsigned int ix=0;ix<part.size();++ix) _pv[ix]=part[ix]->momentum();
  _thrustDone = false;
  _spherDone  = false;
  _linTenDone = false;
  _hemDone    = false;
  _useCmBoost = false; 
}

inline double EventShapes::sphericity() {
  checkSphericity(); 
  return 3./2.*(_spher[1]+_spher[2]); 
}

inline double EventShapes::aplanarity() {
  checkSphericity(); 
  return 3./2.*_spher[2];
}

inline double EventShapes::planarity() {
  checkSphericity(); 
  return _spher[1]-_spher[2]; 
}

inline Vector3 EventShapes::sphericityAxis() {
  checkSphericity(); 
  return _spherAxis[0]; 
}

inline vector<double> EventShapes::sphericityEigenValues() {
  checkSphericity(); 
  return _spher; 
}

inline vector<Vector3> EventShapes::sphericityEigenVectors() {
  checkSphericity(); 
  return _spherAxis; 
}

inline vector<double> EventShapes::linTenEigenValues() {
  checkLinTen(); 
  return _linTen; 
}

inline vector<Vector3> EventShapes::linTenEigenVectors() {
  checkLinTen(); 
  return _linTenAxis; 
}

inline double EventShapes::CParameter() {
  checkLinTen(); 
  return 3.*(_linTen[0]*_linTen[1]+_linTen[1]*_linTen[2]
	     +_linTen[2]*_linTen[0]); 
}

inline double EventShapes::DParameter() {
  checkLinTen(); 
  return 27.*(_linTen[0]*_linTen[1]*_linTen[2]); 
}

inline double EventShapes::Mhigh2() {
  checkHemispheres();
  return _mPlus; 
} 

inline double EventShapes::Mlow2() {
  checkHemispheres();
  return _mMinus; 
} 

inline double EventShapes::Mdiff2() {
  checkHemispheres();
  return _mPlus-_mMinus; 
} 

inline double EventShapes::Bmax() {
  checkHemispheres(); 
  return _bPlus;
}

inline double EventShapes::Bmin() {
  checkHemispheres(); 
  return _bMinus;
}

inline double EventShapes::Bsum() {
  checkHemispheres(); 
  return _bPlus+_bMinus;
}

inline double EventShapes::Bdiff() {
  checkHemispheres(); 
  return _bPlus-_bMinus;
}

inline void EventShapes::checkLinTen() {
  if (!_linTenDone) {
    _linTenDone = true;
    diagonalizeTensors(true, _useCmBoost); 
  }
}

inline void EventShapes::checkSphericity() {
  if (!_spherDone) {
    _spherDone = true;
    diagonalizeTensors(false, _useCmBoost); 
  }
}

inline void EventShapes::checkThrust() {
  if (!_thrustDone) {
    _thrustDone = true;
    calculateThrust(); 
  }
}

inline void EventShapes::checkHemispheres() {
  if (!_hemDone) {
    _hemDone = true;
    calcHemisphereMasses(); 
  }
}

inline void EventShapes::calcHemisphereMasses() {
  Lorentz5Momentum pos, neg;
  vector<Lorentz5Momentum>::const_iterator cit;
  Energy pden(0.),epos(0.),eneg(0.);
  for(unsigned int ix=0;ix<_pv.size();++ix)
    {
      if(_pv[ix]*thrustAxis()>0.)
	{
	  pos  += _pv[ix];
	  epos += _pv[ix].perp(thrustAxis()); 
	}
      else
	{
	  neg  += _pv[ix];
	  eneg += _pv[ix].perp(thrustAxis()); 
	}
      pden += _pv[ix].vect().mag();	 
    }
  // denominator and masses
  Energy2 den(sqr(pos.e()+neg.e()));
  _mPlus = pos.m2()/den;
  _mMinus = neg.m2()/den;
  if (_mPlus < _mMinus) swap(_mPlus, _mMinus);
  // jet broadening
  _bPlus  = 0.5*epos/pden;
  _bMinus = 0.5*eneg/pden;
  if (_bPlus < _bMinus) swap(_bPlus, _bMinus);
}

inline double EventShapes::getX(const Lorentz5Momentum & p, 
			      const Energy & Ebeam) {
  return(Ebeam > 0 ? p.vect().mag()/Ebeam : -1.); 
}

inline double EventShapes::getXi(const Lorentz5Momentum & p, 
			       const Energy & Ebeam) {
  return((Ebeam > 0 && p.vect().mag() > 0) ? 
	 log(Ebeam/p.vect().mag()) : -1.); 
}

inline Energy EventShapes::getPt(const Lorentz5Momentum & p) {
  return p.perp(); 
}

inline Energy EventShapes::getRapidity(const Lorentz5Momentum & p) {
  return (p.t() > p.z() ? p.rapidity() : 1e99); 
}

inline Energy EventShapes::ptInT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[1]; 
}

inline Energy EventShapes::ptOutT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[2]; 
}

inline double EventShapes::yT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return (p.t() > p.vect()*_thrustAxis[0] ? 
	  p.rapidity(_thrustAxis[0]) : 1e99);
}

inline Energy EventShapes::ptInS(const Lorentz5Momentum & p) { 
  checkSphericity(); 
  return p.vect()*_spherAxis[1]; 
}

inline Energy EventShapes::ptOutS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return p.vect()*_spherAxis[2]; 
}

inline double EventShapes::yS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return (p.t() > p.vect()*_spherAxis[0] ? 
	  p.rapidity(_spherAxis[0]) : 1e99);
}

inline void EventShapes::normalizeEEC(vector<double> & hi, long evts) {
  for (unsigned int bin = 0; bin < hi.size(); bin++) bin /= (hi.size()*evts);
}

inline double EventShapes::AEEC(vector<double> & hi, double& coschi) {
  if (coschi > 0. && coschi <= 1.) {
    int i = (int) floor((-coschi+1.)/2.*hi.size()); 
    int j = (int) floor((coschi+1.)/2.*hi.size()); 
    return hi[i]-hi[j];
  } else {
    return 1e99;
  }
}
}
