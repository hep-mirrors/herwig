// -*- C++ -*-
//
// EventShapes.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the EventShapes class.
//

namespace Herwig {

inline double EventShapes::thrust() {
  checkThrust(); 
  return _thrust[0];
}

inline double EventShapes::thrustMajor() {
  checkThrust(); 
  return _thrust[1];
}

inline double EventShapes::thrustMinor() {
  checkThrust(); 
  return _thrust[2];
}

inline double EventShapes::oblateness() {
  checkThrust(); 
  return _thrust[1]-_thrust[2];
}

inline Axis EventShapes::thrustAxis() {
  checkThrust(); 
  return _thrustAxis[0];
}

inline Axis EventShapes::majorAxis() {
  checkThrust(); 
  return _thrustAxis[1];
}

inline Axis EventShapes::minorAxis() {
  checkThrust(); 
  return _thrustAxis[2];
}

inline void EventShapes::reset(const tPVector &part) {
  _pv.resize(part.size());
  for(unsigned int ix=0;ix<part.size();++ix) _pv[ix]=part[ix]->momentum();
  _thrustDone = false;
  _spherDone  = false;
  _linTenDone = false;
  _hemDone    = false;
  _useCmBoost = false; 
}

inline double EventShapes::sphericity() {
  checkSphericity(); 
  return 3./2.*(_spher[1]+_spher[2]); 
}

inline double EventShapes::aplanarity() {
  checkSphericity(); 
  return 3./2.*_spher[2];
}

inline double EventShapes::planarity() {
  checkSphericity(); 
  return _spher[1]-_spher[2]; 
}

inline Axis EventShapes::sphericityAxis() {
  checkSphericity(); 
  return _spherAxis[0]; 
}

inline vector<double> EventShapes::sphericityEigenValues() {
  checkSphericity(); 
  return _spher; 
}

inline vector<Axis> EventShapes::sphericityEigenVectors() {
  checkSphericity(); 
  return _spherAxis; 
}

inline vector<double> EventShapes::linTenEigenValues() {
  checkLinTen(); 
  return _linTen; 
}

inline vector<Axis> EventShapes::linTenEigenVectors() {
  checkLinTen(); 
  return _linTenAxis; 
}

inline double EventShapes::CParameter() {
  checkLinTen(); 
  return 3.*(_linTen[0]*_linTen[1]+_linTen[1]*_linTen[2]
	     +_linTen[2]*_linTen[0]); 
}

inline double EventShapes::DParameter() {
  checkLinTen(); 
  return 27.*(_linTen[0]*_linTen[1]*_linTen[2]); 
}

inline double EventShapes::Mhigh2() {
  checkHemispheres();
  return _mPlus; 
} 

inline double EventShapes::Mlow2() {
  checkHemispheres();
  return _mMinus; 
} 

inline double EventShapes::Mdiff2() {
  checkHemispheres();
  return _mPlus-_mMinus; 
} 

inline double EventShapes::Bmax() {
  checkHemispheres(); 
  return _bPlus;
}

inline double EventShapes::Bmin() {
  checkHemispheres(); 
  return _bMinus;
}

inline double EventShapes::Bsum() {
  checkHemispheres(); 
  return _bPlus+_bMinus;
}

inline double EventShapes::Bdiff() {
  checkHemispheres(); 
  return _bPlus-_bMinus;
}

inline void EventShapes::checkLinTen() {
  if (!_linTenDone) {
    _linTenDone = true;
    diagonalizeTensors(true, _useCmBoost); 
  }
}

inline void EventShapes::checkSphericity() {
  if (!_spherDone) {
    _spherDone = true;
    diagonalizeTensors(false, _useCmBoost); 
  }
}

inline void EventShapes::checkThrust() {
  if (!_thrustDone) {
    _thrustDone = true;
    calculateThrust(); 
  }
}

inline void EventShapes::checkHemispheres() {
  if (!_hemDone) {
    _hemDone = true;
    calcHemisphereMasses(); 
  }
}

inline double EventShapes::getXi(const Lorentz5Momentum & p, 
				 const Energy & Ebeam) {
  return((Ebeam > 0*MeV && p.vect().mag() > 0*MeV) ? 
	 log(Ebeam/p.vect().mag()) : -1.); 
}

inline Energy EventShapes::getPt(const Lorentz5Momentum & p) {
  return p.perp(); 
}

inline double EventShapes::getRapidity(const Lorentz5Momentum & p) {
  return (p.t() > p.z() ? p.rapidity() : 1e99); 
}

inline Energy EventShapes::ptInT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[1]; 
}

inline Energy EventShapes::ptOutT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[2]; 
}

inline double EventShapes::yT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return (p.t() > p.vect()*_thrustAxis[0] ? 
	  p.rapidity(_thrustAxis[0]) : 1e99);
}

inline Energy EventShapes::ptInS(const Lorentz5Momentum & p) { 
  checkSphericity(); 
  return p.vect()*_spherAxis[1]; 
}

inline Energy EventShapes::ptOutS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return p.vect()*_spherAxis[2]; 
}

inline double EventShapes::yS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return (p.t() > p.vect()*_spherAxis[0] ? 
	  p.rapidity(_spherAxis[0]) : 1e99);
}

inline void EventShapes::normalizeEEC(vector<double> & hi, long evts) {
  for (unsigned int bin = 0; bin < hi.size(); bin++) bin /= (hi.size()*evts);
}

inline double EventShapes::AEEC(vector<double> & hi, double& coschi) {
  if (coschi > 0. && coschi <= 1.) {
    int i = static_cast<int>( floor((-coschi+1.)/2.*hi.size()) ); 
    int j = static_cast<int>( floor(( coschi+1.)/2.*hi.size()) ); 
    return hi[i]-hi[j];
  } else {
    return 1e99;
  }
}
}
