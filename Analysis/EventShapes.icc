// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the EventShapes class.
//

namespace Herwig {

inline EventShapes::EventShapes() {}

inline EventShapes::EventShapes(const EventShapes & x)
  : Interfaced(x) {}

inline IBPtr EventShapes::clone() const {
  return new_ptr(*this);
}

inline IBPtr EventShapes::fullclone() const {
  return new_ptr(*this);
}

inline double EventShapes::thrust() {
  checkThrust(); 
  return _thrust[0];
}

inline double EventShapes::thrustMajor() {
  checkThrust(); 
  return _thrust[1];
}

inline double EventShapes::thrustMinor() {
  checkThrust(); 
  return _thrust[2];
}

inline double EventShapes::oblateness() {
  checkThrust(); 
  return _thrust[1]-_thrust[2];
}

inline Axis EventShapes::thrustAxis() {
  checkThrust(); 
  return _thrustAxis[0];
}

inline Axis EventShapes::majorAxis() {
  checkThrust(); 
  return _thrustAxis[1];
}

inline Axis EventShapes::minorAxis() {
  checkThrust(); 
  return _thrustAxis[2];
}

inline void EventShapes::reset(const tPVector &part)
{
  _pv.resize(part.size());
  for(unsigned int ix=0;ix<part.size();++ix) _pv[ix]=part[ix]->momentum();
  _thrustDone = false;
  _spherDone  = false;
  _linTenDone = false;
  _hemDone    = false;
  _useCmBoost = false; 
}

inline double EventShapes::sphericity() {
  checkSphericity(); 
  return 3./2.*(_spher[1]+_spher[2]); 
}

inline double EventShapes::aplanarity() {
  checkSphericity(); 
  return 3./2.*_spher[2];
}

inline double EventShapes::planarity() {
  checkSphericity(); 
  return _spher[1]-_spher[2]; 
}

inline Axis EventShapes::sphericityAxis() {
  checkSphericity(); 
  return _spherAxis[0]; 
}

inline vector<double> EventShapes::sphericityEigenValues() {
  checkSphericity(); 
  return _spher; 
}

inline vector<Axis> EventShapes::sphericityEigenVectors() {
  checkSphericity(); 
  return _spherAxis; 
}

inline vector<double> EventShapes::linTenEigenValues() {
  checkLinTen(); 
  return _linTen; 
}

inline vector<Axis> EventShapes::linTenEigenVectors() {
  checkLinTen(); 
  return _linTenAxis; 
}

inline double EventShapes::CParameter() {
  checkLinTen(); 
  return 3.*(_linTen[0]*_linTen[1]+_linTen[1]*_linTen[2]
	     +_linTen[2]*_linTen[0]); 
}

inline double EventShapes::DParameter() {
  checkLinTen(); 
  return 27.*(_linTen[0]*_linTen[1]*_linTen[2]); 
}

inline double EventShapes::Mhigh2() {
  checkHemispheres();
  return _mPlus; 
} 

inline double EventShapes::Mlow2() {
  checkHemispheres();
  return _mMinus; 
} 

inline double EventShapes::Mdiff2() {
  checkHemispheres();
  return _mPlus-_mMinus; 
} 

inline double EventShapes::Bmax() {
  checkHemispheres(); 
  return _bPlus;
}

inline double EventShapes::Bmin() {
  checkHemispheres(); 
  return _bMinus;
}

inline double EventShapes::Bsum() {
  checkHemispheres(); 
  return _bPlus+_bMinus;
}

inline double EventShapes::Bdiff() {
  checkHemispheres(); 
  return _bPlus-_bMinus;
}

inline void EventShapes::checkLinTen() {
  if (!_linTenDone) {
    _linTenDone = true;
    diagonalizeTensors(true, _useCmBoost); 
  }
}

inline void EventShapes::checkSphericity() {
  if (!_spherDone) {
    _spherDone = true;
    diagonalizeTensors(false, _useCmBoost); 
  }
}

inline void EventShapes::checkThrust() {
  if (!_thrustDone) {
    _thrustDone = true;
    calculateThrust(); 
  }
}

inline void EventShapes::checkHemispheres() {
  if (!_hemDone) {
    _hemDone = true;
    calcHemisphereMasses(); 
  }
}

inline void EventShapes::calcHemisphereMasses() {
  Lorentz5Momentum pos, neg;
  Energy pden(0.*MeV),epos(0.*MeV),eneg(0.*MeV);
  for(unsigned int ix=0;ix<_pv.size();++ix)
    {
      if(_pv[ix].vect() * thrustAxis() > 0.*MeV)
	{
	  pos  += _pv[ix];
	  epos += _pv[ix].perp(thrustAxis()); 
	}
      else
	{
	  neg  += _pv[ix];
	  eneg += _pv[ix].perp(thrustAxis()); 
	}
      pden += _pv[ix].vect().mag();	 
    }
  // denominator and masses
  Energy2 den(sqr(pos.e()+neg.e()));
  _mPlus = pos.m2()/den;
  _mMinus = neg.m2()/den;
  if (_mPlus < _mMinus) swap(_mPlus, _mMinus);
  // jet broadening
  _bPlus  = 0.5*epos/pden;
  _bMinus = 0.5*eneg/pden;
  if (_bPlus < _bMinus) swap(_bPlus, _bMinus);
}

inline double EventShapes::getX(const Lorentz5Momentum & p, 
				const Energy & Ebeam) {
  return(Ebeam > 0*MeV ? double(p.vect().mag()/Ebeam) : -1.); 
}

inline double EventShapes::getXi(const Lorentz5Momentum & p, 
				 const Energy & Ebeam) {
  return((Ebeam > 0*MeV && p.vect().mag() > 0*MeV) ? 
	 log(Ebeam/p.vect().mag()) : -1.); 
}

inline Energy EventShapes::getPt(const Lorentz5Momentum & p) {
  return p.perp(); 
}

inline double EventShapes::getRapidity(const Lorentz5Momentum & p) {
  return (p.t() > p.z() ? p.rapidity() : 1e99); 
}

inline Energy EventShapes::ptInT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[1]; 
}

inline Energy EventShapes::ptOutT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[2]; 
}

inline double EventShapes::yT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return (p.t() > p.vect()*_thrustAxis[0] ? 
	  p.rapidity(_thrustAxis[0]) : 1e99);
}

inline Energy EventShapes::ptInS(const Lorentz5Momentum & p) { 
  checkSphericity(); 
  return p.vect()*_spherAxis[1]; 
}

inline Energy EventShapes::ptOutS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return p.vect()*_spherAxis[2]; 
}

inline double EventShapes::yS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return (p.t() > p.vect()*_spherAxis[0] ? 
	  p.rapidity(_spherAxis[0]) : 1e99);
}

inline void EventShapes::normalizeEEC(vector<double> & hi, long evts) {
  for (unsigned int bin = 0; bin < hi.size(); bin++) bin /= (hi.size()*evts);
}

inline double EventShapes::AEEC(vector<double> & hi, double& coschi) {
  if (coschi > 0. && coschi <= 1.) {
    int i = static_cast<int>( floor((-coschi+1.)/2.*hi.size()) ); 
    int j = static_cast<int>( floor(( coschi+1.)/2.*hi.size()) ); 
    return hi[i]-hi[j];
  } else {
    return 1e99;
  }
}
}
