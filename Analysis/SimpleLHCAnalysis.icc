// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the SimpleLHCAnalysis class.
//

namespace Herwig {

inline SimpleLHCAnalysis::SimpleLHCAnalysis() :
  _ptZ(4,Histogram(0.,250.,250)), 
  _ptWp(4,Histogram(0.,250.,250)), 
  _ptWm(4,Histogram(0.,250.,250)), 
  _mZ(0.,250.,250), _mWp(0.,250.,250), _mWm(0.,250.,250), 
  _rapZ(-10.,10.,100),_rapWp(-10.,10.,100),_rapWm(-10.,10.,100) {}

inline SimpleLHCAnalysis::SimpleLHCAnalysis(const SimpleLHCAnalysis & x)
  : AnalysisHandler(x), _ptZ(x._ptZ), _ptWp(x._ptWp), _ptWm(x._ptWm),
    _mZ(x._mZ),_mWp(x._mWp),_mWm(x._mWm),
    _rapZ(x._rapZ),_rapWp(x._rapWp),_rapWm(x._rapWm) {}

inline IBPtr SimpleLHCAnalysis::clone() const {
  return new_ptr(*this);
}

inline IBPtr SimpleLHCAnalysis::fullclone() const {
  return new_ptr(*this);
}

inline void SimpleLHCAnalysis::doupdate() throw(UpdateException) {
  AnalysisHandler::doupdate();
  // First update base class.
  bool redo = touched();
  // redo if touched.
//  UpdateChecker::check(aDependentMember, redo);
  // Update referenced objects on which this depends redo is set to true
  // if the dependent object is touched.
//  for_each(ContainerOfDependencies, UpdateChecker(redo));
  // Update a container of references.
//  for_each(MapOfDependencies, UpdateMapChecker(redo));
  // Update a map of references.
  if ( !redo ) return;
  // return if nothing has been touched. Otherwise do the actual update.
//  touch()
  // Touch if anything has changed.
}

inline void SimpleLHCAnalysis::doinit() throw(InitException) {
  AnalysisHandler::doinit();
}

inline void SimpleLHCAnalysis::dofinish() {
  AnalysisHandler::dofinish();
  ofstream outfile("SimpleLHCAnalysis.top");
  string title;
  for(unsigned int ix=0;ix<4;++ix)
    {
      if(ix==0){title="pt of Z for all masses ";}
      else if(ix==1){title="pt of Z for mass 40-80 GeV";}
      else if(ix==2){title="pt of Z for mass 80-100 GeV";}
      else if(ix==3){title="pt of Z for mass 100- GeV";}
      _ptZ[ix].topdrawOutput(outfile,true,false,false,false,"BLACK",title);
      _ptZ[ix].topdrawOutput(outfile,true,false,false,true,"BLACK",title);
      if(ix==0){title="pt of Wp for all masses ";}
      else if(ix==1){title="pt of Wp for mass 40-80 GeV";}
      else if(ix==2){title="pt of Wp for mass 80-100 GeV";}
      else if(ix==3){title="pt of Wp for mass 100- GeV";}
      _ptWp[ix].topdrawOutput(outfile,true,false,false,false,"BLACK",title);
      _ptWp[ix].topdrawOutput(outfile,true,false,false,true,"BLACK",title);
      if(ix==0){title="pt of Wm for all masses ";}
      else if(ix==1){title="pt of Wm for mass 40-80 GeV";}
      else if(ix==2){title="pt of Wm for mass 80-100 GeV";}
      else if(ix==3){title="pt of Wm for mass 100- GeV";}
      _ptWm[ix].topdrawOutput(outfile,true,false,false,false,"BLACK",title);
      _ptWm[ix].topdrawOutput(outfile,true,false,false,true,"BLACK",title);
    }
  _mZ.topdrawOutput(outfile,true,false,false,false,"BLACK","Mass of Z");
  _mZ.topdrawOutput(outfile,true,false,false,true,"BLACK", "Mass of Z");
  _mWp.topdrawOutput(outfile,true,false,false,false,"BLACK","Mass of Wp");
  _mWp.topdrawOutput(outfile,true,false,false,true,"BLACK", "Mass of Wp");
  _mWm.topdrawOutput(outfile,true,false,false,false,"BLACK","Mass of Wm");
  _mWm.topdrawOutput(outfile,true,false,false,true,"BLACK", "Mass of Wm");
  _rapZ.topdrawOutput(outfile,true,false,false,false,"BLACK","Rapidity of Z");
  _rapZ.topdrawOutput(outfile,true,false,false,true,"BLACK","Rapidity of Z");
  _rapWp.topdrawOutput(outfile,true,false,false,false,"BLACK","Rapidity of Wp");
  _rapWp.topdrawOutput(outfile,true,false,false,true,"BLACK","Rapidity of Wp");
  _rapWm.topdrawOutput(outfile,true,false,false,false,"BLACK","Rapidity of Wm");
  _rapWm.topdrawOutput(outfile,true,false,false,true,"BLACK","Rapidity of Wm");}

inline void SimpleLHCAnalysis::doinitrun() {
  AnalysisHandler::doinitrun();
}

inline void SimpleLHCAnalysis::rebind(const TranslationMap & trans)
  throw(RebindException) {
  // dummy = trans.translate(dummy);
  AnalysisHandler::rebind(trans);
}

inline IVector SimpleLHCAnalysis::getReferences() {
  IVector ret = AnalysisHandler::getReferences();
  // ret.push_back(dummy);
  return ret;
}

}
