#! /usr/bin/env python
import logging
import sys

if sys.version_info[:3] < (2,4,0):
    print "rivet scripts require Python version >= 2.4.0... exiting"
    sys.exit(1)

import os, yoda

# #############################################

def fillAbove(desthisto, sourcehistosbyptmin):
    pthigh= 1e100
    ptlow =-1e100
    for pt, h in sorted(sourcehistosbyptmin.iteritems(),reverse=True):
        ptlow=pt
        if(type(desthisto)==yoda.core.Scatter2D) :
            for i in range(0,h.numPoints) :
                xMin = h.points[i].x-h.points[i].xErrs.minus
                if( xMin >= ptlow and 
                    xMin <  pthigh ) :
                    desthisto.addPoint(h.points[i])
        elif(type(desthisto)==yoda.core.Profile1D) :
            for i in range(0,h.numBins) :
                if(h.bins[i].xMin  >= ptlow and 
                   h.bins[i].xMin  <  pthigh ) :
                    desthisto.bins[i] += h.bins[i]
        elif(type(desthisto)==yoda.core.Histo1D) :
            for i in range(0,h.numBins) :
                if(h.bins[i].xMin  >= ptlow and 
                   h.bins[i].xMin  <  pthigh ) :
                    desthisto.bins[i] += h.bins[i]
        else :
            logging.error("Can't merge %s, unknown type" % desthisto.path)
            sys.exit(1)
        pthigh=pt

def mergeByPt(hpath, sqrts):
    global inhistos
    global outhistos
    try:
        fillAbove(outhistos[hpath], inhistos[hpath][float(sqrts)])
    except:
        pass

def useOnePt(hpath, sqrts, ptmin):
    global inhistos
    global outhistos
    try:
       ## Find best pT_min match
        ptmins = inhistos[hpath][float(sqrts)].keys()
        closest_ptmin = None
        for ptm in ptmins:
            if closest_ptmin is None or \
                    abs(ptm-float(ptmin)) < abs(closest_ptmin-float(ptmin)):
                closest_ptmin = ptm
        if closest_ptmin != float(ptmin):
            logging.warning("Inexact match for requested pTmin=%s: " % ptmin + \
                                "using pTmin=%e instead" % closest_ptmin)
        outhistos[hpath] =  inhistos[hpath][float(sqrts)][closest_ptmin]
    except:
        pass

# #######################################

if __name__ == "__main__":
    import logging
    from optparse import OptionParser, OptionGroup
    parser = OptionParser(usage="%prog name")
    verbgroup = OptionGroup(parser, "Verbosity control")
    verbgroup.add_option("-v", "--verbose", action="store_const", const=logging.DEBUG, dest="LOGLEVEL",
                         default=logging.INFO, help="print debug (very verbose) messages")
    verbgroup.add_option("-q", "--quiet", action="store_const", const=logging.WARNING, dest="LOGLEVEL",
                         default=logging.INFO, help="be very quiet")
    parser.add_option_group(verbgroup)
    (opts, args) = parser.parse_args()
    logging.basicConfig(level=opts.LOGLEVEL, format="%(message)s")

    ## Check args
    if len(args) < 1:
        logging.error("Must specify at least the name of the files")
        sys.exit(1)

yodafiles=["-UE.yoda","-Jets-1.yoda","-Jets-2.yoda","-Jets-3.yoda","-Jets-4.yoda"]

## Get histos
inhistos = {}
outhistos={}
weights = {}
for f in yodafiles:
    file=args[0]+f
    if(file.find("-UE")>0) :
        sqrts=200
        ptmin=0.
    elif(file.find("-Jets-1")>0) :
        sqrts=200
        ptmin=2.
    elif(file.find("-Jets-2")>0) :
        sqrts=200
        ptmin=5.
    elif(file.find("-Jets-3")>0) :
        sqrts=200
        ptmin=26.
    elif(file.find("-Jets-4")>0) :
        sqrts=200
        ptmin=15.

    if not os.access(file, os.R_OK):
        logging.error("%s can not be read" % file)
        break
    try:
        aos = yoda.read(file)
    except:
        logging.error("%s can not be parsed as YODA" % file)
        break
    ## Get histos from this YODA file
    for aopath, ao in aos.iteritems() :
        if(aopath.find("6870392")>0 or aopath.find("HELEN")>0) :
            if not inhistos.has_key(aopath):
                inhistos[aopath] = {}
            tmpE = inhistos[aopath]
            if not tmpE.has_key(sqrts):
                tmpE[sqrts] = {}
            tmpP = tmpE[sqrts]
            if not tmpP.has_key(ptmin):
                tmpP[ptmin] = ao
            else:
                raise Exception("A set with ptmin = %s already exists" % ( ptmin))
        else :
            outhistos[aopath] = ao

## Make empty output histos if needed
for hpath,hsets in inhistos.iteritems():
    if( (hpath.find("6870392")>0 and hpath.find("d02-x01-y01" )>0 ) or
        hpath.find("HELEN")>0 ) :
        if(type(hsets.values()[0].values()[0])==yoda.core.Scatter2D) :
            outhistos[hpath] = yoda.core.Scatter2D(hsets.values()[0].values()[0].path,
                                                   hsets.values()[0].values()[0].title)
        elif(type(hsets.values()[0].values()[0])==yoda.core.Profile1D) :
            outhistos[hpath] = yoda.core.Profile1D(hsets.values()[0].values()[0].path,
                                                   hsets.values()[0].values()[0].title)
            for i in range(0,hsets.values()[0].values()[0].numBins) :
                outhistos[hpath].addBin(hsets.values()[0].values()[0].bins[i].xMin,
                                        hsets.values()[0].values()[0].bins[i].xMax)
        elif(type(hsets.values()[0].values()[0])==yoda.core.Histo1D) :
            outhistos[hpath] = yoda.core.Histo1D(hsets.values()[0].values()[0].path,
                                                hsets.values()[0].values()[0].title)
            for i in range(0,hsets.values()[0].values()[0].numBins) :
                outhistos[hpath].addBin(hsets.values()[0].values()[0].bins[i].xMin,
                                        hsets.values()[0].values()[0].bins[i].xMax)
        else :
            logging.error("Histogram %s is of unknown type" % hpath)
            print hpath,type(hsets.values()[0].values()[0])
            sys.exit(1)

useOnePt("/STAR_2006_S6870392/d01-x01-y01","200","2")
mergeByPt("/STAR_2006_S6870392/d02-x01-y01","200")
mergeByPt("/STAR_2009_UE_HELEN/d01-x01-y01","200")
mergeByPt("/STAR_2009_UE_HELEN/d02-x01-y01","200")
mergeByPt("/STAR_2009_UE_HELEN/d03-x01-y01","200")

# Choose output file
name = args[0]+".yoda"
print "write to ",name
yoda.writeYODA(outhistos,name)
sys.exit(0)
