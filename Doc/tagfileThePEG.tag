<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>
<tagfile>
  <compound kind="page">
    <name>index</name>
    <title>T&lt;small&gt;HE&lt;/small&gt;PEG Reference Manual</title>
    <filename>index</filename>
    <docanchor file="index">ThePEGIntroduction</docanchor>
  </compound>
  <compound kind="file">
    <name>ACDCGenConfig.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/ACDC/</path>
    <filename>ACDCGenConfig_8h</filename>
    <namespace>ACDCGenerator</namespace>
    <member kind="typedef">
      <type>short</type>
      <name>DimType</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>algorithm.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</path>
    <filename>algorithm_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes" imported="no">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::IteratorRange</class>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::iterator &gt;</type>
      <name>range</name>
      <anchor>a330</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_iterator &gt;</type>
      <name>range</name>
      <anchor>a331</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a332</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a333</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a334</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find</name>
      <anchor>a335</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find_if</name>
      <anchor>a336</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, Pred p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a337</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a338</anchor>
      <arglist>(Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a339</anchor>
      <arglist>(const Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find</name>
      <anchor>a340</anchor>
      <arglist>(Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find</name>
      <anchor>a341</anchor>
      <arglist>(const Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find_if</name>
      <anchor>a342</anchor>
      <arglist>(Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find_if</name>
      <anchor>a343</anchor>
      <arglist>(const Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a344</anchor>
      <arglist>(Cont &amp;c, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>Containers.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</path>
    <filename>Containers_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a345</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a346</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a347</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a348</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a349</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a350</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>set&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a351</anchor>
      <arglist>(set&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a352</anchor>
      <arglist>(OStream &amp;os, const vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a353</anchor>
      <arglist>(IStream &amp;is, vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a354</anchor>
      <arglist>(OStream &amp;os, const set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a355</anchor>
      <arglist>(IStream &amp;is, set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a356</anchor>
      <arglist>(OStream &amp;os, const map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a357</anchor>
      <arglist>(IStream &amp;is, map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PDPtr, less&lt; PDPtr &gt;, Allocator&lt; PDPtr &gt; &gt;</type>
      <name>ParticleDataSet</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PDPtr &gt;</type>
      <name>PDVector</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPDPtr &gt;</type>
      <name>cPDVector</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPtr &gt;</type>
      <name>tPDVector</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPDPtr &gt;</type>
      <name>tcPDVector</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PMPtr, less&lt; PMPtr &gt;, Allocator&lt; PMPtr &gt; &gt;</type>
      <name>MatcherSet</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; DMPtr, less&lt; DMPtr &gt;, Allocator&lt; DMPtr &gt; &gt;</type>
      <name>DecayModeSet</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>ObjectSet</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>DependencySet</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; long, PDPtr, less&lt; long &gt;, Allocator&lt; std::pair&lt; long const, PDPtr &gt; &gt; &gt;</type>
      <name>ParticleMap</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, IBPtr, less&lt; string &gt;, Allocator&lt; std::pair&lt; string const, IBPtr &gt; &gt; &gt;</type>
      <name>ObjectMap</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; IBPtr, DependencySet, less&lt; IBPtr &gt;, Allocator&lt; std::pair&lt; IBPtr const, DependencySet &gt; &gt; &gt;</type>
      <name>DependencyMap</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; IBPtr &gt;</type>
      <name>IVector</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cIBPtr &gt;</type>
      <name>CIVector</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>ParticleVector</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>PVector</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPPtr &gt;</type>
      <name>cPVector</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tPVector</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPPtr &gt;</type>
      <name>tcPVector</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, const InterfaceBase *, less&lt; string &gt;, Allocator&lt; std::pair&lt; string const, const InterfaceBase * &gt; &gt; &gt;</type>
      <name>InterfaceMap</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; InterfacedBase &gt;</type>
      <name>TranslationMap</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, EGPtr, less&lt; string &gt;, Allocator&lt; std::pair&lt; string const, EGPtr &gt; &gt; &gt;</type>
      <name>GeneratorMap</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; AnaPtr &gt;</type>
      <name>AnalysisVector</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PDPtr, PDPtr &gt;</type>
      <name>PDPair</name>
      <anchor>a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPDPtr, cPDPtr &gt;</type>
      <name>cPDPair</name>
      <anchor>a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPDPtr, tPDPtr &gt;</type>
      <name>tPDPair</name>
      <anchor>a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPDPtr, tcPDPtr &gt;</type>
      <name>tcPDPair</name>
      <anchor>a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PPtr, PPtr &gt;</type>
      <name>PPair</name>
      <anchor>a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPPtr, cPPtr &gt;</type>
      <name>cPPair</name>
      <anchor>a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPPtr, tPPtr &gt;</type>
      <name>tPPair</name>
      <anchor>a34</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPPtr, tcPPtr &gt;</type>
      <name>tcPPair</name>
      <anchor>a35</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Interval&lt; Energy2 &gt;</type>
      <name>SInterval</name>
      <anchor>a36</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SInterval &gt;</type>
      <name>SIntervalVector</name>
      <anchor>a37</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPair &gt;</type>
      <name>tPartonPairVec</name>
      <anchor>a38</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tColinePtr, tColinePtr &gt;</type>
      <name>tColinePair</name>
      <anchor>a39</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tDMPtr, less&lt; tDMPtr &gt;, Allocator&lt; tDMPtr &gt; &gt;</type>
      <name>DecaySet</name>
      <anchor>a40</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; string, less&lt; string &gt;, Allocator&lt; string &gt; &gt;</type>
      <name>StringSet</name>
      <anchor>a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Energy &gt;</type>
      <name>EnergyVector</name>
      <anchor>a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; EIPtr &gt;</type>
      <name>EIVector</name>
      <anchor>a43</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a44</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; double, double &gt;</type>
      <name>DPair</name>
      <anchor>a45</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>EventConfig.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/EventRecord/</path>
    <filename>EventConfig_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes" imported="no">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::EventConfig</class>
    <member kind="typedef">
      <type>Base</type>
      <name>EventRecordBase</name>
      <anchor>a195</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::pointer</type>
      <name>EventBasePtr</name>
      <anchor>a196</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::const_pointer</type>
      <name>cEventBasePtr</name>
      <anchor>a197</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_pointer</type>
      <name>tEventBasePtr</name>
      <anchor>a198</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_const_pointer</type>
      <name>tcEventBasePtr</name>
      <anchor>a199</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; EventRecordBase &gt;</type>
      <name>EventTranslationMap</name>
      <anchor>a200</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle</type>
      <name>ParticleClass</name>
      <anchor>a201</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>ParticleDataClass</name>
      <anchor>a202</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::pointer</type>
      <name>EventPDPtr</name>
      <anchor>a203</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::const_pointer</type>
      <name>cEventPDPtr</name>
      <anchor>a204</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_pointer</type>
      <name>tEventPDPtr</name>
      <anchor>a205</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_const_pointer</type>
      <name>tcEventPDPtr</name>
      <anchor>a206</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tParticleVector</name>
      <anchor>a207</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PPtr, less&lt; PPtr &gt;, Allocator&lt; PPtr &gt; &gt;</type>
      <name>ParticleSet</name>
      <anchor>a208</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tPPtr, less&lt; tPPtr &gt;, Allocator&lt; tPPtr &gt; &gt;</type>
      <name>tParticleSet</name>
      <anchor>a209</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tcPPtr, less&lt; tcPPtr &gt;, Allocator&lt; tcPPtr &gt; &gt;</type>
      <name>tcParticleSet</name>
      <anchor>a210</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepPtr &gt;</type>
      <name>StepVector</name>
      <anchor>a211</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SubProPtr &gt;</type>
      <name>SubProcessVector</name>
      <anchor>a212</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tSubProPtr &gt;</type>
      <name>tSubProcessVector</name>
      <anchor>a213</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; CollPtr &gt;</type>
      <name>CollisionVector</name>
      <anchor>a214</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; StepPtr, less&lt; StepPtr &gt;, Allocator&lt; StepPtr &gt; &gt;</type>
      <name>StepSet</name>
      <anchor>a215</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; SubProPtr, less&lt; SubProPtr &gt;, Allocator&lt; SubProPtr &gt; &gt;</type>
      <name>SubProcessSet</name>
      <anchor>a216</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>HelicityDefinitions.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Helicity/</path>
    <filename>HelicityDefinitions_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes" imported="no">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <namespace>ThePEG::Helicity</namespace>
    <class kind="class">ThePEG::Helicity::HelicityLogicalError</class>
    <class kind="class">ThePEG::Helicity::HelicityConsistencyError</class>
    <member kind="enumeration">
      <name>DiracRep</name>
      <anchor>a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HELASDRep</name>
      <anchor>a45a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HaberDRep</name>
      <anchor>a45a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>defaultDRep</name>
      <anchor>a45a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>SpinorType</name>
      <anchor>a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>u_spinortype</name>
      <anchor>a46a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>v_spinortype</name>
      <anchor>a46a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown_spinortype</name>
      <anchor>a46a9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>JamesRandom.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>JamesRandom_8h</filename>
  </compound>
  <compound kind="file">
    <name>LorentzVector.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>LorentzVector_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="function">
      <type>double</type>
      <name>dirPlus</name>
      <anchor>a312</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirMinus</name>
      <anchor>a313</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirZ</name>
      <anchor>a314</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirTheta</name>
      <anchor>a315</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirCosTheta</name>
      <anchor>a316</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Vector3</type>
      <name>dirBoostVector</name>
      <anchor>a317</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a318</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a319</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a320</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a321</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a322</anchor>
      <arglist>(OStream &amp;os, const LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a323</anchor>
      <arglist>(IStream &amp;is, LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>Matrix.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>Matrix_8h</filename>
  </compound>
  <compound kind="file">
    <name>PhysicalConstants.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>PhysicalConstants_8h</filename>
  </compound>
  <compound kind="file">
    <name>Pointers.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</path>
    <filename>Pointers_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes" imported="no">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_TEMPLATE_POINTERS</name>
      <anchor>a0</anchor>
      <arglist>(full, abbrev)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_POINTERS</name>
      <anchor>a1</anchor>
      <arglist>(full, abbrev)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_CLASS_POINTERS</name>
      <anchor>a2</anchor>
      <arglist>(full, abbrev)</arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::pointer</type>
      <name>IBPtr</name>
      <anchor>a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::const_pointer</type>
      <name>cIBPtr</name>
      <anchor>a47</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_pointer</type>
      <name>tIBPtr</name>
      <anchor>a48</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_const_pointer</type>
      <name>tcIBPtr</name>
      <anchor>a49</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::pointer</type>
      <name>IPtr</name>
      <anchor>a50</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::const_pointer</type>
      <name>cIPtr</name>
      <anchor>a51</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_pointer</type>
      <name>tIPtr</name>
      <anchor>a52</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_const_pointer</type>
      <name>tcIPtr</name>
      <anchor>a53</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::pointer</type>
      <name>PDPtr</name>
      <anchor>a54</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::const_pointer</type>
      <name>cPDPtr</name>
      <anchor>a55</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_pointer</type>
      <name>tPDPtr</name>
      <anchor>a56</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_const_pointer</type>
      <name>tcPDPtr</name>
      <anchor>a57</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::pointer</type>
      <name>PMPtr</name>
      <anchor>a58</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::const_pointer</type>
      <name>cPMPtr</name>
      <anchor>a59</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_pointer</type>
      <name>tPMPtr</name>
      <anchor>a60</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_const_pointer</type>
      <name>tcPMPtr</name>
      <anchor>a61</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::pointer</type>
      <name>DMPtr</name>
      <anchor>a62</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::const_pointer</type>
      <name>cDMPtr</name>
      <anchor>a63</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_pointer</type>
      <name>tDMPtr</name>
      <anchor>a64</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_const_pointer</type>
      <name>tcDMPtr</name>
      <anchor>a65</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::pointer</type>
      <name>PPtr</name>
      <anchor>a66</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::const_pointer</type>
      <name>cPPtr</name>
      <anchor>a67</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_pointer</type>
      <name>tPPtr</name>
      <anchor>a68</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_const_pointer</type>
      <name>tcPPtr</name>
      <anchor>a69</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::pointer</type>
      <name>EGPtr</name>
      <anchor>a70</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::const_pointer</type>
      <name>cEGPtr</name>
      <anchor>a71</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_pointer</type>
      <name>tEGPtr</name>
      <anchor>a72</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_const_pointer</type>
      <name>tcEGPtr</name>
      <anchor>a73</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::pointer</type>
      <name>EHPtr</name>
      <anchor>a74</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::const_pointer</type>
      <name>cEHPtr</name>
      <anchor>a75</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_pointer</type>
      <name>tEHPtr</name>
      <anchor>a76</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_const_pointer</type>
      <name>tcEHPtr</name>
      <anchor>a77</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::pointer</type>
      <name>StepHdlPtr</name>
      <anchor>a78</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::const_pointer</type>
      <name>cStepHdlPtr</name>
      <anchor>a79</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_pointer</type>
      <name>tStepHdlPtr</name>
      <anchor>a80</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_const_pointer</type>
      <name>tcStepHdlPtr</name>
      <anchor>a81</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::pointer</type>
      <name>HintPtr</name>
      <anchor>a82</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::const_pointer</type>
      <name>cHintPtr</name>
      <anchor>a83</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_pointer</type>
      <name>tHintPtr</name>
      <anchor>a84</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_const_pointer</type>
      <name>tcHintPtr</name>
      <anchor>a85</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::pointer</type>
      <name>HadrHdlPtr</name>
      <anchor>a86</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::const_pointer</type>
      <name>cHadrHdlPtr</name>
      <anchor>a87</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_pointer</type>
      <name>tHadrHdlPtr</name>
      <anchor>a88</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_const_pointer</type>
      <name>tcHadrHdlPtr</name>
      <anchor>a89</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::pointer</type>
      <name>CascHdlPtr</name>
      <anchor>a90</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::const_pointer</type>
      <name>cCascHdlPtr</name>
      <anchor>a91</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_pointer</type>
      <name>tCascHdlPtr</name>
      <anchor>a92</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_const_pointer</type>
      <name>tcCascHdlPtr</name>
      <anchor>a93</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::pointer</type>
      <name>MIHdlPtr</name>
      <anchor>a94</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::const_pointer</type>
      <name>cMIHdlPtr</name>
      <anchor>a95</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_pointer</type>
      <name>tMIHdlPtr</name>
      <anchor>a96</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_const_pointer</type>
      <name>tcMIHdlPtr</name>
      <anchor>a97</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::pointer</type>
      <name>DecayHdlPtr</name>
      <anchor>a98</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::const_pointer</type>
      <name>cDecayHdlPtr</name>
      <anchor>a99</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_pointer</type>
      <name>tDecayHdlPtr</name>
      <anchor>a100</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_const_pointer</type>
      <name>tcDecayHdlPtr</name>
      <anchor>a101</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::pointer</type>
      <name>PileHdlPtr</name>
      <anchor>a102</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::const_pointer</type>
      <name>cPileHdlPtr</name>
      <anchor>a103</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_pointer</type>
      <name>tPileHdlPtr</name>
      <anchor>a104</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_const_pointer</type>
      <name>tcPileHdlPtr</name>
      <anchor>a105</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::pointer</type>
      <name>LumiFnPtr</name>
      <anchor>a106</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::const_pointer</type>
      <name>cLumiFnPtr</name>
      <anchor>a107</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_pointer</type>
      <name>tLumiFnPtr</name>
      <anchor>a108</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_const_pointer</type>
      <name>tcLumiFnPtr</name>
      <anchor>a109</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::pointer</type>
      <name>KinCutPtr</name>
      <anchor>a110</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::const_pointer</type>
      <name>cKinCutPtr</name>
      <anchor>a111</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_pointer</type>
      <name>tKinCutPtr</name>
      <anchor>a112</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_const_pointer</type>
      <name>tcKinCutPtr</name>
      <anchor>a113</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::pointer</type>
      <name>PExtrPtr</name>
      <anchor>a114</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::const_pointer</type>
      <name>cPExtrPtr</name>
      <anchor>a115</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_pointer</type>
      <name>tPExtrPtr</name>
      <anchor>a116</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_const_pointer</type>
      <name>tcPExtrPtr</name>
      <anchor>a117</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::pointer</type>
      <name>RanGenPtr</name>
      <anchor>a118</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::const_pointer</type>
      <name>cRanGenPtr</name>
      <anchor>a119</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_pointer</type>
      <name>tRanGenPtr</name>
      <anchor>a120</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_const_pointer</type>
      <name>tcRanGenPtr</name>
      <anchor>a121</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::pointer</type>
      <name>AnaPtr</name>
      <anchor>a122</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::const_pointer</type>
      <name>cAnaPtr</name>
      <anchor>a123</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_pointer</type>
      <name>tAnaPtr</name>
      <anchor>a124</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_const_pointer</type>
      <name>tcAnaPtr</name>
      <anchor>a125</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::pointer</type>
      <name>EvtManipPtr</name>
      <anchor>a126</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::const_pointer</type>
      <name>cEvtManipPtr</name>
      <anchor>a127</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_pointer</type>
      <name>tEvtManipPtr</name>
      <anchor>a128</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_const_pointer</type>
      <name>tcEvtManipPtr</name>
      <anchor>a129</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::pointer</type>
      <name>DecayerPtr</name>
      <anchor>a130</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::const_pointer</type>
      <name>cDecayerPtr</name>
      <anchor>a131</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_pointer</type>
      <name>tDecayerPtr</name>
      <anchor>a132</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_const_pointer</type>
      <name>tcDecayerPtr</name>
      <anchor>a133</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::pointer</type>
      <name>EventPtr</name>
      <anchor>a134</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::const_pointer</type>
      <name>cEventPtr</name>
      <anchor>a135</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_pointer</type>
      <name>tEventPtr</name>
      <anchor>a136</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_const_pointer</type>
      <name>tcEventPtr</name>
      <anchor>a137</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::pointer</type>
      <name>CollPtr</name>
      <anchor>a138</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::const_pointer</type>
      <name>cCollPtr</name>
      <anchor>a139</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_pointer</type>
      <name>tCollPtr</name>
      <anchor>a140</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_const_pointer</type>
      <name>tcCollPtr</name>
      <anchor>a141</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::pointer</type>
      <name>StepPtr</name>
      <anchor>a142</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::const_pointer</type>
      <name>cStepPtr</name>
      <anchor>a143</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_pointer</type>
      <name>tStepPtr</name>
      <anchor>a144</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_const_pointer</type>
      <name>tcStepPtr</name>
      <anchor>a145</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::pointer</type>
      <name>SubProPtr</name>
      <anchor>a146</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::const_pointer</type>
      <name>cSubProPtr</name>
      <anchor>a147</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_pointer</type>
      <name>tSubProPtr</name>
      <anchor>a148</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_const_pointer</type>
      <name>tcSubProPtr</name>
      <anchor>a149</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::pointer</type>
      <name>StrategyPtr</name>
      <anchor>a150</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::const_pointer</type>
      <name>cStrategyPtr</name>
      <anchor>a151</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_pointer</type>
      <name>tStrategyPtr</name>
      <anchor>a152</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_const_pointer</type>
      <name>tcStrategyPtr</name>
      <anchor>a153</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::pointer</type>
      <name>XCombPtr</name>
      <anchor>a154</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::const_pointer</type>
      <name>cXCombPtr</name>
      <anchor>a155</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_pointer</type>
      <name>tXCombPtr</name>
      <anchor>a156</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_const_pointer</type>
      <name>tcXCombPtr</name>
      <anchor>a157</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::pointer</type>
      <name>RemHPtr</name>
      <anchor>a158</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::const_pointer</type>
      <name>cRemHPtr</name>
      <anchor>a159</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_pointer</type>
      <name>tRemHPtr</name>
      <anchor>a160</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_const_pointer</type>
      <name>tcRemHPtr</name>
      <anchor>a161</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::pointer</type>
      <name>PDFPtr</name>
      <anchor>a162</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::const_pointer</type>
      <name>cPDFPtr</name>
      <anchor>a163</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_pointer</type>
      <name>tPDFPtr</name>
      <anchor>a164</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_const_pointer</type>
      <name>tcPDFPtr</name>
      <anchor>a165</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::pointer</type>
      <name>SMPtr</name>
      <anchor>a166</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::const_pointer</type>
      <name>cSMPtr</name>
      <anchor>a167</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_pointer</type>
      <name>tSMPtr</name>
      <anchor>a168</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_const_pointer</type>
      <name>tcSMPtr</name>
      <anchor>a169</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::pointer</type>
      <name>CBPtr</name>
      <anchor>a170</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::const_pointer</type>
      <name>cCBPtr</name>
      <anchor>a171</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_pointer</type>
      <name>tCBPtr</name>
      <anchor>a172</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_const_pointer</type>
      <name>tcCBPtr</name>
      <anchor>a173</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::pointer</type>
      <name>SpinPtr</name>
      <anchor>a174</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::const_pointer</type>
      <name>cSpinPtr</name>
      <anchor>a175</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_pointer</type>
      <name>tSpinPtr</name>
      <anchor>a176</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_const_pointer</type>
      <name>tcSpinPtr</name>
      <anchor>a177</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::pointer</type>
      <name>EIPtr</name>
      <anchor>a178</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::const_pointer</type>
      <name>cEIPtr</name>
      <anchor>a179</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_pointer</type>
      <name>tEIPtr</name>
      <anchor>a180</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_const_pointer</type>
      <name>tcEIPtr</name>
      <anchor>a181</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::pointer</type>
      <name>ReweightPtr</name>
      <anchor>a182</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::const_pointer</type>
      <name>cReweightPtr</name>
      <anchor>a183</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_pointer</type>
      <name>tReweightPtr</name>
      <anchor>a184</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_const_pointer</type>
      <name>tcReweightPtr</name>
      <anchor>a185</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::pointer</type>
      <name>ColinePtr</name>
      <anchor>a186</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::const_pointer</type>
      <name>cColinePtr</name>
      <anchor>a187</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_pointer</type>
      <name>tColinePtr</name>
      <anchor>a188</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_const_pointer</type>
      <name>tcColinePtr</name>
      <anchor>a189</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>a190</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>a191</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>a192</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>a193</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RandBreitWigner.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandBreitWigner_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandExponential.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandExponential_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandomEngine.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandomEngine_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandPoisson.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandPoisson_8h</filename>
  </compound>
  <compound kind="file">
    <name>Rotation.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>Rotation_8h</filename>
  </compound>
  <compound kind="file">
    <name>SpinOneLorentzRotation.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>SpinOneLorentzRotation_8h</filename>
  </compound>
  <compound kind="file">
    <name>sstream.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Utilities/</path>
    <filename>sstream_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes" imported="no">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
  </compound>
  <compound kind="file">
    <name>StandardMatchers.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/PDT/</path>
    <filename>StandardMatchers_8h</filename>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::AnyMatcher</class>
    <class kind="struct">ThePEG::ChargedMatcher</class>
    <class kind="struct">ThePEG::PositiveMatcher</class>
    <class kind="struct">ThePEG::NeutralMatcher</class>
    <class kind="struct">ThePEG::NegativeMatcher</class>
    <class kind="struct">ThePEG::BaryonMatcher</class>
    <class kind="struct">ThePEG::MesonMatcher</class>
    <class kind="struct">ThePEG::DiquarkMatcher</class>
    <class kind="struct">ThePEG::QuarkMatcher</class>
    <class kind="struct">ThePEG::LeptonMatcher</class>
    <class kind="struct">ThePEG::LightQuarkMatcher</class>
    <class kind="struct">ThePEG::LightAntiQuarkMatcher</class>
    <class kind="struct">ThePEG::StandardQCDPartonMatcher</class>
    <class kind="struct">ThePEG::PseudoScalarMesonMatcher</class>
    <class kind="struct">ThePEG::VectorMesonMatcher</class>
    <member kind="typedef">
      <type>Matcher&lt; AnyMatcher &gt;</type>
      <name>MatchAny</name>
      <anchor>a286</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; ChargedMatcher &gt;</type>
      <name>MatchCharged</name>
      <anchor>a287</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PositiveMatcher &gt;</type>
      <name>MatchPositive</name>
      <anchor>a288</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NeutralMatcher &gt;</type>
      <name>MatchNeutral</name>
      <anchor>a289</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NegativeMatcher &gt;</type>
      <name>MatchNegative</name>
      <anchor>a290</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; BaryonMatcher &gt;</type>
      <name>MatchBaryon</name>
      <anchor>a291</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; MesonMatcher &gt;</type>
      <name>MatchMeson</name>
      <anchor>a292</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; DiquarkMatcher &gt;</type>
      <name>MatchDiquark</name>
      <anchor>a293</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; QuarkMatcher &gt;</type>
      <name>MatchQuark</name>
      <anchor>a294</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LeptonMatcher &gt;</type>
      <name>MatchLepton</name>
      <anchor>a295</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightQuarkMatcher &gt;</type>
      <name>MatchLightQuark</name>
      <anchor>a296</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightAntiQuarkMatcher &gt;</type>
      <name>MatchLightAntiQuark</name>
      <anchor>a297</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; StandardQCDPartonMatcher &gt;</type>
      <name>MatchStandardQCDParton</name>
      <anchor>a298</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PseudoScalarMesonMatcher &gt;</type>
      <name>MatchPseudoScalarMeson</name>
      <anchor>a299</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; VectorMesonMatcher &gt;</type>
      <name>MatchVectorMeson</name>
      <anchor>a300</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>StandardSelectors.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/EventRecord/</path>
    <filename>StandardSelectors_8h</filename>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::AllSelector</class>
    <class kind="struct">ThePEG::FinalStateSelector</class>
    <class kind="struct">ThePEG::IntermediateSelector</class>
    <class kind="struct">ThePEG::PrimaryCollisionSelector</class>
    <class kind="struct">ThePEG::ChargedSelector</class>
    <member kind="typedef">
      <type>ParticleSelector&lt; AllSelector &gt;</type>
      <name>SelectAll</name>
      <anchor>a217</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; FinalStateSelector &gt;</type>
      <name>SelectFinalState</name>
      <anchor>a218</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; PrimaryCollisionSelector &gt;</type>
      <name>SelectPrimaryCollision</name>
      <anchor>a219</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; ChargedSelector &gt;</type>
      <name>SelectCharged</name>
      <anchor>a220</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>std.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</path>
    <filename>std_8h</filename>
    <namespace>ThePEG</namespace>
    <class kind="struct">std::less&lt; const type_info * &gt;</class>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_SET</name>
      <anchor>a0</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_MULTISET</name>
      <anchor>a1</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_MAP</name>
      <anchor>a2</anchor>
      <arglist>(KEYTYPE, VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_IMPLEMENT_SET</name>
      <anchor>a3</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_IMPLEMENT_MULTISET</name>
      <anchor>a4</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_IMPLEMENT_MAP</name>
      <anchor>a5</anchor>
      <arglist>(KEYTYPE, VALTYPE, NAME)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a358</anchor>
      <arglist>(const Container &amp;c, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a359</anchor>
      <arglist>(const vector&lt; T &gt; &amp;v, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>std::insert_iterator&lt; Cont &gt;</type>
      <name>inserter</name>
      <anchor>a360</anchor>
      <arglist>(Cont &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>left</name>
      <anchor>a361</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>right</name>
      <anchor>a362</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>SystemOfUnits.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>SystemOfUnits_8h</filename>
  </compound>
  <compound kind="file">
    <name>ThePEG.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</path>
    <filename>ThePEG_8h</filename>
    <includes id="std_8h" name="std.h" local="yes" imported="no">std.h</includes>
    <includes id="Pointers_8h" name="Pointers.h" local="yes" imported="no">Pointers.h</includes>
    <includes id="Containers_8h" name="Containers.h" local="yes" imported="no">Containers.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::Base</class>
    <class kind="struct">ThePEG::TraitsType</class>
    <class kind="struct">ThePEG::Veto</class>
    <class kind="struct">ThePEG::Stop</class>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_THROW_SPEC</name>
      <anchor>a0</anchor>
      <arglist>(classes)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DEBUG_LEVEL</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DEBUG_ITEM</name>
      <anchor>a2</anchor>
      <arglist>(item)</arglist>
    </member>
    <member kind="typedef">
      <type>Base</type>
      <name>PersistentBase</name>
      <anchor>a194</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>MultiplicationTraits&lt; T &gt;::ResultType</type>
      <name>sqr</name>
      <anchor>a363</anchor>
      <arglist>(const T &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>abs</name>
      <anchor>a364</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ThreeVector.h</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>ThreeVector_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a326</anchor>
      <arglist>(OStream &amp;os, const Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a327</anchor>
      <arglist>(IStream &amp;is, Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
  </compound>
  <compound kind="page">
    <name>MEee2gZ2qqInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEee2gZ2qq class.</title>
    <filename>MEee2gZ2qqInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>OmegaPhi3PiDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::OmegaPhi3PiDecayer class.</title>
    <filename>OmegaPhi3PiDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>DalitzDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::DalitzDecayer class.</title>
    <filename>DalitzDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ColourPairDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::ColourPairDecayer class.</title>
    <filename>ColourPairDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>Onium3GDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::Onium3GDecayer class.</title>
    <filename>Onium3GDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>SimpleAlphaEMInterfaces</name>
    <title>Interfaces defined for the ThePEG::SimpleAlphaEM class.</title>
    <filename>SimpleAlphaEMInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>StandardCKMInterfaces</name>
    <title>Interfaces defined for the ThePEG::StandardCKM class.</title>
    <filename>StandardCKMInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEGG2GGInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEGG2GG class.</title>
    <filename>MEGG2GGInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEQG2QGInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEQG2QG class.</title>
    <filename>MEQG2QGInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEQQ2QQInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEQQ2QQ class.</title>
    <filename>MEQQ2QQInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEQq2QqInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEQq2Qq class.</title>
    <filename>MEQq2QqInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEGG2QQInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEGG2QQ class.</title>
    <filename>MEGG2QQInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEQQ2GGInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEQQ2GG class.</title>
    <filename>MEQQ2GGInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEQQ2qqInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEQQ2qq class.</title>
    <filename>MEQQ2qqInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEqq2qqInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEqq2qq class.</title>
    <filename>MEqq2qqInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>SimpleFlavourInterfaces</name>
    <title>Interfaces defined for the ThePEG::SimpleFlavour class.</title>
    <filename>SimpleFlavourInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>GaussianPtGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::GaussianPtGenerator class.</title>
    <filename>GaussianPtGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>V2PPDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::V2PPDecayer class.</title>
    <filename>V2PPDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>LeptonLeptonRemnantInterfaces</name>
    <title>Interfaces defined for the ThePEG::LeptonLeptonRemnant class.</title>
    <filename>LeptonLeptonRemnantInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>GRV94MInterfaces</name>
    <title>Interfaces defined for the ThePEG::GRV94M class.</title>
    <filename>GRV94MInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>BaryonRemnantsInterfaces</name>
    <title>Interfaces defined for the ThePEG::BaryonRemnants class.</title>
    <filename>BaryonRemnantsInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ACDCSamplerInterfaces</name>
    <title>Interfaces defined for the ThePEG::ACDCSampler class.</title>
    <filename>ACDCSamplerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>SimpleZGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::SimpleZGenerator class.</title>
    <filename>SimpleZGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MadGraphReaderInterfaces</name>
    <title>Interfaces defined for the ThePEG::MadGraphReader class.</title>
    <filename>MadGraphReaderInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>PartonExtractorInterfaces</name>
    <title>Interfaces defined for the ThePEG::PartonExtractor class.</title>
    <filename>PartonExtractorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>PDFBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::PDFBase class.</title>
    <filename>PDFBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>RemnantHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::RemnantHandler class.</title>
    <filename>RemnantHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>BeamParticleDataInterfaces</name>
    <title>Interfaces defined for the ThePEG::BeamParticleData class.</title>
    <filename>BeamParticleDataInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>AmplitudeInterfaces</name>
    <title>Interfaces defined for the ThePEG::Amplitude class.</title>
    <filename>AmplitudeInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MEBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::MEBase class.</title>
    <filename>MEBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ReweightBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::ReweightBase class.</title>
    <filename>ReweightBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ME2to2BaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::ME2to2Base class.</title>
    <filename>ME2to2BaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ME2to2QCDInterfaces</name>
    <title>Interfaces defined for the ThePEG::ME2to2QCD class.</title>
    <filename>ME2to2QCDInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ReweightConstantInterfaces</name>
    <title>Interfaces defined for the ThePEG::ReweightConstant class.</title>
    <filename>ReweightConstantInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>EventGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::EventGenerator class.</title>
    <filename>EventGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>RandomGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::RandomGenerator class.</title>
    <filename>RandomGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>StrategyInterfaces</name>
    <title>Interfaces defined for the ThePEG::Strategy class.</title>
    <filename>StrategyInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>StandardRandomInterfaces</name>
    <title>Interfaces defined for the ThePEG::StandardRandom class.</title>
    <filename>StandardRandomInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>EventHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::EventHandler class.</title>
    <filename>EventHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>SubProcessHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::SubProcessHandler class.</title>
    <filename>SubProcessHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>AnalysisHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::AnalysisHandler class.</title>
    <filename>AnalysisHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>CascadeHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::CascadeHandler class.</title>
    <filename>CascadeHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MultipleInteractionHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::MultipleInteractionHandler class.</title>
    <filename>MultipleInteractionHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>DecayHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::DecayHandler class.</title>
    <filename>DecayHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>EventManipulatorInterfaces</name>
    <title>Interfaces defined for the ThePEG::EventManipulator class.</title>
    <filename>EventManipulatorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>StepHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::StepHandler class.</title>
    <filename>StepHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>HadronizationHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::HadronizationHandler class.</title>
    <filename>HadronizationHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>KinematicalCutsInterfaces</name>
    <title>Interfaces defined for the ThePEG::KinematicalCuts class.</title>
    <filename>KinematicalCutsInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>FlavourGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::FlavourGenerator class.</title>
    <filename>FlavourGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>LuminosityFunctionInterfaces</name>
    <title>Interfaces defined for the ThePEG::LuminosityFunction class.</title>
    <filename>LuminosityFunctionInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>FixedCMSLuminosityInterfaces</name>
    <title>Interfaces defined for the ThePEG::FixedCMSLuminosity class.</title>
    <filename>FixedCMSLuminosityInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>StandardEventHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::StandardEventHandler class.</title>
    <filename>StandardEventHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>SamplerBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::SamplerBase class.</title>
    <filename>SamplerBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ClusterCollapserInterfaces</name>
    <title>Interfaces defined for the ThePEG::ClusterCollapser class.</title>
    <filename>ClusterCollapserInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>PtGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::PtGenerator class.</title>
    <filename>PtGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ZGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::ZGenerator class.</title>
    <filename>ZGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ParticleDataInterfaces</name>
    <title>Interfaces defined for the ThePEG::ParticleData class.</title>
    <filename>ParticleDataInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>DecayModeInterfaces</name>
    <title>Interfaces defined for the ThePEG::DecayMode class.</title>
    <filename>DecayModeInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>DecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::Decayer class.</title>
    <filename>DecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>MassGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::MassGenerator class.</title>
    <filename>MassGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>WidthGeneratorInterfaces</name>
    <title>Interfaces defined for the ThePEG::WidthGenerator class.</title>
    <filename>WidthGeneratorInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>DummyDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::DummyDecayer class.</title>
    <filename>DummyDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>ConstituentParticleDataInterfaces</name>
    <title>Interfaces defined for the ThePEG::ConstituentParticleData class.</title>
    <filename>ConstituentParticleDataInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>FlatDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::FlatDecayer class.</title>
    <filename>FlatDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>StandardModelBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::StandardModelBase class.</title>
    <filename>StandardModelBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>AlphaEMBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::AlphaEMBase class.</title>
    <filename>AlphaEMBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>CKMBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::CKMBase class.</title>
    <filename>CKMBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>AlphaSBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::AlphaSBase class.</title>
    <filename>AlphaSBaseInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>Helicity::RSFermionSpinInfoInterfaces</name>
    <title>Interfaces defined for the ThePEG::Helicity::RSFermionSpinInfo class.</title>
    <filename>Helicity::RSFermionSpinInfoInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>O1AlphaSInterfaces</name>
    <title>Interfaces defined for the ThePEG::O1AlphaS class.</title>
    <filename>O1AlphaSInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>LesHouchesReaderInterfaces</name>
    <title>Interfaces defined for the ThePEG::LesHouchesReader class.</title>
    <filename>LesHouchesReaderInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>LesHouchesFileReaderInterfaces</name>
    <title>Interfaces defined for the ThePEG::LesHouchesFileReader class.</title>
    <filename>LesHouchesFileReaderInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>LesHouchesEventHandlerInterfaces</name>
    <title>Interfaces defined for the ThePEG::LesHouchesEventHandler class.</title>
    <filename>LesHouchesEventHandlerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>WeakToHadronsDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::WeakToHadronsDecayer class.</title>
    <filename>WeakToHadronsDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>GRV94LInterfaces</name>
    <title>Interfaces defined for the ThePEG::GRV94L class.</title>
    <filename>GRV94LInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>QuarksToHadronsDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::QuarksToHadronsDecayer class.</title>
    <filename>QuarksToHadronsDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>LeptonLeptonPDFInterfaces</name>
    <title>Interfaces defined for the ThePEG::LeptonLeptonPDF class.</title>
    <filename>LeptonLeptonPDFInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>Tau2HadronsDecayerInterfaces</name>
    <title>Interfaces defined for the ThePEG::Tau2HadronsDecayer class.</title>
    <filename>Tau2HadronsDecayerInterfaces</filename>
  </compound>
  <compound kind="page">
    <name>GRVBaseInterfaces</name>
    <title>Interfaces defined for the ThePEG::GRVBase class.</title>
    <filename>GRVBaseInterfaces</filename>
  </compound>
  <compound kind="group">
    <name>Persistency</name>
    <title>Persistency classes</title>
    <filename>group__Persistency.html</filename>
    <class kind="class">ThePEG::InputDescription</class>
    <class kind="class">ThePEG::PersistentIStream</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingClass</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingObject</class>
    <class kind="struct">ThePEG::PersistentIStream::ReadFailior</class>
    <class kind="class">ThePEG::PersistentOStream</class>
    <class kind="struct">ThePEG::PersistentOStream::MissingClass</class>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/ACDC/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/ACDC/</path>
    <filename>dir_000000.html</filename>
    <file>ACDCGen.h</file>
    <file>ACDCGenCell.h</file>
    <file>ACDCGenConfig.h</file>
    <file>ACDCTraits.h</file>
    <file>DRand48Traits.h</file>
    <file>fpudebug.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>dir_000010.html</filename>
    <file>CLHEP.h</file>
    <file>GenEventConverter.h</file>
    <file>JamesRandom.fh</file>
    <file>JamesRandom.h</file>
    <file>Lorentz5Vector.fh</file>
    <file>Lorentz5Vector.h</file>
    <file>LorentzRotation.fh</file>
    <file>LorentzRotation.h</file>
    <file>LorentzVector.fh</file>
    <file>LorentzVector.h</file>
    <file>Matrix.fh</file>
    <file>Matrix.h</file>
    <file>PhysicalConstants.h</file>
    <file>RandBreitWigner.fh</file>
    <file>RandBreitWigner.h</file>
    <file>RandExponential.fh</file>
    <file>RandExponential.h</file>
    <file>RandomEngine.fh</file>
    <file>RandomEngine.h</file>
    <file>RandPoisson.fh</file>
    <file>RandPoisson.h</file>
    <file>Rotation.fh</file>
    <file>Rotation.h</file>
    <file>SpinHalfLorentzRotation.h</file>
    <file>SpinOneLorentzRotation.fh</file>
    <file>SpinOneLorentzRotation.h</file>
    <file>SystemOfUnits.h</file>
    <file>ThreeVector.fh</file>
    <file>ThreeVector.h</file>
    <file>Transverse.fh</file>
    <file>Transverse.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Config/</path>
    <filename>dir_000002.html</filename>
    <file>algorithm.h</file>
    <file>Complex.h</file>
    <file>config.h</file>
    <file>Constants.h</file>
    <file>Containers.h</file>
    <file>Pointers.h</file>
    <file>std.h</file>
    <file>ThePEG.h</file>
    <file>Units.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/EventRecord/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/EventRecord/</path>
    <filename>dir_000011.html</filename>
    <file>Collision.h</file>
    <file>ColourBase.h</file>
    <file>ColourLine.h</file>
    <file>ColourSinglet.h</file>
    <file>Event.h</file>
    <file>EventConfig.h</file>
    <file>EventInfoBase.h</file>
    <file>Particle.fh</file>
    <file>Particle.h</file>
    <file>ParticleTraits.h</file>
    <file>SelectorBase.h</file>
    <file>SpinBase.h</file>
    <file>StandardSelectors.h</file>
    <file>Step.h</file>
    <file>SubProcess.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Handlers/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Handlers/</path>
    <filename>dir_000001.html</filename>
    <file>ACDCSampler.h</file>
    <file>AnalysisHandler.h</file>
    <file>CascadeHandler.h</file>
    <file>ClusterCollapser.fh</file>
    <file>ClusterCollapser.h</file>
    <file>DecayHandler.h</file>
    <file>DecayHandler.xh</file>
    <file>EventHandler.fh</file>
    <file>EventHandler.h</file>
    <file>EventManipulator.h</file>
    <file>FixedCMSLuminosity.h</file>
    <file>FlavourGenerator.h</file>
    <file>GaussianPtGenerator.h</file>
    <file>HadronizationHandler.h</file>
    <file>HandlerBase.h</file>
    <file>HandlerGroup.h</file>
    <file>Hint.h</file>
    <file>KinematicalCuts.h</file>
    <file>KinematicalCuts.xh</file>
    <file>LastXCombInfo.h</file>
    <file>LuminosityFunction.h</file>
    <file>MultipleInteractionHandler.h</file>
    <file>PtGenerator.h</file>
    <file>SamplerBase.fh</file>
    <file>SamplerBase.h</file>
    <file>SimpleFlavour.h</file>
    <file>SimpleZGenerator.h</file>
    <file>StandardEventHandler.fh</file>
    <file>StandardEventHandler.h</file>
    <file>StandardXComb.fh</file>
    <file>StandardXComb.h</file>
    <file>StepHandler.h</file>
    <file>SubProcessHandler.fh</file>
    <file>SubProcessHandler.h</file>
    <file>Two2NCuts.h</file>
    <file>Two2NCuts.xh</file>
    <file>XComb.h</file>
    <file>ZGenerator.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Helicity/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Helicity/</path>
    <filename>dir_000012.html</filename>
    <file>FermionSpinInfo.fh</file>
    <file>FermionSpinInfo.h</file>
    <file>HelicityDefinitions.h</file>
    <file>HelicityVertex.fh</file>
    <file>HelicityVertex.h</file>
    <file>LorentzPolarizationVector.h</file>
    <file>LorentzRSSpinor.fh</file>
    <file>LorentzRSSpinor.h</file>
    <file>LorentzRSSpinorBar.fh</file>
    <file>LorentzRSSpinorBar.h</file>
    <file>LorentzSpinor.fh</file>
    <file>LorentzSpinor.h</file>
    <file>LorentzSpinorBar.fh</file>
    <file>LorentzSpinorBar.h</file>
    <file>LorentzTensor.h</file>
    <file>RhoDMatrix.h</file>
    <file>RSFermionSpinInfo.fh</file>
    <file>RSFermionSpinInfo.h</file>
    <file>ScalarSpinInfo.fh</file>
    <file>ScalarSpinInfo.h</file>
    <file>SpinInfo.fh</file>
    <file>SpinInfo.h</file>
    <file>TensorSpinInfo.fh</file>
    <file>TensorSpinInfo.h</file>
    <file>VectorSpinInfo.fh</file>
    <file>VectorSpinInfo.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Interface/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Interface/</path>
    <filename>dir_000009.html</filename>
    <file>ClassDocumentation.fh</file>
    <file>ClassDocumentation.h</file>
    <file>Command.fh</file>
    <file>Command.h</file>
    <file>Command.xh</file>
    <file>Interface.h</file>
    <file>InterfaceBase.fh</file>
    <file>InterfaceBase.h</file>
    <file>InterfaceBase.xh</file>
    <file>Interfaced.h</file>
    <file>InterfacedBase.h</file>
    <file>InterfacedBase.xh</file>
    <file>Parameter.fh</file>
    <file>Parameter.h</file>
    <file>Parameter.xh</file>
    <file>ParVector.fh</file>
    <file>ParVector.h</file>
    <file>ParVector.xh</file>
    <file>Reference.fh</file>
    <file>Reference.h</file>
    <file>Reference.xh</file>
    <file>RefVector.fh</file>
    <file>RefVector.h</file>
    <file>RefVector.xh</file>
    <file>Switch.fh</file>
    <file>Switch.h</file>
    <file>Switch.xh</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/LesHouches/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/LesHouches/</path>
    <filename>dir_000014.html</filename>
    <file>LesHouches.h</file>
    <file>LesHouchesEventHandler.fh</file>
    <file>LesHouchesEventHandler.h</file>
    <file>LesHouchesFileReader.fh</file>
    <file>LesHouchesFileReader.h</file>
    <file>LesHouchesReader.fh</file>
    <file>LesHouchesReader.h</file>
    <file>MadGraphReader.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/MatrixElement/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/MatrixElement/</path>
    <filename>dir_000004.html</filename>
    <file>Amplitude.h</file>
    <file>ColourLines.h</file>
    <file>ColourLines.xh</file>
    <file>DiagramBase.fh</file>
    <file>DiagramBase.h</file>
    <file>DiagramBase.xh</file>
    <file>ME2to2Base.h</file>
    <file>ME2to2QCD.h</file>
    <file>MEBase.fh</file>
    <file>MEBase.h</file>
    <file>MECuts.h</file>
    <file>MECuts.xh</file>
    <file>MEee2gZ2qq.h</file>
    <file>MEGG2GG.h</file>
    <file>MEGG2QQ.h</file>
    <file>MEQG2QG.h</file>
    <file>MEQQ2GG.h</file>
    <file>MEqq2qq1.h</file>
    <file>MEQQ2qq2.h</file>
    <file>MEQQ2QQ3.h</file>
    <file>MEQq2Qq4.h</file>
    <file>ReweightBase.h</file>
    <file>ReweightConstant.h</file>
    <file>ReweightMinPT.h</file>
    <file>Tree2toNDiagram.h</file>
    <file>Tree2toNDiagram.xh</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/PDF/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/PDF/</path>
    <filename>dir_000005.html</filename>
    <file>BaryonRemnants.h</file>
    <file>BeamParticleData.h</file>
    <file>BeamParticleData.xh</file>
    <file>GRV94L.h</file>
    <file>GRV94M.h</file>
    <file>GRVBase.h</file>
    <file>LeptonLeptonPDF.h</file>
    <file>LeptonLeptonRemnant.h</file>
    <file>NoPDF.h</file>
    <file>NoRemnants.h</file>
    <file>PartonBin.fh</file>
    <file>PartonBin.h</file>
    <file>PartonBinInstance.h</file>
    <file>PartonExtractor.fh</file>
    <file>PartonExtractor.h</file>
    <file>PartonExtractor.xh</file>
    <file>PDF.fh</file>
    <file>PDF.h</file>
    <file>PDFBase.h</file>
    <file>PDFBase.xh</file>
    <file>PDFCuts.h</file>
    <file>RemnantHandler.h</file>
    <file>RemnantHandler.xh</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/PDT/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/PDT/</path>
    <filename>dir_000007.html</filename>
    <file>BreitWignerMass.h</file>
    <file>ColourPairDecayer.h</file>
    <file>CombinedMatcher.h</file>
    <file>ConstituentParticleData.h</file>
    <file>DalitzDecayer.h</file>
    <file>Decayer.fh</file>
    <file>Decayer.h</file>
    <file>DecayMode.fh</file>
    <file>DecayMode.h</file>
    <file>DecayMode.xh</file>
    <file>DummyDecayer.h</file>
    <file>EnumParticles.h</file>
    <file>FlatDecayer.h</file>
    <file>MassGenerator.fh</file>
    <file>MassGenerator.h</file>
    <file>Matcher.h</file>
    <file>MatcherBase.h</file>
    <file>OmegaPhi3PiDecayer.h</file>
    <file>Onium3GDecayer.h</file>
    <file>ParticleData.h</file>
    <file>ParticleData.xh</file>
    <file>PDT.h</file>
    <file>QuarksToHadronsDecayer.h</file>
    <file>StandardMatchers.h</file>
    <file>Tau2HadronsDecayer.h</file>
    <file>V2PPDecayer.h</file>
    <file>WeakToHadronsDecayer.h</file>
    <file>WidthGenerator.fh</file>
    <file>WidthGenerator.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Persistency/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Persistency/</path>
    <filename>dir_000013.html</filename>
    <file>InputDescription.h</file>
    <file>PersistentIStream.fh</file>
    <file>PersistentIStream.h</file>
    <file>PersistentIStream.xh</file>
    <file>PersistentOStream.fh</file>
    <file>PersistentOStream.h</file>
    <file>PersistentOStream.xh</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Pointer/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Pointer/</path>
    <filename>dir_000015.html</filename>
    <file>Ptr.h</file>
    <file>PtrTraits.h</file>
    <file>RCPtr.fh</file>
    <file>RCPtr.h</file>
    <file>ReferenceCounted.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Repository/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Repository/</path>
    <filename>dir_000006.html</filename>
    <file>BaseRepository.h</file>
    <file>BaseRepository.xh</file>
    <file>CurrentGenerator.fh</file>
    <file>CurrentGenerator.h</file>
    <file>EventGenerator.fh</file>
    <file>EventGenerator.h</file>
    <file>EventGenerator.xh</file>
    <file>Main.h</file>
    <file>MultiEventGenerator.h</file>
    <file>RandomGenerator.fh</file>
    <file>RandomGenerator.h</file>
    <file>Repository.h</file>
    <file>StandardRandom.h</file>
    <file>Strategy.fh</file>
    <file>Strategy.h</file>
    <file>ThePEGStrategy.h</file>
    <file>UseRandom.fh</file>
    <file>UseRandom.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/StandardModel/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/StandardModel/</path>
    <filename>dir_000003.html</filename>
    <file>AlphaEMBase.h</file>
    <file>AlphaSBase.h</file>
    <file>CKMBase.h</file>
    <file>O1AlphaS.h</file>
    <file>SimpleAlphaEM.h</file>
    <file>StandardCKM.h</file>
    <file>StandardModelBase.fh</file>
    <file>StandardModelBase.h</file>
  </compound>
  <compound kind="dir">
    <name>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Utilities/</name>
    <path>/home/richardn/montecarlo/c++/ThePEG/ThePEG/Utilities/</path>
    <filename>dir_000008.html</filename>
    <file>CFileLineReader.fh</file>
    <file>CFileLineReader.h</file>
    <file>ClassDescription.fh</file>
    <file>ClassDescription.h</file>
    <file>ClassTraits.h</file>
    <file>CompSelector.h</file>
    <file>Debug.h</file>
    <file>DescriptionList.h</file>
    <file>Direction.h</file>
    <file>Direction.xh</file>
    <file>DIterator.h</file>
    <file>DynamicLoader.h</file>
    <file>EnumIO.h</file>
    <file>Exception.fh</file>
    <file>Exception.h</file>
    <file>FixedSizeAllocator.h</file>
    <file>HoldFlag.h</file>
    <file>Interval.fh</file>
    <file>Interval.h</file>
    <file>Level.h</file>
    <file>LoopGuard.h</file>
    <file>Math.h</file>
    <file>Named.h</file>
    <file>ObjectIndexer.h</file>
    <file>Rebinder.fh</file>
    <file>Rebinder.h</file>
    <file>Selector.h</file>
    <file>SimplePhaseSpace.h</file>
    <file>SimplePhaseSpace.xh</file>
    <file>sstream.h</file>
    <file>StringUtils.h</file>
    <file>SystemUtils.h</file>
    <file>Timer.h</file>
    <file>Triplet.h</file>
    <file>TypeInfo.h</file>
    <file>UnitIO.h</file>
    <file>UtilityBase.fh</file>
    <file>UtilityBase.h</file>
    <file>UtilityBase.xh</file>
    <file>VSelector.h</file>
    <file>XSecStat.h</file>
  </compound>
  <compound kind="namespace">
    <name>ACDCGenerator</name>
    <filename>namespaceACDCGenerator.html</filename>
    <class kind="class">ACDCGenerator::ACDCGen</class>
    <class kind="struct">ACDCGenerator::ACDCGen::Level</class>
    <class kind="struct">ACDCGenerator::ACDCGen::Slicer</class>
    <class kind="class">ACDCGenerator::ACDCGenCell</class>
    <class kind="struct">ACDCGenerator::ACDCGenCellInfo</class>
    <class kind="struct">ACDCGenerator::ACDCTraitsType</class>
    <class kind="struct">ACDCGenerator::ACDCFncTraits</class>
    <class kind="struct">ACDCGenerator::ACDCRandomTraits</class>
    <class kind="struct">ACDCGenerator::DRAND48</class>
    <class kind="struct">ACDCGenerator::ACDCRandomTraits&lt; DRAND48 &gt;</class>
    <class kind="struct">ACDCGenerator::ACDCFncTraits&lt; ThePEG::tStdEHPtr &gt;</class>
    <class kind="struct">ACDCGenerator::ACDCRandomTraits&lt; ThePEG::UseRandom &gt;</class>
    <member kind="typedef">
      <type>short</type>
      <name>DimType</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ACDCGenerator::ACDCGen</name>
    <filename>classACDCGenerator_1_1ACDCGen.html</filename>
    <templarg>Rnd</templarg>
    <templarg>FncPtr</templarg>
    <member kind="typedef">
      <type>Rnd</type>
      <name>RndType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ACDCRandomTraits&lt; RndType &gt;</type>
      <name>RndTraits</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>FncPtr</type>
      <name>FncPtrType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ACDCGenCell * &gt;</type>
      <name>CellVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; FncPtrType &gt;</type>
      <name>FncVector</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; DimType &gt;</type>
      <name>DimVector</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DimVector::size_type</type>
      <name>size_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ACDCFncTraits&lt; FncPtrType &gt;</type>
      <name>FncTraits</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCGen</name>
      <anchor>a0</anchor>
      <arglist>(Rnd *r)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCGen</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addFunction</name>
      <anchor>a2</anchor>
      <arglist>(DimType dim, FncPtrType f, double maxrat=-1.0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>FncPtrType</type>
      <name>generate</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reject</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const DVector &amp;</type>
      <name>lastPoint</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastF</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FncPtrType</type>
      <name>lastFunction</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>last</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a10</anchor>
      <arglist>(POStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a11</anchor>
      <arglist>(PIStream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>eps</name>
      <anchor>z1_0</anchor>
      <arglist>(double newEps)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>margin</name>
      <anchor>z1_1</anchor>
      <arglist>(double newMargin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>nTry</name>
      <anchor>z1_2</anchor>
      <arglist>(size_type newNTry)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>maxTry</name>
      <anchor>z1_3</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>integral</name>
      <anchor>z3_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>n</name>
      <anchor>z3_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>N</name>
      <anchor>z3_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>efficiency</name>
      <anchor>z3_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nBins</name>
      <anchor>z3_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>depth</name>
      <anchor>z3_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxInt</name>
      <anchor>z3_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>z5_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>margin</name>
      <anchor>z5_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>nTry</name>
      <anchor>z5_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxTry</name>
      <anchor>z5_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>cheapRandom</name>
      <anchor>z5_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>z5_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>compensating</name>
      <anchor>z5_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>compleft</name>
      <anchor>z5_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>vector&lt; ACDCGenCellInfo &gt;</type>
      <name>extractCellInfo</name>
      <anchor>z5_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cheapRandom</name>
      <anchor>z7_0</anchor>
      <arglist>(bool b)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRnd</name>
      <anchor>z7_1</anchor>
      <arglist>(Rnd *r)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z7_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z7_3</anchor>
      <arglist>(double lo, double up) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rnd</name>
      <anchor>z7_4</anchor>
      <arglist>(const DVector &amp;lo, const DVector &amp;up, DVector &amp;r) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rnd</name>
      <anchor>z7_5</anchor>
      <arglist>(DimType D, DVector &amp;r) const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>rndInt</name>
      <anchor>z7_6</anchor>
      <arglist>(long x) const </arglist>
    </member>
    <member kind="variable" static="yes">
      <type>size_type</type>
      <name>maxsize</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; Level &gt;</type>
      <name>LevelVector</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>doMaxInt</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const FncVector &amp;</type>
      <name>functions</name>
      <anchor>d1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>FncPtrType</type>
      <name>function</name>
      <anchor>d2</anchor>
      <arglist>(size_type i) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>const DimVector &amp;</type>
      <name>dimensions</name>
      <anchor>d3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>DimType</type>
      <name>dimension</name>
      <anchor>d4</anchor>
      <arglist>(size_type i) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>DimType</type>
      <name>lastDimension</name>
      <anchor>d5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>const CellVector &amp;</type>
      <name>cells</name>
      <anchor>d6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell *</type>
      <name>cell</name>
      <anchor>d7</anchor>
      <arglist>(size_type i) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell *</type>
      <name>lastPrimary</name>
      <anchor>d8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>const DVector &amp;</type>
      <name>sumMaxInts</name>
      <anchor>d9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell *</type>
      <name>lastCell</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>chooseCell</name>
      <anchor>d11</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>compensate</name>
      <anchor>d12</anchor>
      <arglist>(const DVector &amp;lo, const DVector &amp;up)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ACDCGen</name>
      <anchor>d13</anchor>
      <arglist>(const ACDCGen &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGen &amp;</type>
      <name>operator=</name>
      <anchor>d14</anchor>
      <arglist>(const ACDCGen &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RndType *</type>
      <name>theRnd</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNAcc</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theN</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMargin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theNTry</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theMaxTry</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useCheapRandom</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FncVector</type>
      <name>theFunctions</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DimVector</type>
      <name>theDimensions</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CellVector</type>
      <name>thePrimaryCells</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theSumMaxInts</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theLast</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ACDCGenCell *</type>
      <name>theLastCell</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theLastPoint</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastF</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LevelVector</type>
      <name>levels</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Level</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Level.html</filename>
    <member kind="variable">
      <type>long</type>
      <name>lastN</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>cell</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>size_type</type>
      <name>index</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Slicer</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Slicer.html</filename>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a0</anchor>
      <arglist>(DimType, ACDCGen &amp;, const DVector &amp;, const DVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a1</anchor>
      <arglist>(DimType Din, const Slicer &amp;s, ACDCGenCell *cellin, const DVector &amp;loin, const DVector &amp;xselin, const DVector &amp;upin, double fselin)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Slicer</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>divideandconquer</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>slice</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>shiftmaxmin</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dohalf</name>
      <anchor>a7</anchor>
      <arglist>(DimType)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>checkdiag</name>
      <anchor>a8</anchor>
      <arglist>(ACDCGenCell *cell, DimType d, double lod, double upd)</arglist>
    </member>
    <member kind="variable">
      <type>DimType</type>
      <name>D</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcl</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcu</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhl</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhu</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhl</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhu</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xsel</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>fsel</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>current</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>first</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstlo</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstup</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>FncPtr</type>
      <name>f</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>epsilon</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>margin</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>multimap&lt; double, DimType &gt;</type>
      <name>rateslice</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>minf</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>wholecomp</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Level</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Level.html</filename>
    <member kind="variable">
      <type>long</type>
      <name>lastN</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>cell</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>size_type</type>
      <name>index</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Slicer</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Slicer.html</filename>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a0</anchor>
      <arglist>(DimType, ACDCGen &amp;, const DVector &amp;, const DVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a1</anchor>
      <arglist>(DimType Din, const Slicer &amp;s, ACDCGenCell *cellin, const DVector &amp;loin, const DVector &amp;xselin, const DVector &amp;upin, double fselin)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Slicer</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>divideandconquer</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>slice</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>shiftmaxmin</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dohalf</name>
      <anchor>a7</anchor>
      <arglist>(DimType)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>checkdiag</name>
      <anchor>a8</anchor>
      <arglist>(ACDCGenCell *cell, DimType d, double lod, double upd)</arglist>
    </member>
    <member kind="variable">
      <type>DimType</type>
      <name>D</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcl</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcu</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhl</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhu</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhl</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhu</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xsel</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>fsel</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>current</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>first</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstlo</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstup</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>FncPtr</type>
      <name>f</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>epsilon</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>margin</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>multimap&lt; double, DimType &gt;</type>
      <name>rateslice</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>minf</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>wholecomp</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ACDCGenerator::ACDCGenCell</name>
    <filename>classACDCGenerator_1_1ACDCGenCell.html</filename>
    <member kind="function">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>a0</anchor>
      <arglist>(double newG)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>a1</anchor>
      <arglist>(double newG, double newV)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ACDCGenCell</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>generate</name>
      <anchor>a3</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up, RndType *rnd)</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>generate</name>
      <anchor>a4</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up, DVector &amp;rndv)</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>getCell</name>
      <anchor>a5</anchor>
      <arglist>(DVector &amp;lo, const DVector &amp;x, DVector &amp;up)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>smooth</name>
      <anchor>a6</anchor>
      <arglist>(double frac)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isSplit</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>doMaxInt</name>
      <anchor>a8</anchor>
      <arglist>(double rescale=1.0)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxInt</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>splitme</name>
      <anchor>a10</anchor>
      <arglist>(double lo, double newDiv, double up, DimType newDim)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>g</name>
      <anchor>a11</anchor>
      <arglist>(double newG)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>g</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>v</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>DimType</type>
      <name>dim</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>div</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>upper</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>lower</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nBins</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>depth</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>extract</name>
      <anchor>a20</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up, vector&lt; ACDCGenCellInfo &gt; &amp;v) const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>getIndex</name>
      <anchor>a21</anchor>
      <arglist>(const ACDCGenCell *c) const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>getIndex</name>
      <anchor>a22</anchor>
      <arglist>(const ACDCGenCell *c, long &amp;indx) const </arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>getCell</name>
      <anchor>a23</anchor>
      <arglist>(long i)</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>getCell</name>
      <anchor>a24</anchor>
      <arglist>(long i, long &amp;indx)</arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>theG</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>theV</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>theUpper</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>theLower</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>theDivision</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DimType</type>
      <name>theSplitDimension</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>d1</anchor>
      <arglist>(const ACDCGenCell &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ACDCGenCell &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGenCellInfo</name>
    <filename>structACDCGenerator_1_1ACDCGenCellInfo.html</filename>
    <member kind="typedef">
      <type>vector&lt; ACDCGenCellInfo &gt;::size_type</type>
      <name>Index</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>v</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Index</type>
      <name>iup</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Index</type>
      <name>ilo</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCTraitsType</name>
    <filename>structACDCGenerator_1_1ACDCTraitsType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCFncTraits</name>
    <filename>structACDCGenerator_1_1ACDCFncTraits.html</filename>
    <templarg>FncPtr</templarg>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>value</name>
      <anchor>e0</anchor>
      <arglist>(const FncPtr &amp;f, const DVector &amp;x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCRandomTraits</name>
    <filename>structACDCGenerator_1_1ACDCRandomTraits.html</filename>
    <templarg>Rnd</templarg>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e0</anchor>
      <arglist>(Rnd *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>(Rnd *r, double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(Rnd *r, InputIterator l, InputIterator lend, InputIterator u, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(Rnd *r, int D, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e4</anchor>
      <arglist>(Rnd *r, double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e5</anchor>
      <arglist>(Rnd *r, double x, double y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>rndInt</name>
      <anchor>e6</anchor>
      <arglist>(Rnd *r, long x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::DRAND48</name>
    <filename>structACDCGenerator_1_1DRAND48.html</filename>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCRandomTraits&lt; DRAND48 &gt;</name>
    <filename>structACDCGenerator_1_1ACDCRandomTraits_3_01DRAND48_01_4.html</filename>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e0</anchor>
      <arglist>(DRAND48 *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>(DRAND48 *r, double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(DRAND48 *r, InputIterator l, InputIterator lend, InputIterator u, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(DRAND48 *r, int D, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e4</anchor>
      <arglist>(DRAND48 *r, double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e5</anchor>
      <arglist>(DRAND48 *r, double x, double y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>rndInt</name>
      <anchor>e6</anchor>
      <arglist>(DRAND48 *r, long x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCFncTraits&lt; ThePEG::tStdEHPtr &gt;</name>
    <filename>structACDCGenerator_1_1ACDCFncTraits_3_01ThePEG_1_1tStdEHPtr_01_4.html</filename>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::tStdEHPtr</type>
      <name>tStdEHPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>value</name>
      <anchor>e0</anchor>
      <arglist>(const tStdEHPtr &amp;eh, const DVector &amp;x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCRandomTraits&lt; ThePEG::UseRandom &gt;</name>
    <filename>structACDCGenerator_1_1ACDCRandomTraits_3_01ThePEG_1_1UseRandom_01_4.html</filename>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::UseRandom</type>
      <name>UseRandom</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e0</anchor>
      <arglist>(UseRandom *)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>(UseRandom *r, double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(UseRandom *r, InputIterator l, InputIterator lend, InputIterator u, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(UseRandom *r, int D, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e4</anchor>
      <arglist>(UseRandom, double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e5</anchor>
      <arglist>(UseRandom *, double x, double y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>rndInt</name>
      <anchor>e6</anchor>
      <arglist>(UseRandom *, long x)</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>CLHEP</name>
    <filename>namespaceCLHEP.html</filename>
    <member kind="typedef">
      <type>HepJamesRandom</type>
      <name>JamesRandom</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepLorentzVector</type>
      <name>LorentzVector</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepMatrix</type>
      <name>Matrix</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepSymMatrix</type>
      <name>SymMatrix</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepVector</type>
      <name>Vector</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RandBreitWigner</type>
      <name>ThePEGRandBreitWigner</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RandExponential</type>
      <name>ThePEGRandExponential</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepRandomEngine</type>
      <name>RandomEngine</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RandPoisson</type>
      <name>ThePEGRandPoisson</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepRotation</type>
      <name>Rotation</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Hep3Vector</type>
      <name>Vector3</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>std::less&lt; const type_info * &gt;</name>
    <filename>structstd_1_1less_3_01const_01type__info_01_5_01_4.html</filename>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a0</anchor>
      <arglist>(const type_info *x, const type_info *y) const </arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG</name>
    <filename>namespaceThePEG.html</filename>
    <class kind="class">ThePEG::GenEventConverter</class>
    <class kind="struct">ThePEG::GenEventConverter::GenEventConverterException</class>
    <class kind="struct">ThePEG::GenEventConverter::Vertex</class>
    <class kind="class">ThePEG::Lorentz5Vector</class>
    <class kind="class">ThePEG::LorentzRotation</class>
    <class kind="class">ThePEG::SpinHalfLorentzRotation</class>
    <class kind="class">ThePEG::Transverse</class>
    <class kind="struct">ThePEG::IteratorRange</class>
    <class kind="struct">ThePEG::Base</class>
    <class kind="struct">ThePEG::TraitsType</class>
    <class kind="struct">ThePEG::Veto</class>
    <class kind="struct">ThePEG::Stop</class>
    <class kind="struct">ThePEG::MultiplicationTraits</class>
    <class kind="struct">ThePEG::MultiplicationTraits&lt; Lorentz5Vector&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::MultiplicationTraits&lt; LorentzVector &gt;</class>
    <class kind="struct">ThePEG::MultiplicationTraits&lt; Vector3 &gt;</class>
    <class kind="class">ThePEG::Collision</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Collision, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Collision &gt;</class>
    <class kind="class">ThePEG::ColourBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ColourBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ColourBase &gt;</class>
    <class kind="class">ThePEG::ColourLine</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ColourLine, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ColourLine &gt;</class>
    <class kind="class">ThePEG::ColourSinglet</class>
    <class kind="class">ThePEG::ColourSinglet::ColourSingletException</class>
    <class kind="class">ThePEG::Event</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Event, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Event &gt;</class>
    <class kind="struct">ThePEG::EventConfig</class>
    <class kind="class">ThePEG::EventInfoBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventInfoBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventInfoBase &gt;</class>
    <class kind="class">ThePEG::Particle</class>
    <class kind="struct">ThePEG::Particle::ParticleRep</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Particle, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Particle &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; PPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; cPPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; tPPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; tcPPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; LorentzMomentum &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; Lorentz5Momentum &gt;</class>
    <class kind="struct">ThePEG::Transformer</class>
    <class kind="class">ThePEG::SelectorBase</class>
    <class kind="struct">ThePEG::ParticleSelector</class>
    <class kind="class">ThePEG::SelectIfNot</class>
    <class kind="class">ThePEG::SelectIfBoth</class>
    <class kind="class">ThePEG::SelectIfEither</class>
    <class kind="class">ThePEG::SpinBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SpinBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SpinBase &gt;</class>
    <class kind="struct">ThePEG::AllSelector</class>
    <class kind="struct">ThePEG::FinalStateSelector</class>
    <class kind="struct">ThePEG::IntermediateSelector</class>
    <class kind="struct">ThePEG::PrimaryCollisionSelector</class>
    <class kind="struct">ThePEG::ChargedSelector</class>
    <class kind="class">ThePEG::Step</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Step, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Step &gt;</class>
    <class kind="class">ThePEG::SubProcess</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SubProcess, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SubProcess &gt;</class>
    <class kind="class">ThePEG::ACDCSampler</class>
    <class kind="struct">ThePEG::ACDCSampler::ACDCStillCompensating</class>
    <class kind="struct">ThePEG::ACDCSampler::EventInitNoXSec</class>
    <class kind="struct">ThePEG::ACDCSampler::EventLoopException</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ACDCSampler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ACDCSampler &gt;</class>
    <class kind="class">ThePEG::AnalysisHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; AnalysisHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; AnalysisHandler &gt;</class>
    <class kind="class">ThePEG::CascadeHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; CascadeHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; CascadeHandler &gt;</class>
    <class kind="class">ThePEG::ClusterCollapser</class>
    <class kind="class">ThePEG::ClusterCollapser::ClusterException</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ClusterCollapser, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ClusterCollapser &gt;</class>
    <class kind="class">ThePEG::DecayHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DecayHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DecayHandler &gt;</class>
    <class kind="struct">ThePEG::DecHdlNoDecayMode</class>
    <class kind="struct">ThePEG::DecHdlNoDecayer</class>
    <class kind="struct">ThePEG::DecHdlDecayFailed</class>
    <class kind="struct">ThePEG::DecHdlChildFail</class>
    <class kind="class">ThePEG::EventHandler</class>
    <class kind="class">ThePEG::EventHandler::EventHandlerStepError</class>
    <class kind="class">ThePEG::EventHandler::EventHandlerHistError</class>
    <class kind="class">ThePEG::EventHandler::EventHandlerIncompleteError</class>
    <class kind="struct">ThePEG::EventHandler::EventLoopException</class>
    <class kind="struct">ThePEG::EventHandler::LumiFuncError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventHandler &gt;</class>
    <class kind="class">ThePEG::EventManipulator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventManipulator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventManipulator &gt;</class>
    <class kind="class">ThePEG::FixedCMSLuminosity</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FixedCMSLuminosity, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FixedCMSLuminosity &gt;</class>
    <class kind="class">ThePEG::FlavourGenerator</class>
    <class kind="class">ThePEG::FlavourGeneratorException</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FlavourGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FlavourGenerator &gt;</class>
    <class kind="class">ThePEG::GaussianPtGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GaussianPtGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GaussianPtGenerator &gt;</class>
    <class kind="class">ThePEG::HadronizationHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; HadronizationHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; HadronizationHandler &gt;</class>
    <class kind="class">ThePEG::HandlerBaseT</class>
    <class kind="class">ThePEG::HandlerBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; HandlerBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; HandlerBase &gt;</class>
    <class kind="class">ThePEG::HandlerGroupBase</class>
    <class kind="class">ThePEG::HandlerGroup</class>
    <class kind="class">ThePEG::Hint</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Hint, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Hint &gt;</class>
    <class kind="class">ThePEG::KinematicalCuts</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; KinematicalCuts, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; KinematicalCuts &gt;</class>
    <class kind="struct">ThePEG::KinCutSetup</class>
    <class kind="struct">ThePEG::KinCutZeroInterval</class>
    <class kind="class">ThePEG::LastXCombInfo</class>
    <class kind="class">ThePEG::LuminosityFunction</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LuminosityFunction, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LuminosityFunction &gt;</class>
    <class kind="class">ThePEG::MultipleInteractionHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MultipleInteractionHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MultipleInteractionHandler &gt;</class>
    <class kind="class">ThePEG::PtGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PtGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PtGenerator &gt;</class>
    <class kind="class">ThePEG::SamplerBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SamplerBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SamplerBase &gt;</class>
    <class kind="class">ThePEG::SimpleFlavour</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SimpleFlavour, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SimpleFlavour &gt;</class>
    <class kind="class">ThePEG::SimpleZGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SimpleZGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SimpleZGenerator &gt;</class>
    <class kind="class">ThePEG::StandardEventHandler</class>
    <class kind="class">ThePEG::StandardEventHandler::StandardEventHandlerUpdateException</class>
    <class kind="class">ThePEG::StandardEventHandler::StandardEventHandlerInitError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardEventHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardEventHandler &gt;</class>
    <class kind="class">ThePEG::StandardXComb</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardXComb, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardXComb &gt;</class>
    <class kind="class">ThePEG::StepHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StepHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StepHandler &gt;</class>
    <class kind="class">ThePEG::SubProcessHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SubProcessHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SubProcessHandler &gt;</class>
    <class kind="class">ThePEG::Two2NCuts</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Two2NCuts, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Two2NCuts &gt;</class>
    <class kind="struct">ThePEG::KinCutCmdFail1</class>
    <class kind="struct">ThePEG::KinCutCmdFail2</class>
    <class kind="struct">ThePEG::KinCutCmdFail3</class>
    <class kind="class">ThePEG::XComb</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; XComb, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; XComb &gt;</class>
    <class kind="class">ThePEG::ZGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ZGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ZGenerator &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::FermionSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::FermionSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::HelicityVertex, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::HelicityVertex &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::RSFermionSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::RSFermionSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::ScalarSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::ScalarSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::SpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::SpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::TensorSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::TensorSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::VectorSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::VectorSpinInfo &gt;</class>
    <class kind="class">ThePEG::ClassDocumentationBase</class>
    <class kind="class">ThePEG::ClassDocumentation</class>
    <class kind="class">ThePEG::CommandBase</class>
    <class kind="class">ThePEG::Command</class>
    <class kind="struct">ThePEG::CmdExUnknown</class>
    <class kind="class">ThePEG::InterfaceBase</class>
    <class kind="class">ThePEG::RefInterfaceBase</class>
    <class kind="struct">ThePEG::InterfaceException</class>
    <class kind="struct">ThePEG::InterExClass</class>
    <class kind="struct">ThePEG::InterExSetup</class>
    <class kind="struct">ThePEG::InterExUnknown</class>
    <class kind="struct">ThePEG::InterExReadOnly</class>
    <class kind="struct">ThePEG::InterExNoNull</class>
    <class kind="class">ThePEG::Interfaced</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Interfaced, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Interfaced &gt;</class>
    <class kind="class">ThePEG::InterfacedBase</class>
    <class kind="struct">ThePEG::InterfacedBase::UpdateChecker</class>
    <class kind="struct">ThePEG::InterfacedBase::UpdateMapChecker</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; InterfacedBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; InterfacedBase &gt;</class>
    <class kind="struct">ThePEG::SetupException</class>
    <class kind="struct">ThePEG::UpdateException</class>
    <class kind="struct">ThePEG::RebindException</class>
    <class kind="struct">ThePEG::InitException</class>
    <class kind="class">ThePEG::ParameterBase</class>
    <class kind="class">ThePEG::ParameterTBase</class>
    <class kind="class">ThePEG::Parameter</class>
    <class kind="class">ThePEG::ParameterTBase&lt; string &gt;</class>
    <class kind="class">ThePEG::Parameter&lt; T, string &gt;</class>
    <class kind="struct">ThePEG::ParExSetLimit</class>
    <class kind="struct">ThePEG::ParExSetUnknown</class>
    <class kind="struct">ThePEG::ParExGetUnknown</class>
    <class kind="class">ThePEG::ParVectorBase</class>
    <class kind="class">ThePEG::ParVectorTBase</class>
    <class kind="class">ThePEG::ParVector</class>
    <class kind="struct">ThePEG::ParVExLimit</class>
    <class kind="struct">ThePEG::ParVExUnknown</class>
    <class kind="struct">ThePEG::ParVExIndex</class>
    <class kind="struct">ThePEG::ParVExFixed</class>
    <class kind="struct">ThePEG::ParVExDelUnknown</class>
    <class kind="struct">ThePEG::ParVExGetUnknown</class>
    <class kind="class">ThePEG::ReferenceBase</class>
    <class kind="class">ThePEG::Reference</class>
    <class kind="struct">ThePEG::RefExSetRefClass</class>
    <class kind="struct">ThePEG::RefExSetUnknown</class>
    <class kind="struct">ThePEG::RefExGetUnknown</class>
    <class kind="struct">ThePEG::RefExSetNoobj</class>
    <class kind="struct">ThePEG::RefExSetMessage</class>
    <class kind="class">ThePEG::RefVectorBase</class>
    <class kind="class">ThePEG::RefVector</class>
    <class kind="struct">ThePEG::RefVExRefClass</class>
    <class kind="struct">ThePEG::RefVExSetUnknown</class>
    <class kind="struct">ThePEG::RefVExSetUnfound</class>
    <class kind="struct">ThePEG::RefVExIndex</class>
    <class kind="struct">ThePEG::RefVExFixed</class>
    <class kind="struct">ThePEG::RefVExDelUnknown</class>
    <class kind="struct">ThePEG::RefVExGetUnknown</class>
    <class kind="struct">ThePEG::RefVExNoSet</class>
    <class kind="struct">ThePEG::RefVExNoIns</class>
    <class kind="struct">ThePEG::RefVExNoDel</class>
    <class kind="class">ThePEG::SwitchOption</class>
    <class kind="class">ThePEG::SwitchBase</class>
    <class kind="class">ThePEG::Switch</class>
    <class kind="struct">ThePEG::SwExSetOpt</class>
    <class kind="struct">ThePEG::SwExSetUnknown</class>
    <class kind="struct">ThePEG::SwExGetUnknown</class>
    <class kind="class">ThePEG::HEPRUP</class>
    <class kind="class">ThePEG::HEPEUP</class>
    <class kind="class">ThePEG::LesHouchesEventHandler</class>
    <class kind="class">ThePEG::LesHouchesEventHandler::LesHouchesInitError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LesHouchesEventHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LesHouchesEventHandler &gt;</class>
    <class kind="class">ThePEG::LesHouchesFileReader</class>
    <class kind="class">ThePEG::LesHouchesFileReader::LesHouchesFileError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LesHouchesFileReader, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LesHouchesFileReader &gt;</class>
    <class kind="class">ThePEG::LesHouchesReader</class>
    <class kind="class">ThePEG::LesHouchesReader::LesHouchesInconsistencyError</class>
    <class kind="class">ThePEG::LesHouchesReader::LesHouchesReopenWarning</class>
    <class kind="class">ThePEG::LesHouchesReader::LesHouchesReopenError</class>
    <class kind="class">ThePEG::LesHouchesReader::LesHouchesInitError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LesHouchesReader, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LesHouchesReader &gt;</class>
    <class kind="class">ThePEG::MadGraphReader</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MadGraphReader, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MadGraphReader &gt;</class>
    <class kind="class">ThePEG::Amplitude</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Amplitude, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Amplitude &gt;</class>
    <class kind="class">ThePEG::ColourLines</class>
    <class kind="struct">ThePEG::ColourGeometryException</class>
    <class kind="class">ThePEG::DiagramBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DiagramBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DiagramBase &gt;</class>
    <class kind="struct">ThePEG::DiagramBaseSetupException</class>
    <class kind="class">ThePEG::ME2to2Base</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ME2to2Base, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ME2to2Base &gt;</class>
    <class kind="class">ThePEG::ME2to2QCD</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ME2to2QCD, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ME2to2QCD &gt;</class>
    <class kind="class">ThePEG::MEBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEBase &gt;</class>
    <class kind="class">ThePEG::MECuts</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MECuts, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MECuts &gt;</class>
    <class kind="struct">ThePEG::MECutSetup</class>
    <class kind="struct">ThePEG::MECutZeroInterval</class>
    <class kind="class">ThePEG::MEee2gZ2qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEee2gZ2qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEee2gZ2qq &gt;</class>
    <class kind="class">ThePEG::MEGG2GG</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEGG2GG, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEGG2GG &gt;</class>
    <class kind="class">ThePEG::MEGG2QQ</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEGG2QQ, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEGG2QQ &gt;</class>
    <class kind="class">ThePEG::MEQG2QG</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQG2QG, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQG2QG &gt;</class>
    <class kind="class">ThePEG::MEQQ2GG</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQQ2GG, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQQ2GG &gt;</class>
    <class kind="class">ThePEG::MEqq2qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEqq2qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEqq2qq &gt;</class>
    <class kind="class">ThePEG::MEQQ2qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQQ2qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQQ2qq &gt;</class>
    <class kind="class">ThePEG::MEQQ2QQ</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQQ2QQ, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQQ2QQ &gt;</class>
    <class kind="class">ThePEG::MEQq2Qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQq2Qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQq2Qq &gt;</class>
    <class kind="class">ThePEG::ReweightBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ReweightBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ReweightBase &gt;</class>
    <class kind="class">ThePEG::ReweightConstant</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ReweightConstant, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ReweightConstant &gt;</class>
    <class kind="class">ThePEG::ReweightMinPT</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ReweightMinPT, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ReweightMinPT &gt;</class>
    <class kind="class">ThePEG::Tree2toNDiagram</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Tree2toNDiagram, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Tree2toNDiagram &gt;</class>
    <class kind="struct">ThePEG::Tree2toNDiagramError</class>
    <class kind="class">ThePEG::BaryonRemnants</class>
    <class kind="struct">ThePEG::BaryonRemInfo</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; BaryonRemnants, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; BaryonRemnants &gt;</class>
    <class kind="class">ThePEG::BeamParticleData</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; BeamParticleData, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; BeamParticleData &gt;</class>
    <class kind="struct">ThePEG::BeamParticleWrongPDF</class>
    <class kind="class">ThePEG::GRV94L</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GRV94L, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GRV94L &gt;</class>
    <class kind="class">ThePEG::GRV94M</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GRV94M, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GRV94M &gt;</class>
    <class kind="class">ThePEG::GRVBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GRVBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GRVBase &gt;</class>
    <class kind="class">ThePEG::LeptonLeptonPDF</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LeptonLeptonPDF, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LeptonLeptonPDF &gt;</class>
    <class kind="class">ThePEG::LeptonLeptonRemnant</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LeptonLeptonRemnant, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LeptonLeptonRemnant &gt;</class>
    <class kind="class">ThePEG::NoPDF</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; NoPDF, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; NoPDF &gt;</class>
    <class kind="class">ThePEG::NoRemnants</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; NoRemnants, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; NoRemnants &gt;</class>
    <class kind="class">ThePEG::PartonBin</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartonBin, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartonBin &gt;</class>
    <class kind="class">ThePEG::PartonBinInstance</class>
    <class kind="struct">ThePEG::RemInfoBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartonBinInstance, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartonBinInstance &gt;</class>
    <class kind="class">ThePEG::PartonExtractor</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartonExtractor, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartonExtractor &gt;</class>
    <class kind="struct">ThePEG::RemColException</class>
    <class kind="class">ThePEG::PDF</class>
    <class kind="class">ThePEG::PDFBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PDFBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PDFBase &gt;</class>
    <class kind="struct">ThePEG::RemnantHandlerCantHandle</class>
    <class kind="struct">ThePEG::PDFWrongParticle</class>
    <class kind="struct">ThePEG::PDFRange</class>
    <class kind="class">ThePEG::PDFCuts</class>
    <class kind="class">ThePEG::RemnantHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; RemnantHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; RemnantHandler &gt;</class>
    <class kind="struct">ThePEG::RemnantHandlerException</class>
    <class kind="class">ThePEG::BreitWignerMass</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; BreitWignerMass, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; BreitWignerMass &gt;</class>
    <class kind="class">ThePEG::ColourPairDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ColourPairDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ColourPairDecayer &gt;</class>
    <class kind="struct">ThePEG::AndMatcher</class>
    <class kind="struct">ThePEG::OrMatcher</class>
    <class kind="struct">ThePEG::NotMatcher</class>
    <class kind="class">ThePEG::ConstituentParticleData</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ConstituentParticleData, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ConstituentParticleData &gt;</class>
    <class kind="class">ThePEG::DalitzDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DalitzDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DalitzDecayer &gt;</class>
    <class kind="class">ThePEG::Decayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Decayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Decayer &gt;</class>
    <class kind="class">ThePEG::DecayMode</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DecayMode, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DecayMode &gt;</class>
    <class kind="class">ThePEG::DecModNoAccept</class>
    <class kind="class">ThePEG::DecModSetupNoAccept</class>
    <class kind="class">ThePEG::DecModRebind</class>
    <class kind="class">ThePEG::DummyDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DummyDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DummyDecayer &gt;</class>
    <class kind="class">ThePEG::FlatDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FlatDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FlatDecayer &gt;</class>
    <class kind="class">ThePEG::MassGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MassGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MassGenerator &gt;</class>
    <class kind="class">ThePEG::Matcher</class>
    <class kind="struct">ThePEG::MatcherType</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Matcher&lt; T &gt;, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Matcher&lt; T &gt; &gt;</class>
    <class kind="class">ThePEG::MatcherBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MatcherBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MatcherBase &gt;</class>
    <class kind="class">ThePEG::OmegaPhi3PiDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; OmegaPhi3PiDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; OmegaPhi3PiDecayer &gt;</class>
    <class kind="class">ThePEG::Onium3GDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Onium3GDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Onium3GDecayer &gt;</class>
    <class kind="class">ThePEG::ParticleData</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ParticleData, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ParticleData &gt;</class>
    <class kind="struct">ThePEG::ParticleChargeCommand</class>
    <class kind="class">ThePEG::PDT</class>
    <class kind="class">ThePEG::QuarksToHadronsDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; QuarksToHadronsDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; QuarksToHadronsDecayer &gt;</class>
    <class kind="struct">ThePEG::AnyMatcher</class>
    <class kind="struct">ThePEG::ChargedMatcher</class>
    <class kind="struct">ThePEG::PositiveMatcher</class>
    <class kind="struct">ThePEG::NeutralMatcher</class>
    <class kind="struct">ThePEG::NegativeMatcher</class>
    <class kind="struct">ThePEG::BaryonMatcher</class>
    <class kind="struct">ThePEG::MesonMatcher</class>
    <class kind="struct">ThePEG::DiquarkMatcher</class>
    <class kind="struct">ThePEG::QuarkMatcher</class>
    <class kind="struct">ThePEG::LeptonMatcher</class>
    <class kind="struct">ThePEG::LightQuarkMatcher</class>
    <class kind="struct">ThePEG::LightAntiQuarkMatcher</class>
    <class kind="struct">ThePEG::StandardQCDPartonMatcher</class>
    <class kind="struct">ThePEG::PseudoScalarMesonMatcher</class>
    <class kind="struct">ThePEG::VectorMesonMatcher</class>
    <class kind="class">ThePEG::Tau2HadronsDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Tau2HadronsDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Tau2HadronsDecayer &gt;</class>
    <class kind="class">ThePEG::V2PPDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; V2PPDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; V2PPDecayer &gt;</class>
    <class kind="class">ThePEG::WeakToHadronsDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; WeakToHadronsDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; WeakToHadronsDecayer &gt;</class>
    <class kind="class">ThePEG::WidthGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; WidthGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; WidthGenerator &gt;</class>
    <class kind="class">ThePEG::InputDescription</class>
    <class kind="class">ThePEG::PersistentIStream</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingClass</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingObject</class>
    <class kind="struct">ThePEG::PersistentIStream::ReadFailior</class>
    <class kind="class">ThePEG::PersistentOStream</class>
    <class kind="struct">ThePEG::PersistentOStream::MissingClass</class>
    <class kind="class">ThePEG::BaseRepository</class>
    <class kind="struct">ThePEG::BadClassClone</class>
    <class kind="struct">ThePEG::BadClone</class>
    <class kind="struct">ThePEG::RepoNameException</class>
    <class kind="struct">ThePEG::RepositoryNoDirectory</class>
    <class kind="struct">ThePEG::RepositoryNotFound</class>
    <class kind="struct">ThePEG::RepositoryClassMisMatch</class>
    <class kind="class">ThePEG::CurrentGenerator</class>
    <class kind="class">ThePEG::EventGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventGenerator &gt;</class>
    <class kind="struct">ThePEG::EGNoPath</class>
    <class kind="class">ThePEG::Main</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Main, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Main &gt;</class>
    <class kind="class">ThePEG::MultiEventGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MultiEventGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MultiEventGenerator &gt;</class>
    <class kind="class">ThePEG::RandomGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; RandomGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; RandomGenerator &gt;</class>
    <class kind="class">ThePEG::Repository</class>
    <class kind="class">ThePEG::StandardRandom</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardRandom, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardRandom &gt;</class>
    <class kind="class">ThePEG::Strategy</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Strategy, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Strategy &gt;</class>
    <class kind="class">ThePEG::ThePEGStrategy</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEGStrategy, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEGStrategy &gt;</class>
    <class kind="class">ThePEG::UseRandom</class>
    <class kind="class">ThePEG::AlphaEMBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; AlphaEMBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; AlphaEMBase &gt;</class>
    <class kind="class">ThePEG::AlphaSBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; AlphaSBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; AlphaSBase &gt;</class>
    <class kind="class">ThePEG::CKMBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; CKMBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; CKMBase &gt;</class>
    <class kind="class">ThePEG::O1AlphaS</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; O1AlphaS, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; O1AlphaS &gt;</class>
    <class kind="class">ThePEG::SimpleAlphaEM</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SimpleAlphaEM, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SimpleAlphaEM &gt;</class>
    <class kind="class">ThePEG::StandardCKM</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardCKM, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardCKM &gt;</class>
    <class kind="class">ThePEG::StandardModelBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardModelBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardModelBase &gt;</class>
    <class kind="class">ThePEG::CFileLineReader</class>
    <class kind="class">ThePEG::ClassDescriptionBase</class>
    <class kind="class">ThePEG::ClassDescriptionTBase</class>
    <class kind="class">ThePEG::AbstractClassDescription</class>
    <class kind="class">ThePEG::ClassDescription</class>
    <class kind="class">ThePEG::NoPIOClassDescription</class>
    <class kind="class">ThePEG::AbstractNoPIOClassDescription</class>
    <class kind="struct">ThePEG::ClassDescriptionHelper</class>
    <class kind="struct">ThePEG::ClassDescriptionHelper&lt; T, IBase, int &gt;</class>
    <class kind="struct">ThePEG::ClassTraitsType</class>
    <class kind="struct">ThePEG::ClassTraitsBase</class>
    <class kind="struct">ThePEG::ClassTraits</class>
    <class kind="struct">ThePEG::BaseClassTrait</class>
    <class kind="class">ThePEG::CompSelector</class>
    <class kind="struct">ThePEG::CompSelector::Level</class>
    <class kind="class">ThePEG::Debug</class>
    <class kind="class">ThePEG::DescriptionList</class>
    <class kind="class">ThePEG::Direction</class>
    <class kind="struct">ThePEG::MultipleDirectionException</class>
    <class kind="struct">ThePEG::UndefinedDirectionException</class>
    <class kind="class">ThePEG::DIterator</class>
    <class kind="class">ThePEG::DynamicLoader</class>
    <class kind="struct">ThePEG::OEnum</class>
    <class kind="struct">ThePEG::IEnum</class>
    <class kind="class">ThePEG::Exception</class>
    <class kind="class">ThePEG::FixedSizeAllocator</class>
    <class kind="struct">ThePEG::FixedSizeAllocator::ChunkStack</class>
    <class kind="struct">ThePEG::SizeOf8</class>
    <class kind="struct">ThePEG::FixedAllocator</class>
    <class kind="class">ThePEG::Allocator</class>
    <class kind="struct">ThePEG::Allocator::rebind</class>
    <class kind="class">ThePEG::HoldFlag</class>
    <class kind="class">ThePEG::HoldFlag&lt; bool &gt;</class>
    <class kind="class">ThePEG::Interval</class>
    <class kind="class">ThePEG::Level</class>
    <class kind="class">ThePEG::LoopGuard</class>
    <class kind="class">ThePEG::Named</class>
    <class kind="class">ThePEG::ObjectIndexer</class>
    <class kind="class">ThePEG::Rebinder</class>
    <class kind="class">ThePEG::Selector</class>
    <class kind="struct">ThePEG::SimplePhaseSpace</class>
    <class kind="struct">ThePEG::ImpossibleKinematics</class>
    <class kind="class">ThePEG::StringUtils</class>
    <class kind="class">ThePEG::SystemUtils</class>
    <class kind="class">ThePEG::TimeCounter</class>
    <class kind="class">ThePEG::MainTimer</class>
    <class kind="class">ThePEG::Timer</class>
    <class kind="struct">ThePEG::Triplet</class>
    <class kind="struct">ThePEG::TypeInfo</class>
    <class kind="struct">ThePEG::OUnit</class>
    <class kind="struct">ThePEG::IUnit</class>
    <class kind="struct">ThePEG::UtilityBase</class>
    <class kind="struct">ThePEG::Utilities</class>
    <class kind="class">ThePEG::VSelector</class>
    <class kind="class">ThePEG::XSecStat</class>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a345</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a346</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a347</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a348</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a349</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a350</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>set&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a351</anchor>
      <arglist>(set&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a352</anchor>
      <arglist>(OStream &amp;os, const vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a353</anchor>
      <arglist>(IStream &amp;is, vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a354</anchor>
      <arglist>(OStream &amp;os, const set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a355</anchor>
      <arglist>(IStream &amp;is, set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a356</anchor>
      <arglist>(OStream &amp;os, const map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a357</anchor>
      <arglist>(IStream &amp;is, map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a381</anchor>
      <arglist>(PersistentIStream &amp;, pair&lt; T1, T2 &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a382</anchor>
      <arglist>(PersistentIStream &amp;, map&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a383</anchor>
      <arglist>(PersistentIStream &amp;, multimap&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a384</anchor>
      <arglist>(PersistentIStream &amp;, set&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a385</anchor>
      <arglist>(PersistentIStream &amp;, multiset&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a386</anchor>
      <arglist>(PersistentIStream &amp;, list&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a387</anchor>
      <arglist>(PersistentIStream &amp;, vector&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a388</anchor>
      <arglist>(PersistentIStream &amp;, deque&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a393</anchor>
      <arglist>(PersistentOStream &amp;, const pair&lt; T1, T2 &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a394</anchor>
      <arglist>(PersistentOStream &amp;, const multimap&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a395</anchor>
      <arglist>(PersistentOStream &amp;, const map&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a396</anchor>
      <arglist>(PersistentOStream &amp;, const set&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a397</anchor>
      <arglist>(PersistentOStream &amp;, const multiset&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a398</anchor>
      <arglist>(PersistentOStream &amp;, const list&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a399</anchor>
      <arglist>(PersistentOStream &amp;, const vector&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a400</anchor>
      <arglist>(PersistentOStream &amp;, const deque&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="typedef">
      <type>CLHEP::ThePEGRandBreitWigner</type>
      <name>RandBreitWigner</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEP::ThePEGRandExponential</type>
      <name>RandExponential</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEP::ThePEGRandPoisson</type>
      <name>RandPoisson</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEP::HepLorentzRotation</type>
      <name>SpinOneLorentzRotation</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::complex&lt; double &gt;</type>
      <name>Complex</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PDPtr, less&lt; PDPtr &gt;, Allocator&lt; PDPtr &gt; &gt;</type>
      <name>ParticleDataSet</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PDPtr &gt;</type>
      <name>PDVector</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPDPtr &gt;</type>
      <name>cPDVector</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPtr &gt;</type>
      <name>tPDVector</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPDPtr &gt;</type>
      <name>tcPDVector</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PMPtr, less&lt; PMPtr &gt;, Allocator&lt; PMPtr &gt; &gt;</type>
      <name>MatcherSet</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; DMPtr, less&lt; DMPtr &gt;, Allocator&lt; DMPtr &gt; &gt;</type>
      <name>DecayModeSet</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>ObjectSet</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>DependencySet</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; long, PDPtr, less&lt; long &gt;, Allocator&lt; std::pair&lt; long const, PDPtr &gt; &gt; &gt;</type>
      <name>ParticleMap</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, IBPtr, less&lt; string &gt;, Allocator&lt; std::pair&lt; string const, IBPtr &gt; &gt; &gt;</type>
      <name>ObjectMap</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; IBPtr, DependencySet, less&lt; IBPtr &gt;, Allocator&lt; std::pair&lt; IBPtr const, DependencySet &gt; &gt; &gt;</type>
      <name>DependencyMap</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; IBPtr &gt;</type>
      <name>IVector</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cIBPtr &gt;</type>
      <name>CIVector</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>ParticleVector</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>PVector</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPPtr &gt;</type>
      <name>cPVector</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tPVector</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPPtr &gt;</type>
      <name>tcPVector</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, const InterfaceBase *, less&lt; string &gt;, Allocator&lt; std::pair&lt; string const, const InterfaceBase * &gt; &gt; &gt;</type>
      <name>InterfaceMap</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; InterfacedBase &gt;</type>
      <name>TranslationMap</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, EGPtr, less&lt; string &gt;, Allocator&lt; std::pair&lt; string const, EGPtr &gt; &gt; &gt;</type>
      <name>GeneratorMap</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; AnaPtr &gt;</type>
      <name>AnalysisVector</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PDPtr, PDPtr &gt;</type>
      <name>PDPair</name>
      <anchor>a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPDPtr, cPDPtr &gt;</type>
      <name>cPDPair</name>
      <anchor>a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPDPtr, tPDPtr &gt;</type>
      <name>tPDPair</name>
      <anchor>a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPDPtr, tcPDPtr &gt;</type>
      <name>tcPDPair</name>
      <anchor>a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PPtr, PPtr &gt;</type>
      <name>PPair</name>
      <anchor>a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPPtr, cPPtr &gt;</type>
      <name>cPPair</name>
      <anchor>a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPPtr, tPPtr &gt;</type>
      <name>tPPair</name>
      <anchor>a34</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPPtr, tcPPtr &gt;</type>
      <name>tcPPair</name>
      <anchor>a35</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Interval&lt; Energy2 &gt;</type>
      <name>SInterval</name>
      <anchor>a36</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SInterval &gt;</type>
      <name>SIntervalVector</name>
      <anchor>a37</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPair &gt;</type>
      <name>tPartonPairVec</name>
      <anchor>a38</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tColinePtr, tColinePtr &gt;</type>
      <name>tColinePair</name>
      <anchor>a39</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tDMPtr, less&lt; tDMPtr &gt;, Allocator&lt; tDMPtr &gt; &gt;</type>
      <name>DecaySet</name>
      <anchor>a40</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; string, less&lt; string &gt;, Allocator&lt; string &gt; &gt;</type>
      <name>StringSet</name>
      <anchor>a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Energy &gt;</type>
      <name>EnergyVector</name>
      <anchor>a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; EIPtr &gt;</type>
      <name>EIVector</name>
      <anchor>a43</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a44</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; double, double &gt;</type>
      <name>DPair</name>
      <anchor>a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::pointer</type>
      <name>IBPtr</name>
      <anchor>a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::const_pointer</type>
      <name>cIBPtr</name>
      <anchor>a47</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_pointer</type>
      <name>tIBPtr</name>
      <anchor>a48</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_const_pointer</type>
      <name>tcIBPtr</name>
      <anchor>a49</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::pointer</type>
      <name>IPtr</name>
      <anchor>a50</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::const_pointer</type>
      <name>cIPtr</name>
      <anchor>a51</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_pointer</type>
      <name>tIPtr</name>
      <anchor>a52</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_const_pointer</type>
      <name>tcIPtr</name>
      <anchor>a53</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::pointer</type>
      <name>PDPtr</name>
      <anchor>a54</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::const_pointer</type>
      <name>cPDPtr</name>
      <anchor>a55</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_pointer</type>
      <name>tPDPtr</name>
      <anchor>a56</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_const_pointer</type>
      <name>tcPDPtr</name>
      <anchor>a57</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::pointer</type>
      <name>PMPtr</name>
      <anchor>a58</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::const_pointer</type>
      <name>cPMPtr</name>
      <anchor>a59</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_pointer</type>
      <name>tPMPtr</name>
      <anchor>a60</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_const_pointer</type>
      <name>tcPMPtr</name>
      <anchor>a61</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::pointer</type>
      <name>DMPtr</name>
      <anchor>a62</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::const_pointer</type>
      <name>cDMPtr</name>
      <anchor>a63</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_pointer</type>
      <name>tDMPtr</name>
      <anchor>a64</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_const_pointer</type>
      <name>tcDMPtr</name>
      <anchor>a65</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::pointer</type>
      <name>PPtr</name>
      <anchor>a66</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::const_pointer</type>
      <name>cPPtr</name>
      <anchor>a67</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_pointer</type>
      <name>tPPtr</name>
      <anchor>a68</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_const_pointer</type>
      <name>tcPPtr</name>
      <anchor>a69</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::pointer</type>
      <name>EGPtr</name>
      <anchor>a70</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::const_pointer</type>
      <name>cEGPtr</name>
      <anchor>a71</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_pointer</type>
      <name>tEGPtr</name>
      <anchor>a72</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_const_pointer</type>
      <name>tcEGPtr</name>
      <anchor>a73</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::pointer</type>
      <name>EHPtr</name>
      <anchor>a74</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::const_pointer</type>
      <name>cEHPtr</name>
      <anchor>a75</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_pointer</type>
      <name>tEHPtr</name>
      <anchor>a76</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_const_pointer</type>
      <name>tcEHPtr</name>
      <anchor>a77</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::pointer</type>
      <name>StepHdlPtr</name>
      <anchor>a78</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::const_pointer</type>
      <name>cStepHdlPtr</name>
      <anchor>a79</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_pointer</type>
      <name>tStepHdlPtr</name>
      <anchor>a80</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_const_pointer</type>
      <name>tcStepHdlPtr</name>
      <anchor>a81</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::pointer</type>
      <name>HintPtr</name>
      <anchor>a82</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::const_pointer</type>
      <name>cHintPtr</name>
      <anchor>a83</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_pointer</type>
      <name>tHintPtr</name>
      <anchor>a84</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_const_pointer</type>
      <name>tcHintPtr</name>
      <anchor>a85</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::pointer</type>
      <name>HadrHdlPtr</name>
      <anchor>a86</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::const_pointer</type>
      <name>cHadrHdlPtr</name>
      <anchor>a87</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_pointer</type>
      <name>tHadrHdlPtr</name>
      <anchor>a88</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_const_pointer</type>
      <name>tcHadrHdlPtr</name>
      <anchor>a89</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::pointer</type>
      <name>CascHdlPtr</name>
      <anchor>a90</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::const_pointer</type>
      <name>cCascHdlPtr</name>
      <anchor>a91</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_pointer</type>
      <name>tCascHdlPtr</name>
      <anchor>a92</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_const_pointer</type>
      <name>tcCascHdlPtr</name>
      <anchor>a93</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::pointer</type>
      <name>MIHdlPtr</name>
      <anchor>a94</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::const_pointer</type>
      <name>cMIHdlPtr</name>
      <anchor>a95</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_pointer</type>
      <name>tMIHdlPtr</name>
      <anchor>a96</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_const_pointer</type>
      <name>tcMIHdlPtr</name>
      <anchor>a97</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::pointer</type>
      <name>DecayHdlPtr</name>
      <anchor>a98</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::const_pointer</type>
      <name>cDecayHdlPtr</name>
      <anchor>a99</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_pointer</type>
      <name>tDecayHdlPtr</name>
      <anchor>a100</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_const_pointer</type>
      <name>tcDecayHdlPtr</name>
      <anchor>a101</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::pointer</type>
      <name>PileHdlPtr</name>
      <anchor>a102</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::const_pointer</type>
      <name>cPileHdlPtr</name>
      <anchor>a103</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_pointer</type>
      <name>tPileHdlPtr</name>
      <anchor>a104</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_const_pointer</type>
      <name>tcPileHdlPtr</name>
      <anchor>a105</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::pointer</type>
      <name>LumiFnPtr</name>
      <anchor>a106</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::const_pointer</type>
      <name>cLumiFnPtr</name>
      <anchor>a107</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_pointer</type>
      <name>tLumiFnPtr</name>
      <anchor>a108</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_const_pointer</type>
      <name>tcLumiFnPtr</name>
      <anchor>a109</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::pointer</type>
      <name>KinCutPtr</name>
      <anchor>a110</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::const_pointer</type>
      <name>cKinCutPtr</name>
      <anchor>a111</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_pointer</type>
      <name>tKinCutPtr</name>
      <anchor>a112</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_const_pointer</type>
      <name>tcKinCutPtr</name>
      <anchor>a113</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::pointer</type>
      <name>PExtrPtr</name>
      <anchor>a114</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::const_pointer</type>
      <name>cPExtrPtr</name>
      <anchor>a115</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_pointer</type>
      <name>tPExtrPtr</name>
      <anchor>a116</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_const_pointer</type>
      <name>tcPExtrPtr</name>
      <anchor>a117</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::pointer</type>
      <name>RanGenPtr</name>
      <anchor>a118</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::const_pointer</type>
      <name>cRanGenPtr</name>
      <anchor>a119</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_pointer</type>
      <name>tRanGenPtr</name>
      <anchor>a120</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_const_pointer</type>
      <name>tcRanGenPtr</name>
      <anchor>a121</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::pointer</type>
      <name>AnaPtr</name>
      <anchor>a122</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::const_pointer</type>
      <name>cAnaPtr</name>
      <anchor>a123</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_pointer</type>
      <name>tAnaPtr</name>
      <anchor>a124</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_const_pointer</type>
      <name>tcAnaPtr</name>
      <anchor>a125</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::pointer</type>
      <name>EvtManipPtr</name>
      <anchor>a126</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::const_pointer</type>
      <name>cEvtManipPtr</name>
      <anchor>a127</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_pointer</type>
      <name>tEvtManipPtr</name>
      <anchor>a128</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_const_pointer</type>
      <name>tcEvtManipPtr</name>
      <anchor>a129</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::pointer</type>
      <name>DecayerPtr</name>
      <anchor>a130</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::const_pointer</type>
      <name>cDecayerPtr</name>
      <anchor>a131</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_pointer</type>
      <name>tDecayerPtr</name>
      <anchor>a132</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_const_pointer</type>
      <name>tcDecayerPtr</name>
      <anchor>a133</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::pointer</type>
      <name>EventPtr</name>
      <anchor>a134</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::const_pointer</type>
      <name>cEventPtr</name>
      <anchor>a135</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_pointer</type>
      <name>tEventPtr</name>
      <anchor>a136</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_const_pointer</type>
      <name>tcEventPtr</name>
      <anchor>a137</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::pointer</type>
      <name>CollPtr</name>
      <anchor>a138</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::const_pointer</type>
      <name>cCollPtr</name>
      <anchor>a139</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_pointer</type>
      <name>tCollPtr</name>
      <anchor>a140</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_const_pointer</type>
      <name>tcCollPtr</name>
      <anchor>a141</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::pointer</type>
      <name>StepPtr</name>
      <anchor>a142</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::const_pointer</type>
      <name>cStepPtr</name>
      <anchor>a143</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_pointer</type>
      <name>tStepPtr</name>
      <anchor>a144</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_const_pointer</type>
      <name>tcStepPtr</name>
      <anchor>a145</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::pointer</type>
      <name>SubProPtr</name>
      <anchor>a146</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::const_pointer</type>
      <name>cSubProPtr</name>
      <anchor>a147</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_pointer</type>
      <name>tSubProPtr</name>
      <anchor>a148</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_const_pointer</type>
      <name>tcSubProPtr</name>
      <anchor>a149</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::pointer</type>
      <name>StrategyPtr</name>
      <anchor>a150</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::const_pointer</type>
      <name>cStrategyPtr</name>
      <anchor>a151</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_pointer</type>
      <name>tStrategyPtr</name>
      <anchor>a152</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_const_pointer</type>
      <name>tcStrategyPtr</name>
      <anchor>a153</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::pointer</type>
      <name>XCombPtr</name>
      <anchor>a154</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::const_pointer</type>
      <name>cXCombPtr</name>
      <anchor>a155</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_pointer</type>
      <name>tXCombPtr</name>
      <anchor>a156</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_const_pointer</type>
      <name>tcXCombPtr</name>
      <anchor>a157</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::pointer</type>
      <name>RemHPtr</name>
      <anchor>a158</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::const_pointer</type>
      <name>cRemHPtr</name>
      <anchor>a159</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_pointer</type>
      <name>tRemHPtr</name>
      <anchor>a160</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_const_pointer</type>
      <name>tcRemHPtr</name>
      <anchor>a161</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::pointer</type>
      <name>PDFPtr</name>
      <anchor>a162</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::const_pointer</type>
      <name>cPDFPtr</name>
      <anchor>a163</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_pointer</type>
      <name>tPDFPtr</name>
      <anchor>a164</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_const_pointer</type>
      <name>tcPDFPtr</name>
      <anchor>a165</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::pointer</type>
      <name>SMPtr</name>
      <anchor>a166</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::const_pointer</type>
      <name>cSMPtr</name>
      <anchor>a167</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_pointer</type>
      <name>tSMPtr</name>
      <anchor>a168</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_const_pointer</type>
      <name>tcSMPtr</name>
      <anchor>a169</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::pointer</type>
      <name>CBPtr</name>
      <anchor>a170</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::const_pointer</type>
      <name>cCBPtr</name>
      <anchor>a171</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_pointer</type>
      <name>tCBPtr</name>
      <anchor>a172</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_const_pointer</type>
      <name>tcCBPtr</name>
      <anchor>a173</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::pointer</type>
      <name>SpinPtr</name>
      <anchor>a174</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::const_pointer</type>
      <name>cSpinPtr</name>
      <anchor>a175</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_pointer</type>
      <name>tSpinPtr</name>
      <anchor>a176</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_const_pointer</type>
      <name>tcSpinPtr</name>
      <anchor>a177</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::pointer</type>
      <name>EIPtr</name>
      <anchor>a178</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::const_pointer</type>
      <name>cEIPtr</name>
      <anchor>a179</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_pointer</type>
      <name>tEIPtr</name>
      <anchor>a180</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_const_pointer</type>
      <name>tcEIPtr</name>
      <anchor>a181</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::pointer</type>
      <name>ReweightPtr</name>
      <anchor>a182</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::const_pointer</type>
      <name>cReweightPtr</name>
      <anchor>a183</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_pointer</type>
      <name>tReweightPtr</name>
      <anchor>a184</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_const_pointer</type>
      <name>tcReweightPtr</name>
      <anchor>a185</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::pointer</type>
      <name>ColinePtr</name>
      <anchor>a186</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::const_pointer</type>
      <name>cColinePtr</name>
      <anchor>a187</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_pointer</type>
      <name>tColinePtr</name>
      <anchor>a188</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_const_pointer</type>
      <name>tcColinePtr</name>
      <anchor>a189</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>a190</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>a191</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>a192</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>a193</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Base</type>
      <name>PersistentBase</name>
      <anchor>a194</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Base</type>
      <name>EventRecordBase</name>
      <anchor>a195</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::pointer</type>
      <name>EventBasePtr</name>
      <anchor>a196</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::const_pointer</type>
      <name>cEventBasePtr</name>
      <anchor>a197</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_pointer</type>
      <name>tEventBasePtr</name>
      <anchor>a198</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_const_pointer</type>
      <name>tcEventBasePtr</name>
      <anchor>a199</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; EventRecordBase &gt;</type>
      <name>EventTranslationMap</name>
      <anchor>a200</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle</type>
      <name>ParticleClass</name>
      <anchor>a201</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>ParticleDataClass</name>
      <anchor>a202</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::pointer</type>
      <name>EventPDPtr</name>
      <anchor>a203</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::const_pointer</type>
      <name>cEventPDPtr</name>
      <anchor>a204</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_pointer</type>
      <name>tEventPDPtr</name>
      <anchor>a205</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_const_pointer</type>
      <name>tcEventPDPtr</name>
      <anchor>a206</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tParticleVector</name>
      <anchor>a207</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PPtr, less&lt; PPtr &gt;, Allocator&lt; PPtr &gt; &gt;</type>
      <name>ParticleSet</name>
      <anchor>a208</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tPPtr, less&lt; tPPtr &gt;, Allocator&lt; tPPtr &gt; &gt;</type>
      <name>tParticleSet</name>
      <anchor>a209</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tcPPtr, less&lt; tcPPtr &gt;, Allocator&lt; tcPPtr &gt; &gt;</type>
      <name>tcParticleSet</name>
      <anchor>a210</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepPtr &gt;</type>
      <name>StepVector</name>
      <anchor>a211</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SubProPtr &gt;</type>
      <name>SubProcessVector</name>
      <anchor>a212</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tSubProPtr &gt;</type>
      <name>tSubProcessVector</name>
      <anchor>a213</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; CollPtr &gt;</type>
      <name>CollisionVector</name>
      <anchor>a214</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; StepPtr, less&lt; StepPtr &gt;, Allocator&lt; StepPtr &gt; &gt;</type>
      <name>StepSet</name>
      <anchor>a215</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; SubProPtr, less&lt; SubProPtr &gt;, Allocator&lt; SubProPtr &gt; &gt;</type>
      <name>SubProcessSet</name>
      <anchor>a216</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; AllSelector &gt;</type>
      <name>SelectAll</name>
      <anchor>a217</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; FinalStateSelector &gt;</type>
      <name>SelectFinalState</name>
      <anchor>a218</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; PrimaryCollisionSelector &gt;</type>
      <name>SelectPrimaryCollision</name>
      <anchor>a219</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; ChargedSelector &gt;</type>
      <name>SelectCharged</name>
      <anchor>a220</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::pointer</type>
      <name>ClusterCollapserPtr</name>
      <anchor>a221</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::const_pointer</type>
      <name>cClusterCollapserPtr</name>
      <anchor>a222</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::transient_pointer</type>
      <name>tClusterCollapserPtr</name>
      <anchor>a223</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::transient_const_pointer</type>
      <name>tcClusterCollapserPtr</name>
      <anchor>a224</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::pointer</type>
      <name>SamplerPtr</name>
      <anchor>a225</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::const_pointer</type>
      <name>cSamplerPtr</name>
      <anchor>a226</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::transient_pointer</type>
      <name>tSamplerPtr</name>
      <anchor>a227</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::transient_const_pointer</type>
      <name>tcSamplerPtr</name>
      <anchor>a228</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardEventHandler &gt;::pointer</type>
      <name>StdEHPtr</name>
      <anchor>a229</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardEventHandler &gt;::const_pointer</type>
      <name>cStdEHPtr</name>
      <anchor>a230</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardEventHandler &gt;::transient_pointer</type>
      <name>tStdEHPtr</name>
      <anchor>a231</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardEventHandler &gt;::transient_const_pointer</type>
      <name>tcStdEHPtr</name>
      <anchor>a232</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardXComb &gt;::pointer</type>
      <name>StdXCombPtr</name>
      <anchor>a233</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardXComb &gt;::const_pointer</type>
      <name>cStdXCombPtr</name>
      <anchor>a234</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardXComb &gt;::transient_pointer</type>
      <name>tStdXCombPtr</name>
      <anchor>a235</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardXComb &gt;::transient_const_pointer</type>
      <name>tcStdXCombPtr</name>
      <anchor>a236</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::pointer</type>
      <name>SubHdlPtr</name>
      <anchor>a237</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::const_pointer</type>
      <name>cSubHdlPtr</name>
      <anchor>a238</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::transient_pointer</type>
      <name>tSubHdlPtr</name>
      <anchor>a239</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::transient_const_pointer</type>
      <name>tcSubHdlPtr</name>
      <anchor>a240</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::pointer</type>
      <name>LesHouchesEventHandlerPtr</name>
      <anchor>a241</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::const_pointer</type>
      <name>cLesHouchesEventHandlerPtr</name>
      <anchor>a242</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::transient_pointer</type>
      <name>tLesHouchesEventHandlerPtr</name>
      <anchor>a243</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::transient_const_pointer</type>
      <name>tcLesHouchesEventHandlerPtr</name>
      <anchor>a244</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::pointer</type>
      <name>LesHouchesReaderPtr</name>
      <anchor>a245</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::const_pointer</type>
      <name>cLesHouchesReaderPtr</name>
      <anchor>a246</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::transient_pointer</type>
      <name>tLesHouchesReaderPtr</name>
      <anchor>a247</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::transient_const_pointer</type>
      <name>tcLesHouchesReaderPtr</name>
      <anchor>a248</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::pointer</type>
      <name>DiagPtr</name>
      <anchor>a249</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::const_pointer</type>
      <name>cDiagPtr</name>
      <anchor>a250</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::transient_pointer</type>
      <name>tDiagPtr</name>
      <anchor>a251</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::transient_const_pointer</type>
      <name>tcDiagPtr</name>
      <anchor>a252</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::pointer</type>
      <name>MEPtr</name>
      <anchor>a253</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::const_pointer</type>
      <name>cMEPtr</name>
      <anchor>a254</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::transient_pointer</type>
      <name>tMEPtr</name>
      <anchor>a255</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::transient_const_pointer</type>
      <name>tcMEPtr</name>
      <anchor>a256</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; MEPtr &gt;</type>
      <name>MEVector</name>
      <anchor>a257</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::pointer</type>
      <name>PBPtr</name>
      <anchor>a258</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::const_pointer</type>
      <name>cPBPtr</name>
      <anchor>a259</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::transient_pointer</type>
      <name>tPBPtr</name>
      <anchor>a260</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::transient_const_pointer</type>
      <name>tcPBPtr</name>
      <anchor>a261</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PBPtr &gt;</type>
      <name>PartonVector</name>
      <anchor>a262</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PBPtr, PBPtr &gt;</type>
      <name>PBPair</name>
      <anchor>a263</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPBPtr, tcPBPtr &gt;</type>
      <name>tcPBPair</name>
      <anchor>a264</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PBPair &gt;</type>
      <name>PartonPairVec</name>
      <anchor>a265</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::pointer</type>
      <name>PBIPtr</name>
      <anchor>a266</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::const_pointer</type>
      <name>cPBIPtr</name>
      <anchor>a267</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::transient_pointer</type>
      <name>tPBIPtr</name>
      <anchor>a268</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::transient_const_pointer</type>
      <name>tcPBIPtr</name>
      <anchor>a269</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PBIPtr, PBIPtr &gt;</type>
      <name>PBIPair</name>
      <anchor>a270</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::pointer</type>
      <name>RemIPtr</name>
      <anchor>a271</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::const_pointer</type>
      <name>cRemIPtr</name>
      <anchor>a272</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::transient_pointer</type>
      <name>tRemIPtr</name>
      <anchor>a273</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::transient_const_pointer</type>
      <name>tcRemIPtr</name>
      <anchor>a274</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tPDPtr, less&lt; tPDPtr &gt;, Allocator&lt; tPDPtr &gt; &gt;</type>
      <name>ParticleMSet</name>
      <anchor>a275</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tPMPtr, less&lt; tPMPtr &gt;, Allocator&lt; tPMPtr &gt; &gt;</type>
      <name>MatcherMSet</name>
      <anchor>a276</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tDMPtr, less&lt; tDMPtr &gt;, Allocator&lt; tDMPtr &gt; &gt;</type>
      <name>ModeMSet</name>
      <anchor>a277</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::pointer</type>
      <name>MassGenPtr</name>
      <anchor>a278</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::const_pointer</type>
      <name>cMassGenPtr</name>
      <anchor>a279</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::transient_pointer</type>
      <name>tMassGenPtr</name>
      <anchor>a280</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::transient_const_pointer</type>
      <name>tcMassGenPtr</name>
      <anchor>a281</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>FlavGenPtr</name>
      <anchor>a282</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::const_pointer</type>
      <name>cFlavGenPtr</name>
      <anchor>a283</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::transient_pointer</type>
      <name>tFlavGenPtr</name>
      <anchor>a284</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::transient_const_pointer</type>
      <name>tcFlavGenPtr</name>
      <anchor>a285</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; AnyMatcher &gt;</type>
      <name>MatchAny</name>
      <anchor>a286</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; ChargedMatcher &gt;</type>
      <name>MatchCharged</name>
      <anchor>a287</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PositiveMatcher &gt;</type>
      <name>MatchPositive</name>
      <anchor>a288</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NeutralMatcher &gt;</type>
      <name>MatchNeutral</name>
      <anchor>a289</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NegativeMatcher &gt;</type>
      <name>MatchNegative</name>
      <anchor>a290</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; BaryonMatcher &gt;</type>
      <name>MatchBaryon</name>
      <anchor>a291</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; MesonMatcher &gt;</type>
      <name>MatchMeson</name>
      <anchor>a292</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; DiquarkMatcher &gt;</type>
      <name>MatchDiquark</name>
      <anchor>a293</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; QuarkMatcher &gt;</type>
      <name>MatchQuark</name>
      <anchor>a294</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LeptonMatcher &gt;</type>
      <name>MatchLepton</name>
      <anchor>a295</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightQuarkMatcher &gt;</type>
      <name>MatchLightQuark</name>
      <anchor>a296</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightAntiQuarkMatcher &gt;</type>
      <name>MatchLightAntiQuark</name>
      <anchor>a297</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; StandardQCDPartonMatcher &gt;</type>
      <name>MatchStandardQCDParton</name>
      <anchor>a298</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PseudoScalarMesonMatcher &gt;</type>
      <name>MatchPseudoScalarMeson</name>
      <anchor>a299</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; VectorMesonMatcher &gt;</type>
      <name>MatchVectorMeson</name>
      <anchor>a300</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::pointer</type>
      <name>WidthGeneratorPtr</name>
      <anchor>a301</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::const_pointer</type>
      <name>cWidthGeneratorPtr</name>
      <anchor>a302</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::transient_pointer</type>
      <name>tWidthGeneratorPtr</name>
      <anchor>a303</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::transient_const_pointer</type>
      <name>tcWidthGeneratorPtr</name>
      <anchor>a304</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PersistentIStream &amp;(*</type>
      <name>PersistentIManip</name>
      <anchor>a305</anchor>
      <arglist>)(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="typedef">
      <type>PersistentOStream &amp;(*</type>
      <name>PersistentOManip</name>
      <anchor>a306</anchor>
      <arglist>)(PersistentOStream &amp;)</arglist>
    </member>
    <member kind="typedef">
      <type>Interval&lt; double &gt;</type>
      <name>DInterval</name>
      <anchor>a307</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a308</anchor>
      <arglist>(OStream &amp;os, const Lorentz5Vector&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a309</anchor>
      <arglist>(IStream &amp;is, Lorentz5Vector&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation</type>
      <name>inverseOf</name>
      <anchor>a310</anchor>
      <arglist>(const LorentzRotation &amp;lt)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a311</anchor>
      <arglist>(std::ostream &amp;os, const LorentzRotation &amp;lt)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirPlus</name>
      <anchor>a312</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirMinus</name>
      <anchor>a313</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirZ</name>
      <anchor>a314</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirTheta</name>
      <anchor>a315</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirCosTheta</name>
      <anchor>a316</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Vector3</type>
      <name>dirBoostVector</name>
      <anchor>a317</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a318</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a319</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a320</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a321</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a322</anchor>
      <arglist>(OStream &amp;os, const LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a323</anchor>
      <arglist>(IStream &amp;is, LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation</type>
      <name>inverseOf</name>
      <anchor>a324</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;lt)</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a325</anchor>
      <arglist>(std::ostream &amp;os, const SpinHalfLorentzRotation &amp;lt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a326</anchor>
      <arglist>(OStream &amp;os, const Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a327</anchor>
      <arglist>(IStream &amp;is, Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a328</anchor>
      <arglist>(OStream &amp;os, const Transverse&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a329</anchor>
      <arglist>(IStream &amp;is, Transverse&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::iterator &gt;</type>
      <name>range</name>
      <anchor>a330</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_iterator &gt;</type>
      <name>range</name>
      <anchor>a331</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a332</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a333</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a334</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find</name>
      <anchor>a335</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find_if</name>
      <anchor>a336</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, Pred p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a337</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a338</anchor>
      <arglist>(Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a339</anchor>
      <arglist>(const Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find</name>
      <anchor>a340</anchor>
      <arglist>(Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find</name>
      <anchor>a341</anchor>
      <arglist>(const Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find_if</name>
      <anchor>a342</anchor>
      <arglist>(Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find_if</name>
      <anchor>a343</anchor>
      <arglist>(const Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a344</anchor>
      <arglist>(Cont &amp;c, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a358</anchor>
      <arglist>(const Container &amp;c, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a359</anchor>
      <arglist>(const vector&lt; T &gt; &amp;v, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>std::insert_iterator&lt; Cont &gt;</type>
      <name>inserter</name>
      <anchor>a360</anchor>
      <arglist>(Cont &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>left</name>
      <anchor>a361</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>right</name>
      <anchor>a362</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>MultiplicationTraits&lt; T &gt;::ResultType</type>
      <name>sqr</name>
      <anchor>a363</anchor>
      <arglist>(const T &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>abs</name>
      <anchor>a364</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a365</anchor>
      <arglist>(ostream &amp;, const Collision &amp;)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a366</anchor>
      <arglist>(ostream &amp;, const Event &amp;)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a367</anchor>
      <arglist>(ostream &amp;, const Particle &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyIfCheck</name>
      <anchor>a368</anchor>
      <arglist>(OutputIterator r, const Container &amp;c, const SelectorBase &amp;s)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a369</anchor>
      <arglist>(ostream &amp;, const Step &amp;)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a370</anchor>
      <arglist>(ostream &amp;, const SubProcess &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a371</anchor>
      <arglist>(PersistentOStream &amp;, const HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a372</anchor>
      <arglist>(PersistentIStream &amp;, HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator/</name>
      <anchor>a373</anchor>
      <arglist>(string, string)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>operator *</name>
      <anchor>a374</anchor>
      <arglist>(double, string)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a375</anchor>
      <arglist>(IStream &amp;, PDT::Colour &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a376</anchor>
      <arglist>(IStream &amp;, PDT::Charge &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a377</anchor>
      <arglist>(IStream &amp;, PDT::Spin &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a378</anchor>
      <arglist>(PersistentIStream &amp;, PersistentIManip)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>pedantic</name>
      <anchor>a379</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>tolerant</name>
      <anchor>a380</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a389</anchor>
      <arglist>(PersistentOStream &amp;os, PersistentOManip func)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>flush</name>
      <anchor>a390</anchor>
      <arglist>(PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>push</name>
      <anchor>a391</anchor>
      <arglist>(PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>pop</name>
      <anchor>a392</anchor>
      <arglist>(PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a401</anchor>
      <arglist>(OStream &amp;, const CompSelector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a402</anchor>
      <arglist>(IStream &amp;, CompSelector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>OEnum&lt; T &gt;</type>
      <name>oenum</name>
      <anchor>a403</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>IEnum&lt; T &gt;</type>
      <name>ienum</name>
      <anchor>a404</anchor>
      <arglist>(T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a405</anchor>
      <arglist>(OStream &amp;os, const OEnum&lt; T &gt; &amp;e)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a406</anchor>
      <arglist>(IStream &amp;is, const IEnum&lt; T &gt; &amp;e)</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T &gt;</type>
      <name>makeInterval</name>
      <anchor>a407</anchor>
      <arglist>(T dn, T up)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a408</anchor>
      <arglist>(OStream &amp;, const Interval&lt; T, CMP &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a409</anchor>
      <arglist>(IStream &amp;, Interval&lt; T, CMP &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a410</anchor>
      <arglist>(OStream &amp;os, const Interval&lt; T, CMP &gt; &amp;i, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a411</anchor>
      <arglist>(IStream &amp;is, Interval&lt; T, CMP &gt; &amp;i, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a412</anchor>
      <arglist>(OStream &amp;, const Selector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a413</anchor>
      <arglist>(IStream &amp;, Selector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Triplet&lt; T1, T2, T3 &gt;</type>
      <name>makeTriplet</name>
      <anchor>a414</anchor>
      <arglist>(const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a415</anchor>
      <arglist>(OStream &amp;os, const Triplet&lt; T1, T2, T3 &gt; &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a416</anchor>
      <arglist>(IStream &amp;is, Triplet&lt; T1, T2, T3 &gt; &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>OUnit&lt; T, UT &gt;</type>
      <name>ounit</name>
      <anchor>a417</anchor>
      <arglist>(const T &amp;t, const UT &amp;ut)</arglist>
    </member>
    <member kind="function">
      <type>IUnit&lt; T, UT &gt;</type>
      <name>iunit</name>
      <anchor>a418</anchor>
      <arglist>(T &amp;t, const UT &amp;ut)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a419</anchor>
      <arglist>(OStream &amp;os, const T &amp;t, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a420</anchor>
      <arglist>(IStream &amp;is, T &amp;t, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a421</anchor>
      <arglist>(OStream &amp;os, const OUnit&lt; T, UT &gt; &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a422</anchor>
      <arglist>(IStream &amp;is, const IUnit&lt; T, UT &gt; &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a423</anchor>
      <arglist>(OStream &amp;, const VSelector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a424</anchor>
      <arglist>(IStream &amp;, VSelector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a425</anchor>
      <arglist>(PersistentOStream &amp;, const XSecStat &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a426</anchor>
      <arglist>(PersistentIStream &amp;, XSecStat &amp;)</arglist>
    </member>
    <member kind="function">
      <type>XSecStat</type>
      <name>operator+</name>
      <anchor>a427</anchor>
      <arglist>(const XSecStat &amp;x1, const XSecStat &amp;x2)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GenEventConverter</name>
    <filename>classThePEG_1_1GenEventConverter.html</filename>
    <member kind="typedef">
      <type>CLHEPMC::GenParticle</type>
      <name>GenParticle</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEPMC::GenEvent</type>
      <name>GenEvent</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEPMC::GenVertex</type>
      <name>GenVertex</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tcPPtr, GenParticle * &gt;</type>
      <name>ParticleMap</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tcColinePtr, long &gt;</type>
      <name>FlowMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tcPPtr, Vertex * &gt;</type>
      <name>VertexMap</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const Vertex *, GenVertex * &gt;</type>
      <name>GenVertexMap</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>GenEvent *</type>
      <name>convert</name>
      <anchor>e0</anchor>
      <arglist>(const Event &amp;ev)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>GenEventConverter</name>
      <anchor>d0</anchor>
      <arglist>(const Event &amp;ev)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>GenEventConverter</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>GenEventConverter</name>
      <anchor>d2</anchor>
      <arglist>(const GenEventConverter &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GenEventConverter &amp;</type>
      <name>operator=</name>
      <anchor>d3</anchor>
      <arglist>(const GenEventConverter &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GenParticle *</type>
      <name>createParticle</name>
      <anchor>d4</anchor>
      <arglist>(tcPPtr p) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>join</name>
      <anchor>d5</anchor>
      <arglist>(tcPPtr parent, tcPPtr child)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GenVertex *</type>
      <name>createVertex</name>
      <anchor>d6</anchor>
      <arglist>(Vertex *v)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GenEvent *</type>
      <name>geneve</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>pmap</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlowMap</type>
      <name>flowmap</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Vertex &gt;</type>
      <name>vertices</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexMap</type>
      <name>prov</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexMap</type>
      <name>decv</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GenVertexMap</type>
      <name>vmap</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::GenEventConverterException</name>
    <filename>structThePEG_1_1GenEventConverter_1_1GenEventConverterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>GenEventConverterException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::Vertex</name>
    <filename>structThePEG_1_1GenEventConverter_1_1Vertex.html</filename>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>in</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>out</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::GenEventConverterException</name>
    <filename>structThePEG_1_1GenEventConverter_1_1GenEventConverterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>GenEventConverterException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::Vertex</name>
    <filename>structThePEG_1_1GenEventConverter_1_1Vertex.html</filename>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>in</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>out</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Lorentz5Vector</name>
    <filename>classThePEG_1_1Lorentz5Vector.html</filename>
    <templarg>FloatType</templarg>
    <member kind="typedef">
      <type>FloatType</type>
      <name>FloatType2</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Lorentz5Vector &amp;</type>
      <name>transform</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_1</anchor>
      <arglist>(FloatType m)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_2</anchor>
      <arglist>(FloatType x, FloatType y, FloatType z, FloatType t=FloatType())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_3</anchor>
      <arglist>(FloatType x, FloatType y, FloatType z, FloatType t, FloatType tau)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_4</anchor>
      <arglist>(const Vector3 &amp;, FloatType)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_5</anchor>
      <arglist>(FloatType, const Vector3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_6</anchor>
      <arglist>(const Vector3 &amp;, FloatType t, FloatType tau)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_7</anchor>
      <arglist>(const LorentzVector &amp;, FloatType)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_8</anchor>
      <arglist>(const Lorentz5Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_9</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Lorentz5Vector</name>
      <anchor>z9_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTau</name>
      <anchor>z11_0</anchor>
      <arglist>(FloatType)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMass</name>
      <anchor>z11_1</anchor>
      <arglist>(FloatType)</arglist>
    </member>
    <member kind="function">
      <type>Lorentz5Vector &amp;</type>
      <name>operator=</name>
      <anchor>z11_2</anchor>
      <arglist>(const Lorentz5Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Lorentz5Vector &amp;</type>
      <name>operator=</name>
      <anchor>z11_3</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleEnergy</name>
      <anchor>z13_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleRho</name>
      <anchor>z13_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleMass</name>
      <anchor>z13_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>massError</name>
      <anchor>z15_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>energyError</name>
      <anchor>z15_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>rhoError</name>
      <anchor>z15_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>operator()</name>
      <anchor>z17_0</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>operator[]</name>
      <anchor>z17_1</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>FloatType2</type>
      <name>mass2</name>
      <anchor>z17_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType2</type>
      <name>tau2</name>
      <anchor>z17_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>mass</name>
      <anchor>z17_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>tau</name>
      <anchor>z17_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>dirPlus</name>
      <anchor>z17_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>dirMinus</name>
      <anchor>z17_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FloatType</type>
      <name>mm</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LorentzRotation</name>
    <filename>classThePEG_1_1LorentzRotation.html</filename>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isIdentity</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation</type>
      <name>inverse</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>invert</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>print</name>
      <anchor>a4</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRotation</name>
      <anchor>z19_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRotation</name>
      <anchor>z19_1</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRotation</name>
      <anchor>z19_2</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRotation</name>
      <anchor>z19_3</anchor>
      <arglist>(const Hep3Vector &amp;b)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LorentzRotation</name>
      <anchor>z19_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setBoost</name>
      <anchor>z21_0</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setBoost</name>
      <anchor>z21_1</anchor>
      <arglist>(const Hep3Vector &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setBoostX</name>
      <anchor>z21_2</anchor>
      <arglist>(double boost)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setBoostY</name>
      <anchor>z21_3</anchor>
      <arglist>(double boost)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setBoostZ</name>
      <anchor>z21_4</anchor>
      <arglist>(double boost)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setRotate</name>
      <anchor>z21_5</anchor>
      <arglist>(double delta, const Hep3Vector &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setRotateX</name>
      <anchor>z21_6</anchor>
      <arglist>(double angle)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setRotateY</name>
      <anchor>z21_7</anchor>
      <arglist>(double angle)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>setRotateZ</name>
      <anchor>z21_8</anchor>
      <arglist>(double angle)</arglist>
    </member>
    <member kind="function">
      <type>const SpinHalfLorentzRotation &amp;</type>
      <name>half</name>
      <anchor>z23_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const SpinOneLorentzRotation &amp;</type>
      <name>one</name>
      <anchor>z23_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator const SpinOneLorentzRotation &amp;</name>
      <anchor>z23_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xx</name>
      <anchor>z25_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xy</name>
      <anchor>z25_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xz</name>
      <anchor>z25_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xt</name>
      <anchor>z25_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yx</name>
      <anchor>z25_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yy</name>
      <anchor>z25_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yz</name>
      <anchor>z25_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yt</name>
      <anchor>z25_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>zx</name>
      <anchor>z25_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>zy</name>
      <anchor>z25_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>zz</name>
      <anchor>z25_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>zt</name>
      <anchor>z25_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>tx</name>
      <anchor>z25_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ty</name>
      <anchor>z25_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>tz</name>
      <anchor>z25_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>tt</name>
      <anchor>z25_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s1</name>
      <anchor>z27_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s2</name>
      <anchor>z27_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s3</name>
      <anchor>z27_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s4</name>
      <anchor>z27_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s1</name>
      <anchor>z27_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s2</name>
      <anchor>z27_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s3</name>
      <anchor>z27_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s4</name>
      <anchor>z27_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s1</name>
      <anchor>z27_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s2</name>
      <anchor>z27_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s3</name>
      <anchor>z27_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s4</name>
      <anchor>z27_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s1</name>
      <anchor>z27_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s2</name>
      <anchor>z27_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s3</name>
      <anchor>z27_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s4</name>
      <anchor>z27_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>operator *</name>
      <anchor>z29_0</anchor>
      <arglist>(const LorentzVector &amp;lv) const </arglist>
    </member>
    <member kind="function">
      <type>Lorentz5Vector&lt; FloatType &gt;</type>
      <name>operator *</name>
      <anchor>z29_1</anchor>
      <arglist>(const Lorentz5Vector&lt; FloatType &gt; &amp;lv) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation</type>
      <name>operator *</name>
      <anchor>z29_2</anchor>
      <arglist>(const LorentzRotation &amp;lt) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>operator *=</name>
      <anchor>z29_3</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>transform</name>
      <anchor>z29_4</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>rotateX</name>
      <anchor>z29_5</anchor>
      <arglist>(double delta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>rotateY</name>
      <anchor>z29_6</anchor>
      <arglist>(double delta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>rotateZ</name>
      <anchor>z29_7</anchor>
      <arglist>(double delta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>rotate</name>
      <anchor>z29_8</anchor>
      <arglist>(double delta, const Hep3Vector &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>boostX</name>
      <anchor>z29_9</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>boostY</name>
      <anchor>z29_10</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>boostZ</name>
      <anchor>z29_11</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>boost</name>
      <anchor>z29_12</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRotation &amp;</type>
      <name>boost</name>
      <anchor>z29_13</anchor>
      <arglist>(const Hep3Vector &amp;bv)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinHalfLorentzRotation</type>
      <name>_half</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinOneLorentzRotation</type>
      <name>_one</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend LorentzRotation</type>
      <name>inverseOf</name>
      <anchor>n0</anchor>
      <arglist>(const LorentzRotation &amp;lt)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SpinHalfLorentzRotation</name>
    <filename>classThePEG_1_1SpinHalfLorentzRotation.html</filename>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isIdentity</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation</type>
      <name>inverse</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>invert</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::ostream &amp;</type>
      <name>print</name>
      <anchor>a4</anchor>
      <arglist>(std::ostream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinHalfLorentzRotation</name>
      <anchor>z31_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinHalfLorentzRotation</name>
      <anchor>z31_1</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinHalfLorentzRotation</name>
      <anchor>z31_2</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinHalfLorentzRotation</name>
      <anchor>z31_3</anchor>
      <arglist>(const Hep3Vector &amp;b)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SpinHalfLorentzRotation</name>
      <anchor>z31_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setBoost</name>
      <anchor>z33_0</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setBoost</name>
      <anchor>z33_1</anchor>
      <arglist>(const Hep3Vector &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setBoostX</name>
      <anchor>z33_2</anchor>
      <arglist>(double &amp;boost)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setBoostY</name>
      <anchor>z33_3</anchor>
      <arglist>(double &amp;boost)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setBoostZ</name>
      <anchor>z33_4</anchor>
      <arglist>(double &amp;boost)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setRotate</name>
      <anchor>z33_5</anchor>
      <arglist>(double delta, const Hep3Vector &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setRotateX</name>
      <anchor>z33_6</anchor>
      <arglist>(double &amp;angle)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setRotateY</name>
      <anchor>z33_7</anchor>
      <arglist>(double &amp;angle)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>setRotateZ</name>
      <anchor>z33_8</anchor>
      <arglist>(double &amp;angle)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s1</name>
      <anchor>z35_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s2</name>
      <anchor>z35_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s3</name>
      <anchor>z35_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1s4</name>
      <anchor>z35_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s1</name>
      <anchor>z35_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s2</name>
      <anchor>z35_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s3</name>
      <anchor>z35_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2s4</name>
      <anchor>z35_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s1</name>
      <anchor>z35_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s2</name>
      <anchor>z35_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s3</name>
      <anchor>z35_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3s4</name>
      <anchor>z35_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s1</name>
      <anchor>z35_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s2</name>
      <anchor>z35_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s3</name>
      <anchor>z35_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4s4</name>
      <anchor>z35_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z35_16</anchor>
      <arglist>(unsigned int, unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation</type>
      <name>operator *</name>
      <anchor>z37_0</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;lt) const </arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>operator *=</name>
      <anchor>z37_1</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>transform</name>
      <anchor>z37_2</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>rotateX</name>
      <anchor>z37_3</anchor>
      <arglist>(double delta)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>rotateY</name>
      <anchor>z37_4</anchor>
      <arglist>(double delta)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>rotateZ</name>
      <anchor>z37_5</anchor>
      <arglist>(double delta)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>rotate</name>
      <anchor>z37_6</anchor>
      <arglist>(double delta, const Hep3Vector &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>boostX</name>
      <anchor>z37_7</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>boostY</name>
      <anchor>z37_8</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>boostZ</name>
      <anchor>z37_9</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>boost</name>
      <anchor>z37_10</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>SpinHalfLorentzRotation &amp;</type>
      <name>boost</name>
      <anchor>z37_11</anchor>
      <arglist>(const Hep3Vector &amp;bv)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>SpinHalfLorentzRotation</name>
      <anchor>b0</anchor>
      <arglist>(Complex s1s1, Complex s1s2, Complex s1s3, Complex s1s4, Complex s2s1, Complex s2s2, Complex s2s3, Complex s2s4, Complex s3s1, Complex s3s2, Complex s3s3, Complex s3s4, Complex s4s1, Complex s4s2, Complex s4s3, Complex s4s4)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_mx</name>
      <anchor>r0</anchor>
      <arglist>[4][4]</arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend SpinHalfLorentzRotation</type>
      <name>inverseOf</name>
      <anchor>n0</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;lt)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Transverse</name>
    <filename>classThePEG_1_1Transverse.html</filename>
    <templarg>FloatType</templarg>
    <member kind="typedef">
      <type>FloatType</type>
      <name>FloatType2</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; FloatType, FloatType &gt;</type>
      <name>BasePair</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_1</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_2</anchor>
      <arglist>(const BasePair &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_3</anchor>
      <arglist>(FloatType x, FloatType y)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_4</anchor>
      <arglist>(const Vector3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_5</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z39_6</anchor>
      <arglist>(const Lorentz5Vector&lt; FloatType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z41_0</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z41_1</anchor>
      <arglist>(const BasePair &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z41_2</anchor>
      <arglist>(const Vector3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z41_3</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z41_4</anchor>
      <arglist>(const Lorentz5Vector&lt; FloatType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Transverse</type>
      <name>operator-</name>
      <anchor>z43_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Transverse</type>
      <name>operator-</name>
      <anchor>z43_1</anchor>
      <arglist>(const Transverse &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Transverse &amp;</type>
      <name>operator-=</name>
      <anchor>z43_2</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Transverse</type>
      <name>operator+</name>
      <anchor>z43_3</anchor>
      <arglist>(const Transverse &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Transverse &amp;</type>
      <name>operator+=</name>
      <anchor>z43_4</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>x</name>
      <anchor>z45_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>y</name>
      <anchor>z45_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType2</type>
      <name>pt2</name>
      <anchor>z45_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>pt</name>
      <anchor>z45_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>phi</name>
      <anchor>z45_4</anchor>
      <arglist>() const </arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IteratorRange</name>
    <filename>structThePEG_1_1IteratorRange.html</filename>
    <templarg>Iterator</templarg>
    <member kind="typedef">
      <type>std::pair&lt; Iterator, Iterator &gt;</type>
      <name>BaseType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IteratorRange</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IteratorRange</name>
      <anchor>a1</anchor>
      <arglist>(const IteratorRange &amp;ir)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IteratorRange</name>
      <anchor>a2</anchor>
      <arglist>(const BaseType &amp;ir)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Base</name>
    <filename>structThePEG_1_1Base.html</filename>
    <base>ThePEG::Pointer::ReferenceCounted</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Base</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::TraitsType</name>
    <filename>structThePEG_1_1TraitsType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Veto</name>
    <filename>structThePEG_1_1Veto.html</filename>
    <member kind="function">
      <type></type>
      <name>Veto</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Stop</name>
    <filename>structThePEG_1_1Stop.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits</name>
    <filename>structThePEG_1_1MultiplicationTraits.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits&lt; Lorentz5Vector&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1MultiplicationTraits_3_01Lorentz5Vector_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits&lt; LorentzVector &gt;</name>
    <filename>structThePEG_1_1MultiplicationTraits_3_01LorentzVector_01_4.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits&lt; Vector3 &gt;</name>
    <filename>structThePEG_1_1MultiplicationTraits_3_01Vector3_01_4.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Collision</name>
    <filename>classThePEG_1_1Collision.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Collision</name>
      <anchor>a2</anchor>
      <arglist>(const PPair &amp;newIncoming, tEventPtr newEvent=tEventPtr(), tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Collision</name>
      <anchor>a3</anchor>
      <arglist>(const Collision &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Collision</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>a5</anchor>
      <arglist>(tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addStep</name>
      <anchor>a6</anchor>
      <arglist>(tStepPtr s)</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>event</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const LorentzPoint &amp;</type>
      <name>vertex</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>vertex</name>
      <anchor>a10</anchor>
      <arglist>(const LorentzPoint &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>a11</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>m2</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a13</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a14</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z51_0</anchor>
      <arglist>(OutputIterator r, const SelectorBase &amp;s) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>selectFinalState</name>
      <anchor>z51_1</anchor>
      <arglist>(OutputIterator r) const </arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>getFinalState</name>
      <anchor>z51_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tSubProPtr</type>
      <name>primarySubProcess</name>
      <anchor>z51_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const SubProcessVector &amp;</type>
      <name>subProcesses</name>
      <anchor>z51_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcStepPtr</type>
      <name>finalStep</name>
      <anchor>z51_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>finalStep</name>
      <anchor>z51_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const StepVector &amp;</type>
      <name>steps</name>
      <anchor>z51_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcStepPtr</type>
      <name>step</name>
      <anchor>z51_8</anchor>
      <arglist>(unsigned int i) const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>z51_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>getRemnants</name>
      <anchor>z51_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isRemnant</name>
      <anchor>z51_11</anchor>
      <arglist>(tPPtr) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeDecay</name>
      <anchor>z53_0</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeParticle</name>
      <anchor>z53_1</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cleanSteps</name>
      <anchor>z53_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>popStep</name>
      <anchor>z53_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const ParticleSet &amp;</type>
      <name>all</name>
      <anchor>b0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>CollPtr</type>
      <name>clone</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b2</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addSubProcess</name>
      <anchor>z55_0</anchor>
      <arglist>(tSubProPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticles</name>
      <anchor>z55_1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticle</name>
      <anchor>z55_2</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>z55_3</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Collision</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Collision &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Collision &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepVector</type>
      <name>theSteps</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubProcessVector</type>
      <name>theSubProcesses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>allParticles</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEventPtr</type>
      <name>theEvent</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LorentzPoint</type>
      <name>theVertex</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Collision &gt;</type>
      <name>initCollision</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>EventHandler</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Event</name>
      <anchor>n1</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Step</name>
      <anchor>n2</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt;Collision&gt;</name>
      <anchor>n3</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>n4</anchor>
      <arglist>(ostream &amp;os, const Collision &amp;c)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Collision, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Collision_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Collision &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Collision_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Collision &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourBase</name>
    <filename>classThePEG_1_1ColourBase.html</filename>
    <base>ThePEG::EventInfoBase</base>
    <member kind="function">
      <type></type>
      <name>ColourBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourBase</name>
      <anchor>a1</anchor>
      <arglist>(const ColourBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>antiColourLine</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>colourLine</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a5</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a6</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a7</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>antiColourLine</name>
      <anchor>d0</anchor>
      <arglist>(tColinePtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>colourLine</name>
      <anchor>d1</anchor>
      <arglist>(tColinePtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ColourBase &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ColourBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ColinePtr</type>
      <name>theAntiColourLine</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ColinePtr</type>
      <name>theColourLine</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ColourBase &gt;</type>
      <name>initColourBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>ColourLine</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ColourBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ColourBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventInfoBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ColourBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ColourBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ColourBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourLine</name>
    <filename>classThePEG_1_1ColourLine.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>ColourLine</name>
      <anchor>z57_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLine</name>
      <anchor>z57_1</anchor>
      <arglist>(const ColourLine &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tColinePtr</type>
      <name>create</name>
      <anchor>z57_2</anchor>
      <arglist>(tPPtr col, tPPtr anti)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tColinePtr</type>
      <name>create</name>
      <anchor>z57_3</anchor>
      <arglist>(tPPtr p, bool anti=false)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tColinePtr</type>
      <name>createAnti</name>
      <anchor>z57_4</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourLine</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::iterator_traits&lt; Iterator &gt;::value_type</type>
      <name>getColouredParticle</name>
      <anchor>a1</anchor>
      <arglist>(Iterator first, Iterator last, bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a2</anchor>
      <arglist>(ostream &amp;os, tcEventPtr event, bool anti)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a3</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a4</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>coloured</name>
      <anchor>z59_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>antiColoured</name>
      <anchor>z59_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>startParticle</name>
      <anchor>z59_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>endParticle</name>
      <anchor>z59_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addAntiColoured</name>
      <anchor>z61_0</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addColoured</name>
      <anchor>z61_1</anchor>
      <arglist>(tPPtr p, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeAntiColoured</name>
      <anchor>z61_2</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeColoured</name>
      <anchor>z61_3</anchor>
      <arglist>(tPPtr p, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>tColinePair</type>
      <name>sinkNeighbours</name>
      <anchor>z63_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tColinePair</type>
      <name>sourceNeighbours</name>
      <anchor>z63_1</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSinkNeighbours</name>
      <anchor>z63_2</anchor>
      <arglist>(tColinePtr, tColinePtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSourceNeighbours</name>
      <anchor>z63_3</anchor>
      <arglist>(tColinePtr, tColinePtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ColourLine &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ColourLine &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theColoured</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theAntiColoured</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tColinePair</type>
      <name>theSourceNeighbours</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tColinePair</type>
      <name>theSinkNeighbours</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ColourLine &gt;</type>
      <name>initColourLine</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ColourLine, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ColourLine_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ColourLine &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ColourLine_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ColourLine &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourSinglet</name>
    <filename>classThePEG_1_1ColourSinglet.html</filename>
    <member kind="typedef">
      <type>deque&lt; tcPPtr &gt;</type>
      <name>StringPiece</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>StringPiece::size_type</type>
      <name>Index</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; Index, Index &gt;</type>
      <name>Junction</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>a1</anchor>
      <arglist>(const ColourSinglet &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>a2</anchor>
      <arglist>(tcColinePtr cl, tcParticleSet &amp;left)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ColourSinglet</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const ColourSinglet &amp;)</arglist>
    </member>
    <member kind="function">
      <type>tcPVector &amp;</type>
      <name>partons</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const tcPVector &amp;</type>
      <name>partons</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPPtr</type>
      <name>parton</name>
      <anchor>a7</anchor>
      <arglist>(tcPVector::size_type i) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzMomentum</type>
      <name>momentum</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Index</type>
      <name>nPieces</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>StringPiece &amp;</type>
      <name>piece</name>
      <anchor>a10</anchor>
      <arglist>(Index i)</arglist>
    </member>
    <member kind="function">
      <type>const StringPiece &amp;</type>
      <name>piece</name>
      <anchor>a11</anchor>
      <arglist>(Index i) const </arglist>
    </member>
    <member kind="function">
      <type>Junction &amp;</type>
      <name>junction</name>
      <anchor>a12</anchor>
      <arglist>(Index i, bool forward)</arglist>
    </member>
    <member kind="function">
      <type>const Junction &amp;</type>
      <name>junction</name>
      <anchor>a13</anchor>
      <arglist>(Index i, bool forward) const </arglist>
    </member>
    <member kind="function">
      <type>Junction &amp;</type>
      <name>sink</name>
      <anchor>a14</anchor>
      <arglist>(Index i)</arglist>
    </member>
    <member kind="function">
      <type>const Junction &amp;</type>
      <name>sink</name>
      <anchor>a15</anchor>
      <arglist>(Index i) const </arglist>
    </member>
    <member kind="function">
      <type>Junction &amp;</type>
      <name>source</name>
      <anchor>a16</anchor>
      <arglist>(Index i)</arglist>
    </member>
    <member kind="function">
      <type>const Junction &amp;</type>
      <name>source</name>
      <anchor>a17</anchor>
      <arglist>(Index i) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDVector</type>
      <name>getTripletData</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitInternal</name>
      <anchor>a19</anchor>
      <arglist>(Index sp=0)</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitInternal</name>
      <anchor>a20</anchor>
      <arglist>(Index sp, Index sa, Index sc, const vector&lt; bool &gt; &amp;assing)</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitDiQuarkJunction</name>
      <anchor>a21</anchor>
      <arglist>(Index sp, tcPPtr diq, tcPPair qq, const vector&lt; bool &gt; &amp;assign=vector&lt; bool &gt;())</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitDiDiQuark</name>
      <anchor>a22</anchor>
      <arglist>(tcPPair qq1, tcPPair qq2, const vector&lt; bool &gt; &amp;assign=vector&lt; bool &gt;())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a23</anchor>
      <arglist>(ColourSinglet &amp;x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; ColourSinglet &gt;</type>
      <name>getSinglets</name>
      <anchor>e0</anchor>
      <arglist>(tcParticleSet &amp;left)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; ColourSinglet &gt;</type>
      <name>getSinglets</name>
      <anchor>e1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>b0</anchor>
      <arglist>(const ColourSinglet &amp;cs, Index si)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>fill</name>
      <anchor>d0</anchor>
      <arglist>(Index s0, bool forward, tcColinePtr first, tcParticleSet &amp;left)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>fill</name>
      <anchor>d1</anchor>
      <arglist>(Index i0, bool forward, const ColourSinglet &amp;cs, Index i1)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Index</type>
      <name>addPiece</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Junction</type>
      <name>addJunction</name>
      <anchor>d3</anchor>
      <arglist>(Index s0, bool forward)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcPVector</type>
      <name>thePartons</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; StringPiece &gt;</type>
      <name>thePieces</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Junction &gt;</type>
      <name>theSources</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Junction &gt;</type>
      <name>theSinks</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourSinglet::ColourSingletException</name>
    <filename>classThePEG_1_1ColourSinglet_1_1ColourSingletException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourSinglet::ColourSingletException</name>
    <filename>classThePEG_1_1ColourSinglet_1_1ColourSingletException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::Event</name>
    <filename>classThePEG_1_1Event.html</filename>
    <base>ThePEG::Base</base>
    <base>ThePEG::Named</base>
    <member kind="typedef">
      <type>map&lt; tcColinePtr, int &gt;</type>
      <name>ColourLineMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Event</name>
      <anchor>a2</anchor>
      <arglist>(const PPair &amp;newIncoming, tcEventBasePtr newHandler=tcEventBasePtr(), string newName=&quot;&quot;, long newNumber=-1, double weight=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Event</name>
      <anchor>a3</anchor>
      <arglist>(const Event &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Event</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>clone</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>newCollision</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>a9</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>number</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>colourLineIndex</name>
      <anchor>a11</anchor>
      <arglist>(tcColinePtr) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>weight</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>weight</name>
      <anchor>a13</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setInfo</name>
      <anchor>a14</anchor>
      <arglist>(tcEventBasePtr newHandler, string newName, long newNumber, double weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addCollision</name>
      <anchor>a15</anchor>
      <arglist>(tCollPtr c)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>primaryCollision</name>
      <anchor>a16</anchor>
      <arglist>(tCollPtr c)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a17</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a18</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z65_0</anchor>
      <arglist>(OutputIterator r, const SelectorBase &amp;s) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>selectFinalState</name>
      <anchor>z65_1</anchor>
      <arglist>(OutputIterator r) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getFinalState</name>
      <anchor>z65_2</anchor>
      <arglist>(Container c) const </arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>getFinalState</name>
      <anchor>z65_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>primaryCollision</name>
      <anchor>z65_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const CollisionVector &amp;</type>
      <name>collisions</name>
      <anchor>z65_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tSubProPtr</type>
      <name>primarySubProcess</name>
      <anchor>z65_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>z65_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeDecay</name>
      <anchor>z67_0</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeParticle</name>
      <anchor>z67_1</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cleanSteps</name>
      <anchor>z67_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticles</name>
      <anchor>b0</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticle</name>
      <anchor>b1</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addSubProcess</name>
      <anchor>b2</anchor>
      <arglist>(tSubProPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addStep</name>
      <anchor>b3</anchor>
      <arglist>(tStepPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>b4</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b5</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Event</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Event &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Event &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CollisionVector</type>
      <name>theCollisions</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepSet</type>
      <name>allSteps</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubProcessSet</type>
      <name>allSubProcesses</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>allParticles</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ColourLineMap</type>
      <name>theColourLines</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNumber</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theWeight</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Event &gt;</type>
      <name>initEvent</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>EventHandler</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Collision</name>
      <anchor>n1</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt;Event&gt;</name>
      <anchor>n2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Event, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Event_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Event &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Event_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Event &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventConfig</name>
    <filename>structThePEG_1_1EventConfig.html</filename>
    <member kind="function" static="yes">
      <type>void</type>
      <name>putHandler</name>
      <anchor>e0</anchor>
      <arglist>(PersistentOStream &amp;os, tcEventBasePtr h)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>getHandler</name>
      <anchor>e1</anchor>
      <arglist>(PersistentIStream &amp;is, tcEventBasePtr &amp;h)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>putParticleData</name>
      <anchor>e2</anchor>
      <arglist>(PersistentOStream &amp;os, tcEventPDPtr pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>getParticleData</name>
      <anchor>e3</anchor>
      <arglist>(PersistentIStream &amp;is, cEventPDPtr &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>nameHandler</name>
      <anchor>e4</anchor>
      <arglist>(tcEventBasePtr h)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>tcEventBasePtr</type>
      <name>currentGenerator</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventInfoBase</name>
    <filename>classThePEG_1_1EventInfoBase.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>EventInfoBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventInfoBase</name>
      <anchor>a1</anchor>
      <arglist>(const EventInfoBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventInfoBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a3</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventInfoBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const EventInfoBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; EventInfoBase &gt;</type>
      <name>initEventInfoBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventInfoBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventInfoBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventInfoBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventInfoBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventInfoBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Particle</name>
    <filename>classThePEG_1_1Particle.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>z69_0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>z69_1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Particle</name>
      <anchor>z69_2</anchor>
      <arglist>(tcEventPDPtr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Particle</name>
      <anchor>z69_3</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Particle</name>
      <anchor>z69_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>decayed</name>
      <anchor>z71_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleVector &amp;</type>
      <name>children</name>
      <anchor>z71_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addChild</name>
      <anchor>z71_2</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>abandonChild</name>
      <anchor>z71_3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>const tParticleVector &amp;</type>
      <name>parents</name>
      <anchor>z71_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>siblings</name>
      <anchor>z71_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>undecay</name>
      <anchor>z71_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>decayMode</name>
      <anchor>z71_7</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function">
      <type>tDMPtr</type>
      <name>decayMode</name>
      <anchor>z71_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>next</name>
      <anchor>z71_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>previous</name>
      <anchor>z71_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPPtr</type>
      <name>original</name>
      <anchor>z71_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>original</name>
      <anchor>z71_12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcPPtr</type>
      <name>final</name>
      <anchor>z71_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>final</name>
      <anchor>z71_14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>birthStep</name>
      <anchor>z73_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>number</name>
      <anchor>z73_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleDataClass &amp;</type>
      <name>data</name>
      <anchor>z75_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcEventPDPtr</type>
      <name>dataPtr</name>
      <anchor>z75_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>PDGName</name>
      <anchor>z75_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>id</name>
      <anchor>z75_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>momentum</name>
      <anchor>z77_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>z77_1</anchor>
      <arglist>(const Momentum3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>z77_2</anchor>
      <arglist>(const LorentzMomentum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>z77_3</anchor>
      <arglist>(const Lorentz5Momentum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mass</name>
      <anchor>z77_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>nominalMass</name>
      <anchor>z77_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scale</name>
      <anchor>z77_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>z77_7</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>mt2</name>
      <anchor>z77_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mt</name>
      <anchor>z77_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>perpmass2</name>
      <anchor>z77_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>perpmass</name>
      <anchor>z77_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rapidity</name>
      <anchor>z77_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eta</name>
      <anchor>z77_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>Pplus</name>
      <anchor>z77_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>Pminus</name>
      <anchor>z77_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const LorentzPoint &amp;</type>
      <name>vertex</name>
      <anchor>z79_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPoint</type>
      <name>labVertex</name>
      <anchor>z79_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPoint</type>
      <name>decayVertex</name>
      <anchor>z79_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPoint</type>
      <name>labDecayVertex</name>
      <anchor>z79_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Distance &amp;</type>
      <name>lifeLength</name>
      <anchor>z79_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVertex</name>
      <anchor>z79_5</anchor>
      <arglist>(const LorentzPoint &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLabVertex</name>
      <anchor>z79_6</anchor>
      <arglist>(const LorentzPoint &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLifeLength</name>
      <anchor>z79_7</anchor>
      <arglist>(const Distance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLifeLength</name>
      <anchor>z79_8</anchor>
      <arglist>(const LorentzDistance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLifeLength</name>
      <anchor>z79_9</anchor>
      <arglist>(const Lorentz5Distance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Time</type>
      <name>lifeTime</name>
      <anchor>z79_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>z81_0</anchor>
      <arglist>(const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>boost</name>
      <anchor>z81_1</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>boost</name>
      <anchor>z81_2</anchor>
      <arglist>(const Vector3 &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotateX</name>
      <anchor>z81_3</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotateY</name>
      <anchor>z81_4</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotateZ</name>
      <anchor>z81_5</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotate</name>
      <anchor>z81_6</anchor>
      <arglist>(double a, const Vector3 &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>mirror</name>
      <anchor>z81_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepTransform</name>
      <anchor>z81_8</anchor>
      <arglist>(const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepBoost</name>
      <anchor>z81_9</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepBoost</name>
      <anchor>z81_10</anchor>
      <arglist>(const Vector3 &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotateX</name>
      <anchor>z81_11</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotateY</name>
      <anchor>z81_12</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotateZ</name>
      <anchor>z81_13</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotate</name>
      <anchor>z81_14</anchor>
      <arglist>(double a, const Vector3 &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>massError</name>
      <anchor>z83_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>energyError</name>
      <anchor>z83_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>rhoError</name>
      <anchor>z83_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleEnergy</name>
      <anchor>z83_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleRho</name>
      <anchor>z83_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleMass</name>
      <anchor>z83_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasColourInfo</name>
      <anchor>z85_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>antiColourLine</name>
      <anchor>z85_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>colourLine</name>
      <anchor>z85_2</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>coloured</name>
      <anchor>z85_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasColour</name>
      <anchor>z85_4</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAntiColour</name>
      <anchor>z85_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcCBPtr</type>
      <name>colourInfo</name>
      <anchor>z85_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tCBPtr</type>
      <name>colourInfo</name>
      <anchor>z85_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourInfo</name>
      <anchor>z85_8</anchor>
      <arglist>(tCBPtr)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>colourNeighbour</name>
      <anchor>z85_9</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>antiColourNeighbour</name>
      <anchor>z85_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourNeighbour</name>
      <anchor>z85_11</anchor>
      <arglist>(tPPtr, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>antiColourNeighbour</name>
      <anchor>z85_12</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>antiColourConnect</name>
      <anchor>z85_13</anchor>
      <arglist>(tPPtr neighbour)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourConnect</name>
      <anchor>z85_14</anchor>
      <arglist>(tPPtr neighbour, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>incomingColour</name>
      <anchor>z85_15</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>incomingAntiColour</name>
      <anchor>z85_16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>incomingColour</name>
      <anchor>z85_17</anchor>
      <arglist>(tPPtr, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>incomingAntiColour</name>
      <anchor>z85_18</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>outgoingColour</name>
      <anchor>z85_19</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>outgoingAntiColour</name>
      <anchor>z85_20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outgoingColour</name>
      <anchor>z85_21</anchor>
      <arglist>(tPPtr, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outgoingAntiColour</name>
      <anchor>z85_22</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourFlow</name>
      <anchor>z85_23</anchor>
      <arglist>(tPPtr child, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>antiColourFlow</name>
      <anchor>z85_24</anchor>
      <arglist>(tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetColour</name>
      <anchor>z85_25</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcSpinPtr</type>
      <name>spinInfo</name>
      <anchor>z87_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tSpinPtr</type>
      <name>spinInfo</name>
      <anchor>z87_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spinInfo</name>
      <anchor>z87_2</anchor>
      <arglist>(tSpinPtr s)</arglist>
    </member>
    <member kind="function">
      <type>const EIVector &amp;</type>
      <name>getInfo</name>
      <anchor>z89_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>EIVector &amp;</type>
      <name>getInfo</name>
      <anchor>z89_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasRep</name>
      <anchor>z91_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initFull</name>
      <anchor>z91_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z93_0</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z93_1</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PrintParticles</name>
      <anchor>e0</anchor>
      <arglist>(ostream &amp;os, Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PrintParticles</name>
      <anchor>e1</anchor>
      <arglist>(ostream &amp;os, const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>string</type>
      <name>outputFormat</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual PPtr</type>
      <name>clone</name>
      <anchor>d0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>d1</anchor>
      <arglist>(const EventTranslationMap &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>number</name>
      <anchor>d2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>removeChild</name>
      <anchor>d3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>removeParent</name>
      <anchor>d4</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>mass</name>
      <anchor>d5</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>lifeTime</name>
      <anchor>d6</anchor>
      <arglist>(Length)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleRep &amp;</type>
      <name>rep</name>
      <anchor>d7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ParticleRep &amp;</type>
      <name>rep</name>
      <anchor>d8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Particle</name>
      <anchor>d9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Particle &amp;</type>
      <name>operator=</name>
      <anchor>d10</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cEventPDPtr</type>
      <name>theData</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>theMomentum</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleRep *</type>
      <name>theRep</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Particle &gt;</type>
      <name>initParticle</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Event</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Collision</name>
      <anchor>n1</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Step</name>
      <anchor>n2</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>SubProcess</name>
      <anchor>n3</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>ParticleData</name>
      <anchor>n4</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt;Particle&gt;</name>
      <anchor>n5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Particle::ParticleRep</name>
    <filename>structThePEG_1_1Particle_1_1ParticleRep.html</filename>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleRep &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>tParticleVector</type>
      <name>theParents</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleVector</type>
      <name>theChildren</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tPPtr</type>
      <name>thePrevious</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>PPtr</type>
      <name>theNext</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tDMPtr</type>
      <name>theDecayMode</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tStepPtr</type>
      <name>theBirthStep</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>LorentzPoint</type>
      <name>theVertex</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Lorentz5Distance</type>
      <name>theLifeLength</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Energy2</type>
      <name>theScale</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>theNumber</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>CBPtr</type>
      <name>theColourInfo</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpinPtr</type>
      <name>theSpinInfo</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>EIVector</type>
      <name>theExtraInfo</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Particle::ParticleRep</name>
    <filename>structThePEG_1_1Particle_1_1ParticleRep.html</filename>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleRep &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>tParticleVector</type>
      <name>theParents</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleVector</type>
      <name>theChildren</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tPPtr</type>
      <name>thePrevious</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>PPtr</type>
      <name>theNext</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tDMPtr</type>
      <name>theDecayMode</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tStepPtr</type>
      <name>theBirthStep</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>LorentzPoint</type>
      <name>theVertex</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Lorentz5Distance</type>
      <name>theLifeLength</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Energy2</type>
      <name>theScale</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>theNumber</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>CBPtr</type>
      <name>theColourInfo</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpinPtr</type>
      <name>theSpinInfo</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>EIVector</type>
      <name>theExtraInfo</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Particle, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Particle_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Particle &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Particle_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Particle &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits</name>
    <filename>structThePEG_1_1ParticleTraits.html</filename>
    <templarg>PType</templarg>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>PType &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(PType &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzMomentum</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(PType &amp;p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(PType &amp;p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e6</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; PPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01PPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(tPPtr p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(tPPtr p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(tPPtr p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e6</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; cPPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01cPPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>const Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tcPPtr &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e3</anchor>
      <arglist>(tcPPtr &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; tPPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01tPPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(tPPtr p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(tPPtr p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(tPPtr p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e6</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; tcPPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01tcPPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>const Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e3</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; LorentzMomentum &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01LorentzMomentum_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>LorentzMomentum &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(LorentzMomentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(const LorentzMomentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const LorentzMomentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(LorentzMomentum &amp;p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(LorentzMomentum &amp;p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(LorentzMomentum &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; Lorentz5Momentum &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01Lorentz5Momentum_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>Lorentz5Momentum &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(Lorentz5Momentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(Lorentz5Momentum &amp;p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(Lorentz5Momentum &amp;p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(Lorentz5Momentum &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Transformer</name>
    <filename>structThePEG_1_1Transformer.html</filename>
    <member kind="function">
      <type></type>
      <name>Transformer</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzRotation &amp;rin)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transformer</name>
      <anchor>a1</anchor>
      <arglist>(const Transformer &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
    <member kind="variable">
      <type>const LorentzRotation &amp;</type>
      <name>r</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectorBase</name>
    <filename>classThePEG_1_1SelectorBase.html</filename>
    <member kind="function">
      <type></type>
      <name>SelectorBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SelectorBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleSelector</name>
    <filename>structThePEG_1_1ParticleSelector.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>ParticleSelector</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParticleSelector</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectIfNot</name>
    <filename>classThePEG_1_1SelectIfNot.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>SelectIfNot</name>
      <anchor>a0</anchor>
      <arglist>(const SelectorBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SelectIfNot</name>
      <anchor>a1</anchor>
      <arglist>(const SelectIfNot &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SelectIfNot</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectIfBoth</name>
    <filename>classThePEG_1_1SelectIfBoth.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>SelectIfBoth</name>
      <anchor>a0</anchor>
      <arglist>(const SelectorBase &amp;, const SelectorBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SelectIfBoth</name>
      <anchor>a1</anchor>
      <arglist>(const SelectIfBoth &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SelectIfBoth</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s1</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectIfEither</name>
    <filename>classThePEG_1_1SelectIfEither.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>SelectIfEither</name>
      <anchor>a0</anchor>
      <arglist>(const SelectorBase &amp;, const SelectorBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SelectIfEither</name>
      <anchor>a1</anchor>
      <arglist>(const SelectIfEither &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SelectIfEither</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s1</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SpinBase</name>
    <filename>classThePEG_1_1SpinBase.html</filename>
    <base>ThePEG::EventInfoBase</base>
    <member kind="function">
      <type></type>
      <name>SpinBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinBase</name>
      <anchor>a1</anchor>
      <arglist>(const SpinBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SpinBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>hasPolarization</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DPair</type>
      <name>polarization</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a5</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a6</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SpinBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SpinBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; SpinBase &gt;</type>
      <name>initSpinBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SpinBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SpinBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventInfoBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SpinBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SpinBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SpinBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::AllSelector</name>
    <filename>structThePEG_1_1AllSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FinalStateSelector</name>
    <filename>structThePEG_1_1FinalStateSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IntermediateSelector</name>
    <filename>structThePEG_1_1IntermediateSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PrimaryCollisionSelector</name>
    <filename>structThePEG_1_1PrimaryCollisionSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ChargedSelector</name>
    <filename>structThePEG_1_1ChargedSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Step</name>
    <filename>classThePEG_1_1Step.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Step</name>
      <anchor>a2</anchor>
      <arglist>(tCollPtr newCollision=tCollPtr(), tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Step</name>
      <anchor>a3</anchor>
      <arglist>(const Step &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Step</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>collision</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>a7</anchor>
      <arglist>(OutputIterator r, const SelectorBase &amp;s) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>selectFinalState</name>
      <anchor>a8</anchor>
      <arglist>(OutputIterator r) const </arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>getFinalState</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>all</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>particles</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>intermediates</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const SubProcessVector &amp;</type>
      <name>subProcesses</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>find</name>
      <anchor>a15</anchor>
      <arglist>(tcPPtr) const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>copyParticle</name>
      <anchor>a16</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>setCopy</name>
      <anchor>a17</anchor>
      <arglist>(tcPPtr pold, tPPtr pnew)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>insertCopy</name>
      <anchor>a18</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a19</anchor>
      <arglist>(tcPPtr parent, tPPtr child, bool fixColour=true)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a20</anchor>
      <arglist>(tcPPtr parent, CIterator firstChild, CIterator lastChild, bool fixColour=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addDecayNoCheck</name>
      <anchor>a21</anchor>
      <arglist>(tPPtr parent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addDecayProduct</name>
      <anchor>a22</anchor>
      <arglist>(tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>removeDecayProduct</name>
      <anchor>a23</anchor>
      <arglist>(tcPPtr parent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>removeDecayProduct</name>
      <anchor>a24</anchor>
      <arglist>(tcPPtr parent, CIterator firstChild, CIterator lastChild)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a25</anchor>
      <arglist>(Iterator firstParent, Iterator lastParent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a26</anchor>
      <arglist>(PIterator firstParent, PIterator lastParent, CIterator firstChild, CIterator lastChild)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fixColourFlow</name>
      <anchor>a27</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>colourNeighbour</name>
      <anchor>a28</anchor>
      <arglist>(tcPPtr particle, bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>antiColourNeighbour</name>
      <anchor>a29</anchor>
      <arglist>(tcPPtr particle) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addParticles</name>
      <anchor>a30</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addParticle</name>
      <anchor>a31</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIntermediates</name>
      <anchor>a32</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIntermediate</name>
      <anchor>a33</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>insertIntermediate</name>
      <anchor>a34</anchor>
      <arglist>(tPPtr p, tPPtr parent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addSubProcess</name>
      <anchor>a35</anchor>
      <arglist>(tSubProPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeParticle</name>
      <anchor>a36</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>nullStep</name>
      <anchor>a37</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>getCurrent</name>
      <anchor>a38</anchor>
      <arglist>(const Cont &amp;c) const </arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>getCurrent</name>
      <anchor>a39</anchor>
      <arglist>(Iterator first, Iterator last) const </arglist>
    </member>
    <member kind="function">
      <type>StepPtr</type>
      <name>clone</name>
      <anchor>a40</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a41</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a42</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; tPVector &gt;</type>
      <name>getSinglets</name>
      <anchor>e0</anchor>
      <arglist>(PIterator first, PIterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>b0</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addIfFinal</name>
      <anchor>b2</anchor>
      <arglist>(Inserter o, PPointer p)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>vector&lt; tPVector &gt;</type>
      <name>getSinglets</name>
      <anchor>f0</anchor>
      <arglist>(tParticleSet &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Step &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Step &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>collision</name>
      <anchor>d1</anchor>
      <arglist>(tCollPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>handler</name>
      <anchor>d2</anchor>
      <arglist>(tcEventBasePtr)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>theParticles</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>theIntermediates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubProcessVector</type>
      <name>theSubProcesses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>allParticles</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tCollPtr</type>
      <name>theCollision</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Step &gt;</type>
      <name>initStep</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Collision</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Event</name>
      <anchor>n1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Step, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Step_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Step &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Step_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Step &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SubProcess</name>
    <filename>classThePEG_1_1SubProcess.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcess</name>
      <anchor>a2</anchor>
      <arglist>(const PPair &amp;newIncoming, tCollPtr newCollision=tCollPtr(), tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcess</name>
      <anchor>a3</anchor>
      <arglist>(const SubProcess &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SubProcess</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>collision</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleVector &amp;</type>
      <name>intermediates</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleVector &amp;</type>
      <name>outgoing</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setOutgoing</name>
      <anchor>a10</anchor>
      <arglist>(InputIterator, InputIterator)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addOutgoing</name>
      <anchor>a11</anchor>
      <arglist>(tPPtr p, bool fixrelations=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setIntermediates</name>
      <anchor>a12</anchor>
      <arglist>(InputIterator, InputIterator)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIntermediate</name>
      <anchor>a13</anchor>
      <arglist>(tPPtr p, bool fixrelations=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>a14</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>SubProPtr</type>
      <name>clone</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>a16</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>shat</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>that</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uhat</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a20</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a21</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SubProcess</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SubProcess &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const SubProcess &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tCollPtr</type>
      <name>theCollision</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleVector</type>
      <name>theIntermediates</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleVector</type>
      <name>theOutgoing</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SubProcess &gt;</type>
      <name>initSubProcess</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Step</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Collision</name>
      <anchor>n1</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt;SubProcess&gt;</name>
      <anchor>n2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SubProcess, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SubProcess_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SubProcess &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SubProcess_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SubProcess &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ACDCSampler</name>
    <filename>classThePEG_1_1ACDCSampler.html</filename>
    <base>ThePEG::SamplerBase</base>
    <member kind="typedef">
      <type>ACDCGenerator::ACDCGen&lt; UseRandom, tStdEHPtr &gt;</type>
      <name>SamplerType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCSampler</name>
      <anchor>z95_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCSampler</name>
      <anchor>z95_1</anchor>
      <arglist>(const ACDCSampler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ACDCSampler</name>
      <anchor>z95_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z97_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z97_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>lastBin</name>
      <anchor>z97_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rejectLast</name>
      <anchor>z97_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>integratedXSec</name>
      <anchor>z97_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>sumWeights</name>
      <anchor>z97_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z99_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z99_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z101_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z101_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z103_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z103_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z103_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z103_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z103_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z103_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCSampler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ACDCSampler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SamplerType</type>
      <name>theSampler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMargin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNTry</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ACDCSampler &gt;</type>
      <name>initACDCSampler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ACDCSampler::ACDCStillCompensating</name>
    <filename>structThePEG_1_1ACDCSampler_1_1ACDCStillCompensating.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ACDCSampler::EventInitNoXSec</name>
    <filename>structThePEG_1_1ACDCSampler_1_1EventInitNoXSec.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ACDCSampler::EventLoopException</name>
    <filename>structThePEG_1_1ACDCSampler_1_1EventLoopException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ACDCSampler::ACDCStillCompensating</name>
    <filename>structThePEG_1_1ACDCSampler_1_1ACDCStillCompensating.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ACDCSampler::EventInitNoXSec</name>
    <filename>structThePEG_1_1ACDCSampler_1_1EventInitNoXSec.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ACDCSampler::EventLoopException</name>
    <filename>structThePEG_1_1ACDCSampler_1_1EventLoopException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ACDCSampler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ACDCSampler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>SamplerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ACDCSampler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ACDCSampler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ACDCSampler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AnalysisHandler</name>
    <filename>classThePEG_1_1AnalysisHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z113_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z113_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z113_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z113_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z113_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z113_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AnalysisVector</type>
      <name>theSlaves</name>
      <anchor>z113_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AnalysisHandler</name>
      <anchor>z105_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AnalysisHandler</name>
      <anchor>z105_1</anchor>
      <arglist>(const AnalysisHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~AnalysisHandler</name>
      <anchor>z105_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>analyze</name>
      <anchor>z107_0</anchor>
      <arglist>(tEventPtr event, long ieve, int loop, int state)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual LorentzRotation</type>
      <name>transform</name>
      <anchor>z107_1</anchor>
      <arglist>(tEventPtr event) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>analyze</name>
      <anchor>z107_2</anchor>
      <arglist>(const tPVector &amp;particles)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>analyze</name>
      <anchor>z107_3</anchor>
      <arglist>(tPPtr particle)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z109_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z109_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z111_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z111_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; AnalysisHandler &gt;</type>
      <name>initAnalysisHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; AnalysisHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01AnalysisHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; AnalysisHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01AnalysisHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; AnalysisHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CascadeHandler</name>
    <filename>classThePEG_1_1CascadeHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>cascade</name>
      <anchor>a0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CascadeHandler</name>
      <anchor>z115_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CascadeHandler</name>
      <anchor>z115_1</anchor>
      <arglist>(const CascadeHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CascadeHandler</name>
      <anchor>z115_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z117_0</anchor>
      <arglist>(EventHandler &amp;eh, const tPVector &amp;tagged, const Hint &amp;hint)</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>tagged</name>
      <anchor>z119_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Hint &amp;</type>
      <name>hint</name>
      <anchor>z119_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PDF &amp;</type>
      <name>firstPDF</name>
      <anchor>z119_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PDF &amp;</type>
      <name>secondPDF</name>
      <anchor>z119_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const pair&lt; PDF, PDF &gt; &amp;</type>
      <name>pdfs</name>
      <anchor>z119_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tEHPtr</type>
      <name>eventHandler</name>
      <anchor>z119_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z121_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z121_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z121_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z121_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z121_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z121_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CascadeHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const CascadeHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const tPVector *</type>
      <name>theTagged</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const Hint *</type>
      <name>theHint</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pair&lt; PDF, PDF &gt;</type>
      <name>thePDFs</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEHPtr</type>
      <name>theEventHandler</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; CascadeHandler &gt;</type>
      <name>initCascadeHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; CascadeHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01CascadeHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; CascadeHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01CascadeHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; CascadeHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClusterCollapser</name>
    <filename>classThePEG_1_1ClusterCollapser.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>FlavGenPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multimap&lt; Energy, ColourSinglet &gt;</type>
      <name>SingletMap</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; ColourSinglet &gt;</type>
      <name>collapse</name>
      <anchor>a0</anchor>
      <arglist>(tPVector tagged, tStepPtr newstep)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual SingletMap</type>
      <name>getSinglets</name>
      <anchor>a1</anchor>
      <arglist>(const tPVector &amp;tagged) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ColourSinglet</type>
      <name>splitDiQuarkJunction</name>
      <anchor>a2</anchor>
      <arglist>(ColourSinglet &amp;cs, tStepPtr newStep) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ColourSinglet</type>
      <name>splitDiDiQuark</name>
      <anchor>a3</anchor>
      <arglist>(ColourSinglet &amp;cs, tStepPtr newStep) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>cut</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nTry2</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>pickFlavour</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ClusterCollapser</name>
      <anchor>z123_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ClusterCollapser</name>
      <anchor>z123_1</anchor>
      <arglist>(const ClusterCollapser &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClusterCollapser</name>
      <anchor>z123_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z125_0</anchor>
      <arglist>(EventHandler &amp;eh, const tPVector &amp;tagged, const Hint &amp;hint)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z127_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z127_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>diQuarkJunction</name>
      <anchor>e0</anchor>
      <arglist>(const ColourSinglet &amp;cs)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>diDiQuark</name>
      <anchor>e1</anchor>
      <arglist>(const ColourSinglet &amp;cs)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const ColourSinglet &amp;cl)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>insert</name>
      <anchor>e3</anchor>
      <arglist>(SingletMap &amp;mmap, const ColourSinglet &amp;cl)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>collapse</name>
      <anchor>b0</anchor>
      <arglist>(tStepPtr newStep, const ColourSinglet &amp;cs, const tPVector &amp;tagged) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>collapse2</name>
      <anchor>b1</anchor>
      <arglist>(tStepPtr newStep, const ColourSinglet &amp;cs) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tPVector</type>
      <name>getCompensators</name>
      <anchor>b2</anchor>
      <arglist>(Energy mh, const ColourSinglet &amp;cs, const tPVector &amp;tagged, tStepPtr newStep) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>b3</anchor>
      <arglist>(const ColourSinglet &amp;cs) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPair</type>
      <name>getHadrons</name>
      <anchor>b4</anchor>
      <arglist>(const ColourSinglet &amp;cs) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z129_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z129_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z131_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z131_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z131_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z131_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z131_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z131_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Exception::Severity</type>
      <name>errorlevel</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>pStrange</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>ClusterCollapser &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ClusterCollapser &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theEnergyCut</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNTry2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlavGenPtr</type>
      <name>flavGen</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ClusterCollapser &gt;</type>
      <name>initClusterCollapser</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClusterCollapser::ClusterException</name>
    <filename>classThePEG_1_1ClusterCollapser_1_1ClusterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>ClusterException</name>
      <anchor>a0</anchor>
      <arglist>(const ClusterCollapser &amp;cc)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClusterCollapser::ClusterException</name>
    <filename>classThePEG_1_1ClusterCollapser_1_1ClusterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>ClusterException</name>
      <anchor>a0</anchor>
      <arglist>(const ClusterCollapser &amp;cc)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ClusterCollapser, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ClusterCollapser_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ClusterCollapser &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ClusterCollapser_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ClusterCollapser &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecayHandler</name>
    <filename>classThePEG_1_1DecayHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="function">
      <type>void</type>
      <name>performDecay</name>
      <anchor>a0</anchor>
      <arglist>(tPPtr parent, Step &amp;s) const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxLoop</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayHandler</name>
      <anchor>z133_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayHandler</name>
      <anchor>z133_1</anchor>
      <arglist>(const DecayHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DecayHandler</name>
      <anchor>z133_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z135_0</anchor>
      <arglist>(EventHandler &amp;eh, const tPVector &amp;tagged, const Hint &amp;hint)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z137_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z137_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z139_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z139_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z141_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z141_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z141_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z141_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z141_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DecayHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theMaxLoop</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; DecayHandler &gt;</type>
      <name>initDecayHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DecayHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DecayHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DecayHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DecayHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DecayHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlNoDecayMode</name>
    <filename>structThePEG_1_1DecHdlNoDecayMode.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlNoDecayMode</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlNoDecayer</name>
    <filename>structThePEG_1_1DecHdlNoDecayer.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlNoDecayer</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;, const Interfaced &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlDecayFailed</name>
    <filename>structThePEG_1_1DecHdlDecayFailed.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlDecayFailed</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;, long n)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlChildFail</name>
    <filename>structThePEG_1_1DecHdlChildFail.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlChildFail</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;, const Interfaced &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler</name>
    <filename>classThePEG_1_1EventHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="typedef">
      <type>vector&lt; HandlerGroupBase * &gt;</type>
      <name>GroupVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventHandler</name>
      <anchor>z143_0</anchor>
      <arglist>(bool warnincomplete=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventHandler</name>
      <anchor>z143_1</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventHandler</name>
      <anchor>z143_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z145_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>generateEvent</name>
      <anchor>z145_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>generateEvent</name>
      <anchor>z145_2</anchor>
      <arglist>(tEventPtr e)</arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>generateEvent</name>
      <anchor>z145_3</anchor>
      <arglist>(tStepPtr s)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>continueEvent</name>
      <anchor>z145_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>continueCollision</name>
      <anchor>z145_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clearEvent</name>
      <anchor>z145_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>empty</name>
      <anchor>z145_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>statistics</name>
      <anchor>z145_8</anchor>
      <arglist>(ostream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>histogramScale</name>
      <anchor>z145_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxLoop</name>
      <anchor>z147_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>incoming</name>
      <anchor>z147_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const LuminosityFunction &amp;</type>
      <name>lumiFn</name>
      <anchor>z147_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcLumiFnPtr</type>
      <name>lumiFnPtr</name>
      <anchor>z147_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tLumiFnPtr</type>
      <name>lumiFnPtr</name>
      <anchor>z147_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>kinematicalCuts</name>
      <anchor>z147_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>partonExtractor</name>
      <anchor>z147_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>currentEvent</name>
      <anchor>z147_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>currentCollision</name>
      <anchor>z147_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>currentStep</name>
      <anchor>z147_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>statLevel</name>
      <anchor>z147_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>performStep</name>
      <anchor>z149_0</anchor>
      <arglist>(tStepHdlPtr handler, tHintPtr hint)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addStep</name>
      <anchor>z149_1</anchor>
      <arglist>(Group::Level, Group::Handler, tStepHdlPtr=tStepHdlPtr(), tHintPtr=tHintPtr())</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>z149_2</anchor>
      <arglist>(tcStepHdlPtr sh=tcStepHdlPtr())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>popStep</name>
      <anchor>z149_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initGroups</name>
      <anchor>z149_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentEvent</name>
      <anchor>z149_5</anchor>
      <arglist>(tEventPtr e)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentCollision</name>
      <anchor>z149_6</anchor>
      <arglist>(tCollPtr c)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentStep</name>
      <anchor>z149_7</anchor>
      <arglist>(tStepPtr s)</arglist>
    </member>
    <member kind="function">
      <type>tStepHdlPtr</type>
      <name>currentStepHandler</name>
      <anchor>z149_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentStepHandler</name>
      <anchor>z149_9</anchor>
      <arglist>(tStepHdlPtr sh)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>throwCurrent</name>
      <anchor>z149_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clean</name>
      <anchor>z149_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z151_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z151_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>LuminosityFunction &amp;</type>
      <name>lumiFn</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setupGroups</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>GroupVector &amp;</type>
      <name>groups</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const GroupVector &amp;</type>
      <name>groups</name>
      <anchor>b3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z153_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z153_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z155_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z155_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z155_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z155_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z155_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; SubProcessHandler &gt;</type>
      <name>optSubprocessGroup</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; CascadeHandler &gt;</type>
      <name>optCascadeGroup</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; MultipleInteractionHandler &gt;</type>
      <name>optMultiGroup</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; HadronizationHandler &gt;</type>
      <name>optHadronizationGroup</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; DecayHandler &gt;</type>
      <name>optDecayGroup</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>GroupVector</type>
      <name>optGroups</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>warnIncomplete</name>
      <anchor>p6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>cPDPair</type>
      <name>theIncoming</name>
      <anchor>p7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>lumiFn</name>
      <anchor>d0</anchor>
      <arglist>(LumiFnPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostSubProcessHandler</name>
      <anchor>d1</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostSubProcessHandler</name>
      <anchor>d2</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostSubProcessHandler</name>
      <anchor>d3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostSubProcessHandler</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreCascadeHandler</name>
      <anchor>d5</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreCascadeHandler</name>
      <anchor>d6</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreCascadeHandler</name>
      <anchor>d7</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreCascadeHandler</name>
      <anchor>d8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetCascadeHandler</name>
      <anchor>d9</anchor>
      <arglist>(CascHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CascHdlPtr</type>
      <name>interfaceGetCascadeHandler</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostCascadeHandler</name>
      <anchor>d11</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostCascadeHandler</name>
      <anchor>d12</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostCascadeHandler</name>
      <anchor>d13</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostCascadeHandler</name>
      <anchor>d14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreMultipleInteractionHandler</name>
      <anchor>d15</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreMultipleInteractionHandler</name>
      <anchor>d16</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreMultipleInteractionHandler</name>
      <anchor>d17</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreMultipleInteractionHandler</name>
      <anchor>d18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetMultipleInteractionHandler</name>
      <anchor>d19</anchor>
      <arglist>(MIHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MIHdlPtr</type>
      <name>interfaceGetMultipleInteractionHandler</name>
      <anchor>d20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostMultipleInteractionHandler</name>
      <anchor>d21</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostMultipleInteractionHandler</name>
      <anchor>d22</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostMultipleInteractionHandler</name>
      <anchor>d23</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostMultipleInteractionHandler</name>
      <anchor>d24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreHadronizationHandler</name>
      <anchor>d25</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreHadronizationHandler</name>
      <anchor>d26</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreHadronizationHandler</name>
      <anchor>d27</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreHadronizationHandler</name>
      <anchor>d28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetHadronizationHandler</name>
      <anchor>d29</anchor>
      <arglist>(HadrHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HadrHdlPtr</type>
      <name>interfaceGetHadronizationHandler</name>
      <anchor>d30</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostHadronizationHandler</name>
      <anchor>d31</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostHadronizationHandler</name>
      <anchor>d32</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostHadronizationHandler</name>
      <anchor>d33</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostHadronizationHandler</name>
      <anchor>d34</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreDecayHandler</name>
      <anchor>d35</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreDecayHandler</name>
      <anchor>d36</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreDecayHandler</name>
      <anchor>d37</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreDecayHandler</name>
      <anchor>d38</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetDecayHandler</name>
      <anchor>d39</anchor>
      <arglist>(DecayHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayHdlPtr</type>
      <name>interfaceGetDecayHandler</name>
      <anchor>d40</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostDecayHandler</name>
      <anchor>d41</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostDecayHandler</name>
      <anchor>d42</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostDecayHandler</name>
      <anchor>d43</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostDecayHandler</name>
      <anchor>d44</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventHandler &amp;</type>
      <name>operator=</name>
      <anchor>d45</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theMaxLoop</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theStatLevel</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LumiFnPtr</type>
      <name>theLumiFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theKinematicalCuts</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PExtrPtr</type>
      <name>thePartonExtractor</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; SubProcessHandler &gt;</type>
      <name>theSubprocessGroup</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; CascadeHandler &gt;</type>
      <name>theCascadeGroup</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; MultipleInteractionHandler &gt;</type>
      <name>theMultiGroup</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; HadronizationHandler &gt;</type>
      <name>theHadronizationGroup</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; DecayHandler &gt;</type>
      <name>theDecayGroup</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GroupVector</type>
      <name>theGroups</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>EventPtr</type>
      <name>theCurrentEvent</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CollPtr</type>
      <name>theCurrentCollision</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepPtr</type>
      <name>theCurrentStep</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepHdlPtr</type>
      <name>theCurrentStepHandler</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; EventHandler &gt;</type>
      <name>initEventHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler::EventHandlerHistError</name>
    <filename>classThePEG_1_1EventHandler_1_1EventHandlerHistError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler::EventHandlerIncompleteError</name>
    <filename>classThePEG_1_1EventHandler_1_1EventHandlerIncompleteError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler::EventHandlerStepError</name>
    <filename>classThePEG_1_1EventHandler_1_1EventHandlerStepError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventHandler::EventLoopException</name>
    <filename>structThePEG_1_1EventHandler_1_1EventLoopException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>EventLoopException</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventHandler::LumiFuncError</name>
    <filename>structThePEG_1_1EventHandler_1_1LumiFuncError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler::EventHandlerStepError</name>
    <filename>classThePEG_1_1EventHandler_1_1EventHandlerStepError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler::EventHandlerHistError</name>
    <filename>classThePEG_1_1EventHandler_1_1EventHandlerHistError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler::EventHandlerIncompleteError</name>
    <filename>classThePEG_1_1EventHandler_1_1EventHandlerIncompleteError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventHandler::EventLoopException</name>
    <filename>structThePEG_1_1EventHandler_1_1EventLoopException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>EventLoopException</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventHandler::LumiFuncError</name>
    <filename>structThePEG_1_1EventHandler_1_1LumiFuncError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventManipulator</name>
    <filename>classThePEG_1_1EventManipulator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function" virtualness="pure">
      <type>virtual int</type>
      <name>manipulate</name>
      <anchor>a0</anchor>
      <arglist>(tEHPtr eh, tEventPtr event)=0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventManipulator</name>
      <anchor>z157_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventManipulator</name>
      <anchor>z157_1</anchor>
      <arglist>(const EventManipulator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventManipulator</name>
      <anchor>z157_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z159_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z159_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z159_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z159_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z159_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventManipulator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const EventManipulator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; EventManipulator &gt;</type>
      <name>initEventManipulator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventManipulator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventManipulator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventManipulator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventManipulator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventManipulator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FixedCMSLuminosity</name>
    <filename>classThePEG_1_1FixedCMSLuminosity.html</filename>
    <base>ThePEG::LuminosityFunction</base>
    <member kind="function">
      <type>Energy</type>
      <name>energy</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FixedCMSLuminosity</name>
      <anchor>z161_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FixedCMSLuminosity</name>
      <anchor>z161_1</anchor>
      <arglist>(const FixedCMSLuminosity &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FixedCMSLuminosity</name>
      <anchor>z161_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z163_0</anchor>
      <arglist>(const cPDPair &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z163_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z165_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z165_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z165_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z165_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z165_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z167_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z167_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z169_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z169_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>FixedCMSLuminosity &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FixedCMSLuminosity &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theEnergy</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; FixedCMSLuminosity &gt;</type>
      <name>initFixedCMSLuminosity</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FixedCMSLuminosity, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FixedCMSLuminosity_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>LuminosityFunction</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FixedCMSLuminosity &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FixedCMSLuminosity_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FixedCMSLuminosity &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FlavourGenerator</name>
    <filename>classThePEG_1_1FlavourGenerator.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>FlavourGenerator</name>
      <anchor>z171_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FlavourGenerator</name>
      <anchor>z171_1</anchor>
      <arglist>(const FlavourGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FlavourGenerator</name>
      <anchor>z171_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tcPDPair</type>
      <name>generateHadron</name>
      <anchor>z173_0</anchor>
      <arglist>(tcPDPtr quark) const =0</arglist>
    </member>
    <member kind="function">
      <type>tcPDPair</type>
      <name>alwaysGenerateHadron</name>
      <anchor>z173_1</anchor>
      <arglist>(tcPDPtr quark) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>z173_2</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>z173_3</anchor>
      <arglist>(long iq1, long iq2) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetHadron</name>
      <anchor>z173_4</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetHadron</name>
      <anchor>z173_5</anchor>
      <arglist>(long iq1, long iq2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getBaryon</name>
      <anchor>z173_6</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2, tcPDPtr q3) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getBaryon</name>
      <anchor>z173_7</anchor>
      <arglist>(long q1, long q2, long q3) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetBaryon</name>
      <anchor>z173_8</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2, tcPDPtr q3) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetBaryon</name>
      <anchor>z173_9</anchor>
      <arglist>(long q1, long q2, long q3) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>selectQuark</name>
      <anchor>z173_10</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>selectFlavour</name>
      <anchor>z173_11</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z175_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z175_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlavourGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FlavourGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; FlavourGenerator &gt;</type>
      <name>initFlavourGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FlavourGeneratorException</name>
    <filename>classThePEG_1_1FlavourGeneratorException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FlavourGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FlavourGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FlavourGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FlavourGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FlavourGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GaussianPtGenerator</name>
    <filename>classThePEG_1_1GaussianPtGenerator.html</filename>
    <base>ThePEG::PtGenerator</base>
    <member kind="function">
      <type></type>
      <name>GaussianPtGenerator</name>
      <anchor>z177_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GaussianPtGenerator</name>
      <anchor>z177_1</anchor>
      <arglist>(const GaussianPtGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GaussianPtGenerator</name>
      <anchor>z177_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual TransverseMomentum</type>
      <name>generate</name>
      <anchor>z179_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z181_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z181_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z183_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z183_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z185_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z185_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z185_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z185_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z185_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z185_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GaussianPtGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GaussianPtGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theSigma</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theUpperCut</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; GaussianPtGenerator &gt;</type>
      <name>initGaussianPtGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GaussianPtGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GaussianPtGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PtGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GaussianPtGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GaussianPtGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GaussianPtGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HadronizationHandler</name>
    <filename>classThePEG_1_1HadronizationHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="function">
      <type></type>
      <name>HadronizationHandler</name>
      <anchor>z187_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HadronizationHandler</name>
      <anchor>z187_1</anchor>
      <arglist>(const HadronizationHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HadronizationHandler</name>
      <anchor>z187_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z189_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z189_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z189_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z189_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z189_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HadronizationHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HadronizationHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; HadronizationHandler &gt;</type>
      <name>initHadronizationHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; HadronizationHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01HadronizationHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; HadronizationHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01HadronizationHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; HadronizationHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerBaseT</name>
    <filename>classThePEG_1_1HandlerBaseT.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>a1</anchor>
      <arglist>(double xu) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>a2</anchor>
      <arglist>(double xl, double xu) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>a4</anchor>
      <arglist>(double p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>a5</anchor>
      <arglist>(double p1, double p2) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rndsign</name>
      <anchor>a6</anchor>
      <arglist>(double p1, double p2, double p3) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd2</name>
      <anchor>a7</anchor>
      <arglist>(double p0, double p1) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd3</name>
      <anchor>a8</anchor>
      <arglist>(double p0, double p1, double p2) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd4</name>
      <anchor>a9</anchor>
      <arglist>(double p0, double p1, double p2, double p3) const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>irnd</name>
      <anchor>a10</anchor>
      <arglist>(long xu=2) const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>irnd</name>
      <anchor>a11</anchor>
      <arglist>(long xl, long xu) const </arglist>
    </member>
    <member kind="function">
      <type>const StandardModelBase &amp;</type>
      <name>SM</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tSMPtr</type>
      <name>standardModel</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HandlerBaseT</name>
      <anchor>z191_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HandlerBaseT</name>
      <anchor>z191_1</anchor>
      <arglist>(const HandlerBaseT &amp;)</arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual</type>
      <name>~HandlerBaseT</name>
      <anchor>z191_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>HandlerBase</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerBase</name>
    <filename>classThePEG_1_1HandlerBase.html</filename>
    <base>ThePEG::HandlerBaseT&lt; UseRandom &gt;</base>
    <member kind="function">
      <type></type>
      <name>HandlerBase</name>
      <anchor>z193_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerBase</name>
      <anchor>z193_1</anchor>
      <arglist>(const HandlerBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HandlerBase</name>
      <anchor>z193_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z195_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z195_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z195_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z195_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z195_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HandlerBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HandlerBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; HandlerBase &gt;</type>
      <name>initHandlerBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; HandlerBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01HandlerBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; HandlerBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01HandlerBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; HandlerBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerGroupBase</name>
    <filename>classThePEG_1_1HandlerGroupBase.html</filename>
    <member kind="typedef">
      <type>pair&lt; StepHdlPtr, HintPtr &gt;</type>
      <name>StepWithHint</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>StepVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepWithHint &gt;</type>
      <name>StepHintVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>deque&lt; HintPtr &gt;</type>
      <name>HintVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerGroupBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HandlerGroupBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a3</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type>StepWithHint</type>
      <name>next</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPreHandler</name>
      <anchor>a5</anchor>
      <arglist>(tStepHdlPtr sh, tHintPtr hint, const HandlerGroupBase &amp;ext)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPostHandler</name>
      <anchor>a6</anchor>
      <arglist>(tStepHdlPtr sh, tHintPtr hint, const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addHint</name>
      <anchor>a7</anchor>
      <arglist>(tHintPtr hint, const HandlerGroupBase &amp;ext)</arglist>
    </member>
    <member kind="function">
      <type>StepVector &amp;</type>
      <name>preHandlers</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const StepVector &amp;</type>
      <name>preHandlers</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tStepHdlPtr</type>
      <name>defaultHandler</name>
      <anchor>a10</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>StepVector &amp;</type>
      <name>postHandlers</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const StepVector &amp;</type>
      <name>postHandlers</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tStepHdlPtr</type>
      <name>handler</name>
      <anchor>a13</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setHandler</name>
      <anchor>a14</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>setHandler</name>
      <anchor>a15</anchor>
      <arglist>(tStepHdlPtr, const HandlerGroupBase &amp;ext)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>refillDefaultHandler</name>
      <anchor>a16</anchor>
      <arglist>(tStepHdlPtr)=0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>refillDefaults</name>
      <anchor>a17</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clear</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>handlerClass</name>
      <anchor>a19</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceSetPrehandler</name>
      <anchor>a20</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceInsertPrehandler</name>
      <anchor>a21</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceErasePrehandler</name>
      <anchor>a22</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPrehandlers</name>
      <anchor>a23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceSetPosthandler</name>
      <anchor>a24</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceInsertPosthandler</name>
      <anchor>a25</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceErasePosthandler</name>
      <anchor>a26</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPosthandlers</name>
      <anchor>a27</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>write</name>
      <anchor>a28</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>read</name>
      <anchor>a29</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>HandlerGroupBase</name>
      <anchor>b0</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isEmpty</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepVector</type>
      <name>theDefaultPreHandlers</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepVector</type>
      <name>theDefaultPostHandlers</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepHintVector</type>
      <name>thePreHandlers</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HintVector</type>
      <name>theHints</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepHintVector</type>
      <name>thePostHandlers</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>checkInsert</name>
      <anchor>d0</anchor>
      <arglist>(StepHintVector &amp;current, const StepVector &amp;def)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HandlerGroupBase &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerGroup</name>
    <filename>classThePEG_1_1HandlerGroup.html</filename>
    <templarg>HDLR</templarg>
    <base>ThePEG::HandlerGroupBase</base>
    <member kind="typedef">
      <type>Ptr&lt; HDLR &gt;::pointer</type>
      <name>HdlPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HDLR &gt;::transient_pointer</type>
      <name>tHdlPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerGroup</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerGroup</name>
      <anchor>a1</anchor>
      <arglist>(const HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HandlerGroup</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>setHandler</name>
      <anchor>a3</anchor>
      <arglist>(tStepHdlPtr, const HandlerGroupBase &amp;ext)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setHandler</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tStepHdlPtr</type>
      <name>handler</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tStepHdlPtr</type>
      <name>defaultHandler</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>refillDefaultHandler</name>
      <anchor>a7</anchor>
      <arglist>(tStepHdlPtr)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clear</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>handlerClass</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceSetHandler</name>
      <anchor>a10</anchor>
      <arglist>(HdlPtr)</arglist>
    </member>
    <member kind="function">
      <type>HdlPtr</type>
      <name>interfaceGetHandler</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>write</name>
      <anchor>a12</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>read</name>
      <anchor>a13</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HandlerGroup&lt; HDLR &gt; &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HdlPtr</type>
      <name>theDefaultHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HdlPtr</type>
      <name>theHandler</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Hint</name>
    <filename>classThePEG_1_1Hint.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>bool</type>
      <name>tagged</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>tagged</name>
      <anchor>a1</anchor>
      <arglist>(const Step &amp;s) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>tag</name>
      <anchor>a2</anchor>
      <arglist>(InputIterator first, InputIterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>tag</name>
      <anchor>a3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a4</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>stop</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>a6</anchor>
      <arglist>(const Scale &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Scale &amp;</type>
      <name>scale</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Hint</name>
      <anchor>z197_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Hint</name>
      <anchor>z197_1</anchor>
      <arglist>(const Hint &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Hint</name>
      <anchor>z197_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z199_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z199_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tHintPtr</type>
      <name>Default</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const Hint &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Hint &amp;h)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theTagged</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Scale</type>
      <name>theScale</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theStopFlag</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>Hint</type>
      <name>theDefaultHint</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Hint &gt;</type>
      <name>initHint</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Hint, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Hint_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Hint &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Hint_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Hint &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::KinematicalCuts</name>
    <filename>classThePEG_1_1KinematicalCuts.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>KinematicalCuts</name>
      <anchor>z201_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>KinematicalCuts</name>
      <anchor>z201_1</anchor>
      <arglist>(const KinematicalCuts &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~KinematicalCuts</name>
      <anchor>z201_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cut</name>
      <anchor>z203_0</anchor>
      <arglist>(const SubProcess &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cut</name>
      <anchor>z203_1</anchor>
      <arglist>(const Collision &amp;, const LorentzRotation &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMin</name>
      <anchor>z205_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMax</name>
      <anchor>z205_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMin</name>
      <anchor>z205_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMax</name>
      <anchor>z205_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>mHat</name>
      <anchor>z205_4</anchor>
      <arglist>(Energy mhat) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>sHat</name>
      <anchor>z205_5</anchor>
      <arglist>(Energy2 shat) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMin</name>
      <anchor>z205_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMax</name>
      <anchor>z205_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>pTHat</name>
      <anchor>z205_8</anchor>
      <arglist>(Energy pt) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatSingularMin</name>
      <anchor>z205_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>singularMassMax</name>
      <anchor>z205_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yStarMin</name>
      <anchor>z207_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yStarMax</name>
      <anchor>z207_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>yStar</name>
      <anchor>z207_2</anchor>
      <arglist>(double y) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxYMin</name>
      <anchor>z207_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxYMax</name>
      <anchor>z207_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>maxY</name>
      <anchor>z207_5</anchor>
      <arglist>(double y) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minYMin</name>
      <anchor>z207_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minYMax</name>
      <anchor>z207_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>minY</name>
      <anchor>z207_8</anchor>
      <arglist>(double y) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxEtaMin</name>
      <anchor>z207_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxEtaMax</name>
      <anchor>z207_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>maxEta</name>
      <anchor>z207_11</anchor>
      <arglist>(double eta) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minEtaMin</name>
      <anchor>z207_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minEtaMax</name>
      <anchor>z207_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>minEta</name>
      <anchor>z207_14</anchor>
      <arglist>(double eta) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxCTMin</name>
      <anchor>z207_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxCTMax</name>
      <anchor>z207_16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>maxCT</name>
      <anchor>z207_17</anchor>
      <arglist>(double ct) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minCTMin</name>
      <anchor>z207_18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minCTMax</name>
      <anchor>z207_19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>minCT</name>
      <anchor>z207_20</anchor>
      <arglist>(double ct) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x1Min</name>
      <anchor>z207_21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x1Max</name>
      <anchor>z207_22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>x1</name>
      <anchor>z207_23</anchor>
      <arglist>(double x) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x2Min</name>
      <anchor>z207_24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x2Max</name>
      <anchor>z207_25</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>x2</name>
      <anchor>z207_26</anchor>
      <arglist>(double x) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xFMin</name>
      <anchor>z207_27</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xFMax</name>
      <anchor>z207_28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>xF</name>
      <anchor>z207_29</anchor>
      <arglist>(double x) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMin</name>
      <anchor>z207_30</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMax</name>
      <anchor>z207_31</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>cTH</name>
      <anchor>z207_32</anchor>
      <arglist>(double cth) const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMin</name>
      <anchor>z207_33</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMax</name>
      <anchor>z207_34</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>tHat</name>
      <anchor>z207_35</anchor>
      <arglist>(Energy2 that) const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMin</name>
      <anchor>z207_36</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMax</name>
      <anchor>z207_37</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>uHat</name>
      <anchor>z207_38</anchor>
      <arglist>(Energy2 uhat) const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMin</name>
      <anchor>z207_39</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>z207_40</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>scale</name>
      <anchor>z207_41</anchor>
      <arglist>(Energy2 sc) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton1EnergyMin</name>
      <anchor>z209_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton1EnergyMax</name>
      <anchor>z209_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton1AngleMin</name>
      <anchor>z209_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton1AngleMax</name>
      <anchor>z209_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ21Min</name>
      <anchor>z209_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ21Max</name>
      <anchor>z209_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton2EnergyMin</name>
      <anchor>z209_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton2EnergyMax</name>
      <anchor>z209_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton2AngleMin</name>
      <anchor>z209_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton2AngleMax</name>
      <anchor>z209_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ22Min</name>
      <anchor>z209_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ22Max</name>
      <anchor>z209_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISW2Min</name>
      <anchor>z209_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISW2Max</name>
      <anchor>z209_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z211_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z211_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>z213_0</anchor>
      <arglist>(const SubProcess &amp;) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>z213_1</anchor>
      <arglist>(const Collision &amp;, const LorentzRotation &amp;) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z215_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z215_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z215_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z217_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z217_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>isLepton</name>
      <anchor>d0</anchor>
      <arglist>(const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>maxYMinMax</name>
      <anchor>d1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>minYMaxMin</name>
      <anchor>d2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>maxEtaMinMax</name>
      <anchor>d3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>minEtaMaxMin</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>maxCTMinMax</name>
      <anchor>d5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>minCTMaxMin</name>
      <anchor>d6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>KinematicalCuts &amp;</type>
      <name>operator=</name>
      <anchor>d7</anchor>
      <arglist>(const KinematicalCuts &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMax</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatSingularMin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theSingularMassMax</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theYStarMin</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theYStarMax</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxYMin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxYMax</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinYMin</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinYMax</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxEtaMin</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxEtaMax</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinEtaMin</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinEtaMax</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxCTMin</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxCTMax</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinCTMin</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinCTMax</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX1Min</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX1Max</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX2Min</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX2Max</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theXFMin</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theXFMax</name>
      <anchor>r25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMin</name>
      <anchor>r26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMax</name>
      <anchor>r27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMin</name>
      <anchor>r28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMax</name>
      <anchor>r29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMin</name>
      <anchor>r30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMax</name>
      <anchor>r31</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMin</name>
      <anchor>r32</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMax</name>
      <anchor>r33</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useLeptoCuts</name>
      <anchor>r34</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton1EnergyMin</name>
      <anchor>r35</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton1EnergyMax</name>
      <anchor>r36</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton1AngleMin</name>
      <anchor>r37</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton1AngleMax</name>
      <anchor>r38</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ21Min</name>
      <anchor>r39</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ21Max</name>
      <anchor>r40</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton2EnergyMin</name>
      <anchor>r41</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton2EnergyMax</name>
      <anchor>r42</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton2AngleMin</name>
      <anchor>r43</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton2AngleMax</name>
      <anchor>r44</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ22Min</name>
      <anchor>r45</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ22Max</name>
      <anchor>r46</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISW2Min</name>
      <anchor>r47</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISW2Max</name>
      <anchor>r48</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; MatchLepton &gt;::pointer</type>
      <name>theLeptonMatcher</name>
      <anchor>r49</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; KinematicalCuts &gt;</type>
      <name>initKinematicalCuts</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; KinematicalCuts, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01KinematicalCuts_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; KinematicalCuts &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01KinematicalCuts_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; KinematicalCuts &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutSetup</name>
    <filename>structThePEG_1_1KinCutSetup.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>KinCutSetup</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutZeroInterval</name>
    <filename>structThePEG_1_1KinCutZeroInterval.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>KinCutZeroInterval</name>
      <anchor>a0</anchor>
      <arglist>(const KinematicalCuts &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LastXCombInfo</name>
    <filename>classThePEG_1_1LastXCombInfo.html</filename>
    <templarg>XC</templarg>
    <member kind="typedef">
      <type>Ptr&lt; XC &gt;::pointer</type>
      <name>XCPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XC &gt;::const_pointer</type>
      <name>cXCPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XC &gt;::transient_pointer</type>
      <name>tXCPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XC &gt;::transient_const_pointer</type>
      <name>tcXCPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LastXCombInfo</name>
      <anchor>z219_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LastXCombInfo</name>
      <anchor>z219_1</anchor>
      <arglist>(const LastXCombInfo&lt; XC &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LastXCombInfo &amp;</type>
      <name>operator=</name>
      <anchor>z219_2</anchor>
      <arglist>(const LastXCombInfo&lt; XC &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const XC &amp;</type>
      <name>lastXComb</name>
      <anchor>z221_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tXCPtr</type>
      <name>lastXCombPtr</name>
      <anchor>z221_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const EventHandler &amp;</type>
      <name>lastEventHandler</name>
      <anchor>z223_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>lastExtractor</name>
      <anchor>z223_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDFT</type>
      <name>pdf</name>
      <anchor>z223_2</anchor>
      <arglist>(tcPPtr parton) const </arglist>
    </member>
    <member kind="function">
      <type>const KinematicalCuts &amp;</type>
      <name>lastCuts</name>
      <anchor>z223_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>lastCutsPtr</name>
      <anchor>z223_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastParticles</name>
      <anchor>z225_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastS</name>
      <anchor>z225_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastPartons</name>
      <anchor>z225_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastSHat</name>
      <anchor>z225_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastTau</name>
      <anchor>z225_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastY</name>
      <anchor>z225_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP1</name>
      <anchor>z225_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP2</name>
      <anchor>z225_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL1</name>
      <anchor>z225_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL2</name>
      <anchor>z225_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX1</name>
      <anchor>z225_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX2</name>
      <anchor>z225_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE1</name>
      <anchor>z225_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE2</name>
      <anchor>z225_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastFL1L2</name>
      <anchor>z225_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastScale</name>
      <anchor>z227_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>z227_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>mePartons</name>
      <anchor>z227_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>mePartonData</name>
      <anchor>z227_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>XCPtr</type>
      <name>theLastXComb</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LuminosityFunction</name>
    <filename>classThePEG_1_1LuminosityFunction.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>a0</anchor>
      <arglist>(tXCombPtr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LuminosityFunction</name>
      <anchor>z229_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LuminosityFunction</name>
      <anchor>z229_1</anchor>
      <arglist>(const LuminosityFunction &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LuminosityFunction</name>
      <anchor>z229_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z231_0</anchor>
      <arglist>(const cPDPair &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z231_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual LorentzRotation</type>
      <name>getBoost</name>
      <anchor>z231_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z231_3</anchor>
      <arglist>(const cPDPair &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>value</name>
      <anchor>z231_4</anchor>
      <arglist>(const cPDPair &amp;, double l1, double l2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual pair&lt; double, double &gt;</type>
      <name>generateLL</name>
      <anchor>z231_5</anchor>
      <arglist>(const double *r, double &amp;jacobian) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z233_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z233_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LuminosityFunction &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LuminosityFunction &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; LuminosityFunction &gt;</type>
      <name>initLuminosityFunction</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>EventHandler</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LuminosityFunction, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LuminosityFunction_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LuminosityFunction &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LuminosityFunction_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LuminosityFunction &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MultipleInteractionHandler</name>
    <filename>classThePEG_1_1MultipleInteractionHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="function">
      <type></type>
      <name>MultipleInteractionHandler</name>
      <anchor>z235_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultipleInteractionHandler</name>
      <anchor>z235_1</anchor>
      <arglist>(const MultipleInteractionHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MultipleInteractionHandler</name>
      <anchor>z235_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z237_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z237_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z237_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z237_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z237_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MultipleInteractionHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MultipleInteractionHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; MultipleInteractionHandler &gt;</type>
      <name>initMultipleInteractionHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MultipleInteractionHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MultipleInteractionHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MultipleInteractionHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MultipleInteractionHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MultipleInteractionHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PtGenerator</name>
    <filename>classThePEG_1_1PtGenerator.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>PtGenerator</name>
      <anchor>z239_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PtGenerator</name>
      <anchor>z239_1</anchor>
      <arglist>(const PtGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PtGenerator</name>
      <anchor>z239_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual TransverseMomentum</type>
      <name>generate</name>
      <anchor>z241_0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PtGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PtGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; PtGenerator &gt;</type>
      <name>initPtGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PtGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PtGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PtGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PtGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PtGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SamplerBase</name>
    <filename>classThePEG_1_1SamplerBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>void</type>
      <name>setEventHandler</name>
      <anchor>a0</anchor>
      <arglist>(tStdEHPtr eh)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SamplerBase</name>
      <anchor>z243_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SamplerBase</name>
      <anchor>z243_1</anchor>
      <arglist>(const SamplerBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SamplerBase</name>
      <anchor>z243_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z245_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z245_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>rejectLast</name>
      <anchor>z245_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; double &gt; &amp;</type>
      <name>lastPoint</name>
      <anchor>z245_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>lastBin</name>
      <anchor>z245_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual CrossSection</type>
      <name>integratedXSec</name>
      <anchor>z245_5</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>sumWeights</name>
      <anchor>z245_6</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z247_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z247_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>vector&lt; double &gt; &amp;</type>
      <name>lastPoint</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tStdEHPtr</type>
      <name>eventHandler</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z249_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z249_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z249_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z249_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z249_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z249_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SamplerBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SamplerBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStdEHPtr</type>
      <name>theEventHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; double &gt;</type>
      <name>theLastPoint</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; SamplerBase &gt;</type>
      <name>initSamplerBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SamplerBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SamplerBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SamplerBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SamplerBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SamplerBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SimpleFlavour</name>
    <filename>classThePEG_1_1SimpleFlavour.html</filename>
    <base>ThePEG::FlavourGenerator</base>
    <member kind="typedef">
      <type>map&lt; long, VSelector&lt; pair&lt; long, long &gt; &gt; &gt;</type>
      <name>ProbabilityMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleFlavour</name>
      <anchor>z251_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleFlavour</name>
      <anchor>z251_1</anchor>
      <arglist>(const SimpleFlavour &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SimpleFlavour</name>
      <anchor>z251_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPair</type>
      <name>generateHadron</name>
      <anchor>z253_0</anchor>
      <arglist>(tcPDPtr quark) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>z253_1</anchor>
      <arglist>(long iq1, long iq2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getBaryon</name>
      <anchor>z253_2</anchor>
      <arglist>(long q1, long q2, long q3) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>selectQuark</name>
      <anchor>z253_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>selectFlavour</name>
      <anchor>z253_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sSup</name>
      <anchor>z255_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diSup</name>
      <anchor>z255_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>di1Sup</name>
      <anchor>z255_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diSSup</name>
      <anchor>z255_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>etaSup</name>
      <anchor>z255_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>etaPSup</name>
      <anchor>z255_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>baryon10Sup</name>
      <anchor>z255_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pSpin1</name>
      <anchor>z255_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pSpinS1</name>
      <anchor>z255_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pSpinC1</name>
      <anchor>z255_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z257_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z257_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>setProbabilities</name>
      <anchor>b0</anchor>
      <arglist>(long iq) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>vectorMesonProbability</name>
      <anchor>b1</anchor>
      <arglist>(long iq1, long iq2) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>baryonDecupletProbability</name>
      <anchor>b2</anchor>
      <arglist>(long iq1, long iq2) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>pseudoScalarMeson</name>
      <anchor>b3</anchor>
      <arglist>(long iq, long iqbar) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>vectorMeson</name>
      <anchor>b4</anchor>
      <arglist>(long iq, long iqbar) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>baryonOctet</name>
      <anchor>b5</anchor>
      <arglist>(long iq, long idq) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>baryonDecuplet</name>
      <anchor>b6</anchor>
      <arglist>(long iq, long idq) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>pseudoScalarId</name>
      <anchor>b7</anchor>
      <arglist>(long iqh, long iql) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>vectorId</name>
      <anchor>b8</anchor>
      <arglist>(long iqh, long iql) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>baryonOctetId</name>
      <anchor>b9</anchor>
      <arglist>(long iqa, long iqb, long iqc, long iq, bool dqs1) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>baryonDecupletId</name>
      <anchor>b10</anchor>
      <arglist>(long iqa, long iqb, long iqc) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>pseudoScalarIds</name>
      <anchor>b11</anchor>
      <arglist>(long iqh, long iql) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>vectorIds</name>
      <anchor>b12</anchor>
      <arglist>(long iqh, long iql) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>baryonOctetIds</name>
      <anchor>b13</anchor>
      <arglist>(long iqa, long iqb, long iqc, long iq, bool dqs1) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>baryonDecupletIds</name>
      <anchor>b14</anchor>
      <arglist>(long iqa, long iqb, long iqc) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>clear</name>
      <anchor>b15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z259_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z259_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z261_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z261_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z261_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z261_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z261_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z261_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>double</type>
      <name>weightSU6QDiQSpin</name>
      <anchor>f0</anchor>
      <arglist>(long iq, long idq, int spin)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SimpleFlavour &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SimpleFlavour &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSSup</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDiSup</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDi1Sup</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDiSSup</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEtaSup</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEtaPSup</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theBaryon10Sup</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thePSpin1</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thePSpinS1</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thePSpinC1</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VSelector&lt; long &gt;</type>
      <name>theFlavourSelector</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ProbabilityMap</type>
      <name>theProbabilities</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SimpleFlavour &gt;</type>
      <name>initSimpleFlavour</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SimpleFlavour, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SimpleFlavour_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlavourGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SimpleFlavour &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SimpleFlavour_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SimpleFlavour &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SimpleZGenerator</name>
    <filename>classThePEG_1_1SimpleZGenerator.html</filename>
    <base>ThePEG::ZGenerator</base>
    <member kind="function">
      <type></type>
      <name>SimpleZGenerator</name>
      <anchor>z263_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleZGenerator</name>
      <anchor>z263_1</anchor>
      <arglist>(const SimpleZGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SimpleZGenerator</name>
      <anchor>z263_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z265_0</anchor>
      <arglist>(cPDPtr q1, cPDPtr q2, Energy2 mT2) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z267_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z267_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z269_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z269_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z271_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z271_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z271_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z271_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z271_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z271_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SimpleZGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SimpleZGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SimpleZGenerator &gt;</type>
      <name>initSimpleZGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SimpleZGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SimpleZGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ZGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SimpleZGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SimpleZGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SimpleZGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardEventHandler</name>
    <filename>classThePEG_1_1StandardEventHandler.html</filename>
    <base>ThePEG::EventHandler</base>
    <member kind="typedef">
      <type>vector&lt; SubHdlPtr &gt;</type>
      <name>SubHandlerList</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Selector&lt; StdXCombPtr &gt;</type>
      <name>XSelector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StdXCombPtr &gt;</type>
      <name>XVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; CrossSection &gt;</type>
      <name>XSVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tMEPtr, XVector &gt;</type>
      <name>MEXMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>statistics</name>
      <anchor>a1</anchor>
      <arglist>(ostream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>histogramScale</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardEventHandler</name>
      <anchor>z273_0</anchor>
      <arglist>(const StandardEventHandler &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardEventHandler</name>
      <anchor>z273_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~StandardEventHandler</name>
      <anchor>z273_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>dSigDR</name>
      <anchor>z275_0</anchor>
      <arglist>(const vector&lt; double &gt; &amp;r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>generateEvent</name>
      <anchor>z275_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>continueEvent</name>
      <anchor>z275_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const LorentzRotation &amp;</type>
      <name>currentEventBoost</name>
      <anchor>z275_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>cuts</name>
      <anchor>z277_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nBins</name>
      <anchor>z277_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxDim</name>
      <anchor>z277_2</anchor>
      <arglist>(int bin) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>weighted</name>
      <anchor>z277_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>compensating</name>
      <anchor>z277_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>lumiDim</name>
      <anchor>z277_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nDim</name>
      <anchor>z277_6</anchor>
      <arglist>(int bin) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z279_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z279_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z279_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z279_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z281_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z281_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>dSigDR</name>
      <anchor>b0</anchor>
      <arglist>(const pair&lt; double, double &gt; ll, Energy2 maxS, int ibin, int nr, const double *r)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tStdXCombPtr</type>
      <name>select</name>
      <anchor>b1</anchor>
      <arglist>(int bin, double weight)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addME</name>
      <anchor>b2</anchor>
      <arglist>(Energy maxEnergy, tSubHdlPtr sub, tPExtrPtr extractor, tKinCutPtr cuts, tMEPtr me, const PBPair &amp;pBins)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tCollPtr</type>
      <name>performCollision</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>initGroups</name>
      <anchor>b4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>LorentzRotation &amp;</type>
      <name>currentEventBoost</name>
      <anchor>b5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>createIncoming</name>
      <anchor>b6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setScale</name>
      <anchor>b7</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const XVector &amp;</type>
      <name>xCombs</name>
      <anchor>b8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>XVector &amp;</type>
      <name>xCombs</name>
      <anchor>b9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const XSVector &amp;</type>
      <name>xSecs</name>
      <anchor>b10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>XSVector &amp;</type>
      <name>xSecs</name>
      <anchor>b11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>int</type>
      <name>binStrategy</name>
      <anchor>b12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>reject</name>
      <anchor>b13</anchor>
      <arglist>(double weight)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tSamplerPtr</type>
      <name>sampler</name>
      <anchor>b14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tcSamplerPtr</type>
      <name>sampler</name>
      <anchor>b15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z283_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z283_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>const SubHandlerList &amp;</type>
      <name>subProcesses</name>
      <anchor>d0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>SubHandlerList &amp;</type>
      <name>subProcesses</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const StandardEventHandler &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const StandardEventHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>theIncomingA</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>theIncomingB</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubHandlerList</type>
      <name>theSubProcesses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>XVector</type>
      <name>theXCombs</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>XSVector</type>
      <name>theXSecs</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theBinStrategy</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MEXMap</type>
      <name>theMEXMap</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>theMaxDims</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LorentzRotation</type>
      <name>theCurrentEventBoost</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>weightedEvents</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SamplerPtr</type>
      <name>theSampler</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theLumiDim</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNDim</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardEventHandler &gt;</type>
      <name>initStandardEventHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardEventHandler::StandardEventHandlerInitError</name>
    <filename>classThePEG_1_1StandardEventHandler_1_1StandardEventHandlerInitError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardEventHandler::StandardEventHandlerUpdateException</name>
    <filename>classThePEG_1_1StandardEventHandler_1_1StandardEventHandlerUpdateException.html</filename>
    <base>ThePEG::UpdateException</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardEventHandler::StandardEventHandlerUpdateException</name>
    <filename>classThePEG_1_1StandardEventHandler_1_1StandardEventHandlerUpdateException.html</filename>
    <base>ThePEG::UpdateException</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardEventHandler::StandardEventHandlerInitError</name>
    <filename>classThePEG_1_1StandardEventHandler_1_1StandardEventHandlerInitError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardEventHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardEventHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardEventHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardEventHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardEventHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardXComb</name>
    <filename>classThePEG_1_1StandardXComb.html</filename>
    <base>ThePEG::XComb</base>
    <member kind="typedef">
      <type>MEBase::DiagramVector</type>
      <name>DiagramVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MEBase::DiagramIndex</type>
      <name>DiagramIndex</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardXComb</name>
      <anchor>z285_0</anchor>
      <arglist>(Energy newMaxEnergy, const cPDPair &amp;inc, tStdEHPtr newEventHandler, tSubHdlPtr newSubProcessHandler, tPExtrPtr newExtractor, const PBPair &amp;newPartonBins, tKinCutPtr newCuts, tMEPtr newME, const DiagramVector &amp;newDiagrams, bool mir)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardXComb</name>
      <anchor>z285_1</anchor>
      <arglist>(const StandardXComb &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardXComb</name>
      <anchor>z285_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~StandardXComb</name>
      <anchor>z285_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardXComb</name>
      <anchor>z285_4</anchor>
      <arglist>(tMEPtr me, const tPVector &amp;parts, DiagramIndex i)</arglist>
    </member>
    <member kind="function">
      <type>tcSubHdlPtr</type>
      <name>subProcessHandler</name>
      <anchor>z287_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tMEPtr</type>
      <name>matrixElement</name>
      <anchor>z287_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>checkInit</name>
      <anchor>z289_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nDim</name>
      <anchor>z289_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>dSigDR</name>
      <anchor>z289_2</anchor>
      <arglist>(const pair&lt; double, double &gt; ll, int nr, const double *r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>construct</name>
      <anchor>z289_3</anchor>
      <arglist>(tSubProPtr)</arglist>
    </member>
    <member kind="function">
      <type>const XSecStat &amp;</type>
      <name>stats</name>
      <anchor>z291_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z291_1</anchor>
      <arglist>(double weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accept</name>
      <anchor>z291_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reject</name>
      <anchor>z291_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z291_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const DiagramVector &amp;</type>
      <name>diagrams</name>
      <anchor>z293_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>mirror</name>
      <anchor>z293_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>z293_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>mePartons</name>
      <anchor>z293_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>mePartonData</name>
      <anchor>z293_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcDiagPtr</type>
      <name>lastDiagram</name>
      <anchor>z293_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>DiagramIndex</type>
      <name>lastDiagramIndex</name>
      <anchor>z293_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const DVector &amp;</type>
      <name>meInfo</name>
      <anchor>z293_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>meInfo</name>
      <anchor>z293_8</anchor>
      <arglist>(const DVector &amp;info)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z295_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z295_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>cPDVector &amp;</type>
      <name>mePartonData</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tPVector &amp;</type>
      <name>mePartons</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>lastDiagramIndex</name>
      <anchor>b3</anchor>
      <arglist>(DiagramIndex)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardXComb &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardXComb &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubHdlPtr</type>
      <name>theSubProcessHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tMEPtr</type>
      <name>theME</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>XSecStat</type>
      <name>theStats</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiagramVector</type>
      <name>theDiagrams</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isMirror</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNDim</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pair&lt; int, int &gt;</type>
      <name>partonDims</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Lorentz5Momentum &gt;</type>
      <name>theMEMomenta</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theMEPartons</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>theMEPartonData</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiagramIndex</type>
      <name>theLastDiagramIndex</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theMEInfo</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardXComb &gt;</type>
      <name>initStandardXComb</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>MEBase</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardXComb, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardXComb_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>XComb</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardXComb &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardXComb_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardXComb &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StepHandler</name>
    <filename>classThePEG_1_1StepHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>StepHandler</name>
      <anchor>z297_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StepHandler</name>
      <anchor>z297_1</anchor>
      <arglist>(const StepHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StepHandler</name>
      <anchor>z297_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z299_0</anchor>
      <arglist>(EventHandler &amp;eh, const tPVector &amp;tagged, const Hint &amp;hint)=0</arglist>
    </member>
    <member kind="function">
      <type>tEHPtr</type>
      <name>eventHandler</name>
      <anchor>z301_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>eventHandler</name>
      <anchor>z301_1</anchor>
      <arglist>(tEHPtr)</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>z301_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>currentStep</name>
      <anchor>z301_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>createNewStep</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z303_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z303_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z303_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z303_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z303_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StepHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StepHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEHPtr</type>
      <name>theEventHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStepPtr</type>
      <name>theNewStep</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStepPtr</type>
      <name>theCurrentStep</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; StepHandler &gt;</type>
      <name>initStepHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StepHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StepHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StepHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StepHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StepHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SubProcessHandler</name>
    <filename>classThePEG_1_1SubProcessHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="typedef">
      <type>vector&lt; HandlerGroupBase * &gt;</type>
      <name>GroupVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ReweightPtr &gt;</type>
      <name>ReweightVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcessHandler</name>
      <anchor>z305_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcessHandler</name>
      <anchor>z305_1</anchor>
      <arglist>(const SubProcessHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SubProcessHandler</name>
      <anchor>z305_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>pExtractor</name>
      <anchor>z307_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MEVector &amp;</type>
      <name>MEs</name>
      <anchor>z307_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>cuts</name>
      <anchor>z307_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const HandlerGroupBase &amp;</type>
      <name>handlerGroup</name>
      <anchor>z307_3</anchor>
      <arglist>(Group::Handler) const </arglist>
    </member>
    <member kind="function">
      <type>const GroupVector &amp;</type>
      <name>groups</name>
      <anchor>z307_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>MEVector &amp;</type>
      <name>MEs</name>
      <anchor>z307_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z309_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z309_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z311_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z311_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z313_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z313_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z313_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setupGroups</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostSubProcessHandler</name>
      <anchor>d1</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostSubProcessHandler</name>
      <anchor>d2</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostSubProcessHandler</name>
      <anchor>d3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostSubProcessHandler</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreCascadeHandler</name>
      <anchor>d5</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreCascadeHandler</name>
      <anchor>d6</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreCascadeHandler</name>
      <anchor>d7</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreCascadeHandler</name>
      <anchor>d8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetCascadeHandler</name>
      <anchor>d9</anchor>
      <arglist>(CascHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CascHdlPtr</type>
      <name>interfaceGetCascadeHandler</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostCascadeHandler</name>
      <anchor>d11</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostCascadeHandler</name>
      <anchor>d12</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostCascadeHandler</name>
      <anchor>d13</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostCascadeHandler</name>
      <anchor>d14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreMultipleInteractionHandler</name>
      <anchor>d15</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreMultipleInteractionHandler</name>
      <anchor>d16</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreMultipleInteractionHandler</name>
      <anchor>d17</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreMultipleInteractionHandler</name>
      <anchor>d18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetMultipleInteractionHandler</name>
      <anchor>d19</anchor>
      <arglist>(MIHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MIHdlPtr</type>
      <name>interfaceGetMultipleInteractionHandler</name>
      <anchor>d20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostMultipleInteractionHandler</name>
      <anchor>d21</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostMultipleInteractionHandler</name>
      <anchor>d22</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostMultipleInteractionHandler</name>
      <anchor>d23</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostMultipleInteractionHandler</name>
      <anchor>d24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreHadronizationHandler</name>
      <anchor>d25</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreHadronizationHandler</name>
      <anchor>d26</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreHadronizationHandler</name>
      <anchor>d27</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreHadronizationHandler</name>
      <anchor>d28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetHadronizationHandler</name>
      <anchor>d29</anchor>
      <arglist>(HadrHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HadrHdlPtr</type>
      <name>interfaceGetHadronizationHandler</name>
      <anchor>d30</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostHadronizationHandler</name>
      <anchor>d31</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostHadronizationHandler</name>
      <anchor>d32</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostHadronizationHandler</name>
      <anchor>d33</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostHadronizationHandler</name>
      <anchor>d34</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreDecayHandler</name>
      <anchor>d35</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreDecayHandler</name>
      <anchor>d36</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreDecayHandler</name>
      <anchor>d37</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreDecayHandler</name>
      <anchor>d38</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetDecayHandler</name>
      <anchor>d39</anchor>
      <arglist>(DecayHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayHdlPtr</type>
      <name>interfaceGetDecayHandler</name>
      <anchor>d40</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostDecayHandler</name>
      <anchor>d41</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostDecayHandler</name>
      <anchor>d42</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostDecayHandler</name>
      <anchor>d43</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostDecayHandler</name>
      <anchor>d44</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>const SubProcessHandler &amp;</type>
      <name>operator=</name>
      <anchor>d45</anchor>
      <arglist>(const SubProcessHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PExtrPtr</type>
      <name>thePartonExtractor</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MEVector</type>
      <name>theMEs</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; SubProcessHandler &gt;</type>
      <name>theSubprocessGroup</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; CascadeHandler &gt;</type>
      <name>theCascadeGroup</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; MultipleInteractionHandler &gt;</type>
      <name>theMultiGroup</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; HadronizationHandler &gt;</type>
      <name>theHadronizationGroup</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; DecayHandler &gt;</type>
      <name>theDecayGroup</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GroupVector</type>
      <name>theGroups</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>reweights</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>preweights</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SubProcessHandler &gt;</type>
      <name>initSubProcessHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SubProcessHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SubProcessHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SubProcessHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SubProcessHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SubProcessHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Two2NCuts</name>
    <filename>classThePEG_1_1Two2NCuts.html</filename>
    <base>ThePEG::KinematicalCuts</base>
    <member kind="function">
      <type></type>
      <name>Two2NCuts</name>
      <anchor>z315_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Two2NCuts</name>
      <anchor>z315_1</anchor>
      <arglist>(const Two2NCuts &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Two2NCuts</name>
      <anchor>z315_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>massMin</name>
      <anchor>z317_0</anchor>
      <arglist>(int n, int i) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>massMax</name>
      <anchor>z317_1</anchor>
      <arglist>(int n, int i) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pTMin</name>
      <anchor>z317_2</anchor>
      <arglist>(int n, int i) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pTMax</name>
      <anchor>z317_3</anchor>
      <arglist>(int n, int i) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diMassMin</name>
      <anchor>z317_4</anchor>
      <arglist>(int n, int i, int j) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diMassMax</name>
      <anchor>z317_5</anchor>
      <arglist>(int n, int i, int j) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z319_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z319_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>b0</anchor>
      <arglist>(const SubProcess &amp;) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z321_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z321_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z323_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z323_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z323_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z323_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z323_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; pair&lt; int, int &gt;, Energy &gt;</type>
      <name>Limits2Map</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; Triplet&lt; int, int, int &gt;, Energy &gt;</type>
      <name>Limits3Map</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; Energy &gt;</type>
      <name>LimitsVector</name>
      <anchor>y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetMassMins</name>
      <anchor>d0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMassMins</name>
      <anchor>d1</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insMassMins</name>
      <anchor>d2</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delMassMins</name>
      <anchor>d3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getMassMins</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetMassMins</name>
      <anchor>d5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetMassMaxs</name>
      <anchor>d6</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMassMaxs</name>
      <anchor>d7</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insMassMaxs</name>
      <anchor>d8</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delMassMaxs</name>
      <anchor>d9</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getMassMaxs</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetMassMaxs</name>
      <anchor>d11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetPTMins</name>
      <anchor>d12</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPTMins</name>
      <anchor>d13</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insPTMins</name>
      <anchor>d14</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delPTMins</name>
      <anchor>d15</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getPTMins</name>
      <anchor>d16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetPTMins</name>
      <anchor>d17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetPTMaxs</name>
      <anchor>d18</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPTMaxs</name>
      <anchor>d19</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insPTMaxs</name>
      <anchor>d20</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delPTMaxs</name>
      <anchor>d21</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getPTMaxs</name>
      <anchor>d22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetPTMaxs</name>
      <anchor>d23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetDiMassMins</name>
      <anchor>d24</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setDiMassMins</name>
      <anchor>d25</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insDiMassMins</name>
      <anchor>d26</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delDiMassMins</name>
      <anchor>d27</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getDiMassMins</name>
      <anchor>d28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetDiMassMins</name>
      <anchor>d29</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetDiMassMaxs</name>
      <anchor>d30</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setDiMassMaxs</name>
      <anchor>d31</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insDiMassMaxs</name>
      <anchor>d32</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delDiMassMaxs</name>
      <anchor>d33</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getDiMassMaxs</name>
      <anchor>d34</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetDiMassMaxs</name>
      <anchor>d35</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>pair&lt; int, int &gt;</type>
      <name>get2index</name>
      <anchor>d36</anchor>
      <arglist>(int k) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Triplet&lt; int, int, int &gt;</type>
      <name>get3index</name>
      <anchor>d37</anchor>
      <arglist>(int k) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>index2</name>
      <anchor>d38</anchor>
      <arglist>(const pair&lt; int, int &gt; &amp;) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>index3</name>
      <anchor>d39</anchor>
      <arglist>(const Triplet&lt; int, int, int &gt; &amp;) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Two2NCuts &amp;</type>
      <name>operator=</name>
      <anchor>d40</anchor>
      <arglist>(const Two2NCuts &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>theMassMins</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>theMassMaxs</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>thePTMins</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>thePTMaxs</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits3Map</type>
      <name>theDiMassMins</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits3Map</type>
      <name>theDiMassMaxs</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Two2NCuts &gt;</type>
      <name>initTwo2NCuts</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Two2NCuts, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Two2NCuts_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>KinematicalCuts</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Two2NCuts &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Two2NCuts_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Two2NCuts &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutCmdFail1</name>
    <filename>structThePEG_1_1KinCutCmdFail1.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>KinCutCmdFail1</name>
      <anchor>a0</anchor>
      <arglist>(const Two2NCuts &amp;, string, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutCmdFail2</name>
    <filename>structThePEG_1_1KinCutCmdFail2.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>KinCutCmdFail2</name>
      <anchor>a0</anchor>
      <arglist>(const Two2NCuts &amp;, string, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutCmdFail3</name>
    <filename>structThePEG_1_1KinCutCmdFail3.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>KinCutCmdFail3</name>
      <anchor>a0</anchor>
      <arglist>(const Two2NCuts &amp;, string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::XComb</name>
    <filename>classThePEG_1_1XComb.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z325_0</anchor>
      <arglist>(Energy newMaxEnergy, const cPDPair &amp;inc, tEHPtr newEventHandler, tPExtrPtr newExtractor, const PBPair &amp;newPartonBins, tKinCutPtr newCuts)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z325_1</anchor>
      <arglist>(const XComb &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z325_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~XComb</name>
      <anchor>z325_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const EventHandler &amp;</type>
      <name>eventHandler</name>
      <anchor>z327_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>pExtractor</name>
      <anchor>z327_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>cuts</name>
      <anchor>z327_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>particles</name>
      <anchor>z329_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>partons</name>
      <anchor>z329_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PBPair &amp;</type>
      <name>partonBins</name>
      <anchor>z329_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>maxEnergy</name>
      <anchor>z329_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>z329_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clean</name>
      <anchor>z331_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setPartonBinInstances</name>
      <anchor>z331_1</anchor>
      <arglist>(PBIPair pbis, Energy2 scale)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>prepare</name>
      <anchor>z331_2</anchor>
      <arglist>(const PPair &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastParticles</name>
      <anchor>z331_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastPartons</name>
      <anchor>z331_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastPartons</name>
      <anchor>z331_5</anchor>
      <arglist>(PPair)</arglist>
    </member>
    <member kind="function">
      <type>const PBIPair &amp;</type>
      <name>partonBinInstances</name>
      <anchor>z331_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastS</name>
      <anchor>z331_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastS</name>
      <anchor>z331_8</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastSHat</name>
      <anchor>z331_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastSHat</name>
      <anchor>z331_10</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastTau</name>
      <anchor>z331_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastY</name>
      <anchor>z331_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastY</name>
      <anchor>z331_13</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP1</name>
      <anchor>z331_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP2</name>
      <anchor>z331_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastP1P2</name>
      <anchor>z331_16</anchor>
      <arglist>(pair&lt; double, double &gt;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL1</name>
      <anchor>z331_17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL2</name>
      <anchor>z331_18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastL1L2</name>
      <anchor>z331_19</anchor>
      <arglist>(pair&lt; double, double &gt;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX1</name>
      <anchor>z331_20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX2</name>
      <anchor>z331_21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastX1X2</name>
      <anchor>z331_22</anchor>
      <arglist>(pair&lt; double, double &gt;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE1</name>
      <anchor>z331_23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE2</name>
      <anchor>z331_24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastE1E2</name>
      <anchor>z331_25</anchor>
      <arglist>(pair&lt; double, double &gt;)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastScale</name>
      <anchor>z331_26</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastScale</name>
      <anchor>z331_27</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z333_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z333_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setPartonBinInfo</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>createPartonBinInstances</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>XComb &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const XComb &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEHPtr</type>
      <name>theEventHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PExtrPtr</type>
      <name>thePartonExtractor</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>theParticles</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>thePartons</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBPair</type>
      <name>thePartonBins</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBPair</type>
      <name>theParticleBins</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBIPair</type>
      <name>thePartonBinInstances</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theLastParticles</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theLastPartons</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastS</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastSHat</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastY</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastP1P2</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastL1L2</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastX1X2</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastE1E2</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastScale</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMaxEnergy</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theMEInfo</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; XComb &gt;</type>
      <name>initXComb</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; XComb, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01XComb_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; XComb &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01XComb_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; XComb &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ZGenerator</name>
    <filename>classThePEG_1_1ZGenerator.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>ZGenerator</name>
      <anchor>z335_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ZGenerator</name>
      <anchor>z335_1</anchor>
      <arglist>(const ZGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ZGenerator</name>
      <anchor>z335_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z337_0</anchor>
      <arglist>(cPDPtr q1, cPDPtr q2, Energy2 mT2) const =0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ZGenerator &gt;</type>
      <name>initZGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ZGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ZGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ZGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ZGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ZGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::FermionSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1FermionSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::FermionSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1FermionSpinInfo_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::FermionSpinInfo &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::HelicityVertex, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1HelicityVertex_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventInfoBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::HelicityVertex &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1HelicityVertex_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::HelicityVertex &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::RSFermionSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1RSFermionSpinInfo_00_011_01_4.html</filename>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::RSFermionSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1RSFermionSpinInfo_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::RSFermionSpinInfo &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::ScalarSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1ScalarSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::ScalarSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1ScalarSpinInfo_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::ScalarSpinInfo &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::SpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1SpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>SpinBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::SpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1SpinInfo_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::SpinInfo &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::TensorSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1TensorSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::TensorSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1TensorSpinInfo_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::TensorSpinInfo &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::VectorSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1VectorSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::VectorSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1VectorSpinInfo_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEG::Helicity::VectorSpinInfo &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDocumentationBase</name>
    <filename>classThePEG_1_1ClassDocumentationBase.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDocumentationBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>documentation</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>modelDescription</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>modelReferences</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ClassDocumentationBase</name>
      <anchor>b0</anchor>
      <arglist>(string newDocumentation, string newModelDescription, string newModelReferences, const type_info &amp;newTypeInfo)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentationBase</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentationBase</name>
      <anchor>d1</anchor>
      <arglist>(const ClassDocumentationBase &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ClassDocumentationBase &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ClassDocumentationBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDocumentation</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theModelDescription</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theModelReferences</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDocumentation</name>
    <filename>classThePEG_1_1ClassDocumentation.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDocumentationBase</base>
    <member kind="function">
      <type></type>
      <name>ClassDocumentation</name>
      <anchor>a0</anchor>
      <arglist>(string newDocumentation, string newModelDescription=&quot;&quot;, string newModelReferences=&quot;&quot;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDocumentation</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentation</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentation</name>
      <anchor>d1</anchor>
      <arglist>(const ClassDocumentation &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ClassDocumentation &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ClassDocumentation &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CommandBase</name>
    <filename>classThePEG_1_1CommandBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>CommandBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CommandBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>cmd</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, string c) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Command</name>
    <filename>classThePEG_1_1Command.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::CommandBase</base>
    <member kind="typedef">
      <type>string(T::*</type>
      <name>ExeFn</name>
      <anchor>w0</anchor>
      <arglist>)(string)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Command</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, ExeFn newExeFn, bool depSafe=false)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Command</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>cmd</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ExeFn</type>
      <name>theExeFn</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CmdExUnknown</name>
    <filename>structThePEG_1_1CmdExUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>CmdExUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::InterfaceBase</name>
    <filename>classThePEG_1_1InterfaceBase.html</filename>
    <base>ThePEG::Named</base>
    <member kind="function">
      <type></type>
      <name>InterfaceBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~InterfaceBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, const TranslationMap &amp;trans, const IVector &amp;defs=IVector()) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;is) const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>description</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>fullDescription</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;stream) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>className</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>dependencySafe</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDependencySafe</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDependencySensitive</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>readOnly</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setReadOnly</name>
      <anchor>a15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setReadWrite</name>
      <anchor>a16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>anonymous</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" static="yes">
      <type>bool</type>
      <name>NoReadOnly</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isDependencySafe</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isReadOnly</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDescription</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theClassName</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RefInterfaceBase</name>
    <filename>classThePEG_1_1RefInterfaceBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>RefInterfaceBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, string newRefClassName, const type_info &amp;newRefTypeInfo, bool depSafe, bool readonly, bool norebind, bool nullable, bool defnull)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>refClassName</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const type_info &amp;</type>
      <name>refTypeInfo</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>noRebind</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNoRebind</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRebind</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>noNull</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNullable</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNotNullable</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>defaultIfNull</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultIfNull</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNoDefaultIfNull</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theRefClassName</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const type_info &amp;</type>
      <name>theRefTypeInfo</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>dontRebind</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isNullable</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theDefaultIfNull</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfaceException</name>
    <filename>structThePEG_1_1InterfaceException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>InterfaceException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExClass</name>
    <filename>structThePEG_1_1InterExClass.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExClass</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExSetup</name>
    <filename>structThePEG_1_1InterExSetup.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExSetup</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExUnknown</name>
    <filename>structThePEG_1_1InterExUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExReadOnly</name>
    <filename>structThePEG_1_1InterExReadOnly.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExReadOnly</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExNoNull</name>
    <filename>structThePEG_1_1InterExNoNull.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExNoNull</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Interfaced</name>
    <filename>classThePEG_1_1Interfaced.html</filename>
    <base>ThePEG::InterfacedBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Interfaced</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>debug</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>getParticle</name>
      <anchor>z435_0</anchor>
      <arglist>(long) const </arglist>
    </member>
    <member kind="function">
      <type>PDPtr</type>
      <name>getParticleData</name>
      <anchor>z435_1</anchor>
      <arglist>(long) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>used</name>
      <anchor>z435_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>useMe</name>
      <anchor>z435_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tEGPtr</type>
      <name>generator</name>
      <anchor>z435_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z437_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z437_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>Interfaced</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>Interfaced</name>
      <anchor>b1</anchor>
      <arglist>(string newName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>Interfaced</name>
      <anchor>b2</anchor>
      <arglist>(const Interfaced &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z439_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z439_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z439_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z439_3</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>registerRepository</name>
      <anchor>f0</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>registerRepository</name>
      <anchor>f1</anchor>
      <arglist>(IBPtr, string newName)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setUsed</name>
      <anchor>d0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Interfaced &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Interfaced &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEGPtr</type>
      <name>theGenerator</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theUseFlag</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; Interfaced &gt;</type>
      <name>initInterfaced</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>Repository</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Interfaced, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Interfaced_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>InterfacedBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Interfaced &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Interfaced_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Interfaced &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::InterfacedBase</name>
    <filename>classThePEG_1_1InterfacedBase.html</filename>
    <base>ThePEG::Base</base>
    <base>ThePEG::Named</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~InterfacedBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>fullName</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>name</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>path</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>comment</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setup</name>
      <anchor>a5</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>z443_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>z443_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initrun</name>
      <anchor>z443_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finish</name>
      <anchor>z443_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>touch</name>
      <anchor>z443_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z443_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>z443_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>locked</name>
      <anchor>z443_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>touched</name>
      <anchor>z443_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z445_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z445_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>b0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>InterfacedBase</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>InterfacedBase</name>
      <anchor>b2</anchor>
      <arglist>(string newName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>InterfacedBase</name>
      <anchor>b3</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>z441_0</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z441_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z441_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z441_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z441_4</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z441_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z441_6</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="enumeration">
      <name>InitState</name>
      <anchor>y4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>initializing</name>
      <anchor>y4y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>uninitialized</name>
      <anchor>y4y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>initialized</name>
      <anchor>y4y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>runready</name>
      <anchor>y4y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>name</name>
      <anchor>d0</anchor>
      <arglist>(string newName)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>lock</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>unlock</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>untouch</name>
      <anchor>d3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>addComment</name>
      <anchor>d4</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>InterfacedBase &amp;</type>
      <name>operator=</name>
      <anchor>d5</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isLocked</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isTouched</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>InitState</type>
      <name>initState</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theComment</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; InterfacedBase &gt;</type>
      <name>initInterfacedBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>BaseRepository</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ptr &amp;i)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(tIBPtr, bool &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateMapChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateMapChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateMapChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ref &amp;i)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ptr &amp;i)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(tIBPtr, bool &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateMapChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateMapChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateMapChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ref &amp;i)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; InterfacedBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01InterfacedBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PersistentBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; InterfacedBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01InterfacedBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; InterfacedBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SetupException</name>
    <filename>structThePEG_1_1SetupException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SetupException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::UpdateException</name>
    <filename>structThePEG_1_1UpdateException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>UpdateException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RebindException</name>
    <filename>structThePEG_1_1RebindException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RebindException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InitException</name>
    <filename>structThePEG_1_1InitException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InitException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParameterBase</name>
    <filename>classThePEG_1_1ParameterBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>ParameterBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly, int limits)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParameterBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>fullDescription</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>get</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a9</anchor>
      <arglist>(InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>limited</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>upperLimit</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>lowerLimit</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimited</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUnlimited</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>limit</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParameterTBase</name>
    <filename>classThePEG_1_1ParameterTBase.html</filename>
    <templarg>Type</templarg>
    <base>ThePEG::ParameterBase</base>
    <member kind="function">
      <type></type>
      <name>ParameterTBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, Type newUnit, bool depSafe, bool readonly, int limits)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParameterTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, string newValue) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, Type) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tget</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a12</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a13</anchor>
      <arglist>(InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function">
      <type>Type</type>
      <name>unit</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>unit</name>
      <anchor>a15</anchor>
      <arglist>(Type u)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>putUnit</name>
      <anchor>b0</anchor>
      <arglist>(ostream &amp;, Type val) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theUnit</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Parameter</name>
    <filename>classThePEG_1_1Parameter.html</filename>
    <templarg>T</templarg>
    <templarg>Type</templarg>
    <base>ThePEG::ParameterTBase</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(Type)</arglist>
    </member>
    <member kind="typedef">
      <type>Type(T::*</type>
      <name>GetFn</name>
      <anchor>w1</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>Type T::*</type>
      <name>Member</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool limits=true, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newMinFn=0, GetFn newMaxFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newUnit, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool limits=true, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newMinFn=0, GetFn newMaxFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a2</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, int limits=Interface::limited, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newMinFn=0, GetFn newMaxFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a3</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newUnit, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, int limits=Interface::limited, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newMinFn=0, GetFn newMaxFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Parameter</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tget</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a10</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a11</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a12</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMinFunction</name>
      <anchor>a13</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxFunction</name>
      <anchor>a14</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a15</anchor>
      <arglist>(ostream &amp;stream) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theDefFn</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theMinFn</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theMaxFn</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParameterTBase&lt; string &gt;</name>
    <filename>classThePEG_1_1ParameterTBase_3_01string_01_4.html</filename>
    <base>ThePEG::ParameterBase</base>
    <member kind="function">
      <type></type>
      <name>ParameterTBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParameterTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, string newValue) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>tget</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>tdef</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a11</anchor>
      <arglist>(InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Parameter&lt; T, string &gt;</name>
    <filename>classThePEG_1_1Parameter_3_01T_00_01string_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ParameterTBase&lt; string &gt;</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(string)</arglist>
    </member>
    <member kind="typedef">
      <type>string(T::*</type>
      <name>GetFn</name>
      <anchor>w1</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>string T::*</type>
      <name>Member</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, string newDef, bool depSafe=false, bool readonly=false, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Parameter</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string val) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>tget</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>tdef</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a5</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a6</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a7</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;stream) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theDefFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParExSetLimit</name>
    <filename>structThePEG_1_1ParExSetLimit.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParExSetLimit</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParExSetUnknown</name>
    <filename>structThePEG_1_1ParExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T val)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParExGetUnknown</name>
    <filename>structThePEG_1_1ParExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, const char *)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParVectorBase</name>
    <filename>classThePEG_1_1ParVectorBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVectorBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, int newSize, bool depSafe, bool readonly, int limits)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParVectorBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;, string action, string arguments) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual StringVector</type>
      <name>get</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a10</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>limited</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>upperLimit</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>lowerLimit</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimited</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUnlimited</name>
      <anchor>a15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSize</name>
      <anchor>a17</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVariableSize</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>limit</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theSize</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParVectorTBase</name>
    <filename>classThePEG_1_1ParVectorTBase.html</filename>
    <templarg>Type</templarg>
    <base>ThePEG::ParVectorBase</base>
    <member kind="typedef">
      <type>vector&lt; Type &gt;</type>
      <name>TypeVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVectorTBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, Type newUnit, int newSize, bool depSafe, bool readonly, int limits)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParVectorTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a6</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tinsert</name>
      <anchor>a7</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual StringVector</type>
      <name>get</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual TypeVector</type>
      <name>tget</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a12</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a13</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a14</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a15</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a16</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function">
      <type>Type</type>
      <name>unit</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>unit</name>
      <anchor>a18</anchor>
      <arglist>(Type u)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>putUnit</name>
      <anchor>b0</anchor>
      <arglist>(ostream &amp;, Type val) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theUnit</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParVector</name>
    <filename>classThePEG_1_1ParVector.html</filename>
    <templarg>T</templarg>
    <templarg>Type</templarg>
    <base>ThePEG::ParVectorTBase</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(Type, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>InsFn</name>
      <anchor>w1</anchor>
      <arglist>)(Type, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>DelFn</name>
      <anchor>w2</anchor>
      <arglist>)(int)</arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Type &gt;</type>
      <name>TypeVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TypeVector(T::*</type>
      <name>GetFn</name>
      <anchor>w4</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>StringVector(T::*</type>
      <name>StringGetFn</name>
      <anchor>w6</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>Type(T::*</type>
      <name>DefFn</name>
      <anchor>w7</anchor>
      <arglist>)(int) const </arglist>
    </member>
    <member kind="typedef">
      <type>TypeVector T::*</type>
      <name>Member</name>
      <anchor>w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVector</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool limits=true, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, DefFn newDefFn=0, DefFn newMinFn=0, DefFn newMaxFn=0, StringGetFn newStringGetFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVector</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newUnit, int newSize, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool limits=true, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, DefFn newDefFn=0, DefFn newMinFn=0, DefFn newMaxFn=0, StringGetFn newStringGetFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVector</name>
      <anchor>a2</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, int limits=Interface::limited, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, DefFn newDefFn=0, DefFn newMinFn=0, DefFn newMaxFn=0, StringGetFn newStringGetFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVector</name>
      <anchor>a3</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newUnit, int newSize, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, int limits=Interface::limited, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, DefFn newDefFn=0, DefFn newMinFn=0, DefFn newMaxFn=0, StringGetFn newStringGetFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tinsert</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a6</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual StringVector</type>
      <name>get</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual TypeVector</type>
      <name>tget</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;, int) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a12</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setInsertFunction</name>
      <anchor>a13</anchor>
      <arglist>(InsFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a14</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setEraseFunction</name>
      <anchor>a15</anchor>
      <arglist>(DelFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a16</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMinFunction</name>
      <anchor>a17</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxFunction</name>
      <anchor>a18</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setStringGetFunction</name>
      <anchor>a19</anchor>
      <arglist>(StringGetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a20</anchor>
      <arglist>(ostream &amp;stream) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>InsFn</type>
      <name>theInsFn</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DelFn</type>
      <name>theDelFn</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DefFn</type>
      <name>theDefFn</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DefFn</type>
      <name>theMinFn</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DefFn</type>
      <name>theMaxFn</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringGetFn</type>
      <name>theStringGetFn</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExLimit</name>
    <filename>structThePEG_1_1ParVExLimit.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExLimit</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExUnknown</name>
    <filename>structThePEG_1_1ParVExUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T v, int j, const char *s)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExIndex</name>
    <filename>structThePEG_1_1ParVExIndex.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExIndex</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int index)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExFixed</name>
    <filename>structThePEG_1_1ParVExFixed.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExFixed</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExDelUnknown</name>
    <filename>structThePEG_1_1ParVExDelUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExDelUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int j)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExGetUnknown</name>
    <filename>structThePEG_1_1ParVExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, const char *s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReferenceBase</name>
    <filename>classThePEG_1_1ReferenceBase.html</filename>
    <base>ThePEG::RefInterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>ReferenceBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, string newRefClassName, const type_info &amp;newRefTypeInfo, bool depSafe, bool readonly, bool norebind, bool nullable, bool defnull)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReferenceBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, bool chk=true) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual IBPtr</type>
      <name>get</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr ip) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a8</anchor>
      <arglist>(InterfacedBase &amp;ib, const TranslationMap &amp;trans, const IVector &amp;defs) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Reference</name>
    <filename>classThePEG_1_1Reference.html</filename>
    <templarg>T</templarg>
    <templarg>R</templarg>
    <base>ThePEG::ReferenceBase</base>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::pointer</type>
      <name>RefPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::const_pointer</type>
      <name>cRefPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w2</anchor>
      <arglist>)(RefPtr)</arglist>
    </member>
    <member kind="typedef">
      <type>bool(T::*</type>
      <name>CheckFn</name>
      <anchor>w3</anchor>
      <arglist>)(cRefPtr) const </arglist>
    </member>
    <member kind="typedef">
      <type>RefPtr(T::*</type>
      <name>GetFn</name>
      <anchor>w4</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>RefPtr T::*</type>
      <name>Member</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Reference</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, bool depSafe=false, bool readonly=false, bool rebind=true, bool nullable=true, SetFn newSetFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Reference</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, bool depSafe, bool readonly, bool rebind, bool nullable, bool defnull, SetFn newSetFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, bool chk=true) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>get</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr newRef) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a5</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a6</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setCheckFunction</name>
      <anchor>a7</anchor>
      <arglist>(CheckFn)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CheckFn</type>
      <name>theCheckFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetRefClass</name>
    <filename>structThePEG_1_1RefExSetRefClass.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetRefClass</name>
      <anchor>a0</anchor>
      <arglist>(const RefInterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetUnknown</name>
    <filename>structThePEG_1_1RefExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExGetUnknown</name>
    <filename>structThePEG_1_1RefExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetNoobj</name>
    <filename>structThePEG_1_1RefExSetNoobj.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetNoobj</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetMessage</name>
    <filename>structThePEG_1_1RefExSetMessage.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetMessage</name>
      <anchor>a0</anchor>
      <arglist>(string ref, const InterfacedBase &amp;o, const InterfacedBase &amp;o2, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RefVectorBase</name>
    <filename>classThePEG_1_1RefVectorBase.html</filename>
    <base>ThePEG::RefInterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>RefVectorBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, string newRefClassName, const type_info &amp;newRefTypeInfo, int newSize, bool depSafe, bool readonly, bool norebind, bool nullable, bool defnull)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RefVectorBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a6</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a7</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual IVector</type>
      <name>get</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr ip, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a10</anchor>
      <arglist>(InterfacedBase &amp;ib, const TranslationMap &amp;trans, const IVector &amp;defs) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSize</name>
      <anchor>a13</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVariableSize</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theSize</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RefVector</name>
    <filename>classThePEG_1_1RefVector.html</filename>
    <templarg>T</templarg>
    <templarg>R</templarg>
    <base>ThePEG::RefVectorBase</base>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::pointer</type>
      <name>RefPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::const_pointer</type>
      <name>cRefPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w2</anchor>
      <arglist>)(RefPtr, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>InsFn</name>
      <anchor>w3</anchor>
      <arglist>)(RefPtr, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>DelFn</name>
      <anchor>w4</anchor>
      <arglist>)(int)</arglist>
    </member>
    <member kind="typedef">
      <type>bool(T::*</type>
      <name>CheckFn</name>
      <anchor>w5</anchor>
      <arglist>)(cRefPtr, int) const </arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; RefPtr &gt;(T::*</type>
      <name>GetFn</name>
      <anchor>w6</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; RefPtr &gt; T::*</type>
      <name>Member</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RefVector</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, bool depSafe=false, bool readonly=false, bool rebind=true, bool nullable=true, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RefVector</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, bool depSafe, bool readonly, bool rebind, bool nullable, bool defnull, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr, int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a7</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setInsertFunction</name>
      <anchor>a8</anchor>
      <arglist>(InsFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a9</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setEraseFunction</name>
      <anchor>a10</anchor>
      <arglist>(DelFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setCheckFunction</name>
      <anchor>a11</anchor>
      <arglist>(CheckFn)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>InsFn</type>
      <name>theInsFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DelFn</type>
      <name>theDelFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CheckFn</type>
      <name>theCheckFn</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExRefClass</name>
    <filename>structThePEG_1_1RefVExRefClass.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExRefClass</name>
      <anchor>a0</anchor>
      <arglist>(const RefInterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r, const char *)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExSetUnknown</name>
    <filename>structThePEG_1_1RefVExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const RefInterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r, int j, const char *)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExSetUnfound</name>
    <filename>structThePEG_1_1RefVExSetUnfound.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExSetUnfound</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExIndex</name>
    <filename>structThePEG_1_1RefVExIndex.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExIndex</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int j)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExFixed</name>
    <filename>structThePEG_1_1RefVExFixed.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExFixed</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExDelUnknown</name>
    <filename>structThePEG_1_1RefVExDelUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExDelUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int j)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExGetUnknown</name>
    <filename>structThePEG_1_1RefVExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExNoSet</name>
    <filename>structThePEG_1_1RefVExNoSet.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExNoSet</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExNoIns</name>
    <filename>structThePEG_1_1RefVExNoIns.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExNoIns</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExNoDel</name>
    <filename>structThePEG_1_1RefVExNoDel.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExNoDel</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SwitchOption</name>
    <filename>classThePEG_1_1SwitchOption.html</filename>
    <base>ThePEG::Named</base>
    <member kind="function">
      <type></type>
      <name>SwitchOption</name>
      <anchor>a0</anchor>
      <arglist>(SwitchBase &amp;theSwitch, string newName, string newDescription, long newValue)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SwitchOption</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SwitchOption</name>
      <anchor>a2</anchor>
      <arglist>(const SwitchOption &amp;o)</arglist>
    </member>
    <member kind="function">
      <type>const SwitchOption &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const SwitchOption &amp;o)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>description</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>value</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator long</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDescription</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theValue</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SwitchBase</name>
    <filename>classThePEG_1_1SwitchBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="typedef">
      <type>map&lt; long, SwitchOption &gt;</type>
      <name>OptionMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, SwitchOption &gt;</type>
      <name>StringMap</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SwitchBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SwitchBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, long val) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>def</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDef</name>
      <anchor>a7</anchor>
      <arglist>(InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>check</name>
      <anchor>a8</anchor>
      <arglist>(long val) const </arglist>
    </member>
    <member kind="function">
      <type>const OptionMap &amp;</type>
      <name>options</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>registerOption</name>
      <anchor>b0</anchor>
      <arglist>(const SwitchOption &amp;o)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>OptionMap</type>
      <name>theOptions</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringMap</type>
      <name>theOptionNames</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>SwitchOption</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Switch</name>
    <filename>classThePEG_1_1Switch.html</filename>
    <templarg>T</templarg>
    <templarg>Int</templarg>
    <base>ThePEG::SwitchBase</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(Int)</arglist>
    </member>
    <member kind="typedef">
      <type>Int(T::*</type>
      <name>GetFn</name>
      <anchor>w1</anchor>
      <arglist>)() const </arglist>
    </member>
    <member kind="typedef">
      <type>Int T::*</type>
      <name>Member</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Switch</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Int newDef, bool depSafe=false, bool readonly=false, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Switch</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, long val) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>get</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>def</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a5</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a6</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a7</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;stream) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Int</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theDefFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SwExSetOpt</name>
    <filename>structThePEG_1_1SwExSetOpt.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SwExSetOpt</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, long v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SwExSetUnknown</name>
    <filename>structThePEG_1_1SwExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SwExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, long v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SwExGetUnknown</name>
    <filename>structThePEG_1_1SwExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SwExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, const char *s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HEPRUP</name>
    <filename>classThePEG_1_1HEPRUP.html</filename>
    <member kind="function">
      <type></type>
      <name>HEPRUP</name>
      <anchor>z447_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HEPRUP</name>
      <anchor>z447_1</anchor>
      <arglist>(const HEPRUP &amp;)</arglist>
    </member>
    <member kind="function">
      <type>HEPRUP &amp;</type>
      <name>operator=</name>
      <anchor>z447_2</anchor>
      <arglist>(const HEPRUP &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HEPRUP</name>
      <anchor>z447_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>pair&lt; long, long &gt;</type>
      <name>IDBMUP</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>pair&lt; double, double &gt;</type>
      <name>EBMUP</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>pair&lt; int, int &gt;</type>
      <name>PDFGUP</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>pair&lt; int, int &gt;</type>
      <name>PDFSUP</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>IDWTUP</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NRUP</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; double &gt;</type>
      <name>XSECUP</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; double &gt;</type>
      <name>XERRUP</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; double &gt;</type>
      <name>XMAXUP</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>LPRUP</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HEPEUP</name>
    <filename>classThePEG_1_1HEPEUP.html</filename>
    <member kind="function">
      <type></type>
      <name>HEPEUP</name>
      <anchor>z449_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HEPEUP</name>
      <anchor>z449_1</anchor>
      <arglist>(const HEPEUP &amp;)</arglist>
    </member>
    <member kind="function">
      <type>HEPEUP &amp;</type>
      <name>operator=</name>
      <anchor>z449_2</anchor>
      <arglist>(const HEPEUP &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HEPEUP</name>
      <anchor>z449_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>NUP</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>IDPRUP</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>XWGTUP</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>pair&lt; double, double &gt;</type>
      <name>XPDWUP</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>SCALUP</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>AQEDUP</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>AQCDUP</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; long &gt;</type>
      <name>IDUP</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>ISTUP</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; pair&lt; int, int &gt; &gt;</type>
      <name>MOTHUP</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; pair&lt; int, int &gt; &gt;</type>
      <name>ICOLUP</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; vector&lt; double &gt; &gt;</type>
      <name>PUP</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; double &gt;</type>
      <name>VTIMUP</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; double &gt;</type>
      <name>SPINUP</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesEventHandler</name>
    <filename>classThePEG_1_1LesHouchesEventHandler.html</filename>
    <base>ThePEG::EventHandler</base>
    <member kind="typedef">
      <type>vector&lt; LesHouchesReaderPtr &gt;</type>
      <name>ReaderVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CompSelector&lt; int, CrossSection &gt;</type>
      <name>ReaderSelector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>WeightOpt</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unitweight</name>
      <anchor>w6w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unitnegweight</name>
      <anchor>w6w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>varweight</name>
      <anchor>w6w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>varnegweight</name>
      <anchor>w6w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesEventHandler</name>
      <anchor>z451_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesEventHandler</name>
      <anchor>z451_1</anchor>
      <arglist>(const LesHouchesEventHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LesHouchesEventHandler</name>
      <anchor>z451_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z453_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>statistics</name>
      <anchor>z453_1</anchor>
      <arglist>(ostream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>histogramScale</name>
      <anchor>z453_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>generateEvent</name>
      <anchor>z455_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tCollPtr</type>
      <name>performCollision</name>
      <anchor>z455_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>continueEvent</name>
      <anchor>z455_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z457_0</anchor>
      <arglist>(double weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accept</name>
      <anchor>z457_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reject</name>
      <anchor>z457_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>increaseMaxXSec</name>
      <anchor>z457_3</anchor>
      <arglist>(CrossSection maxxsec)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>skipEvents</name>
      <anchor>z457_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>WeightOpt</type>
      <name>weightOption</name>
      <anchor>z459_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ReaderVector &amp;</type>
      <name>readers</name>
      <anchor>z459_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ReaderSelector &amp;</type>
      <name>selector</name>
      <anchor>z459_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tLesHouchesReaderPtr</type>
      <name>currentReader</name>
      <anchor>z459_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentReader</name>
      <anchor>z459_4</anchor>
      <arglist>(tLesHouchesReaderPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z461_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z461_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ReaderVector &amp;</type>
      <name>readers</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ReaderSelector &amp;</type>
      <name>selector</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z463_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z463_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z465_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z465_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z465_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z465_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z465_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z465_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>XSecStat</type>
      <name>stats</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>XSecStat</type>
      <name>histStats</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>LesHouchesEventHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LesHouchesEventHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReaderVector</type>
      <name>theReaders</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReaderSelector</type>
      <name>theSelector</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightOpt</type>
      <name>theWeightOption</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tLesHouchesReaderPtr</type>
      <name>theCurrentReader</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; LesHouchesEventHandler &gt;</type>
      <name>initLesHouchesEventHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesEventHandler::LesHouchesInitError</name>
    <filename>classThePEG_1_1LesHouchesEventHandler_1_1LesHouchesInitError.html</filename>
    <base>ThePEG::InitException</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesEventHandler::LesHouchesInitError</name>
    <filename>classThePEG_1_1LesHouchesEventHandler_1_1LesHouchesInitError.html</filename>
    <base>ThePEG::InitException</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LesHouchesEventHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LesHouchesEventHandler_00_011_01_4.html</filename>
    <member kind="typedef">
      <type>EventHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LesHouchesEventHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LesHouchesEventHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LesHouchesEventHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesFileReader</name>
    <filename>classThePEG_1_1LesHouchesFileReader.html</filename>
    <base>ThePEG::LesHouchesReader</base>
    <member kind="function">
      <type>string</type>
      <name>filename</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FILE *</type>
      <name>file</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesFileReader</name>
      <anchor>z467_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesFileReader</name>
      <anchor>z467_1</anchor>
      <arglist>(const LesHouchesFileReader &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LesHouchesFileReader</name>
      <anchor>z467_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>open</name>
      <anchor>z469_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>close</name>
      <anchor>z469_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z471_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z471_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z473_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z473_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z473_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z473_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z473_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z473_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>CFileLineReader</type>
      <name>cfile</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>neve</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>ieve</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>LesHouchesFileReader &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LesHouchesFileReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FILE *</type>
      <name>theFile</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theFileName</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; LesHouchesFileReader &gt;</type>
      <name>initLesHouchesFileReader</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesFileReader::LesHouchesFileError</name>
    <filename>classThePEG_1_1LesHouchesFileReader_1_1LesHouchesFileError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesFileReader::LesHouchesFileError</name>
    <filename>classThePEG_1_1LesHouchesFileReader_1_1LesHouchesFileError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LesHouchesFileReader, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LesHouchesFileReader_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>LesHouchesReader</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LesHouchesFileReader &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LesHouchesFileReader_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LesHouchesFileReader &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader</name>
    <filename>classThePEG_1_1LesHouchesReader.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type>const PBIPair &amp;</type>
      <name>partonBinInstances</name>
      <anchor>z481_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>beams</name>
      <anchor>z481_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>z481_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>outgoing</name>
      <anchor>z481_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>intermediates</name>
      <anchor>z481_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>size_t</type>
      <name>eventSize</name>
      <anchor>z481_5</anchor>
      <arglist>(int N)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>string</type>
      <name>cacheFileName</name>
      <anchor>z485_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>CFile</type>
      <name>cacheFile</name>
      <anchor>z485_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>openReadCacheFile</name>
      <anchor>z485_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>openWriteCacheFile</name>
      <anchor>z485_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>closeCacheFile</name>
      <anchor>z485_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>compressedCache</name>
      <anchor>z485_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>cacheEvent</name>
      <anchor>z485_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>uncacheEvent</name>
      <anchor>z485_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>reopen</name>
      <anchor>z485_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>char *</type>
      <name>mwrite</name>
      <anchor>z485_9</anchor>
      <arglist>(char *pos, const T &amp;t, size_t n=1)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>const char *</type>
      <name>mread</name>
      <anchor>z485_10</anchor>
      <arglist>(const char *pos, T &amp;t, size_t n=1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesReader</name>
      <anchor>z475_0</anchor>
      <arglist>(bool active=false)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesReader</name>
      <anchor>z475_1</anchor>
      <arglist>(const LesHouchesReader &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LesHouchesReader</name>
      <anchor>z475_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>open</name>
      <anchor>z477_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>doReadEvent</name>
      <anchor>z477_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>close</name>
      <anchor>z477_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z479_0</anchor>
      <arglist>(LesHouchesEventHandler &amp;eh)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>getEvent</name>
      <anchor>z479_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>readEvent</name>
      <anchor>z479_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>skip</name>
      <anchor>z479_3</anchor>
      <arglist>(long n)</arglist>
    </member>
    <member kind="function">
      <type>tXCombPtr</type>
      <name>getXComb</name>
      <anchor>z479_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>scan</name>
      <anchor>z479_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initStat</name>
      <anchor>z479_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>reweight</name>
      <anchor>z479_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>fillEvent</name>
      <anchor>z479_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z479_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>NEvents</name>
      <anchor>z483_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>currentPosition</name>
      <anchor>z483_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxScan</name>
      <anchor>z483_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>active</name>
      <anchor>z483_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>weighted</name>
      <anchor>z483_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>negativeWeights</name>
      <anchor>z483_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const XSecStat &amp;</type>
      <name>xSecStats</name>
      <anchor>z483_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const StatMap &amp;</type>
      <name>processStats</name>
      <anchor>z483_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z483_8</anchor>
      <arglist>(double weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accept</name>
      <anchor>z483_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reject</name>
      <anchor>z483_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>increaseMaxXSec</name>
      <anchor>z483_11</anchor>
      <arglist>(CrossSection maxxsec)</arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>partonExtractor</name>
      <anchor>z483_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PartonPairVec &amp;</type>
      <name>partonBins</name>
      <anchor>z483_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const XCombMap &amp;</type>
      <name>xCombs</name>
      <anchor>z483_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const KinematicalCuts &amp;</type>
      <name>cuts</name>
      <anchor>z483_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z489_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z489_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>checkPartonBin</name>
      <anchor>z487_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>createParticles</name>
      <anchor>z487_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPBPair</type>
      <name>createPartonBinInstances</name>
      <anchor>z487_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>createBeams</name>
      <anchor>z487_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>connectMothers</name>
      <anchor>z487_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>weighted</name>
      <anchor>z491_0</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>NEvents</name>
      <anchor>z491_1</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>negativeWeights</name>
      <anchor>z491_2</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>XCombMap &amp;</type>
      <name>xCombs</name>
      <anchor>z491_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z493_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z493_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z493_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z493_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z493_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z493_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HEPRUP</type>
      <name>heprup</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HEPEUP</type>
      <name>hepeup</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>tcPDPair</type>
      <name>inData</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>pair&lt; PDFPtr, PDFPtr &gt;</type>
      <name>inPDF</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>pair&lt; cPDFPtr, cPDFPtr &gt;</type>
      <name>outPDF</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PExtrPtr</type>
      <name>thePartonExtractor</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PartonPairVec</type>
      <name>thePartonBins</name>
      <anchor>p6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>XCombMap</type>
      <name>theXCombs</name>
      <anchor>p7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>p8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>theNEvents</name>
      <anchor>p9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>position</name>
      <anchor>p10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>reopened</name>
      <anchor>p11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>theMaxScan</name>
      <anchor>p12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isActive</name>
      <anchor>p13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isWeighted</name>
      <anchor>p14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>hasNegativeWeights</name>
      <anchor>p15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>string</type>
      <name>theCacheFileName</name>
      <anchor>p16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>XSecStat</type>
      <name>stats</name>
      <anchor>p17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StatMap</type>
      <name>statmap</name>
      <anchor>p18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PBIPair</type>
      <name>thePartonBinInstances</name>
      <anchor>p19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ObjectIndexer&lt; long, ColourLine &gt;</type>
      <name>colourIndex</name>
      <anchor>p20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ObjectIndexer&lt; long, Particle &gt;</type>
      <name>particleIndex</name>
      <anchor>p21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PPair</type>
      <name>theBeams</name>
      <anchor>p22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>p23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PVector</type>
      <name>theOutgoing</name>
      <anchor>p24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PVector</type>
      <name>theIntermediates</name>
      <anchor>p25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>CFile</type>
      <name>theCacheFile</name>
      <anchor>p26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ReweightVector</type>
      <name>reweights</name>
      <anchor>p27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ReweightVector</type>
      <name>preweights</name>
      <anchor>p28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>preweight</name>
      <anchor>p29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>reweightPDF</name>
      <anchor>p30</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>FILE *</type>
      <name>CFile</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; int, XSecStat &gt;</type>
      <name>StatMap</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; tcPBPair, XCombPtr &gt;</type>
      <name>XCombMap</name>
      <anchor>y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; ReweightPtr &gt;</type>
      <name>ReweightVector</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBeamA</name>
      <anchor>d0</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getBeamA</name>
      <anchor>d1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBeamB</name>
      <anchor>d2</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getBeamB</name>
      <anchor>d3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setEBeamA</name>
      <anchor>d4</anchor>
      <arglist>(Energy e)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getEBeamA</name>
      <anchor>d5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setEBeamB</name>
      <anchor>d6</anchor>
      <arglist>(Energy e)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getEBeamB</name>
      <anchor>d7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPDFA</name>
      <anchor>d8</anchor>
      <arglist>(PDFPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PDFPtr</type>
      <name>getPDFA</name>
      <anchor>d9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPDFB</name>
      <anchor>d10</anchor>
      <arglist>(PDFPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PDFPtr</type>
      <name>getPDFB</name>
      <anchor>d11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>LesHouchesReader &amp;</type>
      <name>operator=</name>
      <anchor>d12</anchor>
      <arglist>(const LesHouchesReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; LesHouchesReader &gt;</type>
      <name>initLesHouchesReader</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>LesHouchesEventHandler</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesInconsistencyError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesInconsistencyError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesInitError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesInitError.html</filename>
    <base>ThePEG::InitException</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesReopenError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesReopenError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesReopenWarning</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesReopenWarning.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesInconsistencyError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesInconsistencyError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesReopenWarning</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesReopenWarning.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesReopenError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesReopenError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesInitError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesInitError.html</filename>
    <base>ThePEG::InitException</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LesHouchesReader, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LesHouchesReader_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LesHouchesReader &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LesHouchesReader_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LesHouchesReader &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MadGraphReader</name>
    <filename>classThePEG_1_1MadGraphReader.html</filename>
    <base>ThePEG::LesHouchesFileReader</base>
    <member kind="function">
      <type></type>
      <name>MadGraphReader</name>
      <anchor>z495_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MadGraphReader</name>
      <anchor>z495_1</anchor>
      <arglist>(const MadGraphReader &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MadGraphReader</name>
      <anchor>z495_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>open</name>
      <anchor>z497_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>scan</name>
      <anchor>z497_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>doReadEvent</name>
      <anchor>z497_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z499_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z499_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z501_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z501_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z503_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z503_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z503_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z503_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z503_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z503_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Energy</type>
      <name>fixedScale</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>fixedAEM</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>fixedAS</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MadGraphReader &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MadGraphReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MadGraphReader &gt;</type>
      <name>initMadGraphReader</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MadGraphReader, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MadGraphReader_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>LesHouchesFileReader</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MadGraphReader &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MadGraphReader_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MadGraphReader &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Amplitude</name>
    <filename>classThePEG_1_1Amplitude.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>Amplitude</name>
      <anchor>z505_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Amplitude</name>
      <anchor>z505_1</anchor>
      <arglist>(const Amplitude &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Amplitude</name>
      <anchor>z505_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Complex</type>
      <name>value</name>
      <anchor>z507_0</anchor>
      <arglist>(const tcPDVector &amp;particles, const vector&lt; Lorentz5Momentum &gt; &amp;momenta, const vector&lt; int &gt; &amp;helicities)=0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Complex</type>
      <name>overestimateValue</name>
      <anchor>z507_1</anchor>
      <arglist>(const tcPDVector &amp;particles, const vector&lt; Lorentz5Momentum &gt; &amp;momenta, const vector&lt; int &gt; &amp;helicities)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>value</name>
      <anchor>z509_0</anchor>
      <arglist>(const PVector &amp;particles, const vector&lt; int &gt; &amp;helicities)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>overestimateValue</name>
      <anchor>z509_1</anchor>
      <arglist>(const PVector &amp;particles, const vector&lt; int &gt; &amp;helicities)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z511_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z511_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>Amplitude &amp;</type>
      <name>operator=</name>
      <anchor>b0</anchor>
      <arglist>(const Amplitude &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z513_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z513_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z513_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z513_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z513_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected" static="yes">
      <type>AbstractClassDescription&lt; Amplitude &gt;</type>
      <name>initAmplitude</name>
      <anchor>t0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Amplitude, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Amplitude_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Amplitude &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Amplitude_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Amplitude &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourLines</name>
    <filename>classThePEG_1_1ColourLines.html</filename>
    <base>ThePEG::Base</base>
    <member kind="typedef">
      <type>vector&lt; int &gt;</type>
      <name>Line</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Line &gt;</type>
      <name>LineVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ColinePtr &gt;</type>
      <name>Vertex</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Vertex &gt;</type>
      <name>VertexVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>connect</name>
      <anchor>a0</anchor>
      <arglist>(const tPVector &amp;partons) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLines</name>
      <anchor>z515_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLines</name>
      <anchor>z515_1</anchor>
      <arglist>(const ColourLines &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLines</name>
      <anchor>z515_2</anchor>
      <arglist>(string s)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourLines</name>
      <anchor>z515_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LineVector</type>
      <name>theLines</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ColourGeometryException</name>
    <filename>structThePEG_1_1ColourGeometryException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>ColourGeometryException</name>
      <anchor>a0</anchor>
      <arglist>(const tPVector &amp;, const vector&lt; int &gt; &amp;=vector&lt; int &gt;())</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DiagramBase</name>
    <filename>classThePEG_1_1DiagramBase.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>DiagramBase</name>
      <anchor>z517_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DiagramBase</name>
      <anchor>z517_1</anchor>
      <arglist>(const DiagramBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DiagramBase</name>
      <anchor>z517_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tPVector</type>
      <name>construct</name>
      <anchor>z519_0</anchor>
      <arglist>(SubProPtr sb, const StandardXComb &amp;, const ColourLines &amp;) const =0</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nIncoming</name>
      <anchor>z521_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>partons</name>
      <anchor>z521_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>id</name>
      <anchor>z521_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>getTag</name>
      <anchor>z521_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z523_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z523_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>partons</name>
      <anchor>b0</anchor>
      <arglist>(int ninc, const cPDVector &amp;parts, int newId)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>done</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>DiagramBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DiagramBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNIncoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>thePartons</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theId</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; DiagramBase &gt;</type>
      <name>initDiagramBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DiagramBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DiagramBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DiagramBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DiagramBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DiagramBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DiagramBaseSetupException</name>
    <filename>structThePEG_1_1DiagramBaseSetupException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DiagramBaseSetupException</name>
      <anchor>a0</anchor>
      <arglist>(const DiagramBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ME2to2Base</name>
    <filename>classThePEG_1_1ME2to2Base.html</filename>
    <base>ThePEG::MEBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>getCosTheta</name>
      <anchor>a0</anchor>
      <arglist>(double cthmin, double cthmax, const double *r)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>scaleChoice</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ME2to2Base</name>
      <anchor>z525_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ME2to2Base</name>
      <anchor>z525_1</anchor>
      <arglist>(const ME2to2Base &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ME2to2Base</name>
      <anchor>z525_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z527_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>generateKinematics</name>
      <anchor>z527_1</anchor>
      <arglist>(const double *r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>dSigHatDR</name>
      <anchor>z527_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>scale</name>
      <anchor>z527_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setKinematics</name>
      <anchor>z527_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHat</name>
      <anchor>z529_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHat</name>
      <anchor>z529_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>phi</name>
      <anchor>z529_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z531_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z531_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z533_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z533_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z533_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z533_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z533_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>Switch&lt; ME2to2Base, int &gt; &amp;</type>
      <name>interfaceScaleChoice</name>
      <anchor>f0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ME2to2Base &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ME2to2Base &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theScaleChoice</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastTHat</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastUHat</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastPhi</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ME2to2Base &gt;</type>
      <name>initME2to2Base</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ME2to2Base, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ME2to2Base_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>MEBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ME2to2Base &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ME2to2Base_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ME2to2Base &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ME2to2QCD</name>
    <filename>classThePEG_1_1ME2to2QCD.html</filename>
    <base>ThePEG::ME2to2Base</base>
    <member kind="function">
      <type></type>
      <name>ME2to2QCD</name>
      <anchor>z535_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ME2to2QCD</name>
      <anchor>z535_1</anchor>
      <arglist>(const ME2to2QCD &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ME2to2QCD</name>
      <anchor>z535_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaS</name>
      <anchor>z537_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaEW</name>
      <anchor>z537_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>comfac</name>
      <anchor>z537_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxFlavour</name>
      <anchor>z537_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>Kfac</name>
      <anchor>z537_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>KfacA</name>
      <anchor>z537_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>interference</name>
      <anchor>z537_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isQuark</name>
      <anchor>z537_7</anchor>
      <arglist>(const ParticleData &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>quark</name>
      <anchor>z537_8</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z539_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z539_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z541_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z541_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z541_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z541_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z541_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ME2to2QCD &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ME2to2QCD &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theMaxFlavour</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theKfac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theKfacA</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useInterference</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ME2to2QCD &gt;</type>
      <name>initME2to2QCD</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ME2to2QCD, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ME2to2QCD_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ME2to2QCD &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ME2to2QCD_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ME2to2QCD &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEBase</name>
    <filename>classThePEG_1_1MEBase.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt; StandardXComb &gt;</base>
    <member kind="typedef">
      <type>vector&lt; DiagPtr &gt;</type>
      <name>DiagramVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DiagramVector::size_type</type>
      <name>DiagramIndex</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ReweightPtr &gt;</type>
      <name>ReweightVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEBase</name>
      <anchor>z543_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEBase</name>
      <anchor>z543_1</anchor>
      <arglist>(const MEBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEBase</name>
      <anchor>z543_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual unsigned int</type>
      <name>orderInAlphaS</name>
      <anchor>z545_0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual unsigned int</type>
      <name>orderInAlphaEW</name>
      <anchor>z545_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z545_2</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy2</type>
      <name>scale</name>
      <anchor>z545_3</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>z545_4</anchor>
      <arglist>(tPPair in, const PVector &amp;out)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setKinematics</name>
      <anchor>z545_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>constructVertex</name>
      <anchor>z545_6</anchor>
      <arglist>(tSubProPtr sub)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z545_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>generateKinematics</name>
      <anchor>z545_8</anchor>
      <arglist>(const double *r)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual CrossSection</type>
      <name>dSigHatDR</name>
      <anchor>z545_9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>generateSubCollision</name>
      <anchor>z545_10</anchor>
      <arglist>(SubProcess &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clearKinematics</name>
      <anchor>z545_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z545_12</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>const DiagramVector &amp;</type>
      <name>diagrams</name>
      <anchor>z545_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z545_14</anchor>
      <arglist>(tcDiagPtr diag) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual const ColourLines &amp;</type>
      <name>selectColourGeometry</name>
      <anchor>z545_15</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z545_16</anchor>
      <arglist>(const DiagramVector &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DiagramIndex</type>
      <name>diagram</name>
      <anchor>z545_17</anchor>
      <arglist>(const DiagramVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>reWeight</name>
      <anchor>z545_18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>preWeight</name>
      <anchor>z545_19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addReweighter</name>
      <anchor>z545_20</anchor>
      <arglist>(tReweightPtr rw)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPreweighter</name>
      <anchor>z545_21</anchor>
      <arglist>(tReweightPtr rw)</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>amplitude</name>
      <anchor>z545_22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>sHat</name>
      <anchor>z547_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>preweight</name>
      <anchor>z547_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setXComb</name>
      <anchor>z547_2</anchor>
      <arglist>(tStdXCombPtr)</arglist>
    </member>
    <member kind="function">
      <type>const DVector &amp;</type>
      <name>meInfo</name>
      <anchor>z547_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>meInfo</name>
      <anchor>z547_4</anchor>
      <arglist>(const DVector &amp;info) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z549_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z549_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>add</name>
      <anchor>b0</anchor>
      <arglist>(DiagPtr) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>jacobian</name>
      <anchor>b2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>jacobian</name>
      <anchor>b3</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z551_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z551_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z551_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z551_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z551_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiagramVector</type>
      <name>theDiagrams</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastSHat</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>reweights</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>preweights</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>lastPreweight</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>theAmplitude</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastJacobian</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; MEBase &gt;</type>
      <name>initMEBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MECuts</name>
    <filename>classThePEG_1_1MECuts.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>MECuts</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MECuts</name>
      <anchor>a1</anchor>
      <arglist>(const MECuts &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MECuts</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cut</name>
      <anchor>a3</anchor>
      <arglist>(const SubProcess &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMin</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMax</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMin</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMax</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMin</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMax</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatSingularMin</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>singularMassMax</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMin</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMax</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMin</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMax</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMin</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMax</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMin</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a20</anchor>
      <arglist>(PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a21</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>b0</anchor>
      <arglist>(const SubProcess &amp;) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>b4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MECuts &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MECuts &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMax</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatSingularMin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theSingularMassMax</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMin</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMax</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMax</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMin</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMax</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMin</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMax</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MECuts &gt;</type>
      <name>initMECuts</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MECuts, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MECuts_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MECuts &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MECuts_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MECuts &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MECutSetup</name>
    <filename>structThePEG_1_1MECutSetup.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>MECutSetup</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MECutZeroInterval</name>
    <filename>structThePEG_1_1MECutZeroInterval.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>MECutZeroInterval</name>
      <anchor>a0</anchor>
      <arglist>(const MECuts &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEee2gZ2qq</name>
    <filename>classThePEG_1_1MEee2gZ2qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEee2gZ2qq</name>
      <anchor>z553_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEee2gZ2qq</name>
      <anchor>z553_1</anchor>
      <arglist>(const MEee2gZ2qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEee2gZ2qq</name>
      <anchor>z553_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaS</name>
      <anchor>z555_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaEW</name>
      <anchor>z555_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z555_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z555_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z555_4</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z555_5</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>scale</name>
      <anchor>z555_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z557_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z557_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z559_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z559_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z561_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>coefs</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Energy2</type>
      <name>mZ2</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Energy2</type>
      <name>GZ2</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>lastCont</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>lastBW</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEee2gZ2qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEee2gZ2qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MEee2gZ2qq &gt;</type>
      <name>initMEee2gZ2qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEee2gZ2qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEee2gZ2qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEee2gZ2qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEee2gZ2qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEee2gZ2qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEGG2GG</name>
    <filename>classThePEG_1_1MEGG2GG.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEGG2GG</name>
      <anchor>z563_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEGG2GG</name>
      <anchor>z563_1</anchor>
      <arglist>(const MEGG2GG &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEGG2GG</name>
      <anchor>z563_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z565_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z565_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z565_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z565_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA1</name>
      <anchor>z567_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB1</name>
      <anchor>z567_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colC1</name>
      <anchor>z567_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA2</name>
      <anchor>z567_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB2</name>
      <anchor>z567_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colC2</name>
      <anchor>z567_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z569_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z569_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEGG2GG &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEGG2GG &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEGG2GG &gt;</type>
      <name>initMEGG2GG</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEGG2GG, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEGG2GG_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEGG2GG &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEGG2GG_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEGG2GG &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEGG2QQ</name>
    <filename>classThePEG_1_1MEGG2QQ.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEGG2QQ</name>
      <anchor>z571_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEGG2QQ</name>
      <anchor>z571_1</anchor>
      <arglist>(const MEGG2QQ &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEGG2QQ</name>
      <anchor>z571_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z573_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z573_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z573_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z573_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z575_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z575_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z577_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z577_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEGG2QQ &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEGG2QQ &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEGG2QQ &gt;</type>
      <name>initMEGG2QQ</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEGG2QQ, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEGG2QQ_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEGG2QQ &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEGG2QQ_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEGG2QQ &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQG2QG</name>
    <filename>classThePEG_1_1MEQG2QG.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQG2QG</name>
      <anchor>z579_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQG2QG</name>
      <anchor>z579_1</anchor>
      <arglist>(const MEQG2QG &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQG2QG</name>
      <anchor>z579_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z581_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z581_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z581_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z581_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA1</name>
      <anchor>z583_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB1</name>
      <anchor>z583_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA2</name>
      <anchor>z583_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB2</name>
      <anchor>z583_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z585_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z585_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQG2QG &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQG2QG &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQG2QG &gt;</type>
      <name>initMEQG2QG</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQG2QG, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQG2QG_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQG2QG &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQG2QG_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQG2QG &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQQ2GG</name>
    <filename>classThePEG_1_1MEQQ2GG.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQQ2GG</name>
      <anchor>z587_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQQ2GG</name>
      <anchor>z587_1</anchor>
      <arglist>(const MEQQ2GG &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQQ2GG</name>
      <anchor>z587_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z589_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z589_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z589_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z589_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z591_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z591_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z593_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z593_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQQ2GG &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQQ2GG &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQQ2GG &gt;</type>
      <name>initMEQQ2GG</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQQ2GG, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQQ2GG_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQQ2GG &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQQ2GG_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQQ2GG &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEqq2qq</name>
    <filename>classThePEG_1_1MEqq2qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEqq2qq</name>
      <anchor>z595_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEqq2qq</name>
      <anchor>z595_1</anchor>
      <arglist>(const MEqq2qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEqq2qq</name>
      <anchor>z595_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z597_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z597_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z597_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z597_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z599_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z599_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z601_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z601_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEqq2qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEqq2qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEqq2qq &gt;</type>
      <name>initMEqq2qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEqq2qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEqq2qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEqq2qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEqq2qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEqq2qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQQ2qq</name>
    <filename>classThePEG_1_1MEQQ2qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQQ2qq</name>
      <anchor>z603_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQQ2qq</name>
      <anchor>z603_1</anchor>
      <arglist>(const MEQQ2qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQQ2qq</name>
      <anchor>z603_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z605_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z605_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z605_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z605_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z607_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z609_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z609_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQQ2qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQQ2qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQQ2qq &gt;</type>
      <name>initMEQQ2qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQQ2qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQQ2qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQQ2qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQQ2qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQQ2qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQQ2QQ</name>
    <filename>classThePEG_1_1MEQQ2QQ.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQQ2QQ</name>
      <anchor>z611_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQQ2QQ</name>
      <anchor>z611_1</anchor>
      <arglist>(const MEQQ2QQ &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQQ2QQ</name>
      <anchor>z611_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z613_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z613_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z613_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z613_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z615_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z615_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z617_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z617_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQQ2QQ &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQQ2QQ &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQQ2QQ &gt;</type>
      <name>initMEQQ2QQ</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQQ2QQ, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQQ2QQ_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQQ2QQ &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQQ2QQ_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQQ2QQ &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQq2Qq</name>
    <filename>classThePEG_1_1MEQq2Qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQq2Qq</name>
      <anchor>z619_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQq2Qq</name>
      <anchor>z619_1</anchor>
      <arglist>(const MEQq2Qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQq2Qq</name>
      <anchor>z619_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z621_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z621_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z621_2</anchor>
      <arglist>(tcDiagPtr diag) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z621_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z623_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z625_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z625_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQq2Qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQq2Qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQq2Qq &gt;</type>
      <name>initMEQq2Qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQq2Qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQq2Qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQq2Qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQq2Qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQq2Qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReweightBase</name>
    <filename>classThePEG_1_1ReweightBase.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt; StandardXComb &gt;</base>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>weight</name>
      <anchor>a0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>a1</anchor>
      <arglist>(Energy2 shat, tcPDPair in, const cPDVector &amp;out, const Lorentz5Momentum &amp;pina, const Lorentz5Momentum &amp;pinb, const vector&lt; Lorentz5Momentum &gt; &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>a2</anchor>
      <arglist>(tPPair in, const PVector &amp;out)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>a3</anchor>
      <arglist>(const SubProcess &amp;sub)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXComb</name>
      <anchor>a4</anchor>
      <arglist>(tStdXCombPtr)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setKinematics</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clearKinematics</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>sHat</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>inData</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>outData</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>inMomentumA</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>inMomentumB</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>outMomentum</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightBase</name>
      <anchor>z627_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightBase</name>
      <anchor>z627_1</anchor>
      <arglist>(const ReweightBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReweightBase</name>
      <anchor>z627_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z629_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z629_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z631_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z631_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z631_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z631_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z631_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ReweightBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ReweightBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastSHat</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>theLastInData</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>theLastOutData</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>theLastInMomentumA</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>theLastInMomentumB</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Lorentz5Momentum &gt;</type>
      <name>theLastOutMomentum</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ReweightBase &gt;</type>
      <name>initReweightBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ReweightBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ReweightBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ReweightBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ReweightBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ReweightBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReweightConstant</name>
    <filename>classThePEG_1_1ReweightConstant.html</filename>
    <base>ThePEG::ReweightBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>weight</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightConstant</name>
      <anchor>z633_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightConstant</name>
      <anchor>z633_1</anchor>
      <arglist>(const ReweightConstant &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReweightConstant</name>
      <anchor>z633_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z635_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z635_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z637_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z637_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z639_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z639_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z639_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z639_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z639_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z639_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ReweightConstant &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ReweightConstant &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>C</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ReweightConstant &gt;</type>
      <name>initReweightConstant</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ReweightConstant, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ReweightConstant_00_011_01_4.html</filename>
    <member kind="typedef">
      <type>ReweightBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ReweightConstant &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ReweightConstant_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ReweightConstant &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReweightMinPT</name>
    <filename>classThePEG_1_1ReweightMinPT.html</filename>
    <base>ThePEG::ReweightBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>weight</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightMinPT</name>
      <anchor>z641_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightMinPT</name>
      <anchor>z641_1</anchor>
      <arglist>(const ReweightMinPT &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReweightMinPT</name>
      <anchor>z641_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z643_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z643_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z645_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z645_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z647_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z647_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z647_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z647_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z647_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ReweightMinPT &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ReweightMinPT &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>power</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ReweightMinPT &gt;</type>
      <name>initReweightMinPT</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ReweightMinPT, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ReweightMinPT_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ReweightBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ReweightMinPT &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ReweightMinPT_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ReweightMinPT &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Tree2toNDiagram</name>
    <filename>classThePEG_1_1Tree2toNDiagram.html</filename>
    <base>ThePEG::DiagramBase</base>
    <member kind="typedef">
      <type>cPDVector::size_type</type>
      <name>size_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tcPDPtr &gt;</type>
      <name>PDMSet</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a0</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a1</anchor>
      <arglist>(PDPtr)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a2</anchor>
      <arglist>(cPDPtr)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a3</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a4</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tPVector</type>
      <name>construct</name>
      <anchor>a5</anchor>
      <arglist>(SubProPtr sb, const StandardXComb &amp;, const ColourLines &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPair</type>
      <name>incoming</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>allPartons</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDVector</type>
      <name>outgoing</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDVector</type>
      <name>external</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>parent</name>
      <anchor>a10</anchor>
      <arglist>(int i) const </arglist>
    </member>
    <member kind="function">
      <type>pair&lt; int, int &gt;</type>
      <name>children</name>
      <anchor>a11</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nSpace</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nOutgoing</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagram</name>
      <anchor>z649_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagram</name>
      <anchor>z649_1</anchor>
      <arglist>(const Tree2toNDiagram &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Tree2toNDiagram</name>
      <anchor>z649_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagram</name>
      <anchor>z649_3</anchor>
      <arglist>(int space)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z651_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z651_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>check</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addSpacelike</name>
      <anchor>d1</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addTimelike</name>
      <anchor>d2</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addTimelike</name>
      <anchor>d3</anchor>
      <arglist>(tcPDPtr, size_type origin)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Tree2toNDiagram &amp;</type>
      <name>add</name>
      <anchor>d4</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator=</name>
      <anchor>d5</anchor>
      <arglist>(const Tree2toNDiagram &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theNSpace</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNOutgoing</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nextOrig</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>thePartons</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>theParents</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Tree2toNDiagram &gt;</type>
      <name>initTree2toNDiagram</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Tree2toNDiagram, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Tree2toNDiagram_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>DiagramBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Tree2toNDiagram &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Tree2toNDiagram_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Tree2toNDiagram &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Tree2toNDiagramError</name>
    <filename>structThePEG_1_1Tree2toNDiagramError.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagramError</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::BaryonRemnants</name>
    <filename>classThePEG_1_1BaryonRemnants.html</filename>
    <base>ThePEG::RemnantHandler</base>
    <member kind="typedef">
      <type>Ptr&lt; PtGenerator &gt;::pointer</type>
      <name>PtGPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ZGenerator &gt;::pointer</type>
      <name>ZGPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>FlGPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>margin</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BaryonRemnants</name>
      <anchor>z653_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BaryonRemnants</name>
      <anchor>z653_1</anchor>
      <arglist>(const BaryonRemnants &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~BaryonRemnants</name>
      <anchor>z653_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z655_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z655_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z655_2</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, Energy2 shat, const LorentzMomentum &amp;parent) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>createRemnants</name>
      <anchor>z655_3</anchor>
      <arglist>(PartonBinInstance &amp;pb) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z657_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z657_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ZGenerator &amp;</type>
      <name>zGenerator</name>
      <anchor>b0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PtGenerator &amp;</type>
      <name>ptGeneratorQ</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PtGenerator &amp;</type>
      <name>ptGeneratorR</name>
      <anchor>b2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlavourGenerator &amp;</type>
      <name>flavourGenerator</name>
      <anchor>b3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>specialValence</name>
      <anchor>b4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z659_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z659_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z661_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z661_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z661_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z661_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z661_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>BaryonRemnants &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const BaryonRemnants &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; PtGenerator &gt;::pointer</type>
      <name>thePtGeneratorQ</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; PtGenerator &gt;::pointer</type>
      <name>thePtGeneratorR</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; ZGenerator &gt;::pointer</type>
      <name>theZGenerator</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>theFlavourGenerator</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMargin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useSpecialValence</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; BaryonRemnants &gt;</type>
      <name>initBaryonRemnants</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaryonRemInfo</name>
    <filename>structThePEG_1_1BaryonRemInfo.html</filename>
    <base>ThePEG::RemInfoBase</base>
    <member kind="variable">
      <type>int</type>
      <name>iq</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>sign</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>flav</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>vflav</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>VSelector&lt; pair&lt; int, int &gt; &gt;</type>
      <name>flavsel</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>mayval</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; BaryonRemnants, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01BaryonRemnants_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RemnantHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; BaryonRemnants &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01BaryonRemnants_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; BaryonRemnants &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::BeamParticleData</name>
    <filename>classThePEG_1_1BeamParticleData.html</filename>
    <base virtualness="virtual">ThePEG::ParticleData</base>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>pdf</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BeamParticleData</name>
      <anchor>z663_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BeamParticleData</name>
      <anchor>z663_1</anchor>
      <arglist>(const BeamParticleData &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~BeamParticleData</name>
      <anchor>z663_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z667_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z667_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>Create</name>
      <anchor>z665_0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPair</type>
      <name>Create</name>
      <anchor>z665_1</anchor>
      <arglist>(long newId, string newPDGName, string newAntiPDGName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>BeamParticleData</name>
      <anchor>b0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual PDPtr</type>
      <name>pdclone</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z669_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z669_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z669_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z669_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z669_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPDF</name>
      <anchor>d0</anchor>
      <arglist>(PDFPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>BeamParticleData &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const BeamParticleData &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDFPtr</type>
      <name>thePDF</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; BeamParticleData &gt;</type>
      <name>initBeamParticleData</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; BeamParticleData, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01BeamParticleData_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; BeamParticleData &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01BeamParticleData_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; BeamParticleData &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BeamParticleWrongPDF</name>
    <filename>structThePEG_1_1BeamParticleWrongPDF.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>BeamParticleWrongPDF</name>
      <anchor>a0</anchor>
      <arglist>(string p, string pdf)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GRV94L</name>
    <filename>classThePEG_1_1GRV94L.html</filename>
    <base>ThePEG::GRVBase</base>
    <member kind="function">
      <type>Energy2</type>
      <name>mu2</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lam2</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94L</name>
      <anchor>z671_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94L</name>
      <anchor>z671_1</anchor>
      <arglist>(const GRV94L &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GRV94L</name>
      <anchor>z671_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(double l, Energy2 scale) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>uv</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>dv</name>
      <anchor>b2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>del</name>
      <anchor>b3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>udb</name>
      <anchor>b4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>sb</name>
      <anchor>b5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>cb</name>
      <anchor>b6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>bb</name>
      <anchor>b7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>gl</name>
      <anchor>b8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z673_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z673_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z675_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z675_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z675_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z675_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z675_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GRV94L &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GRV94L &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; GRV94L &gt;</type>
      <name>initGRV94L</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GRV94L, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GRV94L_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>GRVBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GRV94L &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GRV94L_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GRV94L &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GRV94M</name>
    <filename>classThePEG_1_1GRV94M.html</filename>
    <base>ThePEG::GRVBase</base>
    <member kind="function">
      <type>Energy2</type>
      <name>mu2</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lam2</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94M</name>
      <anchor>z677_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94M</name>
      <anchor>z677_1</anchor>
      <arglist>(const GRV94M &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GRV94M</name>
      <anchor>z677_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(double l, Energy2 scale) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>uv</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>dv</name>
      <anchor>b2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>del</name>
      <anchor>b3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>udb</name>
      <anchor>b4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>sb</name>
      <anchor>b5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>cb</name>
      <anchor>b6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>bb</name>
      <anchor>b7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>gl</name>
      <anchor>b8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z679_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z679_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z681_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z681_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z681_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z681_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z681_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GRV94M &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GRV94M &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; GRV94M &gt;</type>
      <name>initGRV94M</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GRV94M, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GRV94M_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>GRVBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GRV94M &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GRV94M_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GRV94M &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GRVBase</name>
    <filename>classThePEG_1_1GRVBase.html</filename>
    <base>ThePEG::PDFBase</base>
    <member kind="function">
      <type></type>
      <name>GRVBase</name>
      <anchor>z683_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRVBase</name>
      <anchor>z683_1</anchor>
      <arglist>(const GRVBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GRVBase</name>
      <anchor>z683_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z685_0</anchor>
      <arglist>(tcPDPtr particle) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z685_1</anchor>
      <arglist>(tcPDPtr p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z685_2</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvl</name>
      <anchor>z685_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>S</name>
      <anchor>z687_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>S2</name>
      <anchor>z687_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>S3</name>
      <anchor>z687_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rootS</name>
      <anchor>z687_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x</name>
      <anchor>z687_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lx</name>
      <anchor>z687_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>z687_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rootx</name>
      <anchor>z687_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(double l, Energy2 scale) const =0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setup</name>
      <anchor>b1</anchor>
      <arglist>(double l, Energy2 scale, Energy mu2, Energy2 lam2) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>valens</name>
      <anchor>b2</anchor>
      <arglist>(double N, double ak, double bk, double a, double b, double c, double d) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>lightsea</name>
      <anchor>b3</anchor>
      <arglist>(double al, double be, double ak, double bk, double a, double b, double c, double d, double e, double es) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>heavysea</name>
      <anchor>b4</anchor>
      <arglist>(double sth, double al, double be, double ak, double ag, double b, double d, double e, double es) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>uv</name>
      <anchor>b5</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>dv</name>
      <anchor>b6</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>del</name>
      <anchor>b7</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>udb</name>
      <anchor>b8</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>sb</name>
      <anchor>b9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>cb</name>
      <anchor>b10</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>bb</name>
      <anchor>b11</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>gl</name>
      <anchor>b12</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fuv</name>
      <anchor>b13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fdv</name>
      <anchor>b14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fdel</name>
      <anchor>b15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fudb</name>
      <anchor>b16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fsb</name>
      <anchor>b17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fcb</name>
      <anchor>b18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fbb</name>
      <anchor>b19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fgl</name>
      <anchor>b20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z689_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z689_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z689_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z689_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z689_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GRVBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GRVBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLx</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theRootx</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>Q2</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLam2</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theMu2</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theS</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theS2</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theS3</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theRootS</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>uvSave</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>dvSave</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>delSave</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>udbSave</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>sbSave</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>cbSave</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>bbSave</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>glSave</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; GRVBase &gt;</type>
      <name>initGRVBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GRVBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GRVBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PDFBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GRVBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GRVBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GRVBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LeptonLeptonPDF</name>
    <filename>classThePEG_1_1LeptonLeptonPDF.html</filename>
    <base>ThePEG::PDFBase</base>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonPDF</name>
      <anchor>z691_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonPDF</name>
      <anchor>z691_1</anchor>
      <arglist>(const LeptonLeptonPDF &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LeptonLeptonPDF</name>
      <anchor>z691_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z693_0</anchor>
      <arglist>(tcPDPtr particle) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z693_1</anchor>
      <arglist>(tcPDPtr p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z693_2</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvl</name>
      <anchor>z693_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvx</name>
      <anchor>z693_4</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double x, double eps, Energy2 particleScale) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>flattenL</name>
      <anchor>z693_5</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, const PDFCuts &amp;, double z, double &amp;jacobian) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z695_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z695_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z697_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z697_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z697_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z697_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z697_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LeptonLeptonPDF &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LeptonLeptonPDF &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; LeptonLeptonPDF &gt;</type>
      <name>initLeptonLeptonPDF</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LeptonLeptonPDF, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LeptonLeptonPDF_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PDFBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LeptonLeptonPDF &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LeptonLeptonPDF_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LeptonLeptonPDF &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LeptonLeptonRemnant</name>
    <filename>classThePEG_1_1LeptonLeptonRemnant.html</filename>
    <base>ThePEG::RemnantHandler</base>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonRemnant</name>
      <anchor>z699_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonRemnant</name>
      <anchor>z699_1</anchor>
      <arglist>(const LeptonLeptonRemnant &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LeptonLeptonRemnant</name>
      <anchor>z699_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z701_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z701_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z701_2</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, Energy2 shat, const LorentzMomentum &amp;parent) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z703_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z703_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z705_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z705_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z707_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z707_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z707_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z707_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z707_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LeptonLeptonRemnant &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LeptonLeptonRemnant &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>minX</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>photon</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; LeptonLeptonRemnant &gt;</type>
      <name>initLeptonLeptonRemnant</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LeptonLeptonRemnant, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LeptonLeptonRemnant_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RemnantHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LeptonLeptonRemnant &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LeptonLeptonRemnant_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LeptonLeptonRemnant &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::NoPDF</name>
    <filename>classThePEG_1_1NoPDF.html</filename>
    <base>ThePEG::PDFBase</base>
    <member kind="function">
      <type></type>
      <name>NoPDF</name>
      <anchor>z709_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>NoPDF</name>
      <anchor>z709_1</anchor>
      <arglist>(const NoPDF &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~NoPDF</name>
      <anchor>z709_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z711_0</anchor>
      <arglist>(tcPDPtr particle) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z711_1</anchor>
      <arglist>(tcPDPtr particle) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z711_2</anchor>
      <arglist>(tcPDPtr p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z711_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z713_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z713_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z715_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z715_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z715_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z715_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z715_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>NoPDF &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const NoPDF &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; NoPDF &gt;</type>
      <name>initNoPDF</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; NoPDF, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01NoPDF_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PDFBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; NoPDF &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01NoPDF_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; NoPDF &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::NoRemnants</name>
    <filename>classThePEG_1_1NoRemnants.html</filename>
    <base>ThePEG::RemnantHandler</base>
    <member kind="function">
      <type></type>
      <name>NoRemnants</name>
      <anchor>z717_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>NoRemnants</name>
      <anchor>z717_1</anchor>
      <arglist>(const NoRemnants &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~NoRemnants</name>
      <anchor>z717_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z719_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z719_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z719_2</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, Energy2 shat, const LorentzMomentum &amp;parent) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z721_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z721_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z723_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z723_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z723_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z723_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z723_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>NoRemnants &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const NoRemnants &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; NoRemnants &gt;</type>
      <name>initNoRemnants</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; NoRemnants, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01NoRemnants_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RemnantHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; NoRemnants &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01NoRemnants_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; NoRemnants &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartonBin</name>
    <filename>classThePEG_1_1PartonBin.html</filename>
    <base>ThePEG::Base</base>
    <member kind="typedef">
      <type>vector&lt; PBPtr &gt;</type>
      <name>PBVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBin</name>
      <anchor>z725_0</anchor>
      <arglist>(tcPDPtr p, tPBPtr prev, tcPDPtr pi, tcPDFPtr pdf, const PDFCuts &amp;newCuts)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBin</name>
      <anchor>z725_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBin</name>
      <anchor>z725_2</anchor>
      <arglist>(const PartonBin &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartonBin</name>
      <anchor>z725_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>particle</name>
      <anchor>z727_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPBPtr</type>
      <name>incoming</name>
      <anchor>z727_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PBVector &amp;</type>
      <name>outgoing</name>
      <anchor>z727_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addOutgoing</name>
      <anchor>z727_3</anchor>
      <arglist>(tPBPtr)</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>parton</name>
      <anchor>z727_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>pdf</name>
      <anchor>z727_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcRemHPtr</type>
      <name>remnantHandler</name>
      <anchor>z727_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nDim</name>
      <anchor>z727_7</anchor>
      <arglist>(bool doscale)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>pdfDim</name>
      <anchor>z727_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>remDim</name>
      <anchor>z727_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PDFCuts &amp;</type>
      <name>cuts</name>
      <anchor>z729_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fullFn</name>
      <anchor>z729_1</anchor>
      <arglist>(Energy2 newScale=-1.0 *GeV2)</arglist>
    </member>
    <member kind="function">
      <type>tPBPtr</type>
      <name>getFirst</name>
      <anchor>z729_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z731_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z731_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartonBin &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PartonBin &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPtr</type>
      <name>theParticle</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPBPtr</type>
      <name>theIncomingBin</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBVector</type>
      <name>theOutgoing</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPtr</type>
      <name>theParton</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDFPtr</type>
      <name>thePDF</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cRemHPtr</type>
      <name>theRemnantHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>thePDFDim</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theRemDim</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDFCuts</type>
      <name>theCuts</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartonBin &gt;</type>
      <name>initPartonBin</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartonBin, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartonBin_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartonBin &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartonBin_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartonBin &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartonBinInstance</name>
    <filename>classThePEG_1_1PartonBinInstance.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z733_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z733_1</anchor>
      <arglist>(const PartonBinInstance &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartonBinInstance</name>
      <anchor>z733_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z733_3</anchor>
      <arglist>(tcPBPtr, tPBIPtr=tPBIPtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z733_4</anchor>
      <arglist>(tPPtr parton, tcPBPtr pb, Energy2 scale=0.0 *GeV2)</arglist>
    </member>
    <member kind="function">
      <type>tcPBPtr</type>
      <name>bin</name>
      <anchor>z735_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PartonVector &amp;</type>
      <name>bins</name>
      <anchor>z735_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>particleData</name>
      <anchor>z735_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>partonData</name>
      <anchor>z735_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPBIPtr</type>
      <name>incoming</name>
      <anchor>z735_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPBIPtr</type>
      <name>getFirst</name>
      <anchor>z735_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>pdf</name>
      <anchor>z735_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcRemHPtr</type>
      <name>remnantHandler</name>
      <anchor>z735_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z737_0</anchor>
      <arglist>(double lx=0, Energy2 Q2=0.0 *GeV2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>prepare</name>
      <anchor>z737_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>generate</name>
      <anchor>z737_2</anchor>
      <arglist>(const double *r)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fullFn</name>
      <anchor>z737_3</anchor>
      <arglist>(Energy2 newScale=-GeV2)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>jacobian</name>
      <anchor>z737_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>jacobian</name>
      <anchor>z737_5</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>particle</name>
      <anchor>z739_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>particle</name>
      <anchor>z739_1</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>parton</name>
      <anchor>z739_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>parton</name>
      <anchor>z739_3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>partons</name>
      <anchor>z739_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xi</name>
      <anchor>z739_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>z739_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>li</name>
      <anchor>z739_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>li</name>
      <anchor>z739_8</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x</name>
      <anchor>z739_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>l</name>
      <anchor>z739_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>l</name>
      <anchor>z739_11</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scale</name>
      <anchor>z739_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>z739_13</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>const TransverseMomentum &amp;</type>
      <name>kT</name>
      <anchor>z739_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>remnantWeight</name>
      <anchor>z739_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>remnantWeight</name>
      <anchor>z739_16</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>remnants</name>
      <anchor>z739_17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>remnants</name>
      <anchor>z739_18</anchor>
      <arglist>(const PVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>tRemIPtr</type>
      <name>remnantInfo</name>
      <anchor>z739_19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>remnantInfo</name>
      <anchor>z739_20</anchor>
      <arglist>(tRemIPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z741_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z741_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartonBinInstance &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PartonBinInstance &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPBPtr</type>
      <name>theBin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PartonVector</type>
      <name>theBins</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBIPtr</type>
      <name>theIncoming</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theJacobian</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPtr</type>
      <name>theParticle</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPtr</type>
      <name>theParton</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PVector</type>
      <name>thePartons</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theXi</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLi</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theL</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScale</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>TransverseMomentum</type>
      <name>theKT</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theRemnantWeight</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PVector</type>
      <name>theRemnants</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RemIPtr</type>
      <name>theRemInfo</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartonBinInstance &gt;</type>
      <name>initPartonBinInstance</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemInfoBase</name>
    <filename>structThePEG_1_1RemInfoBase.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RemInfoBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartonBinInstance, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartonBinInstance_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartonBinInstance &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartonBinInstance_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartonBinInstance &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartonExtractor</name>
    <filename>classThePEG_1_1PartonExtractor.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="typedef">
      <type>map&lt; cPPtr, PBIPtr &gt;</type>
      <name>PartonBinInstanceMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxTries</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>getPDF</name>
      <anchor>a1</anchor>
      <arglist>(tcPDPtr particle) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonExtractor</name>
      <anchor>z743_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonExtractor</name>
      <anchor>z743_1</anchor>
      <arglist>(const PartonExtractor &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartonExtractor</name>
      <anchor>z743_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z745_0</anchor>
      <arglist>(const cPDPair &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PartonPairVec</type>
      <name>getPartons</name>
      <anchor>z745_1</anchor>
      <arglist>(Energy maxEnergy, const cPDPair &amp;, const KinematicalCuts &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>newScale</name>
      <anchor>z745_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>colourConnect</name>
      <anchor>z745_3</anchor>
      <arglist>(tPPtr particle, tPPtr parton, const tPVector &amp;remnants) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PBIPair</type>
      <name>newRemnants</name>
      <anchor>z745_4</anchor>
      <arglist>(tPPair oldp, tPPair newp, tStepPtr step)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual pair&lt; int, int &gt;</type>
      <name>nDims</name>
      <anchor>z745_5</anchor>
      <arglist>(const PBPair &amp;pbins)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>prepare</name>
      <anchor>z745_6</anchor>
      <arglist>(const PBIPair &amp;pbins)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>generateL</name>
      <anchor>z745_7</anchor>
      <arglist>(const PBIPair &amp;pbins, const double *r1, const double *r2)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>generateSHat</name>
      <anchor>z745_8</anchor>
      <arglist>(Energy2 s, const PBIPair &amp;pbins, const double *r1, const double *r2)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>fullFn</name>
      <anchor>z745_9</anchor>
      <arglist>(const PBIPair &amp;pbins, Energy2 scale)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>construct</name>
      <anchor>z745_10</anchor>
      <arglist>(const PBIPair &amp;pbins, tStepPtr step) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>constructRemnants</name>
      <anchor>z745_11</anchor>
      <arglist>(const PBIPair &amp;pbins, tSubProPtr sub, tStepPtr step) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual LorentzRotation</type>
      <name>boostRemnants</name>
      <anchor>z745_12</anchor>
      <arglist>(PBIPair &amp;bins, LorentzMomentum k1, LorentzMomentum k2, bool side1, bool side2) const </arglist>
    </member>
    <member kind="function">
      <type>tPBIPtr</type>
      <name>partonBinInstance</name>
      <anchor>z747_0</anchor>
      <arglist>(tcPPtr) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z747_1</anchor>
      <arglist>(tXCombPtr newXComb)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z751_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z751_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>addPartons</name>
      <anchor>b0</anchor>
      <arglist>(tPBPtr incoming, const PDFCuts &amp;cuts, PartonVector &amp;pbins) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tcPDFPtr</type>
      <name>noPDF</name>
      <anchor>b1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>findConnect</name>
      <anchor>b2</anchor>
      <arglist>(tColinePtr line, tPPtr parton, bool anti, Iterator first, Iterator last) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>generateL</name>
      <anchor>z749_0</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>generate</name>
      <anchor>z749_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 shat, const Lorentz5Momentum &amp;first)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>fullFn</name>
      <anchor>z749_2</anchor>
      <arglist>(const PartonBinInstance &amp;pb)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>construct</name>
      <anchor>z749_3</anchor>
      <arglist>(PartonBinInstance &amp;pb, tStepPtr step) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PBIPtr</type>
      <name>newRemnants</name>
      <anchor>z749_4</anchor>
      <arglist>(tPBIPtr oldpb, tPPtr newp, const LorentzMomentum &amp;k)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addNewRemnants</name>
      <anchor>z749_5</anchor>
      <arglist>(tPBIPtr oldpb, tPBIPtr newpb, tStepPtr step)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>transformRemnants</name>
      <anchor>z749_6</anchor>
      <arglist>(LorentzMomentum &amp;Ph, LorentzMomentum &amp;Pr, const LorentzMomentum &amp;k, const LorentzMomentum &amp;P) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>constructRemnants</name>
      <anchor>z749_7</anchor>
      <arglist>(PartonBinInstance &amp;pb, LorentzMomentum &amp;Ph, const LorentzMomentum &amp;k) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z753_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z753_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z755_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z755_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z755_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z755_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z755_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartonExtractor &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PartonExtractor &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PartonBinInstanceMap</type>
      <name>partonBinInstances</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; PDFPtr &gt;</type>
      <name>theSpecialDensities</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDFPtr</type>
      <name>theNoPDF</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theMaxTries</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>flatSHatY</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartonExtractor &gt;</type>
      <name>initPartonExtractor</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>XComb</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartonExtractor, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartonExtractor_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartonExtractor &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartonExtractor_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartonExtractor &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemColException</name>
    <filename>structThePEG_1_1RemColException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>RemColException</name>
      <anchor>a0</anchor>
      <arglist>(const PartonExtractor &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDF</name>
    <filename>classThePEG_1_1PDF.html</filename>
    <member kind="function">
      <type></type>
      <name>PDF</name>
      <anchor>z757_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDF</name>
      <anchor>z757_1</anchor>
      <arglist>(const PDF &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDF</name>
      <anchor>z757_2</anchor>
      <arglist>(tcPBIPtr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PDF</name>
      <anchor>z757_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PDF &amp;</type>
      <name>operator=</name>
      <anchor>z757_4</anchor>
      <arglist>(const PDF &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfl</name>
      <anchor>z759_0</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfx</name>
      <anchor>z759_1</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvl</name>
      <anchor>z759_2</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvx</name>
      <anchor>z759_3</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfl</name>
      <anchor>z759_4</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfx</name>
      <anchor>z759_5</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvl</name>
      <anchor>z759_6</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvx</name>
      <anchor>z759_7</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcPDFPtr</type>
      <name>thePDF</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcPDPtr</type>
      <name>theParticle</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDFBase</name>
    <filename>classThePEG_1_1PDFBase.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="enumeration">
      <name>RangeException</name>
      <anchor>z767_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rangeZero</name>
      <anchor>z767_0x1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rangeThrow</name>
      <anchor>z767_0x2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z767_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z767_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z767_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z767_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z767_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RemHPtr</type>
      <name>theRemnantHandler</name>
      <anchor>z767_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RangeException</type>
      <name>rangeException</name>
      <anchor>z767_7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>PDFBase &amp;</type>
      <name>operator=</name>
      <anchor>z767_8</anchor>
      <arglist>(const PDFBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; PDFBase &gt;</type>
      <name>initPDFBase</name>
      <anchor>z767_9</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>tcRemHPtr</type>
      <name>remnantHandler</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFBase</name>
      <anchor>z761_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFBase</name>
      <anchor>z761_1</anchor>
      <arglist>(const PDFBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PDFBase</name>
      <anchor>z761_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z763_0</anchor>
      <arglist>(tcPDPtr particle) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z763_1</anchor>
      <arglist>(tcPDPtr particle) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z763_2</anchor>
      <arglist>(tcPDPtr particle) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z763_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfx</name>
      <anchor>z763_4</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvl</name>
      <anchor>z763_5</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvx</name>
      <anchor>z763_6</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>flattenL</name>
      <anchor>z763_7</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, const PDFCuts &amp;cut, double z, double &amp;jacobian) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>flattenScale</name>
      <anchor>z763_8</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, const PDFCuts &amp;cut, double l, double z, Energy2 &amp;jacobian) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z765_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z765_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PDFBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PDFBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PDFBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PDFBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PDFBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemnantHandlerCantHandle</name>
    <filename>structThePEG_1_1RemnantHandlerCantHandle.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RemnantHandlerCantHandle</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PDFWrongParticle</name>
    <filename>structThePEG_1_1PDFWrongParticle.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>PDFWrongParticle</name>
      <anchor>a0</anchor>
      <arglist>(string p, string pdf, string mess)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PDFRange</name>
    <filename>structThePEG_1_1PDFRange.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>PDFRange</name>
      <anchor>a0</anchor>
      <arglist>(string pdf, string var, double val, double lim)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDFCuts</name>
    <filename>classThePEG_1_1PDFCuts.html</filename>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z769_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z769_1</anchor>
      <arglist>(const PDFCuts &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PDFCuts</name>
      <anchor>z769_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z769_3</anchor>
      <arglist>(const Interval&lt; double &gt; &amp;newL, const SInterval &amp;newScale, const Energy2 &amp;newSMax)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z769_4</anchor>
      <arglist>(const KinematicalCuts &amp;, bool first, const SInterval &amp;S, const SInterval &amp;sHat)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z769_5</anchor>
      <arglist>(const KinematicalCuts &amp;, bool first, Energy maxEnergy)</arglist>
    </member>
    <member kind="function">
      <type>PDFCuts &amp;</type>
      <name>operator=</name>
      <anchor>z769_6</anchor>
      <arglist>(const PDFCuts &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lMin</name>
      <anchor>z771_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lMax</name>
      <anchor>z771_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xMin</name>
      <anchor>z771_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xMax</name>
      <anchor>z771_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMin</name>
      <anchor>z771_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>z771_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>z771_6</anchor>
      <arglist>(double x) const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMaxL</name>
      <anchor>z771_7</anchor>
      <arglist>(double l) const </arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>sMax</name>
      <anchor>z771_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Interval&lt; double &gt;</type>
      <name>theL</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SInterval</type>
      <name>theScale</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theSMax</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RemnantHandler</name>
    <filename>classThePEG_1_1RemnantHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type>bool</type>
      <name>multiCapable</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RemnantHandler</name>
      <anchor>z773_0</anchor>
      <arglist>(bool multi=false)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RemnantHandler</name>
      <anchor>z773_1</anchor>
      <arglist>(const RemnantHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RemnantHandler</name>
      <anchor>z773_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z775_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z775_1</anchor>
      <arglist>(const PartonBin &amp;pb, bool doScale) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z775_2</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;parent) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z775_3</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, Energy2 shat, const LorentzMomentum &amp;parent) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>createRemnants</name>
      <anchor>z775_4</anchor>
      <arglist>(PartonBinInstance &amp;pb) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>recreateRemnants</name>
      <anchor>z775_5</anchor>
      <arglist>(PartonBinInstance &amp;pb, tPPtr oldp, tPPtr newp, double newl, Energy2 scale, const LorentzMomentum &amp;p, const PVector &amp;prev=PVector()) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>recreateRemnants</name>
      <anchor>z775_6</anchor>
      <arglist>(PartonBinInstance &amp;pb, tPPtr oldp, tPPtr newp, double newl, Energy2 scale, Energy2 shat, const LorentzMomentum &amp;p, const PVector &amp;prev=PVector()) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z777_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z777_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z779_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z779_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z779_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z779_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z779_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RemnantHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const RemnantHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isMultiCapable</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; RemnantHandler &gt;</type>
      <name>initRemnantHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; RemnantHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01RemnantHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; RemnantHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01RemnantHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; RemnantHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemnantHandlerException</name>
    <filename>structThePEG_1_1RemnantHandlerException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>RemnantHandlerException</name>
      <anchor>a0</anchor>
      <arglist>(string p0, string p, string r, string mess)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::BreitWignerMass</name>
    <filename>classThePEG_1_1BreitWignerMass.html</filename>
    <base>ThePEG::MassGenerator</base>
    <member kind="function">
      <type></type>
      <name>BreitWignerMass</name>
      <anchor>z781_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BreitWignerMass</name>
      <anchor>z781_1</anchor>
      <arglist>(const BreitWignerMass &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~BreitWignerMass</name>
      <anchor>z781_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z783_0</anchor>
      <arglist>(const ParticleData &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>mass</name>
      <anchor>z783_1</anchor>
      <arglist>(const ParticleData &amp;) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z785_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z785_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z787_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z787_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z787_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z787_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z787_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>BreitWignerMass &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const BreitWignerMass &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; BreitWignerMass &gt;</type>
      <name>initBreitWignerMass</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; BreitWignerMass, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01BreitWignerMass_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>MassGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; BreitWignerMass &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01BreitWignerMass_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; BreitWignerMass &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourPairDecayer</name>
    <filename>classThePEG_1_1ColourPairDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type>bool</type>
      <name>shower</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourPairDecayer</name>
      <anchor>z789_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourPairDecayer</name>
      <anchor>z789_1</anchor>
      <arglist>(const ColourPairDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourPairDecayer</name>
      <anchor>z789_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z791_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>getChildren</name>
      <anchor>z791_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z793_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z793_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z795_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z795_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z797_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z797_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z797_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z797_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z797_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z797_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ColourPairDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ColourPairDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>doShower</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ColourPairDecayer &gt;</type>
      <name>initColourPairDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ColourPairDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ColourPairDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ColourPairDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ColourPairDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ColourPairDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::AndMatcher</name>
    <filename>structThePEG_1_1AndMatcher.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>AndMatcher&lt; typename T1::CC, typename T2::CC &gt;</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::OrMatcher</name>
    <filename>structThePEG_1_1OrMatcher.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>OrMatcher&lt; typename T1::CC, typename T2::CC &gt;</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::NotMatcher</name>
    <filename>structThePEG_1_1NotMatcher.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>NotMatcher&lt; typename T::CC &gt;</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ConstituentParticleData</name>
    <filename>classThePEG_1_1ConstituentParticleData.html</filename>
    <base virtualness="virtual">ThePEG::ParticleData</base>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>constituentMass</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstituentParticleData</name>
      <anchor>z799_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstituentParticleData</name>
      <anchor>z799_1</anchor>
      <arglist>(const ConstituentParticleData &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ConstituentParticleData</name>
      <anchor>z799_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z803_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z803_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>Create</name>
      <anchor>z801_0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPair</type>
      <name>Create</name>
      <anchor>z801_1</anchor>
      <arglist>(long newId, string newPDGName, string newAntiPDGName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ConstituentParticleData</name>
      <anchor>b0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b1</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual PDPtr</type>
      <name>pdclone</name>
      <anchor>b2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z805_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z805_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z805_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z805_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z805_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setConstituentMass</name>
      <anchor>d0</anchor>
      <arglist>(Energy m)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defConstituentMass</name>
      <anchor>d1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxConstituentMass</name>
      <anchor>d2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ConstituentParticleData &amp;</type>
      <name>operator=</name>
      <anchor>d3</anchor>
      <arglist>(const ConstituentParticleData &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theConstituentMass</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefaultConstituentMass</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ConstituentParticleData &gt;</type>
      <name>initConstituentParticleData</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ConstituentParticleData, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ConstituentParticleData_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ConstituentParticleData &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ConstituentParticleData_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ConstituentParticleData &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DalitzDecayer</name>
    <filename>classThePEG_1_1DalitzDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>DalitzDecayer</name>
      <anchor>z807_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DalitzDecayer</name>
      <anchor>z807_1</anchor>
      <arglist>(const DalitzDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DalitzDecayer</name>
      <anchor>z807_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z809_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z809_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z811_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z811_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z813_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z813_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z815_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z815_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z815_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z815_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z815_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z815_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DalitzDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DalitzDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>rho</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; DalitzDecayer &gt;</type>
      <name>initDalitzDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DalitzDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DalitzDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DalitzDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DalitzDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DalitzDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Decayer</name>
    <filename>classThePEG_1_1Decayer.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>amplitude</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Decayer</name>
      <anchor>z817_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Decayer</name>
      <anchor>z817_1</anchor>
      <arglist>(const Decayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Decayer</name>
      <anchor>z817_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z819_0</anchor>
      <arglist>(const DecayMode &amp;dm) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z819_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z819_2</anchor>
      <arglist>(const DecayMode &amp;dm, const ParticleData &amp;pd, double oldbrat) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z819_3</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p, double oldbrat) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>getChildren</name>
      <anchor>z819_4</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>finalBoost</name>
      <anchor>z819_5</anchor>
      <arglist>(const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setScales</name>
      <anchor>z819_6</anchor>
      <arglist>(const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z821_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z821_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Decayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Decayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>theAmplitude</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; Decayer &gt;</type>
      <name>initDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Decayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Decayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Decayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Decayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Decayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecayMode</name>
    <filename>classThePEG_1_1DecayMode.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>vector&lt; tcDMPtr &gt;</type>
      <name>ModeVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPair &gt;</type>
      <name>LinkVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DMPtr</type>
      <name>clone</name>
      <anchor>a0</anchor>
      <arglist>(tPDPtr pd) const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>tag</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>parent</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleMSet &amp;</type>
      <name>products</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const PDVector &amp;</type>
      <name>orderedProducts</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PVector</type>
      <name>produceProducts</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ModeMSet &amp;</type>
      <name>cascadeProducts</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MatcherMSet &amp;</type>
      <name>productMatchers</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPMPtr</type>
      <name>wildProductMatcher</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleMSet &amp;</type>
      <name>excluded</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>brat</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>brat</name>
      <anchor>a11</anchor>
      <arglist>(const Particle &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>tDecayerPtr</type>
      <name>decayer</name>
      <anchor>a12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>includes</name>
      <anchor>a13</anchor>
      <arglist>(const DecayMode &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>tDMPtr</type>
      <name>CC</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a15</anchor>
      <arglist>(const DecayMode &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>const LinkVector &amp;</type>
      <name>links</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ModeVector &amp;</type>
      <name>overlap</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>synchronize</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayMode</name>
      <anchor>z823_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayMode</name>
      <anchor>z823_1</anchor>
      <arglist>(const DecayMode &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~DecayMode</name>
      <anchor>z823_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z825_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z825_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>DMPtr</type>
      <name>constructDecayMode</name>
      <anchor>e0</anchor>
      <arglist>(string &amp;tag)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>parent</name>
      <anchor>b0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>brat</name>
      <anchor>b1</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>switchOn</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>switchOff</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>decayer</name>
      <anchor>b4</anchor>
      <arglist>(tDecayerPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addProduct</name>
      <anchor>b5</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addLink</name>
      <anchor>b6</anchor>
      <arglist>(tPDPtr a, tPDPtr b)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addCascadeProduct</name>
      <anchor>b7</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addProductMatcher</name>
      <anchor>b8</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setWildMatcher</name>
      <anchor>b9</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addExcluded</name>
      <anchor>b10</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>DecayMode</name>
      <anchor>b11</anchor>
      <arglist>(tPDPtr newParticle, double newBrat, bool newOn)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>DMPtr</type>
      <name>dmclone</name>
      <anchor>b12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b13</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ParticleMSet &amp;</type>
      <name>products</name>
      <anchor>b14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ModeMSet &amp;</type>
      <name>cascadeProducts</name>
      <anchor>b15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>MatcherMSet &amp;</type>
      <name>productMatchers</name>
      <anchor>b16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tPMPtr &amp;</type>
      <name>wildProductMatcher</name>
      <anchor>b17</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ParticleMSet &amp;</type>
      <name>excluded</name>
      <anchor>b18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z827_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z827_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z827_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z827_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z827_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z829_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z829_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DMPtr</type>
      <name>Create</name>
      <anchor>f0</anchor>
      <arglist>(tPDPtr newParent, double newBrat=0.0, bool newOn=false)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>addOverlap</name>
      <anchor>d0</anchor>
      <arglist>(tcDMPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>resetOverlap</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>compareId</name>
      <anchor>d2</anchor>
      <arglist>(const ParticleMSet &amp;, const ParticleMSet &amp;) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleMSet::const_iterator</type>
      <name>findId</name>
      <anchor>d3</anchor>
      <arglist>(const ParticleMSet &amp;, const ParticleData &amp;) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>makeTag</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>resetTag</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setOn</name>
      <anchor>d6</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getOn</name>
      <anchor>d7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setDecayer</name>
      <anchor>d8</anchor>
      <arglist>(DecayerPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayMode &amp;</type>
      <name>operator=</name>
      <anchor>d9</anchor>
      <arglist>(const DecayMode &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theTag</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theBrat</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isOn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPDPtr</type>
      <name>theParent</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMSet</type>
      <name>theProducts</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDVector</type>
      <name>theOrderedProducts</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ModeMSet</type>
      <name>theCascadeProducts</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MatcherMSet</type>
      <name>theMatchers</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPMPtr</type>
      <name>theWildMatcher</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMSet</type>
      <name>theExcluded</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ModeVector</type>
      <name>theOverlap</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DecayerPtr</type>
      <name>theDecayer</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tDMPtr</type>
      <name>theAntiPartner</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LinkVector</type>
      <name>theLinks</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; DecayMode &gt;</type>
      <name>initDecayMode</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>ParticleData</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DecayMode, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DecayMode_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DecayMode &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DecayMode_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DecayMode &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecModNoAccept</name>
    <filename>classThePEG_1_1DecModNoAccept.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>DecModNoAccept</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecModSetupNoAccept</name>
    <filename>classThePEG_1_1DecModSetupNoAccept.html</filename>
    <base>ThePEG::SetupException</base>
    <member kind="function">
      <type></type>
      <name>DecModSetupNoAccept</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecModRebind</name>
    <filename>classThePEG_1_1DecModRebind.html</filename>
    <base>ThePEG::RebindException</base>
    <member kind="function">
      <type></type>
      <name>DecModRebind</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DummyDecayer</name>
    <filename>classThePEG_1_1DummyDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>DummyDecayer</name>
      <anchor>z831_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DummyDecayer</name>
      <anchor>z831_1</anchor>
      <arglist>(const DummyDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DummyDecayer</name>
      <anchor>z831_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z833_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z833_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z833_2</anchor>
      <arglist>(const DecayMode &amp;, const ParticleData &amp;, double) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z833_3</anchor>
      <arglist>(const DecayMode &amp;, const Particle &amp;, double) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z835_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z835_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z837_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z837_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z837_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z837_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z837_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z837_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DummyDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DummyDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; DummyDecayer &gt;</type>
      <name>initDummyDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DummyDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DummyDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DummyDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DummyDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DummyDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FlatDecayer</name>
    <filename>classThePEG_1_1FlatDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>FlatDecayer</name>
      <anchor>z839_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FlatDecayer</name>
      <anchor>z839_1</anchor>
      <arglist>(const FlatDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FlatDecayer</name>
      <anchor>z839_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z841_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z841_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z841_2</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z843_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z843_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z845_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z845_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z845_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z845_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z845_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z845_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlatDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FlatDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; FlatDecayer &gt;</type>
      <name>initFlatDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FlatDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FlatDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FlatDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FlatDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FlatDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MassGenerator</name>
    <filename>classThePEG_1_1MassGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>MassGenerator</name>
      <anchor>z847_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MassGenerator</name>
      <anchor>z847_1</anchor>
      <arglist>(const MassGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MassGenerator</name>
      <anchor>z847_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z849_0</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy</type>
      <name>mass</name>
      <anchor>z849_1</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z851_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z851_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z851_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z851_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z851_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MassGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MassGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; MassGenerator &gt;</type>
      <name>initMassGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MassGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MassGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MassGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MassGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MassGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Matcher</name>
    <filename>classThePEG_1_1Matcher.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::MatcherBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual PMPtr</type>
      <name>pmclone</name>
      <anchor>z855_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>PMPtr</type>
      <name>Create</name>
      <anchor>z855_1</anchor>
      <arglist>(const string &amp;newName, string antiName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>z859_0</anchor>
      <arglist>(const ParticleData &amp;pd) const </arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>z859_1</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matcher</name>
      <anchor>z853_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matcher</name>
      <anchor>z853_1</anchor>
      <arglist>(const Matcher&lt; T &gt; &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Matcher</name>
      <anchor>z853_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setCC</name>
      <anchor>b0</anchor>
      <arglist>(tPMPtr, tPMPtr) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z857_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z857_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; Matcher&lt; T &gt; &gt;</type>
      <name>initMatcher</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MatcherType</name>
    <filename>structThePEG_1_1MatcherType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Matcher&lt; T &gt;, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Matcher_3_01T_01_4_00_011_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>MatcherBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Matcher&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Matcher_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsBase&lt; Matcher&lt; T &gt; &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MatcherBase</name>
    <filename>classThePEG_1_1MatcherBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>tPMPtr</type>
      <name>CC</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MatcherBase</name>
      <anchor>z861_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MatcherBase</name>
      <anchor>z861_1</anchor>
      <arglist>(const MatcherBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MatcherBase</name>
      <anchor>z861_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>z863_0</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual PMPtr</type>
      <name>pmclone</name>
      <anchor>z863_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>checkp</name>
      <anchor>z865_0</anchor>
      <arglist>(const Particle &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>matches</name>
      <anchor>z865_1</anchor>
      <arglist>(const ParticleData &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>matches</name>
      <anchor>z865_2</anchor>
      <arglist>(const Particle &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>matches</name>
      <anchor>z865_3</anchor>
      <arglist>(const MatcherBase &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleDataSet &amp;</type>
      <name>particles</name>
      <anchor>z867_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const MatcherSet &amp;</type>
      <name>matchers</name>
      <anchor>z867_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>minMass</name>
      <anchor>z869_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>maxMass</name>
      <anchor>z869_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mass</name>
      <anchor>z869_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>z869_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>cTau</name>
      <anchor>z869_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Charge</type>
      <name>iCharge</name>
      <anchor>z869_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>charged</name>
      <anchor>z869_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>positive</name>
      <anchor>z869_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>negative</name>
      <anchor>z869_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>z869_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Color</type>
      <name>iColor</name>
      <anchor>z869_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>colored</name>
      <anchor>z869_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>stable</name>
      <anchor>z869_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z871_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z871_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addPIfMatch</name>
      <anchor>b0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMIfMatch</name>
      <anchor>b1</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addPIfMatch</name>
      <anchor>b2</anchor>
      <arglist>(Iterator, Iterator)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addPIfMatchFrom</name>
      <anchor>b3</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMIfMatch</name>
      <anchor>b4</anchor>
      <arglist>(Iterator, Iterator)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMIfMatchFrom</name>
      <anchor>b5</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>clear</name>
      <anchor>b6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setCC</name>
      <anchor>b7</anchor>
      <arglist>(tPMPtr, tPMPtr) const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z873_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z873_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z873_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z873_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MatcherBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MatcherBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleDataSet</type>
      <name>matchingParticles</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MatcherSet</type>
      <name>matchingMatchers</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMaxMass</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMinMass</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>commonMass</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>commonWidth</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Length</type>
      <name>commonCTau</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Charge</type>
      <name>commonCharge</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>commonSpin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Color</type>
      <name>commonColor</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>commonStable</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPMPtr</type>
      <name>theAntiPartner</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; MatcherBase &gt;</type>
      <name>initMatcherBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Repository</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MatcherBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MatcherBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MatcherBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MatcherBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MatcherBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::OmegaPhi3PiDecayer</name>
    <filename>classThePEG_1_1OmegaPhi3PiDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type></type>
      <name>OmegaPhi3PiDecayer</name>
      <anchor>z875_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OmegaPhi3PiDecayer</name>
      <anchor>z875_1</anchor>
      <arglist>(const OmegaPhi3PiDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OmegaPhi3PiDecayer</name>
      <anchor>z875_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z877_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z877_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z879_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z879_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z881_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z881_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z883_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z883_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z883_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z883_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z883_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z883_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>OmegaPhi3PiDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const OmegaPhi3PiDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>margin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; OmegaPhi3PiDecayer &gt;</type>
      <name>initOmegaPhi3PiDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; OmegaPhi3PiDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01OmegaPhi3PiDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; OmegaPhi3PiDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01OmegaPhi3PiDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; OmegaPhi3PiDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Onium3GDecayer</name>
    <filename>classThePEG_1_1Onium3GDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type>bool</type>
      <name>shower</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>minGGMass</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Onium3GDecayer</name>
      <anchor>z885_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Onium3GDecayer</name>
      <anchor>z885_1</anchor>
      <arglist>(const Onium3GDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Onium3GDecayer</name>
      <anchor>z885_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z887_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z887_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z887_2</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z889_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z889_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z891_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z891_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z893_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z893_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z893_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z893_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z893_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z893_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Onium3GDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Onium3GDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>doShower</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMinGGMass</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Onium3GDecayer &gt;</type>
      <name>initOnium3GDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Onium3GDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Onium3GDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Onium3GDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Onium3GDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Onium3GDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParticleData</name>
    <filename>classThePEG_1_1ParticleData.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>Selector&lt; tDMPtr &gt;</type>
      <name>DecaySelector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mass</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>massMax</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>massMin</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>constituentMass</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>a4</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthCut</name>
      <anchor>a6</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthCut</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthUpCut</name>
      <anchor>a8</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthUpCut</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthLoCut</name>
      <anchor>a10</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthLoCut</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>cTau</name>
      <anchor>a12</anchor>
      <arglist>(Length)</arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>cTau</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Charge</type>
      <name>iCharge</name>
      <anchor>a14</anchor>
      <arglist>(PDT::Charge)</arglist>
    </member>
    <member kind="function">
      <type>Charge</type>
      <name>charge</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Charge</type>
      <name>iCharge</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>charged</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>positive</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>negative</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>a20</anchor>
      <arglist>(PDT::Spin)</arglist>
    </member>
    <member kind="function">
      <type>AngularMomentum</type>
      <name>spin</name>
      <anchor>a21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>a22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Color</type>
      <name>iColor</name>
      <anchor>a23</anchor>
      <arglist>(PDT::Color)</arglist>
    </member>
    <member kind="function">
      <type>PDT::Colour</type>
      <name>iColour</name>
      <anchor>a24</anchor>
      <arglist>(PDT::Colour)</arglist>
    </member>
    <member kind="function">
      <type>PDT::Color</type>
      <name>iColor</name>
      <anchor>a25</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Colour</type>
      <name>iColour</name>
      <anchor>a26</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>colored</name>
      <anchor>a27</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>coloured</name>
      <anchor>a28</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasColour</name>
      <anchor>a29</anchor>
      <arglist>(bool anti=false) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAntiColour</name>
      <anchor>a30</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stable</name>
      <anchor>a31</anchor>
      <arglist>(bool stab)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>stable</name>
      <anchor>a32</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tPDPtr</type>
      <name>CC</name>
      <anchor>a33</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>synchronized</name>
      <anchor>a34</anchor>
      <arglist>(bool sync)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>synchronized</name>
      <anchor>a35</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>synchronize</name>
      <anchor>a36</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>massGenerator</name>
      <anchor>a37</anchor>
      <arglist>(tMassGenPtr)</arglist>
    </member>
    <member kind="function">
      <type>tMassGenPtr</type>
      <name>massGenerator</name>
      <anchor>a38</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>widthGenerator</name>
      <anchor>a39</anchor>
      <arglist>(tWidthGeneratorPtr)</arglist>
    </member>
    <member kind="function">
      <type>tWidthGeneratorPtr</type>
      <name>widthGenerator</name>
      <anchor>a40</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>variableRatio</name>
      <anchor>a41</anchor>
      <arglist>(bool varRatio)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>variableRatio</name>
      <anchor>a42</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleData</name>
      <anchor>z895_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleData</name>
      <anchor>z895_1</anchor>
      <arglist>(const ParticleData &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParticleData</name>
      <anchor>z895_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>id</name>
      <anchor>z899_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>PDGName</name>
      <anchor>z899_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>genericName</name>
      <anchor>z899_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z901_0</anchor>
      <arglist>(const Lorentz5Momentum &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z901_1</anchor>
      <arglist>(const LorentzMomentum &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z901_2</anchor>
      <arglist>(const LorentzMomentum &amp;, Energy m) const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z901_3</anchor>
      <arglist>(const Momentum3 &amp;pp=Momentum3()) const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z901_4</anchor>
      <arglist>(Energy m, const Momentum3 &amp;pp=Momentum3()) const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z901_5</anchor>
      <arglist>(Energy plus, Energy minus, Energy px, Energy py) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>generateMass</name>
      <anchor>z901_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>generateWidth</name>
      <anchor>z901_7</anchor>
      <arglist>(Energy mass) const </arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>generateLifeTime</name>
      <anchor>z901_8</anchor>
      <arglist>(Energy mass, Energy width) const </arglist>
    </member>
    <member kind="function">
      <type>const DecaySelector &amp;</type>
      <name>decaySelector</name>
      <anchor>z903_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tDMPtr</type>
      <name>selectMode</name>
      <anchor>z903_1</anchor>
      <arglist>(Particle &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z905_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z905_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>Create</name>
      <anchor>z897_0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPair</type>
      <name>Create</name>
      <anchor>z897_1</anchor>
      <arglist>(long newId, string newPDGName, string newAntiPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual PDPtr</type>
      <name>pdclone</name>
      <anchor>b0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ParticleData</name>
      <anchor>b1</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b2</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z907_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z907_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z909_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z909_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z909_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z909_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z909_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>antiSetup</name>
      <anchor>f0</anchor>
      <arglist>(const PDPair &amp;pap)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addDecayMode</name>
      <anchor>d0</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>removeDecayMode</name>
      <anchor>d1</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMass</name>
      <anchor>d2</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defMass</name>
      <anchor>d3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxMass</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setWidth</name>
      <anchor>d5</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getWidth</name>
      <anchor>d6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defWidth</name>
      <anchor>d7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxWidth</name>
      <anchor>d8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setCut</name>
      <anchor>d9</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getCut</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defCut</name>
      <anchor>d11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxCut</name>
      <anchor>d12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setUpCut</name>
      <anchor>d13</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getUpCut</name>
      <anchor>d14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setLoCut</name>
      <anchor>d15</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getLoCut</name>
      <anchor>d16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setCTau</name>
      <anchor>d17</anchor>
      <arglist>(Length)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Length</type>
      <name>getCTau</name>
      <anchor>d18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Length</type>
      <name>defCTau</name>
      <anchor>d19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Length</type>
      <name>maxCTau</name>
      <anchor>d20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setStable</name>
      <anchor>d21</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getStable</name>
      <anchor>d22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setSync</name>
      <anchor>d23</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getSync</name>
      <anchor>d24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setVariableRatio</name>
      <anchor>d25</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getVariableRatio</name>
      <anchor>d26</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>doSync</name>
      <anchor>d27</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMassGenerator</name>
      <anchor>d28</anchor>
      <arglist>(MassGenPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setWidthGenerator</name>
      <anchor>d29</anchor>
      <arglist>(WidthGeneratorPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setCharge</name>
      <anchor>d30</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetCharge</name>
      <anchor>d31</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>getCharge</name>
      <anchor>d32</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>defCharge</name>
      <anchor>d33</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setSpin</name>
      <anchor>d34</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>getSpin</name>
      <anchor>d35</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>defSpin</name>
      <anchor>d36</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setColour</name>
      <anchor>d37</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getColour</name>
      <anchor>d38</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>defColour</name>
      <anchor>d39</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insDecayModes</name>
      <anchor>d40</anchor>
      <arglist>(DMPtr dm, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delDecayModes</name>
      <anchor>d41</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; DMPtr &gt;</type>
      <name>getDecayModes</name>
      <anchor>d42</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theId</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>thePDGName</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMass</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theWidth</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theWidthUpCut</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theWidthLoCut</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Length</type>
      <name>theCTau</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Charge</type>
      <name>theCharge</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>theSpin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Color</type>
      <name>theColor</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MassGenPtr</type>
      <name>theMassGenerator</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isStable</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DecaySelector</type>
      <name>theDecaySelector</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DecaySet</type>
      <name>theDecayModes</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WidthGeneratorPtr</type>
      <name>theWidthGenerator</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theVariableRatio</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPDPtr</type>
      <name>theAntiPartner</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>syncAnti</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefMass</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefWidth</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefCut</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Length</type>
      <name>theDefCTau</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Charge</type>
      <name>theDefCharge</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>theDefSpin</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Colour</type>
      <name>theDefColour</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ParticleData &gt;</type>
      <name>initParticleData</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>Repository</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend">
      <type>friend class</type>
      <name>DecayMode</name>
      <anchor>n1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ParticleData, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ParticleData_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ParticleData &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ParticleData_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ParticleData &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleChargeCommand</name>
    <filename>structThePEG_1_1ParticleChargeCommand.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParticleChargeCommand</name>
      <anchor>a0</anchor>
      <arglist>(const ParticleData &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDT</name>
    <filename>classThePEG_1_1PDT.html</filename>
    <member kind="typedef">
      <type>Colour</type>
      <name>Color</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Spin</name>
      <anchor>w64</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SpinNA</name>
      <anchor>w64w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SpinUnknown</name>
      <anchor>w64w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SpinUndefined</name>
      <anchor>w64w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin0</name>
      <anchor>w64w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin1Half</name>
      <anchor>w64w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin1</name>
      <anchor>w64w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin3Half</name>
      <anchor>w64w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin2</name>
      <anchor>w64w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin5Half</name>
      <anchor>w64w9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin3</name>
      <anchor>w64w10</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin7Half</name>
      <anchor>w64w11</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin4</name>
      <anchor>w64w12</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Charge</name>
      <anchor>w65</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ChargeUnknown</name>
      <anchor>w65w13</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ChargeUndefined</name>
      <anchor>w65w14</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Charged</name>
      <anchor>w65w15</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Positive</name>
      <anchor>w65w16</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Negative</name>
      <anchor>w65w17</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ChargeNeutral</name>
      <anchor>w65w18</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Charge0</name>
      <anchor>w65w19</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus1Third</name>
      <anchor>w65w20</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus2Third</name>
      <anchor>w65w21</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus1</name>
      <anchor>w65w22</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus1Third</name>
      <anchor>w65w23</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus2Third</name>
      <anchor>w65w24</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus1</name>
      <anchor>w65w25</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus4Third</name>
      <anchor>w65w26</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus5Third</name>
      <anchor>w65w27</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus2</name>
      <anchor>w65w28</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus4Third</name>
      <anchor>w65w29</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus5Third</name>
      <anchor>w65w30</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus2</name>
      <anchor>w65w31</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus7Third</name>
      <anchor>w65w32</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus8Third</name>
      <anchor>w65w33</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus3</name>
      <anchor>w65w34</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus7Third</name>
      <anchor>w65w35</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus8Third</name>
      <anchor>w65w36</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus3</name>
      <anchor>w65w37</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus4</name>
      <anchor>w65w38</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus5</name>
      <anchor>w65w39</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus6</name>
      <anchor>w65w40</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus7</name>
      <anchor>w65w41</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus8</name>
      <anchor>w65w42</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus4</name>
      <anchor>w65w43</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus5</name>
      <anchor>w65w44</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus6</name>
      <anchor>w65w45</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus7</name>
      <anchor>w65w46</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus8</name>
      <anchor>w65w47</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Colour</name>
      <anchor>w66</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColourUnknown</name>
      <anchor>w66w48</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColourUndefined</name>
      <anchor>w66w49</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColourNeutral</name>
      <anchor>w66w50</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour0</name>
      <anchor>w66w51</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Coloured</name>
      <anchor>w66w52</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour3</name>
      <anchor>w66w53</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour3bar</name>
      <anchor>w66w54</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour8</name>
      <anchor>w66w55</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColorUnknown</name>
      <anchor>w66w56</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColorUndefined</name>
      <anchor>w66w57</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColorNeutral</name>
      <anchor>w66w58</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color0</name>
      <anchor>w66w59</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colored</name>
      <anchor>w66w60</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color3</name>
      <anchor>w66w61</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color3bar</name>
      <anchor>w66w62</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color8</name>
      <anchor>w66w63</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>charged</name>
      <anchor>e0</anchor>
      <arglist>(Charge c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>positive</name>
      <anchor>e1</anchor>
      <arglist>(Charge c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>negative</name>
      <anchor>e2</anchor>
      <arglist>(Charge c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>colored</name>
      <anchor>e3</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>coloured</name>
      <anchor>e4</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Color</type>
      <name>antiColor</name>
      <anchor>e5</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Colour</type>
      <name>antiColour</name>
      <anchor>e6</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e7</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e8</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e9</anchor>
      <arglist>(tcPPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e10</anchor>
      <arglist>(const ParticleData &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e11</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::QuarksToHadronsDecayer</name>
    <filename>classThePEG_1_1QuarksToHadronsDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>getN</name>
      <anchor>a0</anchor>
      <arglist>(Energy m0, Energy summq, int Nq) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PVector</type>
      <name>getHadrons</name>
      <anchor>a1</anchor>
      <arglist>(int Nh, tcPDVector quarks) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>distribute</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;parent, PVector &amp;children) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>a3</anchor>
      <arglist>(const Particle &amp;parent, const PVector &amp;children) const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>fixedN</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>minN</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>c1</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>c2</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>c3</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcFlavGenPtr</type>
      <name>flavourGenerator</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QuarksToHadronsDecayer</name>
      <anchor>z911_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QuarksToHadronsDecayer</name>
      <anchor>z911_1</anchor>
      <arglist>(const QuarksToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~QuarksToHadronsDecayer</name>
      <anchor>z911_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z913_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z913_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z915_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z915_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z917_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z917_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z919_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z919_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z919_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z919_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z919_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z919_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>QuarksToHadronsDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const QuarksToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theFixedN</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theMinN</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theC1</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theC2</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theC3</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlavGenPtr</type>
      <name>theFlavourGenerator</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; QuarksToHadronsDecayer &gt;</type>
      <name>initQuarksToHadronsDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; QuarksToHadronsDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01QuarksToHadronsDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; QuarksToHadronsDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01QuarksToHadronsDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; QuarksToHadronsDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::AnyMatcher</name>
    <filename>structThePEG_1_1AnyMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>AnyMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ChargedMatcher</name>
    <filename>structThePEG_1_1ChargedMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>ChargedMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PositiveMatcher</name>
    <filename>structThePEG_1_1PositiveMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>NegativeMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::NeutralMatcher</name>
    <filename>structThePEG_1_1NeutralMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>NeutralMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::NegativeMatcher</name>
    <filename>structThePEG_1_1NegativeMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>PositiveMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaryonMatcher</name>
    <filename>structThePEG_1_1BaryonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>BaryonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MesonMatcher</name>
    <filename>structThePEG_1_1MesonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>MesonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DiquarkMatcher</name>
    <filename>structThePEG_1_1DiquarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>DiquarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::QuarkMatcher</name>
    <filename>structThePEG_1_1QuarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>QuarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::LeptonMatcher</name>
    <filename>structThePEG_1_1LeptonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>LeptonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::LightQuarkMatcher</name>
    <filename>structThePEG_1_1LightQuarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>LightAntiQuarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::LightAntiQuarkMatcher</name>
    <filename>structThePEG_1_1LightAntiQuarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>LightQuarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::StandardQCDPartonMatcher</name>
    <filename>structThePEG_1_1StandardQCDPartonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>StandardQCDPartonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PseudoScalarMesonMatcher</name>
    <filename>structThePEG_1_1PseudoScalarMesonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>PseudoScalarMesonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::VectorMesonMatcher</name>
    <filename>structThePEG_1_1VectorMesonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>VectorMesonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Tau2HadronsDecayer</name>
    <filename>classThePEG_1_1Tau2HadronsDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type></type>
      <name>Tau2HadronsDecayer</name>
      <anchor>z921_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tau2HadronsDecayer</name>
      <anchor>z921_1</anchor>
      <arglist>(const Tau2HadronsDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Tau2HadronsDecayer</name>
      <anchor>z921_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z923_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z923_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z925_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z925_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z927_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z927_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z929_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z929_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z929_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z929_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z929_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z929_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Tau2HadronsDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Tau2HadronsDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Tau2HadronsDecayer &gt;</type>
      <name>initTau2HadronsDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Tau2HadronsDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Tau2HadronsDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Tau2HadronsDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Tau2HadronsDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Tau2HadronsDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::V2PPDecayer</name>
    <filename>classThePEG_1_1V2PPDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type></type>
      <name>V2PPDecayer</name>
      <anchor>z931_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>V2PPDecayer</name>
      <anchor>z931_1</anchor>
      <arglist>(const V2PPDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~V2PPDecayer</name>
      <anchor>z931_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z933_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z933_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z933_2</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z935_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z935_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z937_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z937_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z939_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z939_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z939_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z939_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z939_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z939_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>V2PPDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const V2PPDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPPtr</type>
      <name>grandParent</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPPtr</type>
      <name>sibling</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; V2PPDecayer &gt;</type>
      <name>initV2PPDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; V2PPDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01V2PPDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; V2PPDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01V2PPDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; V2PPDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::WeakToHadronsDecayer</name>
    <filename>classThePEG_1_1WeakToHadronsDecayer.html</filename>
    <base>ThePEG::QuarksToHadronsDecayer</base>
    <member kind="function">
      <type></type>
      <name>WeakToHadronsDecayer</name>
      <anchor>z941_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>WeakToHadronsDecayer</name>
      <anchor>z941_1</anchor>
      <arglist>(const WeakToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~WeakToHadronsDecayer</name>
      <anchor>z941_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z943_0</anchor>
      <arglist>(const DecayMode &amp;dm) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z943_1</anchor>
      <arglist>(const Particle &amp;parent, const PVector &amp;children) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PVector</type>
      <name>getHadrons</name>
      <anchor>z943_2</anchor>
      <arglist>(int Nh, tcPDVector quarks) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z945_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z945_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z947_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z947_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z949_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z949_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z949_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z949_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z949_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z949_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>WeakToHadronsDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const WeakToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; WeakToHadronsDecayer &gt;</type>
      <name>initWeakToHadronsDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; WeakToHadronsDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01WeakToHadronsDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>QuarksToHadronsDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; WeakToHadronsDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01WeakToHadronsDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; WeakToHadronsDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::WidthGenerator</name>
    <filename>classThePEG_1_1WidthGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>Selector&lt; tDMPtr &gt;</type>
      <name>DecayMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>WidthGenerator</name>
      <anchor>z951_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>WidthGenerator</name>
      <anchor>z951_1</anchor>
      <arglist>(const WidthGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~WidthGenerator</name>
      <anchor>z951_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z953_0</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>z953_1</anchor>
      <arglist>(const Particle &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy</type>
      <name>width</name>
      <anchor>z953_2</anchor>
      <arglist>(const ParticleData &amp;, Energy m) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Length</type>
      <name>lifeTime</name>
      <anchor>z953_3</anchor>
      <arglist>(const ParticleData &amp;, Energy m, Energy w) const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual DecayMap</type>
      <name>rate</name>
      <anchor>z953_4</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DecayMap</type>
      <name>rate</name>
      <anchor>z953_5</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>WidthGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const WidthGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; WidthGenerator &gt;</type>
      <name>initWidthGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; WidthGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01WidthGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; WidthGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01WidthGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; WidthGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::InputDescription</name>
    <filename>classThePEG_1_1InputDescription.html</filename>
    <base>ThePEG::Named</base>
    <member kind="typedef">
      <type>vector&lt; const InputDescription * &gt;</type>
      <name>DescriptionVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>InputDescription</name>
      <anchor>a0</anchor>
      <arglist>(string newName, int version)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDescription</name>
      <anchor>a1</anchor>
      <arglist>(const ClassDescriptionBase *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addBaseClass</name>
      <anchor>a2</anchor>
      <arglist>(const InputDescription *)</arglist>
    </member>
    <member kind="function">
      <type>const DescriptionVector &amp;</type>
      <name>descriptions</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>BPtr</type>
      <name>create</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a5</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DescriptionVector</type>
      <name>theBaseClasses</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const ClassDescriptionBase *</type>
      <name>theDescription</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theVersion</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PersistentIStream</name>
    <filename>classThePEG_1_1PersistentIStream.html</filename>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; BPtr &gt;</type>
      <name>ObjectVector</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>InputDescription::DescriptionVector</type>
      <name>DescriptionVector</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>a0</anchor>
      <arglist>(istream &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>a1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PersistentIStream</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a3</anchor>
      <arglist>(RCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a4</anchor>
      <arglist>(ConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a5</anchor>
      <arglist>(TransientRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a6</anchor>
      <arglist>(TransientConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getContainer</name>
      <anchor>a7</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>BPtr</type>
      <name>getObject</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getObjectPart</name>
      <anchor>a9</anchor>
      <arglist>(tBPtr obj, const InputDescription *pid)</arglist>
    </member>
    <member kind="function">
      <type>const InputDescription *</type>
      <name>getClass</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>setPedantic</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>setTolerant</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>good</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator bool</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>pedantic</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_0</anchor>
      <arglist>(string &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_1</anchor>
      <arglist>(char &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_2</anchor>
      <arglist>(signed char &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_3</anchor>
      <arglist>(unsigned char &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_4</anchor>
      <arglist>(int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_5</anchor>
      <arglist>(unsigned int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_6</anchor>
      <arglist>(long &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_7</anchor>
      <arglist>(unsigned long &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_8</anchor>
      <arglist>(short &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_9</anchor>
      <arglist>(unsigned short &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_10</anchor>
      <arglist>(double &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_11</anchor>
      <arglist>(float &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_12</anchor>
      <arglist>(bool &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z957_13</anchor>
      <arglist>(Complex &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>init</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>char</type>
      <name>get</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>char</type>
      <name>escaped</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBadState</name>
      <anchor>d3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getSep</name>
      <anchor>d4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>skipField</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>beginObject</name>
      <anchor>d6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endObject</name>
      <anchor>d7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endBase</name>
      <anchor>d8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>istream &amp;</type>
      <name>is</name>
      <anchor>d9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const istream &amp;</type>
      <name>is</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>d11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>d12</anchor>
      <arglist>(const PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PersistentIStream &amp;</type>
      <name>operator=</name>
      <anchor>d13</anchor>
      <arglist>(const PersistentIStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectVector</type>
      <name>readObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DescriptionVector</type>
      <name>readClasses</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>istream *</type>
      <name>theIStream</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isPedantic</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>allocStream</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>badState</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>version</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>subVersion</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tBegin</name>
      <anchor>z959_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tEnd</name>
      <anchor>z959_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNext</name>
      <anchor>z959_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNull</name>
      <anchor>z959_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tSep</name>
      <anchor>z959_4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNoSep</name>
      <anchor>z959_5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tYes</name>
      <anchor>z959_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNo</name>
      <anchor>z959_7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingObject</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingObject.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::ReadFailior</name>
    <filename>structThePEG_1_1PersistentIStream_1_1ReadFailior.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingObject</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingObject.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::ReadFailior</name>
    <filename>structThePEG_1_1PersistentIStream_1_1ReadFailior.html</filename>
  </compound>
  <compound kind="class">
    <name>ThePEG::PersistentOStream</name>
    <filename>classThePEG_1_1PersistentOStream.html</filename>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; cBPtr, int, less&lt; cBPtr &gt;, Allocator&lt; std::pair&lt; cBPtr const, int &gt; &gt; &gt;</type>
      <name>ObjectMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const ClassDescriptionBase *, int, less&lt; const ClassDescriptionBase * &gt;, Allocator&lt; std::pair&lt; const ClassDescriptionBase *const, int &gt; &gt; &gt;</type>
      <name>ClassMap</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ClassDescriptionBase::DescriptionVector</type>
      <name>DescriptionVector</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>a0</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>a1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PersistentOStream</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a3</anchor>
      <arglist>(const RCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a4</anchor>
      <arglist>(const ConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a5</anchor>
      <arglist>(const TransientRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a6</anchor>
      <arglist>(const TransientConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>putContainer</name>
      <anchor>a7</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>outputPointer</name>
      <anchor>a8</anchor>
      <arglist>(tcBPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>putObjectPart</name>
      <anchor>a9</anchor>
      <arglist>(tcBPtr obj, const ClassDescriptionBase *cd)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>flush</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>push</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>pop</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>good</name>
      <anchor>a13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator bool</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_1</anchor>
      <arglist>(char)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_2</anchor>
      <arglist>(signed char)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_3</anchor>
      <arglist>(unsigned char)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_4</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_5</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_6</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_7</anchor>
      <arglist>(unsigned long)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_8</anchor>
      <arglist>(short)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_9</anchor>
      <arglist>(unsigned short)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_10</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_11</anchor>
      <arglist>(float)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_12</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z963_13</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>isToken</name>
      <anchor>d0</anchor>
      <arglist>(char c) const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBadState</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>checkState</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ClassDescriptionBase *</type>
      <name>writeClassId</name>
      <anchor>d3</anchor>
      <arglist>(tcBPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>writeClassDescription</name>
      <anchor>d4</anchor>
      <arglist>(const ClassDescriptionBase *)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>beginObject</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endObject</name>
      <anchor>d6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endBase</name>
      <anchor>d7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>put</name>
      <anchor>d8</anchor>
      <arglist>(char)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>escape</name>
      <anchor>d9</anchor>
      <arglist>(char c)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ostream &amp;</type>
      <name>os</name>
      <anchor>d10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ostream &amp;</type>
      <name>os</name>
      <anchor>d11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>init</name>
      <anchor>d12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>d13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>d14</anchor>
      <arglist>(const PersistentOStream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PersistentOStream &amp;</type>
      <name>operator=</name>
      <anchor>d15</anchor>
      <arglist>(const PersistentOStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectMap</type>
      <name>writtenObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>stack&lt; int &gt;</type>
      <name>lastSavedObject</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ClassMap</type>
      <name>writtenClasses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ostream *</type>
      <name>theOStream</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>badState</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>allocStream</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const int</type>
      <name>version</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const int</type>
      <name>subVersion</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tBegin</name>
      <anchor>z965_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tEnd</name>
      <anchor>z965_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNext</name>
      <anchor>z965_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNull</name>
      <anchor>z965_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tSep</name>
      <anchor>z965_4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNoSep</name>
      <anchor>z965_5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tYes</name>
      <anchor>z965_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNo</name>
      <anchor>z965_7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentOStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentOStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentOStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentOStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="class">
    <name>ThePEG::BaseRepository</name>
    <filename>classThePEG_1_1BaseRepository.html</filename>
    <member kind="typedef">
      <type>StringSet</type>
      <name>DirectorySet</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; const InterfaceBase * &gt;</type>
      <name>InterfaceSet</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const ClassDescriptionBase *, InterfaceSet &gt;</type>
      <name>TypeInterfaceMap</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const ClassDescriptionBase *, const ClassDocumentationBase * &gt;</type>
      <name>TypeDocumentationMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>exec</name>
      <anchor>e0</anchor>
      <arglist>(string cmd, ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z969_0</anchor>
      <arglist>(const InterfaceBase &amp;, const type_info &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z969_1</anchor>
      <arglist>(const ClassDocumentationBase &amp;, const type_info &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z969_2</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z969_3</anchor>
      <arglist>(IBPtr, string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>remove</name>
      <anchor>z969_4</anchor>
      <arglist>(tIBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>remove</name>
      <anchor>z969_5</anchor>
      <arglist>(const ObjectSet &amp;rmset)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rename</name>
      <anchor>z969_6</anchor>
      <arglist>(tIBPtr object, string newName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CreateDirectory</name>
      <anchor>z971_0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CheckObjectDirectory</name>
      <anchor>z971_1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CheckDirectory</name>
      <anchor>z971_2</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>DirectoryAppend</name>
      <anchor>z971_3</anchor>
      <arglist>(string &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>ChangeDirectory</name>
      <anchor>z971_4</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PushDirectory</name>
      <anchor>z971_5</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PopDirectory</name>
      <anchor>z971_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>GetPtr</name>
      <anchor>z973_0</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PtrType</type>
      <name>GetPtr</name>
      <anchor>z973_1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PtrType</type>
      <name>GetObject</name>
      <anchor>z973_2</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>GetPointer</name>
      <anchor>z973_3</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IVector</type>
      <name>SearchDirectory</name>
      <anchor>z973_4</anchor>
      <arglist>(string name, string className=&quot;&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>TraceObject</name>
      <anchor>z973_5</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>getObjectFromNoun</name>
      <anchor>z973_6</anchor>
      <arglist>(string noun)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IVector</type>
      <name>GetObjectsReferingTo</name>
      <anchor>z975_0</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IVector</type>
      <name>DirectReferences</name>
      <anchor>z975_1</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>addReferences</name>
      <anchor>z975_2</anchor>
      <arglist>(tIBPtr obj, ObjectSet &amp;refs)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>InterfaceMap</type>
      <name>getInterfaces</name>
      <anchor>z977_0</anchor>
      <arglist>(const type_info &amp;ti, bool all=true)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const InterfaceBase *</type>
      <name>FindInterface</name>
      <anchor>z977_1</anchor>
      <arglist>(IBPtr object, string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getInterfaceFromNoun</name>
      <anchor>z977_2</anchor>
      <arglist>(string noun)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getPosArgFromNoun</name>
      <anchor>z977_3</anchor>
      <arglist>(string noun)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>update</name>
      <anchor>z979_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>clearAll</name>
      <anchor>z979_1</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>resetAll</name>
      <anchor>z979_2</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>readSetup</name>
      <anchor>z979_3</anchor>
      <arglist>(tIBPtr ip, istream &amp;is)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>lock</name>
      <anchor>z979_4</anchor>
      <arglist>(tIBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unlock</name>
      <anchor>z979_5</anchor>
      <arglist>(tIBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ClassDocumentationBase *</type>
      <name>getDocumentation</name>
      <anchor>z981_0</anchor>
      <arglist>(tcIBPtr ip)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getModelDescription</name>
      <anchor>z981_1</anchor>
      <arglist>(tcIBPtr ip)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getModelReferences</name>
      <anchor>z981_2</anchor>
      <arglist>(tcIBPtr ip)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>cout</name>
      <anchor>z983_0</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>cout</name>
      <anchor>z983_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>cerr</name>
      <anchor>z983_2</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>cerr</name>
      <anchor>z983_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>clog</name>
      <anchor>z983_4</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>clog</name>
      <anchor>z983_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>addInterfaces</name>
      <anchor>f0</anchor>
      <arglist>(const ClassDescriptionBase &amp;, InterfaceMap &amp;, bool all=true)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>clone</name>
      <anchor>z985_0</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>fullclone</name>
      <anchor>z985_1</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>rebind</name>
      <anchor>z985_2</anchor>
      <arglist>(InterfacedBase &amp;obj, const TranslationMap &amp;trans, const IVector &amp;defaults)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ObjectMap &amp;</type>
      <name>objects</name>
      <anchor>z987_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ObjectSet &amp;</type>
      <name>allObjects</name>
      <anchor>z987_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>TypeInterfaceMap &amp;</type>
      <name>interfaces</name>
      <anchor>z987_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>TypeDocumentationMap &amp;</type>
      <name>documentations</name>
      <anchor>z987_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DirectorySet &amp;</type>
      <name>directories</name>
      <anchor>z987_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>StringVector &amp;</type>
      <name>directoryStack</name>
      <anchor>z987_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>bool &amp;</type>
      <name>updating</name>
      <anchor>z987_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ostream *&amp;</type>
      <name>coutp</name>
      <anchor>z987_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ostream *&amp;</type>
      <name>cerrp</name>
      <anchor>z987_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ostream *&amp;</type>
      <name>clogp</name>
      <anchor>z987_9</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BadClassClone</name>
    <filename>structThePEG_1_1BadClassClone.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>BadClassClone</name>
      <anchor>a0</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BadClone</name>
    <filename>structThePEG_1_1BadClone.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>BadClone</name>
      <anchor>a0</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepoNameException</name>
    <filename>structThePEG_1_1RepoNameException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepoNameException</name>
      <anchor>a0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepositoryNoDirectory</name>
    <filename>structThePEG_1_1RepositoryNoDirectory.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepositoryNoDirectory</name>
      <anchor>a0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepositoryNotFound</name>
    <filename>structThePEG_1_1RepositoryNotFound.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepositoryNotFound</name>
      <anchor>a0</anchor>
      <arglist>(string name)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepositoryClassMisMatch</name>
    <filename>structThePEG_1_1RepositoryClassMisMatch.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepositoryClassMisMatch</name>
      <anchor>a0</anchor>
      <arglist>(const InterfacedBase &amp;o, string name)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CurrentGenerator</name>
    <filename>classThePEG_1_1CurrentGenerator.html</filename>
    <member kind="function">
      <type></type>
      <name>CurrentGenerator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CurrentGenerator</name>
      <anchor>a1</anchor>
      <arglist>(const CurrentGenerator &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CurrentGenerator</name>
      <anchor>a2</anchor>
      <arglist>(const EGPtr &amp;eg)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CurrentGenerator</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>isVoid</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>EventGenerator &amp;</type>
      <name>current</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tSMPtr</type>
      <name>standardModel</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tStrategyPtr</type>
      <name>strategy</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>out</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>log</name>
      <anchor>e5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>ref</name>
      <anchor>e6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getPtr</name>
      <anchor>e7</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>getPointer</name>
      <anchor>e8</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getObject</name>
      <anchor>e9</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getDefault</name>
      <anchor>e10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CurrentGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const CurrentGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>generatorPushed</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; EGPtr &gt;</type>
      <name>theGeneratorStack</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventGenerator</name>
    <filename>classThePEG_1_1EventGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>map&lt; const type_info *, int &gt;</type>
      <name>ExceptionMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventGenerator</name>
      <anchor>z989_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventGenerator</name>
      <anchor>z989_1</anchor>
      <arglist>(const EventGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventGenerator</name>
      <anchor>z989_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tSMPtr</type>
      <name>standardModel</name>
      <anchor>z991_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tStrategyPtr</type>
      <name>strategy</name>
      <anchor>z991_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tEHPtr</type>
      <name>currentEventHandler</name>
      <anchor>z991_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentEventHandler</name>
      <anchor>z991_3</anchor>
      <arglist>(tEHPtr)</arglist>
    </member>
    <member kind="function">
      <type>tStepHdlPtr</type>
      <name>currentStepHandler</name>
      <anchor>z991_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentStepHandler</name>
      <anchor>z991_5</anchor>
      <arglist>(tStepHdlPtr)</arglist>
    </member>
    <member kind="function">
      <type>tEHPtr</type>
      <name>eventHandler</name>
      <anchor>z991_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>AnalysisVector &amp;</type>
      <name>analysisHandlers</name>
      <anchor>z991_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tEvtManipPtr</type>
      <name>manipulator</name>
      <anchor>z991_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initialize</name>
      <anchor>z993_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>go</name>
      <anchor>z993_1</anchor>
      <arglist>(long next=1, long maxevent=-1)</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>shoot</name>
      <anchor>z993_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>generateEvent</name>
      <anchor>z993_3</anchor>
      <arglist>(Event &amp;event)</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>generateEvent</name>
      <anchor>z993_4</anchor>
      <arglist>(Step &amp;step)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finalize</name>
      <anchor>z993_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z993_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>currentEventNumber</name>
      <anchor>z993_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>tcEventPtr</type>
      <name>currentEvent</name>
      <anchor>z993_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dump</name>
      <anchor>z993_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>use</name>
      <anchor>z993_10</anchor>
      <arglist>(const Interfaced &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSeed</name>
      <anchor>z993_11</anchor>
      <arglist>(long seed)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>logWarning</name>
      <anchor>z993_12</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>N</name>
      <anchor>z993_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>histogramScale</name>
      <anchor>z993_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>filename</name>
      <anchor>z995_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>runName</name>
      <anchor>z995_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>path</name>
      <anchor>z995_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>openOutputFiles</name>
      <anchor>z995_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>closeOutputFiles</name>
      <anchor>z995_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ofstream &amp;</type>
      <name>outfile</name>
      <anchor>z995_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ofstream &amp;</type>
      <name>logfile</name>
      <anchor>z995_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ofstream &amp;</type>
      <name>reffile</name>
      <anchor>z995_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>out</name>
      <anchor>z995_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>log</name>
      <anchor>z995_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>ref</name>
      <anchor>z995_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ObjectSet &amp;</type>
      <name>objects</name>
      <anchor>z997_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ObjectMap &amp;</type>
      <name>objectMap</name>
      <anchor>z997_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getPtr</name>
      <anchor>z997_2</anchor>
      <arglist>(const T &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>IBPtr</type>
      <name>getPointer</name>
      <anchor>z997_3</anchor>
      <arglist>(string name) const </arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getObject</name>
      <anchor>z997_4</anchor>
      <arglist>(string name) const </arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getDefault</name>
      <anchor>z997_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>getParticle</name>
      <anchor>z997_6</anchor>
      <arglist>(long id) const </arglist>
    </member>
    <member kind="function">
      <type>PDPtr</type>
      <name>getParticleData</name>
      <anchor>z997_7</anchor>
      <arglist>(long id) const </arglist>
    </member>
    <member kind="function">
      <type>const MatcherSet &amp;</type>
      <name>matchers</name>
      <anchor>z997_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ParticleMap &amp;</type>
      <name>particles</name>
      <anchor>z997_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const ObjectSet &amp;</type>
      <name>used</name>
      <anchor>z997_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1001_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1001_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>RandomGenerator &amp;</type>
      <name>random</name>
      <anchor>b0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setup</name>
      <anchor>b1</anchor>
      <arglist>(string newRunName, ObjectSet &amp;newObjects, ParticleMap &amp;newParticles, MatcherSet &amp;newMatchers)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>printException</name>
      <anchor>b2</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>logException</name>
      <anchor>b3</anchor>
      <arglist>(const Exception &amp;, tcEventPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>N</name>
      <anchor>b4</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>runName</name>
      <anchor>b5</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ObjectSet &amp;</type>
      <name>objects</name>
      <anchor>b6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ObjectMap &amp;</type>
      <name>objectMap</name>
      <anchor>b7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>generateReferences</name>
      <anchor>b8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>int</type>
      <name>count</name>
      <anchor>b9</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doGo</name>
      <anchor>z999_0</anchor>
      <arglist>(long next, long maxevent)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doInitialize</name>
      <anchor>z999_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doShoot</name>
      <anchor>z999_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doGenerateEvent</name>
      <anchor>z999_3</anchor>
      <arglist>(tEventPtr)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doGenerateEvent</name>
      <anchor>z999_4</anchor>
      <arglist>(tStepPtr)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1003_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1003_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1005_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1005_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z1005_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1005_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>ieve</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>theDebugLevel</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>const vector&lt; IPtr &gt; &amp;</type>
      <name>defaultObjects</name>
      <anchor>d0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleMap &amp;</type>
      <name>localParticles</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ParticleMap &amp;</type>
      <name>localParticles</name>
      <anchor>d2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>path</name>
      <anchor>d3</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>strategy</name>
      <anchor>d4</anchor>
      <arglist>(StrategyPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setLocalParticles</name>
      <anchor>d5</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insLocalParticles</name>
      <anchor>d6</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delLocalParticles</name>
      <anchor>d7</anchor>
      <arglist>(int place)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; PDPtr &gt;</type>
      <name>getLocalParticles</name>
      <anchor>d8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPath</name>
      <anchor>d9</anchor>
      <arglist>(string newPath)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>defPath</name>
      <anchor>d10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d11</anchor>
      <arglist>(const EventGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; IPtr &gt;</type>
      <name>theDefaultObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>theLocalParticles</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SMPtr</type>
      <name>theStandardModel</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StrategyPtr</type>
      <name>theStrategy</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RanGenPtr</type>
      <name>theRandom</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>EHPtr</type>
      <name>theEventHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AnalysisVector</type>
      <name>theAnalysisHandlers</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>EvtManipPtr</type>
      <name>theEventManipulator</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>thePath</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theRunName</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream</type>
      <name>theOutfile</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream</type>
      <name>theLogfile</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream</type>
      <name>theReffile</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNumberOfEvents</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectSet</type>
      <name>theObjects</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectMap</type>
      <name>theObjectMap</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>theParticles</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDVector</type>
      <name>theQuickParticles</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theQuickSize</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MatcherSet</type>
      <name>theMatchers</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectSet</type>
      <name>usedObjects</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>printEvent</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>dumpPeriod</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>debugEvent</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>maxWarnings</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>maxErrors</name>
      <anchor>r25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ExceptionMap</type>
      <name>theExceptions</name>
      <anchor>r26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>UseRandom *</type>
      <name>theCurrentRandom</name>
      <anchor>r27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CurrentGenerator *</type>
      <name>theCurrentGenerator</name>
      <anchor>r28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEHPtr</type>
      <name>theCurrentEventHandler</name>
      <anchor>r29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStepHdlPtr</type>
      <name>theCurrentStepHandler</name>
      <anchor>r30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; EventGenerator &gt;</type>
      <name>initEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>Repository</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EGNoPath</name>
    <filename>structThePEG_1_1EGNoPath.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>EGNoPath</name>
      <anchor>a0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Main</name>
    <filename>classThePEG_1_1Main.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>Main</name>
      <anchor>z1007_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Main</name>
      <anchor>z1007_1</anchor>
      <arglist>(const Main &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Main</name>
      <anchor>z1007_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>eventGenerator</name>
      <anchor>e0</anchor>
      <arglist>(tEGPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tEGPtr</type>
      <name>eventGenerator</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>N</name>
      <anchor>e2</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>N</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>arguments</name>
      <anchor>e4</anchor>
      <arglist>(const vector&lt; string &gt; &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const vector&lt; string &gt; &amp;</type>
      <name>arguments</name>
      <anchor>e5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Main &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Main &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>EGPtr</type>
      <name>theEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>long</type>
      <name>theN</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; string &gt;</type>
      <name>theArguments</name>
      <anchor>v2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; Main &gt;</type>
      <name>initMain</name>
      <anchor>v3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Main, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Main_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>int</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Main &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Main_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Main &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MultiEventGenerator</name>
    <filename>classThePEG_1_1MultiEventGenerator.html</filename>
    <base>ThePEG::EventGenerator</base>
    <member kind="function">
      <type></type>
      <name>MultiEventGenerator</name>
      <anchor>z1009_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultiEventGenerator</name>
      <anchor>z1009_1</anchor>
      <arglist>(const MultiEventGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MultiEventGenerator</name>
      <anchor>z1009_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1015_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1015_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doGo</name>
      <anchor>z1011_0</anchor>
      <arglist>(long next, long maxevent)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>string</type>
      <name>addInterface</name>
      <anchor>z1013_0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>string</type>
      <name>removeInterface</name>
      <anchor>z1013_1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1017_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1017_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1019_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1019_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z1019_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1019_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1019_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1019_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MultiEventGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MultiEventGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>IVector</type>
      <name>theObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringVector</type>
      <name>theInterfaces</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringVector</type>
      <name>thePosArgs</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; StringVector &gt;</type>
      <name>theValues</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MultiEventGenerator &gt;</type>
      <name>initMultiEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MultiEventGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MultiEventGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MultiEventGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MultiEventGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MultiEventGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RandomGenerator</name>
    <filename>classThePEG_1_1RandomGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>RndVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RndVector::size_type</type>
      <name>size_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandomGenerator</name>
      <anchor>z1021_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandomGenerator</name>
      <anchor>z1021_1</anchor>
      <arglist>(const RandomGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RandomGenerator</name>
      <anchor>z1021_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual RandomEngine &amp;</type>
      <name>randomGenerator</name>
      <anchor>z1023_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setSeed</name>
      <anchor>z1023_1</anchor>
      <arglist>(long seed)=0</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z1025_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RndVector</type>
      <name>rndvec</name>
      <anchor>z1025_1</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>z1025_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>operator()</name>
      <anchor>z1025_3</anchor>
      <arglist>(long N)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>z1025_4</anchor>
      <arglist>(double p=0.5)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>z1025_5</anchor>
      <arglist>(double p1, double p2)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rndsign</name>
      <anchor>z1025_6</anchor>
      <arglist>(double p1, double p2, double p3)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd2</name>
      <anchor>z1025_7</anchor>
      <arglist>(double p0, double p1)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd3</name>
      <anchor>z1025_8</anchor>
      <arglist>(double p0, double p1, double p2)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd4</name>
      <anchor>z1025_9</anchor>
      <arglist>(double p0, double p1, double p2, double p3)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>push_back</name>
      <anchor>z1027_0</anchor>
      <arglist>(double r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>pop_back</name>
      <anchor>z1027_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flush</name>
      <anchor>z1027_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rnd</name>
      <anchor>z1027_3</anchor>
      <arglist>(OutputIterator, size_type n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1029_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1029_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setSize</name>
      <anchor>d0</anchor>
      <arglist>(size_type newSize)</arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual void</type>
      <name>getFlatNumbers</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RandomGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const RandomGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RndVector</type>
      <name>theNumbers</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RndVector::iterator</type>
      <name>nextNumber</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theSize</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theSeed</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; RandomGenerator &gt;</type>
      <name>initRandomGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; RandomGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01RandomGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; RandomGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01RandomGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; RandomGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Repository</name>
    <filename>classThePEG_1_1Repository.html</filename>
    <base>ThePEG::BaseRepository</base>
    <member kind="typedef">
      <type>map&lt; string, EGPtr &gt;</type>
      <name>GeneratorMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z1031_0</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z1031_1</anchor>
      <arglist>(IBPtr, string newName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>defaultParticle</name>
      <anchor>z1033_0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>defaultParticle</name>
      <anchor>z1033_1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tPDPtr</type>
      <name>findParticle</name>
      <anchor>z1033_2</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ParticleDataSet &amp;</type>
      <name>allParticles</name>
      <anchor>z1033_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const MatcherSet &amp;</type>
      <name>allMatchers</name>
      <anchor>z1033_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tPMPtr</type>
      <name>findMatcher</name>
      <anchor>z1033_5</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tDMPtr</type>
      <name>findDecayMode</name>
      <anchor>z1033_6</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>copyParticle</name>
      <anchor>z1033_7</anchor>
      <arglist>(tPDPtr, string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>EGPtr</type>
      <name>makeRun</name>
      <anchor>z1035_0</anchor>
      <arglist>(tEGPtr eg, string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>saveRun</name>
      <anchor>z1035_1</anchor>
      <arglist>(string EGname, string name, string filename)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>load</name>
      <anchor>z1037_0</anchor>
      <arglist>(string filename)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>save</name>
      <anchor>z1037_1</anchor>
      <arglist>(string filename)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>save</name>
      <anchor>z1037_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>stats</name>
      <anchor>z1037_3</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>read</name>
      <anchor>z1039_0</anchor>
      <arglist>(istream &amp;is, ostream &amp;os, string prompt=&quot;&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>exec</name>
      <anchor>z1039_1</anchor>
      <arglist>(string cmd, ostream &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ParticleMap &amp;</type>
      <name>defaultParticles</name>
      <anchor>z1041_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ParticleDataSet &amp;</type>
      <name>particles</name>
      <anchor>z1041_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>MatcherSet &amp;</type>
      <name>matchers</name>
      <anchor>z1041_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DecayModeSet &amp;</type>
      <name>decayModes</name>
      <anchor>z1041_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>GeneratorMap &amp;</type>
      <name>generators</name>
      <anchor>z1041_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>string &amp;</type>
      <name>currentFileName</name>
      <anchor>z1041_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>registerParticle</name>
      <anchor>h0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>registerMatcher</name>
      <anchor>h1</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>registerDecayMode</name>
      <anchor>h2</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardRandom</name>
    <filename>classThePEG_1_1StandardRandom.html</filename>
    <base>ThePEG::RandomGenerator</base>
    <member kind="function" virtualness="virtual">
      <type>virtual RandomEngine &amp;</type>
      <name>randomGenerator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setSeed</name>
      <anchor>a1</anchor>
      <arglist>(long seed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardRandom</name>
      <anchor>z1043_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardRandom</name>
      <anchor>z1043_1</anchor>
      <arglist>(const StandardRandom &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StandardRandom</name>
      <anchor>z1043_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1047_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1047_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1045_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1045_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1045_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1045_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1045_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1049_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1049_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardRandom &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardRandom &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>JamesRandom</type>
      <name>theRandomGenerator</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardRandom &gt;</type>
      <name>initStandardRandom</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardRandom, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardRandom_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RandomGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardRandom &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardRandom_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardRandom &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Strategy</name>
    <filename>classThePEG_1_1Strategy.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>Strategy</name>
      <anchor>z1051_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Strategy</name>
      <anchor>z1051_1</anchor>
      <arglist>(const Strategy &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Strategy</name>
      <anchor>z1051_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ParticleMap &amp;</type>
      <name>particles</name>
      <anchor>z1053_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; IPtr &gt; &amp;</type>
      <name>defaultObjects</name>
      <anchor>z1053_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1055_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1055_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1057_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1057_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1059_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1059_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1059_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleMap &amp;</type>
      <name>particles</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setLocalParticles</name>
      <anchor>d1</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insLocalParticles</name>
      <anchor>d2</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delLocalParticles</name>
      <anchor>d3</anchor>
      <arglist>(int place)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; PDPtr &gt;</type>
      <name>getLocalParticles</name>
      <anchor>d4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>Strategy &amp;</type>
      <name>operator=</name>
      <anchor>d5</anchor>
      <arglist>(const Strategy &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>theParticles</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; IPtr &gt;</type>
      <name>theDefaultObjects</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Strategy &gt;</type>
      <name>initStrategy</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Strategy, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Strategy_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Strategy &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Strategy_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Strategy &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ThePEGStrategy</name>
    <filename>classThePEG_1_1ThePEGStrategy.html</filename>
    <base>ThePEG::Strategy</base>
    <member kind="function">
      <type></type>
      <name>ThePEGStrategy</name>
      <anchor>z1061_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ThePEGStrategy</name>
      <anchor>z1061_1</anchor>
      <arglist>(const ThePEGStrategy &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ThePEGStrategy</name>
      <anchor>z1061_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1063_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1063_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1065_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1065_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1065_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1065_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1065_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ThePEGStrategy &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ThePEGStrategy &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; ThePEGStrategy &gt;</type>
      <name>initThePEGStrategy</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEGStrategy, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEGStrategy_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Strategy</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEGStrategy &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEGStrategy_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEGStrategy &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::UseRandom</name>
    <filename>classThePEG_1_1UseRandom.html</filename>
    <member kind="function">
      <type></type>
      <name>UseRandom</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UseRandom</name>
      <anchor>a1</anchor>
      <arglist>(const UseRandom &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UseRandom</name>
      <anchor>a2</anchor>
      <arglist>(const RanGenPtr &amp;r)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~UseRandom</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RandomGenerator &amp;</type>
      <name>current</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RandomEngine *</type>
      <name>currentEngine</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RandomGenerator::RndVector</type>
      <name>rndvec</name>
      <anchor>e3</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e4</anchor>
      <arglist>(double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e5</anchor>
      <arglist>(double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>e6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>e7</anchor>
      <arglist>(double p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>e8</anchor>
      <arglist>(double p1, double p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rndsign</name>
      <anchor>e9</anchor>
      <arglist>(double p1, double p2, double p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rnd2</name>
      <anchor>e10</anchor>
      <arglist>(double p0, double p1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rnd3</name>
      <anchor>e11</anchor>
      <arglist>(double p0, double p1, double p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rnd4</name>
      <anchor>e12</anchor>
      <arglist>(double p0, double p1, double p2, double p3)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>irnd</name>
      <anchor>e13</anchor>
      <arglist>(long xu=2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>irnd</name>
      <anchor>e14</anchor>
      <arglist>(long xl, long xu)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>UseRandom &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const UseRandom &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>randomPushed</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; RanGenPtr &gt;</type>
      <name>theRandomStack</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AlphaEMBase</name>
    <filename>classThePEG_1_1AlphaEMBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>value</name>
      <anchor>a0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;sm) const =0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AlphaEMBase</name>
      <anchor>z1067_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AlphaEMBase</name>
      <anchor>z1067_1</anchor>
      <arglist>(const AlphaEMBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~AlphaEMBase</name>
      <anchor>z1067_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>AlphaEMBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const AlphaEMBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; AlphaEMBase &gt;</type>
      <name>initAlphaEMBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; AlphaEMBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01AlphaEMBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; AlphaEMBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01AlphaEMBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; AlphaEMBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AlphaSBase</name>
    <filename>classThePEG_1_1AlphaSBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>AlphaSBase</name>
      <anchor>z1069_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AlphaSBase</name>
      <anchor>z1069_1</anchor>
      <arglist>(const AlphaSBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~AlphaSBase</name>
      <anchor>z1069_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>value</name>
      <anchor>z1071_0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;sm) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual vector&lt; Energy2 &gt;</type>
      <name>flavourThresholds</name>
      <anchor>z1071_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual vector&lt; Energy &gt;</type>
      <name>LambdaQCDs</name>
      <anchor>z1071_2</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>Nf</name>
      <anchor>z1073_0</anchor>
      <arglist>(Energy2 scale) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1073_1</anchor>
      <arglist>(unsigned int nflav) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1073_2</anchor>
      <arglist>(Energy2 scale) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1075_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1075_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1077_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1077_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1077_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>AlphaSBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const AlphaSBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Energy2 &gt;</type>
      <name>theFlavourThresholds</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Energy &gt;</type>
      <name>theLambdaQCDs</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; AlphaSBase &gt;</type>
      <name>initAlphaSBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; AlphaSBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01AlphaSBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; AlphaSBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01AlphaSBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; AlphaSBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CKMBase</name>
    <filename>classThePEG_1_1CKMBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function" virtualness="pure">
      <type>virtual vector&lt; vector&lt; double &gt; &gt;</type>
      <name>getMatrix</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int nf) const =0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CKMBase</name>
      <anchor>z1079_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CKMBase</name>
      <anchor>z1079_1</anchor>
      <arglist>(const CKMBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CKMBase</name>
      <anchor>z1079_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CKMBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const CKMBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; CKMBase &gt;</type>
      <name>initCKMBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; CKMBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01CKMBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; CKMBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01CKMBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; CKMBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::O1AlphaS</name>
    <filename>classThePEG_1_1O1AlphaS.html</filename>
    <base>ThePEG::AlphaSBase</base>
    <member kind="function">
      <type>unsigned int</type>
      <name>getMaxFlav</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>O1AlphaS</name>
      <anchor>z1081_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>O1AlphaS</name>
      <anchor>z1081_1</anchor>
      <arglist>(const O1AlphaS &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~O1AlphaS</name>
      <anchor>z1081_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>value</name>
      <anchor>z1083_0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; Energy2 &gt;</type>
      <name>flavourThresholds</name>
      <anchor>z1083_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; Energy &gt;</type>
      <name>LambdaQCDs</name>
      <anchor>z1083_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1085_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1085_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1087_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1087_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1089_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1089_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1089_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1089_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1089_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>O1AlphaS &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const O1AlphaS &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theLambdaQCD</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theLambdaFlavour</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theMaxFlav</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; O1AlphaS &gt;</type>
      <name>initO1AlphaS</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; O1AlphaS, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01O1AlphaS_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>AlphaSBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; O1AlphaS &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01O1AlphaS_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; O1AlphaS &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SimpleAlphaEM</name>
    <filename>classThePEG_1_1SimpleAlphaEM.html</filename>
    <base>ThePEG::AlphaEMBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>value</name>
      <anchor>a0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleAlphaEM</name>
      <anchor>z1091_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleAlphaEM</name>
      <anchor>z1091_1</anchor>
      <arglist>(const SimpleAlphaEM &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SimpleAlphaEM</name>
      <anchor>z1091_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1093_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1093_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1095_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1095_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1095_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SimpleAlphaEM &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SimpleAlphaEM &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; SimpleAlphaEM &gt;</type>
      <name>initSimpleAlphaEM</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SimpleAlphaEM, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SimpleAlphaEM_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>AlphaEMBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SimpleAlphaEM &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SimpleAlphaEM_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SimpleAlphaEM &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardCKM</name>
    <filename>classThePEG_1_1StandardCKM.html</filename>
    <base>ThePEG::CKMBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; vector&lt; double &gt; &gt;</type>
      <name>getMatrix</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int nFamilies) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardCKM</name>
      <anchor>z1097_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardCKM</name>
      <anchor>z1097_1</anchor>
      <arglist>(const StandardCKM &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StandardCKM</name>
      <anchor>z1097_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1099_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1099_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1101_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1101_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1103_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1103_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1103_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1103_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1103_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardCKM &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardCKM &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theta12</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theta13</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theta23</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>delta</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardCKM &gt;</type>
      <name>initStandardCKM</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardCKM, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardCKM_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>CKMBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardCKM &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardCKM_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardCKM &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardModelBase</name>
    <filename>classThePEG_1_1StandardModelBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>unsigned int</type>
      <name>families</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardModelBase</name>
      <anchor>z1105_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardModelBase</name>
      <anchor>z1105_1</anchor>
      <arglist>(const StandardModelBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StandardModelBase</name>
      <anchor>z1105_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaEM</name>
      <anchor>z1107_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaEM</name>
      <anchor>z1107_1</anchor>
      <arglist>(Energy2 scale) const </arglist>
    </member>
    <member kind="function">
      <type>tAEMPtr</type>
      <name>alphaEMPtr</name>
      <anchor>z1107_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sin2ThetaW</name>
      <anchor>z1107_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>enu</name>
      <anchor>z1107_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ee</name>
      <anchor>z1107_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eu</name>
      <anchor>z1107_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ed</name>
      <anchor>z1107_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>vnu</name>
      <anchor>z1107_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ve</name>
      <anchor>z1107_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>vu</name>
      <anchor>z1107_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>vd</name>
      <anchor>z1107_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>anu</name>
      <anchor>z1107_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ae</name>
      <anchor>z1107_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>au</name>
      <anchor>z1107_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ad</name>
      <anchor>z1107_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>CKM</name>
      <anchor>z1107_16</anchor>
      <arglist>(unsigned int uf, unsigned int df) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>CKM</name>
      <anchor>z1107_17</anchor>
      <arglist>(const ParticleData &amp;uType, const ParticleData &amp;dType) const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>Nc</name>
      <anchor>z1109_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>Nf</name>
      <anchor>z1109_1</anchor>
      <arglist>(Energy2 scale) const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaS</name>
      <anchor>z1109_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaS</name>
      <anchor>z1109_3</anchor>
      <arglist>(Energy2 scale) const </arglist>
    </member>
    <member kind="function">
      <type>tASPtr</type>
      <name>alphaSPtr</name>
      <anchor>z1109_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1109_5</anchor>
      <arglist>(unsigned int nflav) const </arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1109_6</anchor>
      <arglist>(Energy2 scale) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1111_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1111_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1113_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1113_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1115_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1115_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1115_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1115_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1115_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaEMBase &gt;::pointer</type>
      <name>AEMPtr</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaSBase &gt;::pointer</type>
      <name>ASPtr</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; CKMBase &gt;::pointer</type>
      <name>CKMPtr</name>
      <anchor>y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaEMBase &gt;::transient_pointer</type>
      <name>tAEMPtr</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaSBase &gt;::transient_pointer</type>
      <name>tASPtr</name>
      <anchor>y4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; CKMBase &gt;::transient_pointer</type>
      <name>tCKMPtr</name>
      <anchor>y5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardModelBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardModelBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theFamilies</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAlphaEM</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AEMPtr</type>
      <name>theRunningAlphaEM</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSin2ThetaW</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEnu</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEe</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEu</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEd</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVnu</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVe</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVu</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVd</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAnu</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAe</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAu</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAd</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>recalculateEW</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CKMPtr</type>
      <name>theCKM</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; vector&lt; double &gt; &gt;</type>
      <name>theCKM2Matrix</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNc</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAlphaS</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ASPtr</type>
      <name>theRunningAlphaS</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardModelBase &gt;</type>
      <name>initStandardModelBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardModelBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardModelBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardModelBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardModelBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardModelBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CFileLineReader</name>
    <filename>classThePEG_1_1CFileLineReader.html</filename>
    <member kind="function">
      <type>bool</type>
      <name>readline</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>getline</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>FILE *</type>
      <name>cfile</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator void *</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>skip</name>
      <anchor>a5</anchor>
      <arglist>(char c)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>find</name>
      <anchor>a6</anchor>
      <arglist>(string str) const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>z1117_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>z1117_1</anchor>
      <arglist>(FILE *f, int len=defsize)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>z1117_2</anchor>
      <arglist>(string filename, int len=defsize)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CFileLineReader</name>
      <anchor>z1117_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>open</name>
      <anchor>z1119_0</anchor>
      <arglist>(FILE *f)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>open</name>
      <anchor>z1119_1</anchor>
      <arglist>(string filename)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>close</name>
      <anchor>z1119_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>char</type>
      <name>getc</name>
      <anchor>z1121_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_1</anchor>
      <arglist>(long &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_2</anchor>
      <arglist>(int &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_3</anchor>
      <arglist>(unsigned long &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_4</anchor>
      <arglist>(unsigned int &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_5</anchor>
      <arglist>(double &amp;d)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_6</anchor>
      <arglist>(float &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1121_7</anchor>
      <arglist>(std::string &amp;s)</arglist>
    </member>
    <member kind="enumeration">
      <name>StreamType</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown</name>
      <anchor>y3y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>plainfile</name>
      <anchor>y3y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pipe</name>
      <anchor>y3y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>d0</anchor>
      <arglist>(const CFileLineReader &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CFileLineReader &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const CFileLineReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FILE *</type>
      <name>file</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>bufflen</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char *</type>
      <name>buff</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char *</type>
      <name>pos</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>bad</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StreamType</type>
      <name>type</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const int</type>
      <name>defsize</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDescriptionBase</name>
    <filename>classThePEG_1_1ClassDescriptionBase.html</filename>
    <base>ThePEG::Named</base>
    <member kind="typedef">
      <type>vector&lt; const ClassDescriptionBase * &gt;</type>
      <name>DescriptionVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDescriptionBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const type_info &amp;</type>
      <name>info</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>version</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>library</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>check</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const DescriptionVector &amp;</type>
      <name>descriptions</name>
      <anchor>a5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>a6</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a7</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a8</anchor>
      <arglist>(tcBPtr b, PersistentOStream &amp;os) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a9</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is, int oldVersion) const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isA</name>
      <anchor>a10</anchor>
      <arglist>(const ClassDescriptionBase &amp;base) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ClassDescriptionBase</name>
      <anchor>b0</anchor>
      <arglist>(string newName, const type_info &amp;newInfo, int newVersion, string newLibrary)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>baseClasses</name>
      <anchor>b1</anchor>
      <arglist>(DescriptionVector::iterator first, DescriptionVector::iterator last)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theVersion</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theLibrary</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const type_info &amp;</type>
      <name>theInfo</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DescriptionVector</type>
      <name>theBaseClasses</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>done</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDescriptionTBase</name>
    <filename>classThePEG_1_1ClassDescriptionTBase.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ClassDescriptionTBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDescriptionTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AbstractClassDescription</name>
    <filename>classThePEG_1_1AbstractClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr b, PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is, int oldVersion) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDescription</name>
    <filename>classThePEG_1_1ClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr b, PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is, int oldVersion) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::NoPIOClassDescription</name>
    <filename>classThePEG_1_1NoPIOClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr, PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr, PersistentIStream &amp;, int) const </arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AbstractNoPIOClassDescription</name>
    <filename>classThePEG_1_1AbstractNoPIOClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr, PersistentOStream &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr, PersistentIStream &amp;, int) const </arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassDescriptionHelper</name>
    <filename>structThePEG_1_1ClassDescriptionHelper.html</filename>
    <templarg>T</templarg>
    <templarg>IBase</templarg>
    <templarg>B</templarg>
    <member kind="function" static="yes">
      <type>void</type>
      <name>addBases</name>
      <anchor>e0</anchor>
      <arglist>(vector&lt; const ClassDescriptionBase * &gt; &amp;c)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassDescriptionHelper&lt; T, IBase, int &gt;</name>
    <filename>structThePEG_1_1ClassDescriptionHelper_3_01T_00_01IBase_00_01int_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>IBase</templarg>
    <member kind="function" static="yes">
      <type>void</type>
      <name>addBases</name>
      <anchor>e0</anchor>
      <arglist>(vector&lt; const ClassDescriptionBase * &gt; &amp;c)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraitsType</name>
    <filename>structThePEG_1_1ClassTraitsType.html</filename>
    <base>ThePEG::TraitsType</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraitsBase</name>
    <filename>structThePEG_1_1ClassTraitsBase.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>TPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::const_pointer</type>
      <name>cTPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_pointer</type>
      <name>tTPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_const_pointer</type>
      <name>tcTPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>version</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>output</name>
      <anchor>e4</anchor>
      <arglist>(tcTPtr t, PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>input</name>
      <anchor>e5</anchor>
      <arglist>(tTPtr t, PersistentIStream &amp;is, int oldVersion)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>cast</name>
      <anchor>e6</anchor>
      <arglist>(BPtr b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>cTPtr</type>
      <name>cast</name>
      <anchor>e7</anchor>
      <arglist>(cBPtr b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tTPtr</type>
      <name>cast</name>
      <anchor>e8</anchor>
      <arglist>(tBPtr b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tcTPtr</type>
      <name>cast</name>
      <anchor>e9</anchor>
      <arglist>(tcBPtr b)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits</name>
    <filename>structThePEG_1_1ClassTraits.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsBase</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait</name>
    <filename>structThePEG_1_1BaseClassTrait.html</filename>
    <templarg>Derived</templarg>
    <templarg>BaseN</templarg>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>int</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CompSelector</name>
    <filename>classThePEG_1_1CompSelector.html</filename>
    <templarg>T</templarg>
    <templarg>WeightType</templarg>
    <member kind="function">
      <type></type>
      <name>CompSelector</name>
      <anchor>z1123_0</anchor>
      <arglist>(double newMargin=1.1)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CompSelector</name>
      <anchor>z1123_1</anchor>
      <arglist>(const CompSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CompSelector</name>
      <anchor>z1123_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>CompSelector &amp;</type>
      <name>operator=</name>
      <anchor>z1123_3</anchor>
      <arglist>(const CompSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>insert</name>
      <anchor>z1125_0</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>z1125_1</anchor>
      <arglist>(RNDGEN &amp;rnd)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>reweight</name>
      <anchor>z1125_2</anchor>
      <arglist>(double &amp;weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z1125_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>z1125_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>margin</name>
      <anchor>z1125_5</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>compensating</name>
      <anchor>z1127_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>compleft</name>
      <anchor>z1127_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>sum</name>
      <anchor>z1127_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>margin</name>
      <anchor>z1127_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>z1129_0</anchor>
      <arglist>(OStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>z1129_1</anchor>
      <arglist>(IStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Selector&lt; T, WeightType &gt;</type>
      <name>selector</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>N</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>last</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMargin</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Level &gt;</type>
      <name>levels</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CompSelector::Level</name>
    <filename>structThePEG_1_1CompSelector_1_1Level.html</filename>
    <member kind="variable">
      <type>long</type>
      <name>lastN</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>weight</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CompSelector::Level</name>
    <filename>structThePEG_1_1CompSelector_1_1Level.html</filename>
    <member kind="variable">
      <type>long</type>
      <name>lastN</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>weight</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Debug</name>
    <filename>classThePEG_1_1Debug.html</filename>
    <member kind="enumeration">
      <name>Levels</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>noDebug</name>
      <anchor>w4w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>printSomeEvents</name>
      <anchor>w4w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>printEveryEvent</name>
      <anchor>w4w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>full</name>
      <anchor>w4w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>debugItem</name>
      <anchor>e0</anchor>
      <arglist>(int item, bool on)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setDebug</name>
      <anchor>e1</anchor>
      <arglist>(int ilev)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>debugItem</name>
      <anchor>e2</anchor>
      <arglist>(int item)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuErrors</name>
      <anchor>z1131_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuOverflow</name>
      <anchor>z1131_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuUnderflow</name>
      <anchor>z1131_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuDivZero</name>
      <anchor>z1131_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuDenorm</name>
      <anchor>z1131_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuInvalid</name>
      <anchor>z1131_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuErrors</name>
      <anchor>z1131_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuOverflow</name>
      <anchor>z1131_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuUnderflow</name>
      <anchor>z1131_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuDivZero</name>
      <anchor>z1131_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuDenorm</name>
      <anchor>z1131_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuInvalid</name>
      <anchor>z1131_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>int</type>
      <name>level</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>std::vector&lt; bool &gt;</type>
      <name>debugItems</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DescriptionList</name>
    <filename>classThePEG_1_1DescriptionList.html</filename>
    <member kind="typedef">
      <type>map&lt; const type_info *, ClassDescriptionBase * &gt;</type>
      <name>DescriptionMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, ClassDescriptionBase * &gt;</type>
      <name>StringMap</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>e0</anchor>
      <arglist>(ClassDescriptionBase &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ClassDescriptionBase *</type>
      <name>find</name>
      <anchor>e1</anchor>
      <arglist>(const type_info &amp;ti)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ClassDescriptionBase *</type>
      <name>find</name>
      <anchor>e2</anchor>
      <arglist>(const string &amp;name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>printHierarchies</name>
      <anchor>e3</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>hookup</name>
      <anchor>f0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>insert</name>
      <anchor>f1</anchor>
      <arglist>(ClassDescriptionBase &amp;pb)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DescriptionMap &amp;</type>
      <name>descriptionMap</name>
      <anchor>f2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>StringMap &amp;</type>
      <name>stringMap</name>
      <anchor>f3</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Direction</name>
    <filename>classThePEG_1_1Direction.html</filename>
    <templarg>I</templarg>
    <member kind="enumeration">
      <name>Dir</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Neg</name>
      <anchor>w5w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Negative</name>
      <anchor>w5w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Undefined</name>
      <anchor>w5w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Pos</name>
      <anchor>w5w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Positive</name>
      <anchor>w5w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Direction</name>
      <anchor>a0</anchor>
      <arglist>(Dir newDirection)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Direction</name>
      <anchor>a1</anchor>
      <arglist>(double rnd)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Direction</name>
      <anchor>a2</anchor>
      <arglist>(bool p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Direction</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set</name>
      <anchor>e0</anchor>
      <arglist>(Dir newDirection)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>reverse</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>pos</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>neg</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Dir</type>
      <name>dir</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Direction</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Direction</name>
      <anchor>d1</anchor>
      <arglist>(const Direction &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Direction &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const Direction &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>Dir</type>
      <name>theDirection</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultipleDirectionException</name>
    <filename>structThePEG_1_1MultipleDirectionException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>MultipleDirectionException</name>
      <anchor>a0</anchor>
      <arglist>(int)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::UndefinedDirectionException</name>
    <filename>structThePEG_1_1UndefinedDirectionException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>UndefinedDirectionException</name>
      <anchor>a0</anchor>
      <arglist>(int)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DIterator</name>
    <filename>classThePEG_1_1DIterator.html</filename>
    <templarg>BaseIterator</templarg>
    <member kind="typedef">
      <type>std::iterator_traits&lt; BaseIterator &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Traits::iterator_category</type>
      <name>iterator_category</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Traits::difference_type</type>
      <name>difference_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Traits::value_type</type>
      <name>PtrType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::iterator_traits&lt; PtrType &gt;</type>
      <name>PtrTraits</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtrTraits::value_type</type>
      <name>value_type</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtrTraits::pointer</type>
      <name>pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtrTraits::reference</type>
      <name>reference</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DIterator</name>
      <anchor>a0</anchor>
      <arglist>(const BaseIterator &amp;in)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DIterator</name>
      <anchor>a1</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator *</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>operator-&gt;</name>
      <anchor>a3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const BaseIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator[]</name>
      <anchor>a6</anchor>
      <arglist>(difference_type n)</arglist>
    </member>
    <member kind="function">
      <type>difference_type</type>
      <name>operator-</name>
      <anchor>a7</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator++</name>
      <anchor>z1133_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator++</name>
      <anchor>z1133_1</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator--</name>
      <anchor>z1133_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator--</name>
      <anchor>z1133_3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator+=</name>
      <anchor>z1133_4</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator+</name>
      <anchor>z1133_5</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator-=</name>
      <anchor>z1133_6</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator-</name>
      <anchor>z1133_7</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z1135_0</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>z1135_1</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>z1135_2</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;</name>
      <anchor>z1135_3</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;=</name>
      <anchor>z1135_4</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;=</name>
      <anchor>z1135_5</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z1135_6</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>z1135_7</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>z1135_8</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;</name>
      <anchor>z1135_9</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;=</name>
      <anchor>z1135_10</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;=</name>
      <anchor>z1135_11</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>DIterator</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BaseIterator</type>
      <name>i</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DynamicLoader</name>
    <filename>classThePEG_1_1DynamicLoader.html</filename>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>loadcmd</name>
      <anchor>e0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>load</name>
      <anchor>e1</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>appendPath</name>
      <anchor>e2</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>prependPath</name>
      <anchor>e3</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>dlname</name>
      <anchor>e4</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>dlnameversion</name>
      <anchor>e5</anchor>
      <arglist>(string libs)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>string</type>
      <name>lastErrorMessage</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>vector&lt; string &gt;</type>
      <name>defaultPaths</name>
      <anchor>h0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; string &gt;</type>
      <name>paths</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>map&lt; string, string &gt;</type>
      <name>versionMap</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::OEnum</name>
    <filename>structThePEG_1_1OEnum.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>OEnum</name>
      <anchor>a0</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OEnum</name>
      <anchor>a1</anchor>
      <arglist>(const OEnum &amp;oe)</arglist>
    </member>
    <member kind="variable">
      <type>const T &amp;</type>
      <name>theT</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IEnum</name>
    <filename>structThePEG_1_1IEnum.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>IEnum</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IEnum</name>
      <anchor>a1</anchor>
      <arglist>(const IEnum &amp;ie)</arglist>
    </member>
    <member kind="variable">
      <type>T &amp;</type>
      <name>theT</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Exception</name>
    <filename>classThePEG_1_1Exception.html</filename>
    <member kind="enumeration">
      <name>Severity</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown</name>
      <anchor>w7w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>info</name>
      <anchor>w7w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>warning</name>
      <anchor>w7w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eventerror</name>
      <anchor>w7w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>runerror</name>
      <anchor>w7w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>maybeabort</name>
      <anchor>w7w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>abortnow</name>
      <anchor>w7w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a0</anchor>
      <arglist>(const string &amp;str, Severity sev)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a2</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Exception</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Exception &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a5</anchor>
      <arglist>(const Exception &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a6</anchor>
      <arglist>(const Exception &amp;) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual const char *</type>
      <name>what</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>message</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>writeMessage</name>
      <anchor>a9</anchor>
      <arglist>(ostream &amp;os=*errstream) const </arglist>
    </member>
    <member kind="function">
      <type>Severity</type>
      <name>severity</name>
      <anchor>a10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>handle</name>
      <anchor>a11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Exception &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a12</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Exception &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a13</anchor>
      <arglist>(Severity sev)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>severity</name>
      <anchor>b0</anchor>
      <arglist>(Severity)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ostringstream</type>
      <name>theMessage</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>handled</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Severity</type>
      <name>theSeverity</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ostream *</type>
      <name>errstream</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FixedSizeAllocator</name>
    <filename>classThePEG_1_1FixedSizeAllocator.html</filename>
    <templarg>Size</templarg>
    <templarg>ChunkSize</templarg>
    <member kind="function" static="yes">
      <type>void *</type>
      <name>allocate</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>deallocate</name>
      <anchor>e1</anchor>
      <arglist>(void *)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>std::vector&lt; void * &gt;</type>
      <name>FreeStack</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>grow</name>
      <anchor>h0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void *</type>
      <name>newallocate</name>
      <anchor>h1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ChunkStack</type>
      <name>chunkstack</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>FreeStack</type>
      <name>freestack</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>size_t</type>
      <name>last</name>
      <anchor>v2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FixedSizeAllocator::ChunkStack</name>
    <filename>structThePEG_1_1FixedSizeAllocator_1_1ChunkStack.html</filename>
    <member kind="typedef">
      <type>vector&lt; char * &gt;</type>
      <name>Stack</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ChunkStack</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>Stack</type>
      <name>s</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FixedSizeAllocator::ChunkStack</name>
    <filename>structThePEG_1_1FixedSizeAllocator_1_1ChunkStack.html</filename>
    <member kind="typedef">
      <type>vector&lt; char * &gt;</type>
      <name>Stack</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ChunkStack</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>Stack</type>
      <name>s</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SizeOf8</name>
    <filename>structThePEG_1_1SizeOf8.html</filename>
    <templarg>T</templarg>
    <member kind="variable" static="yes">
      <type>const size_t</type>
      <name>size</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FixedAllocator</name>
    <filename>structThePEG_1_1FixedAllocator.html</filename>
    <templarg>T</templarg>
    <templarg>ChunkSize</templarg>
    <base>ThePEG::FixedSizeAllocator&lt; SizeOf8&lt; T &gt;::size, ChunkSize &gt;</base>
    <member kind="typedef">
      <type>FixedSizeAllocator&lt; SizeOf8&lt; T &gt;::size, ChunkSize &gt;</type>
      <name>BaseType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>allocate</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Allocator</name>
    <filename>classThePEG_1_1Allocator.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>std::allocator&lt; T &gt;</type>
      <name>BaseAllocator</name>
      <anchor>z1137_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::size_type</type>
      <name>size_type</name>
      <anchor>z1137_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::difference_type</type>
      <name>difference_type</name>
      <anchor>z1137_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::pointer</type>
      <name>pointer</name>
      <anchor>z1137_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::const_pointer</type>
      <name>const_pointer</name>
      <anchor>z1137_4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::reference</type>
      <name>reference</name>
      <anchor>z1137_5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::const_reference</type>
      <name>const_reference</name>
      <anchor>z1137_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::value_type</type>
      <name>value_type</name>
      <anchor>z1137_7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Allocator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Allocator</name>
      <anchor>a1</anchor>
      <arglist>(const Allocator &amp;x)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Allocator</name>
      <anchor>a2</anchor>
      <arglist>(const Allocator&lt; T1 &gt; &amp;x)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Allocator</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>address</name>
      <anchor>a4</anchor>
      <arglist>(reference x) const </arglist>
    </member>
    <member kind="function">
      <type>const_pointer</type>
      <name>address</name>
      <anchor>a5</anchor>
      <arglist>(const_reference x) const </arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>allocate</name>
      <anchor>a6</anchor>
      <arglist>(size_type n, const void *vp=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deallocate</name>
      <anchor>a7</anchor>
      <arglist>(pointer p, size_type n)</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>max_size</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>construct</name>
      <anchor>a9</anchor>
      <arglist>(pointer p, const T &amp;val)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>destroy</name>
      <anchor>a10</anchor>
      <arglist>(pointer p)</arglist>
    </member>
    <member kind="variable">
      <type>BaseAllocator</type>
      <name>fallback</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Allocator::rebind</name>
    <filename>structThePEG_1_1Allocator_1_1rebind.html</filename>
    <templarg>T1</templarg>
    <member kind="typedef">
      <type>Allocator&lt; T1 &gt;</type>
      <name>other</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Allocator::rebind</name>
    <filename>structThePEG_1_1Allocator_1_1rebind.html</filename>
    <templarg>T1</templarg>
    <member kind="typedef">
      <type>Allocator&lt; T1 &gt;</type>
      <name>other</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HoldFlag</name>
    <filename>classThePEG_1_1HoldFlag.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;newFlag, const T &amp;holdFlag)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a1</anchor>
      <arglist>(T &amp;newFlag, const T &amp;holdFlag, const T &amp;finalFlag)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HoldFlag</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d1</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HoldFlag &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T &amp;</type>
      <name>theFlag</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>oldFlag</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HoldFlag&lt; bool &gt;</name>
    <filename>classThePEG_1_1HoldFlag_3_01bool_01_4.html</filename>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;newFlag, bool holdFlag=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a1</anchor>
      <arglist>(bool &amp;newFlag, bool holdFlag, bool finalFlag)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HoldFlag</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d1</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HoldFlag &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool &amp;</type>
      <name>theFlag</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>oldFlag</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Interval</name>
    <filename>classThePEG_1_1Interval.html</filename>
    <templarg>T</templarg>
    <templarg>CMP</templarg>
    <member kind="function">
      <type></type>
      <name>Interval</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Interval</name>
      <anchor>a1</anchor>
      <arglist>(T dn, T up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Interval</name>
      <anchor>a2</anchor>
      <arglist>(const Interval &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>const Interval &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const Interval &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a4</anchor>
      <arglist>(const Interval &amp;i) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a5</anchor>
      <arglist>(const Interval &amp;i) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>check</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a7</anchor>
      <arglist>(T x) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>includes</name>
      <anchor>a8</anchor>
      <arglist>(T x) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>includes</name>
      <anchor>a9</anchor>
      <arglist>(const Interval&lt; T, CMP &gt; &amp;i) const </arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>chopUpper</name>
      <anchor>a10</anchor>
      <arglist>(T x)</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>chopLower</name>
      <anchor>a11</anchor>
      <arglist>(T x)</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>overlap</name>
      <anchor>a12</anchor>
      <arglist>(const Interval &amp;i) const </arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>sum</name>
      <anchor>a13</anchor>
      <arglist>(const Interval &amp;i) const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>upper</name>
      <anchor>a14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>lower</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>upper</name>
      <anchor>a16</anchor>
      <arglist>(T up)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lower</name>
      <anchor>a17</anchor>
      <arglist>(T dn)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>checkAll</name>
      <anchor>e1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>std::vector&lt; Interval&lt; T, CMP &gt; &gt;</type>
      <name>split</name>
      <anchor>e2</anchor>
      <arglist>(Interval&lt; T, CMP &gt;, T x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>std::vector&lt; Interval&lt; T, CMP &gt; &gt;</type>
      <name>split</name>
      <anchor>e3</anchor>
      <arglist>(Interval&lt; T, CMP &gt;, Iterator first, Iterator last)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::pair&lt; T, T &gt;</type>
      <name>theLimits</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>CMP</type>
      <name>cmp</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Level</name>
    <filename>classThePEG_1_1Level.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>Level</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;newLevel)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Level</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Level</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Level</name>
      <anchor>d1</anchor>
      <arglist>(const Level &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Level &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const Level &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T &amp;</type>
      <name>theLevel</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LoopGuard</name>
    <filename>classThePEG_1_1LoopGuard.html</filename>
    <templarg>ExceptionT</templarg>
    <templarg>MessageT</templarg>
    <member kind="function">
      <type></type>
      <name>LoopGuard</name>
      <anchor>a0</anchor>
      <arglist>(const MessageT &amp;mess, long maxc=1000000)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>LoopGuard</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>LoopGuard</name>
      <anchor>d1</anchor>
      <arglist>(const LoopGuard &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>count</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>maxCount</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MessageT &amp;</type>
      <name>message</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Named</name>
    <filename>classThePEG_1_1Named.html</filename>
    <member kind="function">
      <type></type>
      <name>Named</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Named</name>
      <anchor>a1</anchor>
      <arglist>(const string &amp;newName)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Named</name>
      <anchor>a2</anchor>
      <arglist>(const Named &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Named</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const string &amp;</type>
      <name>name</name>
      <anchor>a4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a5</anchor>
      <arglist>(const Named &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a6</anchor>
      <arglist>(const Named &amp;) const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const Named &amp;</type>
      <name>operator=</name>
      <anchor>b0</anchor>
      <arglist>(const Named &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const string &amp;</type>
      <name>name</name>
      <anchor>b1</anchor>
      <arglist>(const string &amp;newName)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theName</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ObjectIndexer</name>
    <filename>classThePEG_1_1ObjectIndexer.html</filename>
    <templarg>IntT</templarg>
    <templarg>ObjT</templarg>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::pointer</type>
      <name>TPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::const_pointer</type>
      <name>cTPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::transient_pointer</type>
      <name>tTPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::transient_const_pointer</type>
      <name>tcTPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; IntT, tTPtr &gt;</type>
      <name>IndexObjectMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; TPtr, IntT &gt;</type>
      <name>ObjectIndexMap</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>IntT</type>
      <name>operator()</name>
      <anchor>a0</anchor>
      <arglist>(tTPtr o)</arglist>
    </member>
    <member kind="function">
      <type>tTPtr</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>(IntT i)</arglist>
    </member>
    <member kind="function">
      <type>tTPtr</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(IntT i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a3</anchor>
      <arglist>(IntT i, tTPtr o)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>included</name>
      <anchor>a4</anchor>
      <arglist>(tTPtr o) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>included</name>
      <anchor>a5</anchor>
      <arglist>(IntT i) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>ObjectIndexer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ObjectIndexer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>IndexObjectMap</type>
      <name>indexObject</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectIndexMap</type>
      <name>objectIndex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Rebinder</name>
    <filename>classThePEG_1_1Rebinder.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>TPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::const_pointer</type>
      <name>cTPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_pointer</type>
      <name>tTPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_const_pointer</type>
      <name>tcTPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; cTPtr, TPtr &gt;</type>
      <name>MapType</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Rebinder</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TPtr &amp;</type>
      <name>operator[]</name>
      <anchor>a1</anchor>
      <arglist>(tcTPtr)</arglist>
    </member>
    <member kind="function">
      <type>R</type>
      <name>translate</name>
      <anchor>a2</anchor>
      <arglist>(const R &amp;r) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>translate</name>
      <anchor>a3</anchor>
      <arglist>(OutputIterator ouptut, InputIterator first, InputIterator last) const </arglist>
    </member>
    <member kind="function">
      <type>R</type>
      <name>alwaysTranslate</name>
      <anchor>a4</anchor>
      <arglist>(const R &amp;r) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>alwaysTranslate</name>
      <anchor>a5</anchor>
      <arglist>(OutputIterator, InputIterator, InputIterator) const </arglist>
    </member>
    <member kind="function">
      <type>const MapType &amp;</type>
      <name>map</name>
      <anchor>a6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Rebinder</name>
      <anchor>d0</anchor>
      <arglist>(const Rebinder &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Rebinder &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Rebinder &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MapType</type>
      <name>theMap</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Selector</name>
    <filename>classThePEG_1_1Selector.html</filename>
    <templarg>T</templarg>
    <templarg>WeightType</templarg>
    <member kind="typedef">
      <type>map&lt; WeightType, T, less&lt; WeightType &gt;, Allocator&lt; std::pair&lt; WeightType const, T &gt; &gt; &gt;</type>
      <name>MapType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::iterator</type>
      <name>iterator</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::size_type</type>
      <name>size_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Selector</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Selector</name>
      <anchor>a1</anchor>
      <arglist>(const Selector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Selector</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Selector &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const Selector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a4</anchor>
      <arglist>(Selector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>insert</name>
      <anchor>a5</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>reweight</name>
      <anchor>a6</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>erase</name>
      <anchor>a7</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a8</anchor>
      <arglist>(const T &amp;oldObject, const T &amp;newObject)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a9</anchor>
      <arglist>(double rnd, double *remainder=0)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a10</anchor>
      <arglist>(double rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a11</anchor>
      <arglist>(double rnd, double *remainder=0) const </arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>operator[]</name>
      <anchor>a12</anchor>
      <arglist>(double rnd) const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a13</anchor>
      <arglist>(RNDGEN &amp;rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a14</anchor>
      <arglist>(RNDGEN &amp;rnd) const </arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>sum</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a20</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a21</anchor>
      <arglist>(OStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a22</anchor>
      <arglist>(IStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MapType</type>
      <name>theMap</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightType</type>
      <name>theSum</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SimplePhaseSpace</name>
    <filename>structThePEG_1_1SimplePhaseSpace.html</filename>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e0</anchor>
      <arglist>(Energy2 s, PType &amp;p1, PType &amp;p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e1</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, Energy2 s, double cosTheta, double phi)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e2</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, Energy2 s, Energy2 t, double phi, const PType &amp;p0)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e3</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, Energy2 s)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e4</anchor>
      <arglist>(const PPairType &amp;p, Energy2 s)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e5</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, PType &amp;p3, Energy2 s, double x1, double x3)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e6</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, PType &amp;p3, Energy2 s, double x1, double x3, double phii=0.0, double theta=0.0, double phi=0.0)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>getMagnitude</name>
      <anchor>e7</anchor>
      <arglist>(Energy2 s, Energy m1, Energy m2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Momentum3</type>
      <name>polar3Vector</name>
      <anchor>e8</anchor>
      <arglist>(Energy p, double costheta, double phi)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; LorentzMomentum &gt;</type>
      <name>CMSn</name>
      <anchor>e9</anchor>
      <arglist>(Energy m0, const vector&lt; Energy &gt; &amp;m)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMSn</name>
      <anchor>e10</anchor>
      <arglist>(Container &amp;particles, Energy m0)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ImpossibleKinematics</name>
    <filename>structThePEG_1_1ImpossibleKinematics.html</filename>
    <member kind="function">
      <type></type>
      <name>ImpossibleKinematics</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StringUtils</name>
    <filename>classThePEG_1_1StringUtils.html</filename>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>StringVector</type>
      <name>split</name>
      <anchor>e0</anchor>
      <arglist>(string s, string ws=&quot; \t\n&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>car</name>
      <anchor>e1</anchor>
      <arglist>(string s, string ws=&quot; \t\n&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>cdr</name>
      <anchor>e2</anchor>
      <arglist>(string s, string ws=&quot; \t\n&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>stripws</name>
      <anchor>e3</anchor>
      <arglist>(string str)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>dirname</name>
      <anchor>e4</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>basename</name>
      <anchor>e5</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>remsuf</name>
      <anchor>e6</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>suffix</name>
      <anchor>e7</anchor>
      <arglist>(string file)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SystemUtils</name>
    <filename>classThePEG_1_1SystemUtils.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getenv</name>
      <anchor>e0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::TimeCounter</name>
    <filename>classThePEG_1_1TimeCounter.html</filename>
    <base>ThePEG::Named</base>
    <member kind="function">
      <type></type>
      <name>TimeCounter</name>
      <anchor>a0</anchor>
      <arglist>(string newName=&quot;&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TimeCounter</name>
      <anchor>a1</anchor>
      <arglist>(const TimeCounter &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TimeCounter</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TimeCounter &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const TimeCounter &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>enter</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>start</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nCalls</name>
      <anchor>a7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>timeTot</name>
      <anchor>a8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>timePer</name>
      <anchor>a9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNCalls</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>clock_t</type>
      <name>startClock</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned long</type>
      <name>totTime</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>loop</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MainTimer</name>
    <filename>classThePEG_1_1MainTimer.html</filename>
    <member kind="function">
      <type></type>
      <name>MainTimer</name>
      <anchor>a0</anchor>
      <arglist>(string file=&quot;.timer&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MainTimer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TimeCounter *</type>
      <name>getCounter</name>
      <anchor>e0</anchor>
      <arglist>(unsigned int i, string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>running</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; unsigned int, TimeCounter &gt;</type>
      <name>CounterMap</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>MainTimer</name>
      <anchor>d0</anchor>
      <arglist>(const MainTimer &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MainTimer &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const MainTimer &amp;)</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>CounterMap &amp;</type>
      <name>counters</name>
      <anchor>h0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>statistics</name>
      <anchor>h1</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>filename</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>bool</type>
      <name>isRunning</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>TimeCounter *</type>
      <name>theCounter</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Timer</name>
    <filename>classThePEG_1_1Timer.html</filename>
    <templarg>I</templarg>
    <member kind="function">
      <type></type>
      <name>Timer</name>
      <anchor>a0</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Timer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>start</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Timer</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Timer</name>
      <anchor>d1</anchor>
      <arglist>(const Timer &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Timer &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const Timer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>started</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>TimeCounter *</type>
      <name>theCounter</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Triplet</name>
    <filename>structThePEG_1_1Triplet.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <templarg>T3</templarg>
    <member kind="typedef">
      <type>T1</type>
      <name>first_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T2</type>
      <name>second_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T3</type>
      <name>third_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a1</anchor>
      <arglist>(const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a2</anchor>
      <arglist>(const Triplet&lt; T1, T2, T3 &gt; &amp;t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a3</anchor>
      <arglist>(const Triplet&lt; U1, U2, U3 &gt; &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a4</anchor>
      <arglist>(const Triplet&lt; T1, T2, T3 &gt; &amp;t) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a5</anchor>
      <arglist>(const Triplet&lt; T1, T2, T3 &gt; &amp;t) const </arglist>
    </member>
    <member kind="variable">
      <type>T1</type>
      <name>first</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T2</type>
      <name>second</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T3</type>
      <name>third</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::TypeInfo</name>
    <filename>structThePEG_1_1TypeInfo.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>name</name>
      <anchor>e0</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>version</name>
      <anchor>e1</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::OUnit</name>
    <filename>structThePEG_1_1OUnit.html</filename>
    <templarg>T</templarg>
    <templarg>UT</templarg>
    <member kind="function">
      <type></type>
      <name>OUnit</name>
      <anchor>a0</anchor>
      <arglist>(const T &amp;t, const UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OUnit</name>
      <anchor>a1</anchor>
      <arglist>(const OUnit&lt; T, UT &gt; &amp;iu)</arglist>
    </member>
    <member kind="variable">
      <type>const T &amp;</type>
      <name>theX</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const UT &amp;</type>
      <name>theUnit</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IUnit</name>
    <filename>structThePEG_1_1IUnit.html</filename>
    <templarg>T</templarg>
    <templarg>UT</templarg>
    <member kind="function">
      <type></type>
      <name>IUnit</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;t, const UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IUnit</name>
      <anchor>a1</anchor>
      <arglist>(const IUnit&lt; T, UT &gt; &amp;iu)</arglist>
    </member>
    <member kind="variable">
      <type>T &amp;</type>
      <name>theX</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const UT &amp;</type>
      <name>theUnit</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::UtilityBase</name>
    <filename>structThePEG_1_1UtilityBase.html</filename>
    <member kind="function" static="yes">
      <type>LorentzMomentum</type>
      <name>sumMomentum</name>
      <anchor>e0</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzMomentum</type>
      <name>sumMomentum</name>
      <anchor>e1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e2</anchor>
      <arglist>(Iterator first, Iterator last, const LorentzRotation &amp;boost)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(Cont &amp;cont, const LorentzRotation &amp;boost)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e4</anchor>
      <arglist>(const pair&lt; PType, PType &gt; &amp;pp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>getBoostToCM</name>
      <anchor>e5</anchor>
      <arglist>(const pair&lt; PType, PType &gt; &amp;pp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>getBoostFromCM</name>
      <anchor>e6</anchor>
      <arglist>(const pair&lt; PType, PType &gt; &amp;pp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e7</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e8</anchor>
      <arglist>(Iterator first, Iterator last, Iterator zAxis)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e9</anchor>
      <arglist>(Iterator first, Iterator last, Iterator zAxis, Iterator xzPlane)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>e10</anchor>
      <arglist>(PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentumFromCMS</name>
      <anchor>e11</anchor>
      <arglist>(PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>e12</anchor>
      <arglist>(Iter first, Iter last, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>e13</anchor>
      <arglist>(Iter first, Iter last, const Momentum3 &amp;q, double eps)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentumFromCMS</name>
      <anchor>e14</anchor>
      <arglist>(Iter first, Iter last, Energy2 m2, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToMomentum</name>
      <anchor>e15</anchor>
      <arglist>(const PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToMomentum</name>
      <anchor>e16</anchor>
      <arglist>(const PType &amp;p, const LorentzMomentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformFromCMS</name>
      <anchor>e17</anchor>
      <arglist>(const LV &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformFromCMS</name>
      <anchor>e18</anchor>
      <arglist>(const LV &amp;sum, LV zAxis)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformFromCMS</name>
      <anchor>e19</anchor>
      <arglist>(const LV &amp;sum, const LV &amp;zAxis, LV xyPlane)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToCMS</name>
      <anchor>e20</anchor>
      <arglist>(const LV &amp;sum, LV zAxis)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToCMS</name>
      <anchor>e21</anchor>
      <arglist>(const LV &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToCMS</name>
      <anchor>e22</anchor>
      <arglist>(const LV &amp;sum, const LV &amp;zAxis, LV xyPlane)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>add</name>
      <anchor>e23</anchor>
      <arglist>(Cont1 &amp;c1, const Cont2 &amp;c2)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Utilities</name>
    <filename>structThePEG_1_1Utilities.html</filename>
    <base>ThePEG::UtilityBase</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::VSelector</name>
    <filename>classThePEG_1_1VSelector.html</filename>
    <templarg>T</templarg>
    <templarg>WeightType</templarg>
    <member kind="typedef">
      <type>vector&lt; WeightType &gt;</type>
      <name>WeightVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>WeightVector::const_iterator</type>
      <name>WIterator</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; T &gt;</type>
      <name>ObjectVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ObjectVector::iterator</type>
      <name>iterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ObjectVector::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ObjectVector::size_type</type>
      <name>size_type</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VSelector</name>
      <anchor>a0</anchor>
      <arglist>(size_type reserved=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VSelector</name>
      <anchor>a1</anchor>
      <arglist>(const VSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VSelector</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const VSelector &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const VSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a4</anchor>
      <arglist>(VSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>insert</name>
      <anchor>a5</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>reweight</name>
      <anchor>a6</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>erase</name>
      <anchor>a7</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a8</anchor>
      <arglist>(const T &amp;told, const T &amp;tnew)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a9</anchor>
      <arglist>(double rnd, double *remainder=0)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a10</anchor>
      <arglist>(double rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a11</anchor>
      <arglist>(double rnd, double *remainder=0) const </arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>operator[]</name>
      <anchor>a12</anchor>
      <arglist>(double rnd) const </arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a13</anchor>
      <arglist>(RNDGEN &amp;rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a14</anchor>
      <arglist>(RNDGEN &amp;rnd) const </arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>sum</name>
      <anchor>a15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reserve</name>
      <anchor>a20</anchor>
      <arglist>(size_type reserved)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a21</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a22</anchor>
      <arglist>(OStream &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a23</anchor>
      <arglist>(IStream &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>size_type</type>
      <name>iselect</name>
      <anchor>b0</anchor>
      <arglist>(double rnd, double *remainder) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightVector</type>
      <name>theSums</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightVector</type>
      <name>theWeights</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectVector</type>
      <name>theObjects</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightType</type>
      <name>theSum</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::XSecStat</name>
    <filename>classThePEG_1_1XSecStat.html</filename>
    <member kind="function">
      <type></type>
      <name>XSecStat</name>
      <anchor>z1139_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XSecStat</name>
      <anchor>z1139_1</anchor>
      <arglist>(CrossSection xsecmax)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XSecStat</name>
      <anchor>z1139_2</anchor>
      <arglist>(const XSecStat &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~XSecStat</name>
      <anchor>z1139_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>XSecStat &amp;</type>
      <name>operator=</name>
      <anchor>z1139_4</anchor>
      <arglist>(const XSecStat &amp;)</arglist>
    </member>
    <member kind="function">
      <type>XSecStat &amp;</type>
      <name>operator+=</name>
      <anchor>z1139_5</anchor>
      <arglist>(const XSecStat &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z1139_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accept</name>
      <anchor>z1141_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z1141_1</anchor>
      <arglist>(double weight)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reject</name>
      <anchor>z1141_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>xSec</name>
      <anchor>z1141_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>xSecErr</name>
      <anchor>z1141_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>maxXSec</name>
      <anchor>z1141_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sumWeights</name>
      <anchor>z1141_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sumWeights2</name>
      <anchor>z1141_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>attempts</name>
      <anchor>z1141_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>accepted</name>
      <anchor>z1141_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>maxXSec</name>
      <anchor>z1141_10</anchor>
      <arglist>(CrossSection)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>z1143_0</anchor>
      <arglist>(PersistentOStream &amp;os) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>z1143_1</anchor>
      <arglist>(PersistentIStream &amp;is)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CrossSection</type>
      <name>theMaxXSec</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theAttempts</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theAccepted</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSumWeights</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSumWeights2</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>lastWeight</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Constants</name>
    <filename>namespaceThePEG_1_1Constants.html</filename>
    <member kind="variable" static="yes">
      <type>const Length</type>
      <name>MaxLength</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const Energy</type>
      <name>MaxEnergy</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const Energy2</type>
      <name>MaxEnergy2</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>MaxDouble</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>HugeDouble</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>MaxFloat</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>HugeFloat</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>MaxRapidity</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>pi</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const long</type>
      <name>MaxInt</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>epsilon</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>EulerGamma</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Group</name>
    <filename>namespaceThePEG_1_1Group.html</filename>
    <member kind="enumeration">
      <name>Handler</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>subproc</name>
      <anchor>a8a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cascade</name>
      <anchor>a8a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>multi</name>
      <anchor>a8a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>hadron</name>
      <anchor>a8a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>decay</name>
      <anchor>a8a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Level</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>before</name>
      <anchor>a9a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>main</name>
      <anchor>a9a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>after</name>
      <anchor>a9a7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Helicity</name>
    <filename>namespaceThePEG_1_1Helicity.html</filename>
    <class kind="class">ThePEG::Helicity::FermionSpinInfo</class>
    <class kind="class">ThePEG::Helicity::HelicityLogicalError</class>
    <class kind="class">ThePEG::Helicity::HelicityConsistencyError</class>
    <class kind="class">ThePEG::Helicity::HelicityVertex</class>
    <class kind="class">ThePEG::Helicity::LorentzPolarizationVector</class>
    <class kind="class">ThePEG::Helicity::LorentzRSSpinor</class>
    <class kind="class">ThePEG::Helicity::LorentzRSSpinorBar</class>
    <class kind="class">ThePEG::Helicity::LorentzSpinor</class>
    <class kind="class">ThePEG::Helicity::LorentzSpinorBar</class>
    <class kind="class">ThePEG::Helicity::LorentzTensor</class>
    <class kind="class">ThePEG::Helicity::RhoDMatrix</class>
    <class kind="class">ThePEG::Helicity::RSFermionSpinInfo</class>
    <class kind="class">ThePEG::Helicity::ScalarSpinInfo</class>
    <class kind="class">ThePEG::Helicity::SpinInfo</class>
    <class kind="class">ThePEG::Helicity::TensorSpinInfo</class>
    <class kind="class">ThePEG::Helicity::VectorSpinInfo</class>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::pointer</type>
      <name>FermionSpinPtr</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::const_pointer</type>
      <name>cFermionSpinPtr</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::transient_pointer</type>
      <name>tFermionSpinPtr</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::transient_const_pointer</type>
      <name>tcFermionSpinPtr</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::pointer</type>
      <name>VertexPtr</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::const_pointer</type>
      <name>cVertexPtr</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::transient_pointer</type>
      <name>tVertexPtr</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::transient_const_pointer</type>
      <name>tcVertexPtr</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RSFermionSpinInfo &gt;::pointer</type>
      <name>RSFermionSpinPtr</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RSFermionSpinInfo &gt;::const_pointer</type>
      <name>cRSFermionSpinPtr</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RSFermionSpinInfo &gt;::transient_pointer</type>
      <name>tRSFermionSpinPtr</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RSFermionSpinInfo &gt;::transient_const_pointer</type>
      <name>tcRSFermionSpinPtr</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::pointer</type>
      <name>ScalarSpinPtr</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::const_pointer</type>
      <name>cScalarSpinPtr</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::transient_pointer</type>
      <name>tScalarSpinPtr</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::transient_const_pointer</type>
      <name>tcScalarSpinPtr</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::pointer</type>
      <name>SpinfoPtr</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::const_pointer</type>
      <name>cSpinfoPtr</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::transient_pointer</type>
      <name>tSpinfoPtr</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::transient_const_pointer</type>
      <name>tcSpinfoPtr</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::pointer</type>
      <name>TensorSpinPtr</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::const_pointer</type>
      <name>cTensorSpinPtr</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::transient_pointer</type>
      <name>tTensorSpinPtr</name>
      <anchor>a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::transient_const_pointer</type>
      <name>tcTensorSpinPtr</name>
      <anchor>a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::pointer</type>
      <name>VectorSpinPtr</name>
      <anchor>a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::const_pointer</type>
      <name>cVectorSpinPtr</name>
      <anchor>a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::transient_pointer</type>
      <name>tVectorSpinPtr</name>
      <anchor>a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::transient_const_pointer</type>
      <name>tcVectorSpinPtr</name>
      <anchor>a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>DiracRep</name>
      <anchor>a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HELASDRep</name>
      <anchor>a45a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HaberDRep</name>
      <anchor>a45a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>defaultDRep</name>
      <anchor>a45a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>SpinorType</name>
      <anchor>a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>u_spinortype</name>
      <anchor>a46a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>v_spinortype</name>
      <anchor>a46a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown_spinortype</name>
      <anchor>a46a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator/</name>
      <anchor>a34</anchor>
      <arglist>(const LorentzPolarizationVector &amp;, Complex a)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a35</anchor>
      <arglist>(Complex a, const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a36</anchor>
      <arglist>(Complex a, const Lorentz5Momentum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostXOf</name>
      <anchor>a37</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostYOf</name>
      <anchor>a38</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostZOf</name>
      <anchor>a39</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostOf</name>
      <anchor>a40</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, const Hep3Vector &amp;betaVector)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostOf</name>
      <anchor>a41</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, const Hep3Vector &amp;axis, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator *</name>
      <anchor>a42</anchor>
      <arglist>(Complex a, const LorentzTensor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a43</anchor>
      <arglist>(const LorentzPolarizationVector &amp;, const LorentzTensor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a44</anchor>
      <arglist>(const LorentzTensor &amp;, const LorentzPolarizationVector &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::FermionSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1FermionSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FermionSpinInfo</name>
      <anchor>z339_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FermionSpinInfo</name>
      <anchor>z339_1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FermionSpinInfo</name>
      <anchor>z339_2</anchor>
      <arglist>(const FermionSpinInfo &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FermionSpinInfo</name>
      <anchor>z339_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z341_0</anchor>
      <arglist>(unsigned int hel, LorentzSpinor in) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z341_1</anchor>
      <arglist>(unsigned int hel, LorentzSpinor in) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>getProductionBasisState</name>
      <anchor>z341_2</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>getDecayBasisState</name>
      <anchor>z341_3</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FermionSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FermionSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzSpinor &gt;</type>
      <name>_productionstates</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzSpinor &gt;</type>
      <name>_decaystates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzSpinor &gt;</type>
      <name>_currentstates</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; FermionSpinInfo &gt;</type>
      <name>initFermionSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::HelicityLogicalError</name>
    <filename>classThePEG_1_1Helicity_1_1HelicityLogicalError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::HelicityConsistencyError</name>
    <filename>classThePEG_1_1Helicity_1_1HelicityConsistencyError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::HelicityVertex</name>
    <filename>classThePEG_1_1Helicity_1_1HelicityVertex.html</filename>
    <base>ThePEG::EventInfoBase</base>
    <member kind="typedef">
      <type>vector&lt; tcSpinPtr &gt;</type>
      <name>SpinVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HelicityVertex</name>
      <anchor>z343_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HelicityVertex</name>
      <anchor>z343_1</anchor>
      <arglist>(const HelicityVertex &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HelicityVertex</name>
      <anchor>z343_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinVector</type>
      <name>incoming</name>
      <anchor>z345_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>SpinVector</type>
      <name>outgoing</name>
      <anchor>z345_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIncoming</name>
      <anchor>z345_2</anchor>
      <arglist>(tcSpinPtr spin, int &amp;loc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addOutgoing</name>
      <anchor>z345_3</anchor>
      <arglist>(tcSpinPtr spin, int &amp;loc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetIncoming</name>
      <anchor>z345_4</anchor>
      <arglist>(tcSpinPtr spin, int loc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetOutgoing</name>
      <anchor>z345_5</anchor>
      <arglist>(tcSpinPtr spin, int loc)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual RhoDMatrix</type>
      <name>getRhoMatrix</name>
      <anchor>z347_0</anchor>
      <arglist>(int loc)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual RhoDMatrix</type>
      <name>getDMatrix</name>
      <anchor>z347_1</anchor>
      <arglist>(int loc)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HelicityVertex &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HelicityVertex &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinVector</type>
      <name>_incoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinVector</type>
      <name>_outgoing</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; HelicityVertex &gt;</type>
      <name>initHelicityVertex</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzPolarizationVector</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzPolarizationVector.html</filename>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z349_0</anchor>
      <arglist>(Complex x, Complex y, Complex z, Complex t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z349_1</anchor>
      <arglist>(Complex x, Complex y, Complex z)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z349_2</anchor>
      <arglist>(Complex t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z349_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z349_4</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z349_5</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LorentzPolarizationVector</name>
      <anchor>z349_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>x</name>
      <anchor>z351_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>y</name>
      <anchor>z351_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>z</name>
      <anchor>z351_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>t</name>
      <anchor>z351_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setX</name>
      <anchor>z351_4</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setY</name>
      <anchor>z351_5</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZ</name>
      <anchor>z351_6</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setT</name>
      <anchor>z351_7</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z351_8</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator[]</name>
      <anchor>z351_9</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z351_10</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator[]</name>
      <anchor>z351_11</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator=</name>
      <anchor>z353_0</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator+</name>
      <anchor>z353_1</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator+=</name>
      <anchor>z353_2</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator-</name>
      <anchor>z353_3</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator-=</name>
      <anchor>z353_4</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator-</name>
      <anchor>z353_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator *=</name>
      <anchor>z353_6</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator/=</name>
      <anchor>z353_7</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>dot</name>
      <anchor>z353_8</anchor>
      <arglist>(const LorentzVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator *</name>
      <anchor>z353_9</anchor>
      <arglist>(const LorentzVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>dot</name>
      <anchor>z353_10</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator *</name>
      <anchor>z353_11</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z355_0</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>z355_1</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boostX</name>
      <anchor>z357_0</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boostY</name>
      <anchor>z357_1</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boostZ</name>
      <anchor>z357_2</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boost</name>
      <anchor>z357_3</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boost</name>
      <anchor>z357_4</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>transform</name>
      <anchor>z357_5</anchor>
      <arglist>(const HepLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boost</name>
      <anchor>z357_6</anchor>
      <arglist>(const Hep3Vector &amp;axis, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateX</name>
      <anchor>z357_7</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateY</name>
      <anchor>z357_8</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateZ</name>
      <anchor>z357_9</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateUz</name>
      <anchor>z357_10</anchor>
      <arglist>(const Hep3Vector &amp;newUz)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotate</name>
      <anchor>z357_11</anchor>
      <arglist>(double, const Hep3Vector &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>conjugate</name>
      <anchor>z357_12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_vec</name>
      <anchor>r0</anchor>
      <arglist>[4]</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzRSSpinor</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzRSSpinor.html</filename>
    <member kind="function">
      <type>Complex</type>
      <name>generalScalar</name>
      <anchor>a0</anchor>
      <arglist>(LorentzRSSpinorBar &amp;fbar, Complex left, Complex right)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>generalCurrent</name>
      <anchor>a1</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar, Complex left, Complex right)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinor</name>
      <anchor>z359_0</anchor>
      <arglist>(SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinor</name>
      <anchor>z359_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinor</name>
      <anchor>z359_2</anchor>
      <arglist>(Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinor</name>
      <anchor>z359_3</anchor>
      <arglist>(Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z361_0</anchor>
      <arglist>(int, int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z361_1</anchor>
      <arglist>(int, int)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs1</name>
      <anchor>z361_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs2</name>
      <anchor>z361_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs3</name>
      <anchor>z361_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs4</name>
      <anchor>z361_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys1</name>
      <anchor>z361_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys2</name>
      <anchor>z361_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys3</name>
      <anchor>z361_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys4</name>
      <anchor>z361_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs1</name>
      <anchor>z361_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs2</name>
      <anchor>z361_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs3</name>
      <anchor>z361_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs4</name>
      <anchor>z361_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts1</name>
      <anchor>z361_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts2</name>
      <anchor>z361_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts3</name>
      <anchor>z361_16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts4</name>
      <anchor>z361_17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS1</name>
      <anchor>z361_18</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS2</name>
      <anchor>z361_19</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS3</name>
      <anchor>z361_20</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS4</name>
      <anchor>z361_21</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS1</name>
      <anchor>z361_22</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS2</name>
      <anchor>z361_23</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS3</name>
      <anchor>z361_24</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS4</name>
      <anchor>z361_25</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS1</name>
      <anchor>z361_26</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS2</name>
      <anchor>z361_27</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS3</name>
      <anchor>z361_28</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS4</name>
      <anchor>z361_29</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS1</name>
      <anchor>z361_30</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS2</name>
      <anchor>z361_31</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS3</name>
      <anchor>z361_32</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS4</name>
      <anchor>z361_33</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor &amp;</type>
      <name>operator=</name>
      <anchor>z363_0</anchor>
      <arglist>(const LorentzRSSpinor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>dot</name>
      <anchor>z363_1</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>dot</name>
      <anchor>z363_2</anchor>
      <arglist>(const LorentzVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinorBar</type>
      <name>bar</name>
      <anchor>z365_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor &amp;</type>
      <name>boost</name>
      <anchor>z365_1</anchor>
      <arglist>(double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor &amp;</type>
      <name>boost</name>
      <anchor>z365_2</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor &amp;</type>
      <name>transform</name>
      <anchor>z365_3</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>changeRep</name>
      <anchor>z367_0</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor</type>
      <name>transformRep</name>
      <anchor>z367_1</anchor>
      <arglist>(DiracRep) const </arglist>
    </member>
    <member kind="function">
      <type>DiracRep</type>
      <name>Rep</name>
      <anchor>z367_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinorType</type>
      <name>Type</name>
      <anchor>z367_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist>[4][4]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiracRep</type>
      <name>_dirac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinorType</type>
      <name>_type</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzRSSpinorBar</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzRSSpinorBar.html</filename>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>generalCurrent</name>
      <anchor>a0</anchor>
      <arglist>(LorentzSpinor &amp;f, Complex left, Complex right)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinorBar</name>
      <anchor>z369_0</anchor>
      <arglist>(SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinorBar</name>
      <anchor>z369_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinorBar</name>
      <anchor>z369_2</anchor>
      <arglist>(Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzRSSpinorBar</name>
      <anchor>z369_3</anchor>
      <arglist>(Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z371_0</anchor>
      <arglist>(int, int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z371_1</anchor>
      <arglist>(int, int)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs1</name>
      <anchor>z371_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs2</name>
      <anchor>z371_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs3</name>
      <anchor>z371_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xs4</name>
      <anchor>z371_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys1</name>
      <anchor>z371_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys2</name>
      <anchor>z371_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys3</name>
      <anchor>z371_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ys4</name>
      <anchor>z371_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs1</name>
      <anchor>z371_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs2</name>
      <anchor>z371_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs3</name>
      <anchor>z371_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zs4</name>
      <anchor>z371_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts1</name>
      <anchor>z371_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts2</name>
      <anchor>z371_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts3</name>
      <anchor>z371_16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ts4</name>
      <anchor>z371_17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS1</name>
      <anchor>z371_18</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS2</name>
      <anchor>z371_19</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS3</name>
      <anchor>z371_20</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXS4</name>
      <anchor>z371_21</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS1</name>
      <anchor>z371_22</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS2</name>
      <anchor>z371_23</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS3</name>
      <anchor>z371_24</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYS4</name>
      <anchor>z371_25</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS1</name>
      <anchor>z371_26</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS2</name>
      <anchor>z371_27</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS3</name>
      <anchor>z371_28</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZS4</name>
      <anchor>z371_29</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS1</name>
      <anchor>z371_30</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS2</name>
      <anchor>z371_31</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS3</name>
      <anchor>z371_32</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTS4</name>
      <anchor>z371_33</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinorBar &amp;</type>
      <name>operator=</name>
      <anchor>z373_0</anchor>
      <arglist>(const LorentzRSSpinorBar &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>dot</name>
      <anchor>z373_1</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>dot</name>
      <anchor>z373_2</anchor>
      <arglist>(const LorentzVector &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor</type>
      <name>bar</name>
      <anchor>z375_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinorBar &amp;</type>
      <name>boost</name>
      <anchor>z375_1</anchor>
      <arglist>(double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinorBar &amp;</type>
      <name>boost</name>
      <anchor>z375_2</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinorBar &amp;</type>
      <name>transform</name>
      <anchor>z375_3</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>changeRep</name>
      <anchor>z377_0</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinorBar</type>
      <name>transformRep</name>
      <anchor>z377_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>DiracRep</type>
      <name>Rep</name>
      <anchor>z377_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinorType</type>
      <name>Type</name>
      <anchor>z377_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist>[4][4]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiracRep</type>
      <name>_dirac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinorType</type>
      <name>_type</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzSpinor</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzSpinor.html</filename>
    <member kind="function">
      <type>LorentzSpinor &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzSpinor &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z379_0</anchor>
      <arglist>(SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z379_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z379_2</anchor>
      <arglist>(Complex, Complex, Complex, Complex, SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z379_3</anchor>
      <arglist>(Complex, Complex, Complex, Complex, DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator[]</name>
      <anchor>z381_0</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z381_1</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z381_2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator[]</name>
      <anchor>z381_3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1</name>
      <anchor>z381_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2</name>
      <anchor>z381_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3</name>
      <anchor>z381_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4</name>
      <anchor>z381_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS1</name>
      <anchor>z381_8</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS2</name>
      <anchor>z381_9</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS3</name>
      <anchor>z381_10</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS4</name>
      <anchor>z381_11</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>bar</name>
      <anchor>z383_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor &amp;</type>
      <name>boost</name>
      <anchor>z383_1</anchor>
      <arglist>(double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor &amp;</type>
      <name>boost</name>
      <anchor>z383_2</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor &amp;</type>
      <name>transform</name>
      <anchor>z383_3</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor &amp;</type>
      <name>transform</name>
      <anchor>z383_4</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>changeRep</name>
      <anchor>z385_0</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>transformRep</name>
      <anchor>z385_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>DiracRep</type>
      <name>Rep</name>
      <anchor>z385_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinorType</type>
      <name>Type</name>
      <anchor>z385_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>leftCurrent</name>
      <anchor>z387_0</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>rightCurrent</name>
      <anchor>z387_1</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>vectorCurrent</name>
      <anchor>z387_2</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>generalCurrent</name>
      <anchor>z387_3</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar, Complex left, Complex right)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>leftScalar</name>
      <anchor>z389_0</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>rightScalar</name>
      <anchor>z389_1</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>scalar</name>
      <anchor>z389_2</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>pseudoScalar</name>
      <anchor>z389_3</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>generalScalar</name>
      <anchor>z389_4</anchor>
      <arglist>(LorentzSpinorBar &amp;fbar, Complex left, Complex right)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist>[4]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiracRep</type>
      <name>_dirac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinorType</type>
      <name>_type</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzSpinorBar</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzSpinorBar.html</filename>
    <member kind="function">
      <type>LorentzSpinorBar &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzSpinorBar &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z391_0</anchor>
      <arglist>(SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z391_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z391_2</anchor>
      <arglist>(Complex, Complex, Complex, Complex, SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z391_3</anchor>
      <arglist>(Complex, Complex, Complex, Complex, DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator[]</name>
      <anchor>z393_0</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z393_1</anchor>
      <arglist>(int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z393_2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator[]</name>
      <anchor>z393_3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1</name>
      <anchor>z393_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2</name>
      <anchor>z393_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3</name>
      <anchor>z393_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4</name>
      <anchor>z393_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS1</name>
      <anchor>z393_8</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS2</name>
      <anchor>z393_9</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS3</name>
      <anchor>z393_10</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS4</name>
      <anchor>z393_11</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>bar</name>
      <anchor>z395_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar &amp;</type>
      <name>boost</name>
      <anchor>z395_1</anchor>
      <arglist>(double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar &amp;</type>
      <name>boost</name>
      <anchor>z395_2</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar &amp;</type>
      <name>transform</name>
      <anchor>z395_3</anchor>
      <arglist>(const SpinHalfLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar &amp;</type>
      <name>transform</name>
      <anchor>z395_4</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>changeRep</name>
      <anchor>z397_0</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>transformRep</name>
      <anchor>z397_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>DiracRep</type>
      <name>Rep</name>
      <anchor>z397_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinorType</type>
      <name>Type</name>
      <anchor>z397_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist>[4]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiracRep</type>
      <name>_dirac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinorType</type>
      <name>_type</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzTensor</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzTensor.html</filename>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z399_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z399_1</anchor>
      <arglist>(Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z399_2</anchor>
      <arglist>(LorentzPolarizationVector, LorentzPolarizationVector)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z399_3</anchor>
      <arglist>(LorentzVector p, LorentzVector q)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LorentzTensor</name>
      <anchor>z399_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xx</name>
      <anchor>z401_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yx</name>
      <anchor>z401_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zx</name>
      <anchor>z401_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>tx</name>
      <anchor>z401_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xy</name>
      <anchor>z401_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yy</name>
      <anchor>z401_5</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zy</name>
      <anchor>z401_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ty</name>
      <anchor>z401_7</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xz</name>
      <anchor>z401_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yz</name>
      <anchor>z401_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zz</name>
      <anchor>z401_10</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>tz</name>
      <anchor>z401_11</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xt</name>
      <anchor>z401_12</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yt</name>
      <anchor>z401_13</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zt</name>
      <anchor>z401_14</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>tt</name>
      <anchor>z401_15</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXX</name>
      <anchor>z401_16</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYX</name>
      <anchor>z401_17</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZX</name>
      <anchor>z401_18</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTX</name>
      <anchor>z401_19</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXY</name>
      <anchor>z401_20</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYY</name>
      <anchor>z401_21</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZY</name>
      <anchor>z401_22</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTY</name>
      <anchor>z401_23</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXZ</name>
      <anchor>z401_24</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYZ</name>
      <anchor>z401_25</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZZ</name>
      <anchor>z401_26</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTZ</name>
      <anchor>z401_27</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXT</name>
      <anchor>z401_28</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYT</name>
      <anchor>z401_29</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZT</name>
      <anchor>z401_30</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTT</name>
      <anchor>z401_31</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z401_32</anchor>
      <arglist>(int, int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z401_33</anchor>
      <arglist>(int, int)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor &amp;</type>
      <name>boost</name>
      <anchor>z403_0</anchor>
      <arglist>(double, double, double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor &amp;</type>
      <name>boost</name>
      <anchor>z403_1</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor &amp;</type>
      <name>transform</name>
      <anchor>z403_2</anchor>
      <arglist>(const SpinOneLorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor &amp;</type>
      <name>transform</name>
      <anchor>z403_3</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>conjugate</name>
      <anchor>z403_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor &amp;</type>
      <name>operator=</name>
      <anchor>z405_0</anchor>
      <arglist>(const LorentzTensor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator *</name>
      <anchor>z405_1</anchor>
      <arglist>(const LorentzTensor &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator *=</name>
      <anchor>z405_2</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator+</name>
      <anchor>z405_3</anchor>
      <arglist>(const LorentzTensor &amp;) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator-</name>
      <anchor>z405_4</anchor>
      <arglist>(const LorentzTensor &amp;) const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_tensor</name>
      <anchor>r0</anchor>
      <arglist>[4][4]</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::RhoDMatrix</name>
    <filename>classThePEG_1_1Helicity_1_1RhoDMatrix.html</filename>
    <member kind="function">
      <type>RhoDMatrix &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const RhoDMatrix &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RhoDMatrix</name>
      <anchor>z407_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RhoDMatrix</name>
      <anchor>z407_1</anchor>
      <arglist>(PDT::Spin)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RhoDMatrix</name>
      <anchor>z407_2</anchor>
      <arglist>(const RhoDMatrix &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RhoDMatrix</name>
      <anchor>z407_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z409_0</anchor>
      <arglist>(unsigned int, unsigned int) const </arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z409_1</anchor>
      <arglist>(unsigned int, unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>average</name>
      <anchor>z409_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zero</name>
      <anchor>z409_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>normalize</name>
      <anchor>z409_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>z411_0</anchor>
      <arglist>(PDT::Spin)</arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>z411_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>_ispin</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_matrix</name>
      <anchor>r2</anchor>
      <arglist>[5][5]</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::RSFermionSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1RSFermionSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RSFermionSpinInfo</name>
      <anchor>z413_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RSFermionSpinInfo</name>
      <anchor>z413_1</anchor>
      <arglist>(const RSFermionSpinInfo &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RSFermionSpinInfo</name>
      <anchor>z413_2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RSFermionSpinInfo</name>
      <anchor>z413_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z415_0</anchor>
      <arglist>(unsigned int hel, LorentzRSSpinor in) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z415_1</anchor>
      <arglist>(unsigned int hel, LorentzRSSpinor in) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor</type>
      <name>getProductionBasisState</name>
      <anchor>z415_2</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzRSSpinor</type>
      <name>getDecayBasisState</name>
      <anchor>z415_3</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>z415_4</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RSFermionSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const RSFermionSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzRSSpinor &gt;</type>
      <name>_productionstates</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzRSSpinor &gt;</type>
      <name>_decaystates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzRSSpinor &gt;</type>
      <name>_currentstates</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; RSFermionSpinInfo &gt;</type>
      <name>initRSFermionSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::ScalarSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1ScalarSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a2</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarSpinInfo</name>
      <anchor>z417_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarSpinInfo</name>
      <anchor>z417_1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarSpinInfo</name>
      <anchor>z417_2</anchor>
      <arglist>(const ScalarSpinInfo &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ScalarSpinInfo</name>
      <anchor>z417_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ScalarSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ScalarSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; ScalarSpinInfo &gt;</type>
      <name>initScalarSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::SpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1SpinInfo.html</filename>
    <base>ThePEG::SpinBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a3</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinInfo</name>
      <anchor>z419_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinInfo</name>
      <anchor>z419_1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinInfo</name>
      <anchor>z419_2</anchor>
      <arglist>(const SpinInfo &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SpinInfo</name>
      <anchor>z419_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setProductionVertex</name>
      <anchor>z421_0</anchor>
      <arglist>(VertexPtr) const </arglist>
    </member>
    <member kind="function">
      <type>tcVertexPtr</type>
      <name>getProductionVertex</name>
      <anchor>z421_1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayVertex</name>
      <anchor>z421_2</anchor>
      <arglist>(VertexPtr) const </arglist>
    </member>
    <member kind="function">
      <type>tcVertexPtr</type>
      <name>getDecayVertex</name>
      <anchor>z421_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>decayed</name>
      <anchor>z423_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>decayed</name>
      <anchor>z423_1</anchor>
      <arglist>(bool) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>developed</name>
      <anchor>z423_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>decay</name>
      <anchor>z423_3</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>develop</name>
      <anchor>z423_4</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDeveloped</name>
      <anchor>z423_5</anchor>
      <arglist>(bool) const </arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>z423_6</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>Particle</name>
      <anchor>z423_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>productionMomentum</name>
      <anchor>z423_8</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>currentMomentum</name>
      <anchor>z423_9</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>timelike</name>
      <anchor>z423_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix</type>
      <name>rhoMatrix</name>
      <anchor>z425_0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix &amp;</type>
      <name>rhoMatrix</name>
      <anchor>z425_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix</type>
      <name>DMatrix</name>
      <anchor>z425_2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix &amp;</type>
      <name>DMatrix</name>
      <anchor>z425_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>b0</anchor>
      <arglist>(PDT::Spin)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setProductionMomentum</name>
      <anchor>b1</anchor>
      <arglist>(const Lorentz5Momentum &amp;in)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setTimelike</name>
      <anchor>b2</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexPtr</type>
      <name>_production</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexPtr</type>
      <name>_decay</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_timelike</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>_prodloc</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>_decayloc</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decayed</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_developed</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RhoDMatrix</type>
      <name>_rhomatrix</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RhoDMatrix</type>
      <name>_Dmatrix</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>_spin</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>_productionmomentum</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>_decaymomentum</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>_currentmomentum</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; SpinInfo &gt;</type>
      <name>initSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::TensorSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1TensorSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TensorSpinInfo</name>
      <anchor>z427_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TensorSpinInfo</name>
      <anchor>z427_1</anchor>
      <arglist>(const TensorSpinInfo &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TensorSpinInfo</name>
      <anchor>z427_2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~TensorSpinInfo</name>
      <anchor>z427_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z429_0</anchor>
      <arglist>(unsigned int hel, LorentzTensor in) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z429_1</anchor>
      <arglist>(unsigned int hel, LorentzTensor in) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>getProductionBasisState</name>
      <anchor>z429_2</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>getDecayBasisState</name>
      <anchor>z429_3</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>TensorSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const TensorSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzTensor &gt;</type>
      <name>_productionstates</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzTensor &gt;</type>
      <name>_decaystates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzTensor &gt;</type>
      <name>_currentstates</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; TensorSpinInfo &gt;</type>
      <name>initTensorSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::VectorSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1VectorSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a2</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorSpinInfo</name>
      <anchor>z431_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorSpinInfo</name>
      <anchor>z431_1</anchor>
      <arglist>(const VectorSpinInfo &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorSpinInfo</name>
      <anchor>z431_2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~VectorSpinInfo</name>
      <anchor>z431_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z433_0</anchor>
      <arglist>(unsigned int hel, LorentzPolarizationVector in) const </arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z433_1</anchor>
      <arglist>(unsigned int hel, LorentzPolarizationVector in) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>getProductionBasisState</name>
      <anchor>z433_2</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>getDecayBasisState</name>
      <anchor>z433_3</anchor>
      <arglist>(unsigned int hel) const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VectorSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const VectorSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzPolarizationVector &gt;</type>
      <name>_productionstates</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzPolarizationVector &gt;</type>
      <name>_decaystates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzPolarizationVector &gt;</type>
      <name>_currentstates</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; VectorSpinInfo &gt;</type>
      <name>initVectorSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Interface</name>
    <filename>namespaceThePEG_1_1Interface.html</filename>
    <member kind="enumeration">
      <name>DepSafe</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unsafe</name>
      <anchor>a14a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>safe</name>
      <anchor>a14a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>ReadOnly</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>readwrite</name>
      <anchor>a15a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>readonly</name>
      <anchor>a15a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Limits</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nolimits</name>
      <anchor>a16a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>limited</name>
      <anchor>a16a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>upperlim</name>
      <anchor>a16a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>lowerlim</name>
      <anchor>a16a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Rebind</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>norebind</name>
      <anchor>a17a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rebind</name>
      <anchor>a17a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Nullable</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nonull</name>
      <anchor>a18a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nullok</name>
      <anchor>a18a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>NullDefault</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nodefnull</name>
      <anchor>a19a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>defnull</name>
      <anchor>a19a13</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Math</name>
    <filename>namespaceThePEG_1_1Math.html</filename>
    <class kind="struct">ThePEG::Math::MathType</class>
    <class kind="struct">ThePEG::Math::Power</class>
    <member kind="function">
      <type>double</type>
      <name>gamma</name>
      <anchor>a0</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lngamma</name>
      <anchor>a1</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>exp1m</name>
      <anchor>a2</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>log1m</name>
      <anchor>a3</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>powi</name>
      <anchor>a4</anchor>
      <arglist>(double x, int p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pIntegrate</name>
      <anchor>a5</anchor>
      <arglist>(double p, double xl, double xu)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pIntegrate</name>
      <anchor>a6</anchor>
      <arglist>(int p, double xl, double xu)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pXIntegrate</name>
      <anchor>a7</anchor>
      <arglist>(double e, double xl, double dx)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pGenerate</name>
      <anchor>a8</anchor>
      <arglist>(double p, double xl, double xu, double rnd)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pGenerate</name>
      <anchor>a9</anchor>
      <arglist>(int p, double xl, double xu, double rnd)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pXGenerate</name>
      <anchor>a10</anchor>
      <arglist>(double e, double xl, double xu, double rnd)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>relativeError</name>
      <anchor>a11</anchor>
      <arglist>(FloatType x, FloatType y)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>absmin</name>
      <anchor>a12</anchor>
      <arglist>(const T &amp;x, const T &amp;y)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>absmax</name>
      <anchor>a13</anchor>
      <arglist>(const T &amp;x, const T &amp;y)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>sign</name>
      <anchor>a14</anchor>
      <arglist>(T x, U y)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>Pow</name>
      <anchor>a15</anchor>
      <arglist>(double x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::MathType</name>
    <filename>structThePEG_1_1Math_1_1MathType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Power</name>
    <filename>structThePEG_1_1Math_1_1Power.html</filename>
    <templarg>N</templarg>
    <templarg>Inv</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>pow</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Math::Functions</name>
    <filename>namespaceThePEG_1_1Math_1_1Functions.html</filename>
    <class kind="struct">ThePEG::Math::Functions::PowX</class>
    <class kind="struct">ThePEG::Math::Functions::Pow1mX</class>
    <class kind="struct">ThePEG::Math::Functions::InvX1mX</class>
    <class kind="struct">ThePEG::Math::Functions::ExpX</class>
    <class kind="struct">ThePEG::Math::Functions::FracPowX</class>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::PowX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1PowX.html</filename>
    <templarg>N</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::Pow1mX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1Pow1mX.html</filename>
    <templarg>N</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::InvX1mX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1InvX1mX.html</filename>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::ExpX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1ExpX.html</filename>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::FracPowX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1FracPowX.html</filename>
    <templarg>N</templarg>
    <templarg>D</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::ParticleID</name>
    <filename>namespaceThePEG_1_1ParticleID.html</filename>
    <member kind="enumeration">
      <name>ParticleCodes</name>
      <anchor>a511</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>d</name>
      <anchor>a511a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dbar</name>
      <anchor>a511a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>u</name>
      <anchor>a511a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ubar</name>
      <anchor>a511a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>s</name>
      <anchor>a511a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sbar</name>
      <anchor>a511a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>c</name>
      <anchor>a511a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cbar</name>
      <anchor>a511a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b</name>
      <anchor>a511a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bbar</name>
      <anchor>a511a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>t</name>
      <anchor>a511a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tbar</name>
      <anchor>a511a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bprime</name>
      <anchor>a511a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bprimebar</name>
      <anchor>a511a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tprime</name>
      <anchor>a511a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tprimebar</name>
      <anchor>a511a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eminus</name>
      <anchor>a511a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eplus</name>
      <anchor>a511a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_e</name>
      <anchor>a511a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_ebar</name>
      <anchor>a511a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>muminus</name>
      <anchor>a511a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>muplus</name>
      <anchor>a511a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_mu</name>
      <anchor>a511a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_mubar</name>
      <anchor>a511a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauminus</name>
      <anchor>a511a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauplus</name>
      <anchor>a511a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_tau</name>
      <anchor>a511a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_taubar</name>
      <anchor>a511a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauprimeminus</name>
      <anchor>a511a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauprimeplus</name>
      <anchor>a511a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nuprime_tau</name>
      <anchor>a511a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nuprime_taubar</name>
      <anchor>a511a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>g</name>
      <anchor>a511a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>gamma</name>
      <anchor>a511a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Z0</name>
      <anchor>a511a34</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wplus</name>
      <anchor>a511a35</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wminus</name>
      <anchor>a511a36</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h0</name>
      <anchor>a511a37</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Zprime0</name>
      <anchor>a511a38</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Zbis0</name>
      <anchor>a511a39</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wprimeplus</name>
      <anchor>a511a40</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wprimeminus</name>
      <anchor>a511a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H0</name>
      <anchor>a511a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>A0</name>
      <anchor>a511a43</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Hplus</name>
      <anchor>a511a44</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Hminus</name>
      <anchor>a511a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Graviton</name>
      <anchor>a511a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>R0</name>
      <anchor>a511a47</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Rbar0</name>
      <anchor>a511a48</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LQ_ue</name>
      <anchor>a511a49</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LQ_uebar</name>
      <anchor>a511a50</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>reggeon</name>
      <anchor>a511a51</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi0</name>
      <anchor>a511a52</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho0</name>
      <anchor>a511a53</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_20</name>
      <anchor>a511a54</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_L0</name>
      <anchor>a511a55</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>piplus</name>
      <anchor>a511a56</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>piminus</name>
      <anchor>a511a57</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rhoplus</name>
      <anchor>a511a58</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rhominus</name>
      <anchor>a511a59</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_2plus</name>
      <anchor>a511a60</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_2minus</name>
      <anchor>a511a61</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta</name>
      <anchor>a511a62</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>omega</name>
      <anchor>a511a63</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>f_2</name>
      <anchor>a511a64</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_S0</name>
      <anchor>a511a65</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K0</name>
      <anchor>a511a66</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kbar0</name>
      <anchor>a511a67</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar0</name>
      <anchor>a511a68</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstarbar0</name>
      <anchor>a511a69</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_20</name>
      <anchor>a511a70</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_2bar0</name>
      <anchor>a511a71</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kplus</name>
      <anchor>a511a72</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kminus</name>
      <anchor>a511a73</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstarplus</name>
      <anchor>a511a74</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstarminus</name>
      <anchor>a511a75</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_2plus</name>
      <anchor>a511a76</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_2minus</name>
      <anchor>a511a77</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>etaprime</name>
      <anchor>a511a78</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>phi</name>
      <anchor>a511a79</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>fprime_2</name>
      <anchor>a511a80</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dplus</name>
      <anchor>a511a81</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dminus</name>
      <anchor>a511a82</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstarplus</name>
      <anchor>a511a83</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstarminus</name>
      <anchor>a511a84</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2plus</name>
      <anchor>a511a85</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2minus</name>
      <anchor>a511a86</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D0</name>
      <anchor>a511a87</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dbar0</name>
      <anchor>a511a88</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar0</name>
      <anchor>a511a89</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstarbar0</name>
      <anchor>a511a90</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_20</name>
      <anchor>a511a91</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2bar0</name>
      <anchor>a511a92</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_splus</name>
      <anchor>a511a93</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_sminus</name>
      <anchor>a511a94</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_splus</name>
      <anchor>a511a95</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_sminus</name>
      <anchor>a511a96</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2splus</name>
      <anchor>a511a97</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2sminus</name>
      <anchor>a511a98</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta_c</name>
      <anchor>a511a99</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Jpsi</name>
      <anchor>a511a100</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_2c</name>
      <anchor>a511a101</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B0</name>
      <anchor>a511a102</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bbar0</name>
      <anchor>a511a103</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar0</name>
      <anchor>a511a104</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstarbar0</name>
      <anchor>a511a105</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_20</name>
      <anchor>a511a106</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2bar0</name>
      <anchor>a511a107</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bplus</name>
      <anchor>a511a108</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bminus</name>
      <anchor>a511a109</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstarplus</name>
      <anchor>a511a110</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstarminus</name>
      <anchor>a511a111</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2plus</name>
      <anchor>a511a112</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2minus</name>
      <anchor>a511a113</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_s0</name>
      <anchor>a511a114</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_sbar0</name>
      <anchor>a511a115</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_s0</name>
      <anchor>a511a116</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_sbar0</name>
      <anchor>a511a117</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2s0</name>
      <anchor>a511a118</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2sbar0</name>
      <anchor>a511a119</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_cplus</name>
      <anchor>a511a120</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_cminus</name>
      <anchor>a511a121</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_cplus</name>
      <anchor>a511a122</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_cminus</name>
      <anchor>a511a123</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2cplus</name>
      <anchor>a511a124</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2cminus</name>
      <anchor>a511a125</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta_b</name>
      <anchor>a511a126</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Upsilon</name>
      <anchor>a511a127</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_2b</name>
      <anchor>a511a128</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pomeron</name>
      <anchor>a511a129</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dd_1</name>
      <anchor>a511a130</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dd_1bar</name>
      <anchor>a511a131</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltaminus</name>
      <anchor>a511a132</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabarplus</name>
      <anchor>a511a133</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_0</name>
      <anchor>a511a134</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_0bar</name>
      <anchor>a511a135</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_1</name>
      <anchor>a511a136</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_1bar</name>
      <anchor>a511a137</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>n0</name>
      <anchor>a511a138</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nbar0</name>
      <anchor>a511a139</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Delta0</name>
      <anchor>a511a140</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabar0</name>
      <anchor>a511a141</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>uu_1</name>
      <anchor>a511a142</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>uu_1bar</name>
      <anchor>a511a143</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pplus</name>
      <anchor>a511a144</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pbarminus</name>
      <anchor>a511a145</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltaplus</name>
      <anchor>a511a146</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabarminus</name>
      <anchor>a511a147</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltaplus2</name>
      <anchor>a511a148</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabarminus2</name>
      <anchor>a511a149</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_0</name>
      <anchor>a511a150</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_0bar</name>
      <anchor>a511a151</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_1</name>
      <anchor>a511a152</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_1bar</name>
      <anchor>a511a153</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmaminus</name>
      <anchor>a511a154</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmabarplus</name>
      <anchor>a511a155</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarminus</name>
      <anchor>a511a156</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarbarplus</name>
      <anchor>a511a157</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda0</name>
      <anchor>a511a158</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambdabar0</name>
      <anchor>a511a159</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_0</name>
      <anchor>a511a160</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_0bar</name>
      <anchor>a511a161</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_1</name>
      <anchor>a511a162</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_1bar</name>
      <anchor>a511a163</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma0</name>
      <anchor>a511a164</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmabar0</name>
      <anchor>a511a165</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar0</name>
      <anchor>a511a166</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarbar0</name>
      <anchor>a511a167</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmaplus</name>
      <anchor>a511a168</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmabarminus</name>
      <anchor>a511a169</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarplus</name>
      <anchor>a511a170</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarbarminus</name>
      <anchor>a511a171</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ss_1</name>
      <anchor>a511a172</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ss_1bar</name>
      <anchor>a511a173</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Ximinus</name>
      <anchor>a511a174</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xibarplus</name>
      <anchor>a511a175</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistarminus</name>
      <anchor>a511a176</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistarbarplus</name>
      <anchor>a511a177</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi0</name>
      <anchor>a511a178</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xibar0</name>
      <anchor>a511a179</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar0</name>
      <anchor>a511a180</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistarbar0</name>
      <anchor>a511a181</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegaminus</name>
      <anchor>a511a182</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegabarplus</name>
      <anchor>a511a183</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_0</name>
      <anchor>a511a184</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_0bar</name>
      <anchor>a511a185</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_1</name>
      <anchor>a511a186</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_1bar</name>
      <anchor>a511a187</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_c0</name>
      <anchor>a511a188</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cbar0</name>
      <anchor>a511a189</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_c0</name>
      <anchor>a511a190</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cbar0</name>
      <anchor>a511a191</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_cplus</name>
      <anchor>a511a192</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_cbarminus</name>
      <anchor>a511a193</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_c0</name>
      <anchor>a511a194</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_cbar0</name>
      <anchor>a511a195</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_0</name>
      <anchor>a511a196</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_0bar</name>
      <anchor>a511a197</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_1</name>
      <anchor>a511a198</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_1bar</name>
      <anchor>a511a199</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cplus</name>
      <anchor>a511a200</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cbarminus</name>
      <anchor>a511a201</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cplus</name>
      <anchor>a511a202</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cbarminus</name>
      <anchor>a511a203</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cplus2</name>
      <anchor>a511a204</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cbarminus2</name>
      <anchor>a511a205</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cplus2</name>
      <anchor>a511a206</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cbarminus2</name>
      <anchor>a511a207</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_cplus</name>
      <anchor>a511a208</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_cbarminus</name>
      <anchor>a511a209</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_0</name>
      <anchor>a511a210</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_0bar</name>
      <anchor>a511a211</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_1</name>
      <anchor>a511a212</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_1bar</name>
      <anchor>a511a213</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_c0</name>
      <anchor>a511a214</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_cbar0</name>
      <anchor>a511a215</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_c0</name>
      <anchor>a511a216</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_cbar0</name>
      <anchor>a511a217</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_cplus</name>
      <anchor>a511a218</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_cbarminus</name>
      <anchor>a511a219</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_cplus</name>
      <anchor>a511a220</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_cbarminus</name>
      <anchor>a511a221</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_c0</name>
      <anchor>a511a222</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_cbar0</name>
      <anchor>a511a223</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_c0</name>
      <anchor>a511a224</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_cbar0</name>
      <anchor>a511a225</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cc_1</name>
      <anchor>a511a226</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cc_1bar</name>
      <anchor>a511a227</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccplus</name>
      <anchor>a511a228</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccbarminus</name>
      <anchor>a511a229</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccplus</name>
      <anchor>a511a230</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccbarminus</name>
      <anchor>a511a231</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccplus2</name>
      <anchor>a511a232</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccbarminus2</name>
      <anchor>a511a233</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccplus2</name>
      <anchor>a511a234</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccbarminus2</name>
      <anchor>a511a235</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_ccplus</name>
      <anchor>a511a236</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_ccbarminus</name>
      <anchor>a511a237</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_ccplus</name>
      <anchor>a511a238</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_ccbarminus</name>
      <anchor>a511a239</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_cccplus2</name>
      <anchor>a511a240</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_cccbarminus</name>
      <anchor>a511a241</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_0</name>
      <anchor>a511a242</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_0bar</name>
      <anchor>a511a243</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_1</name>
      <anchor>a511a244</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_1bar</name>
      <anchor>a511a245</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bminus</name>
      <anchor>a511a246</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bbarplus</name>
      <anchor>a511a247</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bminus</name>
      <anchor>a511a248</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bbarplus</name>
      <anchor>a511a249</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_b0</name>
      <anchor>a511a250</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_bbar0</name>
      <anchor>a511a251</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bminus</name>
      <anchor>a511a252</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbarplus</name>
      <anchor>a511a253</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bc0</name>
      <anchor>a511a254</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bcbar0</name>
      <anchor>a511a255</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_0</name>
      <anchor>a511a256</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_0bar</name>
      <anchor>a511a257</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_1</name>
      <anchor>a511a258</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_1bar</name>
      <anchor>a511a259</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_b0</name>
      <anchor>a511a260</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bbar0</name>
      <anchor>a511a261</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_b0</name>
      <anchor>a511a262</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bbar0</name>
      <anchor>a511a263</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bplus</name>
      <anchor>a511a264</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bbarminus</name>
      <anchor>a511a265</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bplus</name>
      <anchor>a511a266</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bbarminus</name>
      <anchor>a511a267</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_b0</name>
      <anchor>a511a268</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbar0</name>
      <anchor>a511a269</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bcplus</name>
      <anchor>a511a270</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bcbarminus</name>
      <anchor>a511a271</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_0</name>
      <anchor>a511a272</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_0bar</name>
      <anchor>a511a273</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_1</name>
      <anchor>a511a274</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_1bar</name>
      <anchor>a511a275</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bminus</name>
      <anchor>a511a276</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bbarplus</name>
      <anchor>a511a277</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bminus</name>
      <anchor>a511a278</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbarplus</name>
      <anchor>a511a279</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_b0</name>
      <anchor>a511a280</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bbar0</name>
      <anchor>a511a281</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_b0</name>
      <anchor>a511a282</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbar0</name>
      <anchor>a511a283</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bminus</name>
      <anchor>a511a284</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbarplus</name>
      <anchor>a511a285</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bminus</name>
      <anchor>a511a286</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbarplus</name>
      <anchor>a511a287</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bc0</name>
      <anchor>a511a288</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bcbar0</name>
      <anchor>a511a289</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_0</name>
      <anchor>a511a290</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_0bar</name>
      <anchor>a511a291</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_1</name>
      <anchor>a511a292</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_1bar</name>
      <anchor>a511a293</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bc0</name>
      <anchor>a511a294</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bcbar0</name>
      <anchor>a511a295</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bc0</name>
      <anchor>a511a296</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bcbar0</name>
      <anchor>a511a297</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bcplus</name>
      <anchor>a511a298</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bcbarminus</name>
      <anchor>a511a299</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bcplus</name>
      <anchor>a511a300</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bcbarminus</name>
      <anchor>a511a301</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegaprime_bc0</name>
      <anchor>a511a302</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegaprime_bcba</name>
      <anchor>a511a303</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bc0</name>
      <anchor>a511a304</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bcbar0</name>
      <anchor>a511a305</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bccplus</name>
      <anchor>a511a306</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bccbarminus</name>
      <anchor>a511a307</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bccplus</name>
      <anchor>a511a308</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bccbarminus</name>
      <anchor>a511a309</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bb_1</name>
      <anchor>a511a310</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bb_1bar</name>
      <anchor>a511a311</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbminus</name>
      <anchor>a511a312</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbbarplus</name>
      <anchor>a511a313</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbminus</name>
      <anchor>a511a314</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbbarplus</name>
      <anchor>a511a315</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bb0</name>
      <anchor>a511a316</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbbar0</name>
      <anchor>a511a317</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bb0</name>
      <anchor>a511a318</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbbar0</name>
      <anchor>a511a319</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbminus</name>
      <anchor>a511a320</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbbarplus</name>
      <anchor>a511a321</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbminus</name>
      <anchor>a511a322</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbbarplus</name>
      <anchor>a511a323</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbc0</name>
      <anchor>a511a324</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbcbar0</name>
      <anchor>a511a325</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbc0</name>
      <anchor>a511a326</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbcbar0</name>
      <anchor>a511a327</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbbminus</name>
      <anchor>a511a328</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbbbarplus</name>
      <anchor>a511a329</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_00</name>
      <anchor>a511a330</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b_10</name>
      <anchor>a511a331</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_0plus</name>
      <anchor>a511a332</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_0minus</name>
      <anchor>a511a333</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b_1plus</name>
      <anchor>a511a334</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b_1minus</name>
      <anchor>a511a335</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>f_0</name>
      <anchor>a511a336</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h_1</name>
      <anchor>a511a337</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_00</name>
      <anchor>a511a338</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_0bar0</name>
      <anchor>a511a339</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_10</name>
      <anchor>a511a340</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_1bar0</name>
      <anchor>a511a341</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_0plus</name>
      <anchor>a511a342</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_0minus</name>
      <anchor>a511a343</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_1plus</name>
      <anchor>a511a344</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_1minus</name>
      <anchor>a511a345</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta1440</name>
      <anchor>a511a346</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>hprime_1</name>
      <anchor>a511a347</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0plus</name>
      <anchor>a511a348</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0minus</name>
      <anchor>a511a349</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1plus</name>
      <anchor>a511a350</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1minus</name>
      <anchor>a511a351</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_00</name>
      <anchor>a511a352</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0bar0</name>
      <anchor>a511a353</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_10</name>
      <anchor>a511a354</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1bar0</name>
      <anchor>a511a355</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0splus</name>
      <anchor>a511a356</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0sminus</name>
      <anchor>a511a357</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1splus</name>
      <anchor>a511a358</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1sminus</name>
      <anchor>a511a359</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_0c</name>
      <anchor>a511a360</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h_1c</name>
      <anchor>a511a361</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_00</name>
      <anchor>a511a362</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0bar0</name>
      <anchor>a511a363</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_10</name>
      <anchor>a511a364</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1bar0</name>
      <anchor>a511a365</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0plus</name>
      <anchor>a511a366</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0minus</name>
      <anchor>a511a367</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1plus</name>
      <anchor>a511a368</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1minus</name>
      <anchor>a511a369</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0s0</name>
      <anchor>a511a370</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0sbar0</name>
      <anchor>a511a371</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1s0</name>
      <anchor>a511a372</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1sbar0</name>
      <anchor>a511a373</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0cplus</name>
      <anchor>a511a374</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0cminus</name>
      <anchor>a511a375</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1cplus</name>
      <anchor>a511a376</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1cminus</name>
      <anchor>a511a377</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_0b</name>
      <anchor>a511a378</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h_1b</name>
      <anchor>a511a379</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_10</name>
      <anchor>a511a380</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_1plus</name>
      <anchor>a511a381</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_1minus</name>
      <anchor>a511a382</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>f_1</name>
      <anchor>a511a383</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_10</name>
      <anchor>a511a384</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_1bar0</name>
      <anchor>a511a385</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_1plus</name>
      <anchor>a511a386</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_1minus</name>
      <anchor>a511a387</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>fprime_1</name>
      <anchor>a511a388</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1plus</name>
      <anchor>a511a389</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1minus</name>
      <anchor>a511a390</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_10</name>
      <anchor>a511a391</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1bar0</name>
      <anchor>a511a392</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1splus</name>
      <anchor>a511a393</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1sminus</name>
      <anchor>a511a394</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_1c</name>
      <anchor>a511a395</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_10</name>
      <anchor>a511a396</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1bar0</name>
      <anchor>a511a397</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1plus</name>
      <anchor>a511a398</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1minus</name>
      <anchor>a511a399</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1s0</name>
      <anchor>a511a400</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1sbar0</name>
      <anchor>a511a401</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1cplus</name>
      <anchor>a511a402</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1cminus</name>
      <anchor>a511a403</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_1b</name>
      <anchor>a511a404</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>psiprime</name>
      <anchor>a511a405</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Upsilonprime</name>
      <anchor>a511a406</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_L</name>
      <anchor>a511a407</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_Lbar</name>
      <anchor>a511a408</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_L</name>
      <anchor>a511a409</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_Lbar</name>
      <anchor>a511a410</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_L</name>
      <anchor>a511a411</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_Lbar</name>
      <anchor>a511a412</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_L</name>
      <anchor>a511a413</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_Lbar</name>
      <anchor>a511a414</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_1</name>
      <anchor>a511a415</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_1bar</name>
      <anchor>a511a416</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_1</name>
      <anchor>a511a417</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_1bar</name>
      <anchor>a511a418</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Lminus</name>
      <anchor>a511a419</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Lplus</name>
      <anchor>a511a420</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eL</name>
      <anchor>a511a421</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eLbar</name>
      <anchor>a511a422</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Lminus</name>
      <anchor>a511a423</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Lplus</name>
      <anchor>a511a424</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muL</name>
      <anchor>a511a425</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muLbar</name>
      <anchor>a511a426</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_1minus</name>
      <anchor>a511a427</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_1plus</name>
      <anchor>a511a428</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauL</name>
      <anchor>a511a429</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauLbar</name>
      <anchor>a511a430</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_g</name>
      <anchor>a511a431</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_10</name>
      <anchor>a511a432</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_20</name>
      <anchor>a511a433</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_1plus</name>
      <anchor>a511a434</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_1minus</name>
      <anchor>a511a435</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_30</name>
      <anchor>a511a436</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_40</name>
      <anchor>a511a437</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_2plus</name>
      <anchor>a511a438</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_2minus</name>
      <anchor>a511a439</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_Gravitino</name>
      <anchor>a511a440</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_R</name>
      <anchor>a511a441</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_Rbar</name>
      <anchor>a511a442</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_R</name>
      <anchor>a511a443</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_Rbar</name>
      <anchor>a511a444</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_R</name>
      <anchor>a511a445</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_Rbar</name>
      <anchor>a511a446</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_R</name>
      <anchor>a511a447</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_Rbar</name>
      <anchor>a511a448</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_2</name>
      <anchor>a511a449</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_2bar</name>
      <anchor>a511a450</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_2</name>
      <anchor>a511a451</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_2bar</name>
      <anchor>a511a452</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Rminus</name>
      <anchor>a511a453</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Rplus</name>
      <anchor>a511a454</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eR</name>
      <anchor>a511a455</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eRbar</name>
      <anchor>a511a456</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Rminus</name>
      <anchor>a511a457</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Rplus</name>
      <anchor>a511a458</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muR</name>
      <anchor>a511a459</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muRbar</name>
      <anchor>a511a460</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_2minus</name>
      <anchor>a511a461</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_2plus</name>
      <anchor>a511a462</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauR</name>
      <anchor>a511a463</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauRbar</name>
      <anchor>a511a464</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_tc0</name>
      <anchor>a511a465</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_tcplus</name>
      <anchor>a511a466</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_tcminus</name>
      <anchor>a511a467</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>piprime_tc0</name>
      <anchor>a511a468</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta_tc0</name>
      <anchor>a511a469</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_tc0</name>
      <anchor>a511a470</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_tcplus</name>
      <anchor>a511a471</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_tcminus</name>
      <anchor>a511a472</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>omega_tc</name>
      <anchor>a511a473</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>V8_tc</name>
      <anchor>a511a474</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_22_1_tc</name>
      <anchor>a511a475</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_22_8_tc</name>
      <anchor>a511a476</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_11_tc</name>
      <anchor>a511a477</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_12_tc</name>
      <anchor>a511a478</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_21_tc</name>
      <anchor>a511a479</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_22_tc</name>
      <anchor>a511a480</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dstar</name>
      <anchor>a511a481</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dstarbar</name>
      <anchor>a511a482</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ustar</name>
      <anchor>a511a483</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ustarbar</name>
      <anchor>a511a484</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>estarminus</name>
      <anchor>a511a485</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>estarbarplus</name>
      <anchor>a511a486</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nustar_e0</name>
      <anchor>a511a487</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nustar_ebar0</name>
      <anchor>a511a488</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Gravitonstar</name>
      <anchor>a511a489</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_Re</name>
      <anchor>a511a490</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_Rmu</name>
      <anchor>a511a491</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_Rtau</name>
      <anchor>a511a492</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Z_R0</name>
      <anchor>a511a493</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>W_Rplus</name>
      <anchor>a511a494</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>W_Rminus</name>
      <anchor>a511a495</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Lplus2</name>
      <anchor>a511a496</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Lminus2</name>
      <anchor>a511a497</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Rplus2</name>
      <anchor>a511a498</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Rminus2</name>
      <anchor>a511a499</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_diff0</name>
      <anchor>a511a500</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_diffrplus</name>
      <anchor>a511a501</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_diffrminus</name>
      <anchor>a511a502</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>omega_di</name>
      <anchor>a511a503</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>phi_diff</name>
      <anchor>a511a504</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Jpsi_di</name>
      <anchor>a511a505</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>n_diffr0</name>
      <anchor>a511a506</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>n_diffrbar0</name>
      <anchor>a511a507</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>p_diffrplus</name>
      <anchor>a511a508</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>p_diffrbarminus</name>
      <anchor>a511a509</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>undefined</name>
      <anchor>a511a510</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Pointer</name>
    <filename>namespaceThePEG_1_1Pointer.html</filename>
    <class kind="struct">ThePEG::Pointer::Ptr</class>
    <class kind="struct">ThePEG::Pointer::PtrTraitsType</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; T * &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; const T * &gt;</class>
    <class kind="class">ThePEG::Pointer::RCPtrBase</class>
    <class kind="class">ThePEG::Pointer::RCPtr</class>
    <class kind="class">ThePEG::Pointer::ConstRCPtr</class>
    <class kind="class">ThePEG::Pointer::TransientRCPtr</class>
    <class kind="class">ThePEG::Pointer::TransientConstRCPtr</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; RCPtr&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; ConstRCPtr&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; TransientRCPtr&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; TransientConstRCPtr&lt; T &gt; &gt;</class>
    <class kind="class">ThePEG::Pointer::ReferenceCounted</class>
    <member kind="function">
      <type>T1</type>
      <name>dynamic_ptr_cast</name>
      <anchor>a0</anchor>
      <arglist>(const T2 &amp;t2)</arglist>
    </member>
    <member kind="function">
      <type>T1</type>
      <name>const_ptr_cast</name>
      <anchor>a1</anchor>
      <arglist>(const T2 &amp;t2)</arglist>
    </member>
    <member kind="function">
      <type>Ptr</type>
      <name>ptr_new</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Ptr</type>
      <name>ptr_new</name>
      <anchor>a3</anchor>
      <arglist>(typename PtrTraits&lt; Ptr &gt;::const_reference t)</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>new_ptr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>new_ptr</name>
      <anchor>a5</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>TPtr</type>
      <name>ptr_cast</name>
      <anchor>a6</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="function">
      <type>TPtr</type>
      <name>ptr_cast_const</name>
      <anchor>a7</anchor>
      <arglist>(const T *t)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::Ptr</name>
    <filename>structThePEG_1_1Pointer_1_1Ptr.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pointer</type>
      <name>ptr</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const_pointer</type>
      <name>cptr</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_pointer</type>
      <name>tptr</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_const_pointer</type>
      <name>tcptr</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pointer</type>
      <name>p</name>
      <anchor>w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const_pointer</type>
      <name>cp</name>
      <anchor>w9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_pointer</type>
      <name>tp</name>
      <anchor>w10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_const_pointer</type>
      <name>tcp</name>
      <anchor>w11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraitsType</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraitsType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; T * &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01T_01_5_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(T *p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(R *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; const T * &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01const_01T_01_5_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>const T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const T *p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(const R *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const T *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::RCPtrBase</name>
    <filename>classThePEG_1_1Pointer_1_1RCPtrBase.html</filename>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>increment</name>
      <anchor>b0</anchor>
      <arglist>(const ReferenceCounted *)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>release</name>
      <anchor>b1</anchor>
      <arglist>(const ReferenceCounted *)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>ReferenceCounted::CounterType</type>
      <name>CounterType</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::RCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1RCPtr.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::RCPtrBase</base>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const RCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a3</anchor>
      <arglist>(pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>create</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>create</name>
      <anchor>a6</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a7</anchor>
      <arglist>(const RCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a8</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a9</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>assignConst</name>
      <anchor>a10</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>assign</name>
      <anchor>a11</anchor>
      <arglist>(pointer)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a12</anchor>
      <arglist>(RCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a13</anchor>
      <arglist>(const RCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a14</anchor>
      <arglist>(const RCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a15</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a16</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a17</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a18</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a19</anchor>
      <arglist>(const RCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a20</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a21</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator T *</name>
      <anchor>a22</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>operator-&gt;</name>
      <anchor>a23</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator *</name>
      <anchor>a24</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" static="yes">
      <type>RCPtr</type>
      <name>Create</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RCPtr</type>
      <name>Create</name>
      <anchor>e1</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>increment</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>release</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pointer</type>
      <name>ptr</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::ConstRCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1ConstRCPtr.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::RCPtrBase</base>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const ConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a3</anchor>
      <arglist>(const_pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ConstRCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const ConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>ConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>ConstRCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a7</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a8</anchor>
      <arglist>(ConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a9</anchor>
      <arglist>(const ConstRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a10</anchor>
      <arglist>(const ConstRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a11</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a12</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a13</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a14</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a15</anchor>
      <arglist>(const ConstRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a16</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator const T *</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_pointer</type>
      <name>operator-&gt;</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_reference</type>
      <name>operator *</name>
      <anchor>a20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>increment</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>release</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const_pointer</type>
      <name>ptr</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::TransientRCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1TransientRCPtr.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const TransientRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a3</anchor>
      <arglist>(pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TransientRCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const TransientRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a7</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>assignConst</name>
      <anchor>a8</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a9</anchor>
      <arglist>(const TransientRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a10</anchor>
      <arglist>(const TransientRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a11</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a12</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a13</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a14</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a15</anchor>
      <arglist>(const TransientRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a16</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator T *</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>operator-&gt;</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator *</name>
      <anchor>a20</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pointer</type>
      <name>ptr</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::TransientConstRCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1TransientConstRCPtr.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const TransientConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a3</anchor>
      <arglist>(const_pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TransientConstRCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TransientConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const TransientConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>TransientConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>TransientConstRCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a7</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a8</anchor>
      <arglist>(const TransientConstRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a9</anchor>
      <arglist>(const TransientConstRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a10</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a11</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a12</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a13</anchor>
      <arglist>(const UPtr &amp;u) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a14</anchor>
      <arglist>(const TransientConstRCPtr &amp;p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a15</anchor>
      <arglist>(const_pointer p) const </arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a16</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator const T *</name>
      <anchor>a17</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_pointer</type>
      <name>operator-&gt;</name>
      <anchor>a18</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function">
      <type>const_reference</type>
      <name>operator *</name>
      <anchor>a19</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const_pointer</type>
      <name>ptr</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; RCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01RCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const RCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; ConstRCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01ConstRCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>const T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const ConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(const_pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; TransientRCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01TransientRCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const TransientRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e1</anchor>
      <arglist>(transient_pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_pointer</type>
      <name>DynamicCast</name>
      <anchor>e2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_pointer</type>
      <name>ConstCast</name>
      <anchor>e3</anchor>
      <arglist>(transient_const_pointer c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_pointer</type>
      <name>PtrCast</name>
      <anchor>e4</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; TransientConstRCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01TransientConstRCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>const T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const TransientConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e1</anchor>
      <arglist>(transient_const_pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_const_pointer</type>
      <name>DynamicCast</name>
      <anchor>e2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_const_pointer</type>
      <name>ConstCast</name>
      <anchor>e3</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_const_pointer</type>
      <name>PtrCast</name>
      <anchor>e4</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::ReferenceCounted</name>
    <filename>classThePEG_1_1Pointer_1_1ReferenceCounted.html</filename>
    <member kind="typedef">
      <type>unsigned int</type>
      <name>CounterType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>CounterType</type>
      <name>referenceCount</name>
      <anchor>a0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ReferenceCounted</name>
      <anchor>z967_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ReferenceCounted</name>
      <anchor>z967_1</anchor>
      <arglist>(const ReferenceCounted &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ReferenceCounted &amp;</type>
      <name>operator=</name>
      <anchor>z967_2</anchor>
      <arglist>(const ReferenceCounted &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>incrementReferenceCount</name>
      <anchor>d0</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>decrementReferenceCount</name>
      <anchor>d1</anchor>
      <arglist>() const </arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CounterType</type>
      <name>theReferenceCounter</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>RCPtrBase</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Units</name>
    <filename>namespaceThePEG_1_1Units.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>Mass</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Time</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Length</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Charge</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>AngularMomentum</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Area</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Area</type>
      <name>CrossSection</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy2</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy4</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy2XSec</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>DiffXSec</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Diff2XSec</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Diff3XSec</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>InvEnergy</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>InvEnergy2</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>InvEnergy4</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Energy2</type>
      <name>Scale</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector3</type>
      <name>Point</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector3</type>
      <name>Distance</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector3</type>
      <name>Momentum3</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LorentzVector</type>
      <name>LorentzDistance</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Lorentz5Vector&lt; Length &gt;</type>
      <name>Lorentz5Distance</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LorentzVector</type>
      <name>LorentzPoint</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LorentzVector</type>
      <name>LorentzMomentum</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Lorentz5Vector&lt; Energy &gt;</type>
      <name>Lorentz5Momentum</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Transverse&lt; Energy &gt;</type>
      <name>TransverseMomentum</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const Energy2</type>
      <name>GeV2</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
  </compound>
</tagfile>
