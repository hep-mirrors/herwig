<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>
<tagfile>
  <compound kind="page">
    <name>index</name>
    <title>T&lt;small&gt;HE&lt;/small&gt;PEG Reference Manual</title>
    <filename>index</filename>
    <docanchor>ThePEGIntroduction</docanchor>
  </compound>
  <compound kind="file">
    <name>ACDCGenConfig.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/ACDC/</path>
    <filename>ACDCGenConfig_8h</filename>
    <namespace>ACDCGenerator</namespace>
    <member kind="typedef">
      <type>short</type>
      <name>DimType</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>algorithm.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Config/</path>
    <filename>algorithm_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::IteratorRange</class>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::iterator &gt;</type>
      <name>range</name>
      <anchor>a340</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_iterator &gt;</type>
      <name>range</name>
      <anchor>a341</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a342</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a343</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a344</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find</name>
      <anchor>a345</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find_if</name>
      <anchor>a346</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, Pred p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a347</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a348</anchor>
      <arglist>(Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a349</anchor>
      <arglist>(const Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find</name>
      <anchor>a350</anchor>
      <arglist>(Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find</name>
      <anchor>a351</anchor>
      <arglist>(const Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find_if</name>
      <anchor>a352</anchor>
      <arglist>(Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find_if</name>
      <anchor>a353</anchor>
      <arglist>(const Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a354</anchor>
      <arglist>(Cont &amp;c, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>Containers.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Config/</path>
    <filename>Containers_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a355</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a356</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a357</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a358</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a359</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a360</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>set&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a361</anchor>
      <arglist>(set&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a362</anchor>
      <arglist>(OStream &amp;os, const vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a363</anchor>
      <arglist>(IStream &amp;is, vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a364</anchor>
      <arglist>(OStream &amp;os, const set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a365</anchor>
      <arglist>(IStream &amp;is, set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a366</anchor>
      <arglist>(OStream &amp;os, const map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a367</anchor>
      <arglist>(IStream &amp;is, map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PDPtr, less&lt; PDPtr &gt;, Allocator&lt; PDPtr &gt; &gt;</type>
      <name>ParticleDataSet</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PDPtr &gt;</type>
      <name>PDVector</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPDPtr &gt;</type>
      <name>cPDVector</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPtr &gt;</type>
      <name>tPDVector</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPDPtr &gt;</type>
      <name>tcPDVector</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PMPtr, less&lt; PMPtr &gt;, Allocator&lt; PMPtr &gt; &gt;</type>
      <name>MatcherSet</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; DMPtr, less&lt; DMPtr &gt;, Allocator&lt; DMPtr &gt; &gt;</type>
      <name>DecayModeSet</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>ObjectSet</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>DependencySet</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; long, PDPtr, less&lt; long &gt;, Allocator&lt; PDPtr &gt; &gt;</type>
      <name>ParticleMap</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, IBPtr, less&lt; string &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>ObjectMap</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; IBPtr, DependencySet, less&lt; IBPtr &gt;, Allocator&lt; DependencySet &gt; &gt;</type>
      <name>DependencyMap</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; IBPtr &gt;</type>
      <name>IVector</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cIBPtr &gt;</type>
      <name>CIVector</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>ParticleVector</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>PVector</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPPtr &gt;</type>
      <name>cPVector</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tPVector</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPPtr &gt;</type>
      <name>tcPVector</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, const InterfaceBase *, less&lt; string &gt;, Allocator&lt; const InterfaceBase * &gt; &gt;</type>
      <name>InterfaceMap</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; InterfacedBase &gt;</type>
      <name>TranslationMap</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, EGPtr, less&lt; string &gt;, Allocator&lt; EGPtr &gt; &gt;</type>
      <name>GeneratorMap</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; AnaPtr &gt;</type>
      <name>AnalysisVector</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PBPtr, PBPtr &gt;</type>
      <name>PBPair</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PDPtr, PDPtr &gt;</type>
      <name>PDPair</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPDPtr, cPDPtr &gt;</type>
      <name>cPDPair</name>
      <anchor>a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPDPtr, tPDPtr &gt;</type>
      <name>tPDPair</name>
      <anchor>a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPDPtr, tcPDPtr &gt;</type>
      <name>tcPDPair</name>
      <anchor>a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PPtr, PPtr &gt;</type>
      <name>PPair</name>
      <anchor>a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPPtr, cPPtr &gt;</type>
      <name>cPPair</name>
      <anchor>a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPPtr, tPPtr &gt;</type>
      <name>tPPair</name>
      <anchor>a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPPtr, tcPPtr &gt;</type>
      <name>tcPPair</name>
      <anchor>a34</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Interval&lt; Energy2 &gt;</type>
      <name>SInterval</name>
      <anchor>a35</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Energy2 &gt;</type>
      <name>SVector</name>
      <anchor>a36</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SInterval &gt;</type>
      <name>SIntervalVector</name>
      <anchor>a37</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PBPair &gt;</type>
      <name>PartonPairVec</name>
      <anchor>a38</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPair &gt;</type>
      <name>tPartonPairVec</name>
      <anchor>a39</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tColinePtr, tColinePtr &gt;</type>
      <name>tColinePair</name>
      <anchor>a40</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PBPtr &gt;</type>
      <name>PartonVector</name>
      <anchor>a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tDMPtr, less&lt; tDMPtr &gt;, Allocator&lt; tDMPtr &gt; &gt;</type>
      <name>DecaySet</name>
      <anchor>a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; string, less&lt; string &gt;, Allocator&lt; string &gt; &gt;</type>
      <name>StringSet</name>
      <anchor>a43</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Energy &gt;</type>
      <name>EnergyVector</name>
      <anchor>a44</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; EIPtr &gt;</type>
      <name>EIVector</name>
      <anchor>a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; MEPtr &gt;</type>
      <name>MEVector</name>
      <anchor>a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a47</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; double, double &gt;</type>
      <name>DPair</name>
      <anchor>a48</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>EventConfig.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/EventRecord/</path>
    <filename>EventConfig_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes">ThePEG/Config/ThePEG.h</includes>
    <includes id="LorentzRotation_8h" name="LorentzRotation.h" local="yes">ThePEG/CLHEPWrap/LorentzRotation.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::EventConfig</class>
    <member kind="typedef">
      <type>Base</type>
      <name>EventRecordBase</name>
      <anchor>a234</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::pointer</type>
      <name>EventBasePtr</name>
      <anchor>a235</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::const_pointer</type>
      <name>cEventBasePtr</name>
      <anchor>a236</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_pointer</type>
      <name>tEventBasePtr</name>
      <anchor>a237</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_const_pointer</type>
      <name>tcEventBasePtr</name>
      <anchor>a238</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; EventRecordBase &gt;</type>
      <name>EventTranslationMap</name>
      <anchor>a239</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle</type>
      <name>ParticleClass</name>
      <anchor>a240</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>ParticleDataClass</name>
      <anchor>a241</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::pointer</type>
      <name>EventPDPtr</name>
      <anchor>a242</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::const_pointer</type>
      <name>cEventPDPtr</name>
      <anchor>a243</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_pointer</type>
      <name>tEventPDPtr</name>
      <anchor>a244</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_const_pointer</type>
      <name>tcEventPDPtr</name>
      <anchor>a245</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tParticleVector</name>
      <anchor>a246</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PPtr, less&lt; PPtr &gt;, Allocator&lt; PPtr &gt; &gt;</type>
      <name>ParticleSet</name>
      <anchor>a247</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tPPtr, less&lt; tPPtr &gt;, Allocator&lt; tPPtr &gt; &gt;</type>
      <name>tParticleSet</name>
      <anchor>a248</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tcPPtr, less&lt; tcPPtr &gt;, Allocator&lt; tcPPtr &gt; &gt;</type>
      <name>tcParticleSet</name>
      <anchor>a249</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepPtr &gt;</type>
      <name>StepVector</name>
      <anchor>a250</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SubProPtr &gt;</type>
      <name>SubProcessVector</name>
      <anchor>a251</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tSubProPtr &gt;</type>
      <name>tSubProcessVector</name>
      <anchor>a252</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; CollPtr &gt;</type>
      <name>CollisionVector</name>
      <anchor>a253</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; StepPtr, less&lt; StepPtr &gt;, Allocator&lt; StepPtr &gt; &gt;</type>
      <name>StepSet</name>
      <anchor>a254</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; SubProPtr, less&lt; SubProPtr &gt;, Allocator&lt; SubProPtr &gt; &gt;</type>
      <name>SubProcessSet</name>
      <anchor>a255</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>HelicityDefinitions.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Helicity/</path>
    <filename>HelicityDefinitions_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <namespace>ThePEG::Helicity</namespace>
    <class kind="class">ThePEG::Helicity::HelicityLogicalError</class>
    <class kind="class">ThePEG::Helicity::HelicityConsistencyError</class>
    <member kind="enumeration">
      <name>DiracRep</name>
      <anchor>a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HELASDRep</name>
      <anchor>a41a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HaberDRep</name>
      <anchor>a41a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>defaultDRep</name>
      <anchor>a41a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>SpinorType</name>
      <anchor>a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>u_spinortype</name>
      <anchor>a42a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>v_spinortype</name>
      <anchor>a42a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown_spinortype</name>
      <anchor>a42a9</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>JamesRandom.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>JamesRandom_8h</filename>
  </compound>
  <compound kind="file">
    <name>LorentzRotation.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>LorentzRotation_8h</filename>
  </compound>
  <compound kind="file">
    <name>LorentzVector.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>LorentzVector_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="function">
      <type>double</type>
      <name>dirPlus</name>
      <anchor>a324</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirMinus</name>
      <anchor>a325</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirZ</name>
      <anchor>a326</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirTheta</name>
      <anchor>a327</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirCosTheta</name>
      <anchor>a328</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Vector3</type>
      <name>dirBoostVector</name>
      <anchor>a329</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a330</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a331</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a332</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a333</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a334</anchor>
      <arglist>(OStream &amp;os, const LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a335</anchor>
      <arglist>(IStream &amp;is, LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>Matrix.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>Matrix_8h</filename>
  </compound>
  <compound kind="file">
    <name>PhysicalConstants.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>PhysicalConstants_8h</filename>
  </compound>
  <compound kind="file">
    <name>Pointers.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Config/</path>
    <filename>Pointers_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_TEMPLATE_POINTERS</name>
      <anchor>a0</anchor>
      <arglist>(full, abbrev)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_POINTERS</name>
      <anchor>a1</anchor>
      <arglist>(full, abbrev)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_CLASS_POINTERS</name>
      <anchor>a2</anchor>
      <arglist>(full, abbrev)</arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::pointer</type>
      <name>IBPtr</name>
      <anchor>a49</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::const_pointer</type>
      <name>cIBPtr</name>
      <anchor>a50</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_pointer</type>
      <name>tIBPtr</name>
      <anchor>a51</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_const_pointer</type>
      <name>tcIBPtr</name>
      <anchor>a52</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::pointer</type>
      <name>IPtr</name>
      <anchor>a53</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::const_pointer</type>
      <name>cIPtr</name>
      <anchor>a54</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_pointer</type>
      <name>tIPtr</name>
      <anchor>a55</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_const_pointer</type>
      <name>tcIPtr</name>
      <anchor>a56</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::pointer</type>
      <name>PDPtr</name>
      <anchor>a57</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::const_pointer</type>
      <name>cPDPtr</name>
      <anchor>a58</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_pointer</type>
      <name>tPDPtr</name>
      <anchor>a59</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_const_pointer</type>
      <name>tcPDPtr</name>
      <anchor>a60</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::pointer</type>
      <name>PMPtr</name>
      <anchor>a61</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::const_pointer</type>
      <name>cPMPtr</name>
      <anchor>a62</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_pointer</type>
      <name>tPMPtr</name>
      <anchor>a63</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_const_pointer</type>
      <name>tcPMPtr</name>
      <anchor>a64</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::pointer</type>
      <name>DMPtr</name>
      <anchor>a65</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::const_pointer</type>
      <name>cDMPtr</name>
      <anchor>a66</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_pointer</type>
      <name>tDMPtr</name>
      <anchor>a67</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_const_pointer</type>
      <name>tcDMPtr</name>
      <anchor>a68</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::pointer</type>
      <name>PPtr</name>
      <anchor>a69</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::const_pointer</type>
      <name>cPPtr</name>
      <anchor>a70</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_pointer</type>
      <name>tPPtr</name>
      <anchor>a71</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_const_pointer</type>
      <name>tcPPtr</name>
      <anchor>a72</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::pointer</type>
      <name>EHPtr</name>
      <anchor>a73</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::const_pointer</type>
      <name>cEHPtr</name>
      <anchor>a74</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_pointer</type>
      <name>tEHPtr</name>
      <anchor>a75</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_const_pointer</type>
      <name>tcEHPtr</name>
      <anchor>a76</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::pointer</type>
      <name>EGPtr</name>
      <anchor>a77</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::const_pointer</type>
      <name>cEGPtr</name>
      <anchor>a78</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_pointer</type>
      <name>tEGPtr</name>
      <anchor>a79</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_const_pointer</type>
      <name>tcEGPtr</name>
      <anchor>a80</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::pointer</type>
      <name>FEGPtr</name>
      <anchor>a81</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::const_pointer</type>
      <name>cFEGPtr</name>
      <anchor>a82</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::transient_pointer</type>
      <name>tFEGPtr</name>
      <anchor>a83</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::transient_const_pointer</type>
      <name>tcFEGPtr</name>
      <anchor>a84</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::pointer</type>
      <name>PEGPtr</name>
      <anchor>a85</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::const_pointer</type>
      <name>cPEGPtr</name>
      <anchor>a86</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::transient_pointer</type>
      <name>tPEGPtr</name>
      <anchor>a87</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::transient_const_pointer</type>
      <name>tcPEGPtr</name>
      <anchor>a88</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::pointer</type>
      <name>CollHdlPtr</name>
      <anchor>a89</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::const_pointer</type>
      <name>cCollHdlPtr</name>
      <anchor>a90</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::transient_pointer</type>
      <name>tCollHdlPtr</name>
      <anchor>a91</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::transient_const_pointer</type>
      <name>tcCollHdlPtr</name>
      <anchor>a92</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::pointer</type>
      <name>PartCollHdlPtr</name>
      <anchor>a93</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::const_pointer</type>
      <name>cPartCollHdlPtr</name>
      <anchor>a94</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::transient_pointer</type>
      <name>tPartCollHdlPtr</name>
      <anchor>a95</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::transient_const_pointer</type>
      <name>tcPartCollHdlPtr</name>
      <anchor>a96</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::pointer</type>
      <name>SubHdlPtr</name>
      <anchor>a97</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::const_pointer</type>
      <name>cSubHdlPtr</name>
      <anchor>a98</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::transient_pointer</type>
      <name>tSubHdlPtr</name>
      <anchor>a99</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::transient_const_pointer</type>
      <name>tcSubHdlPtr</name>
      <anchor>a100</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::pointer</type>
      <name>StepHdlPtr</name>
      <anchor>a101</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::const_pointer</type>
      <name>cStepHdlPtr</name>
      <anchor>a102</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_pointer</type>
      <name>tStepHdlPtr</name>
      <anchor>a103</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_const_pointer</type>
      <name>tcStepHdlPtr</name>
      <anchor>a104</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::pointer</type>
      <name>HintPtr</name>
      <anchor>a105</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::const_pointer</type>
      <name>cHintPtr</name>
      <anchor>a106</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_pointer</type>
      <name>tHintPtr</name>
      <anchor>a107</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_const_pointer</type>
      <name>tcHintPtr</name>
      <anchor>a108</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::pointer</type>
      <name>HadrHdlPtr</name>
      <anchor>a109</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::const_pointer</type>
      <name>cHadrHdlPtr</name>
      <anchor>a110</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_pointer</type>
      <name>tHadrHdlPtr</name>
      <anchor>a111</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_const_pointer</type>
      <name>tcHadrHdlPtr</name>
      <anchor>a112</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::pointer</type>
      <name>CascHdlPtr</name>
      <anchor>a113</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::const_pointer</type>
      <name>cCascHdlPtr</name>
      <anchor>a114</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_pointer</type>
      <name>tCascHdlPtr</name>
      <anchor>a115</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_const_pointer</type>
      <name>tcCascHdlPtr</name>
      <anchor>a116</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::pointer</type>
      <name>MIHdlPtr</name>
      <anchor>a117</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::const_pointer</type>
      <name>cMIHdlPtr</name>
      <anchor>a118</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_pointer</type>
      <name>tMIHdlPtr</name>
      <anchor>a119</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_const_pointer</type>
      <name>tcMIHdlPtr</name>
      <anchor>a120</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::pointer</type>
      <name>DecayHdlPtr</name>
      <anchor>a121</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::const_pointer</type>
      <name>cDecayHdlPtr</name>
      <anchor>a122</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_pointer</type>
      <name>tDecayHdlPtr</name>
      <anchor>a123</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_const_pointer</type>
      <name>tcDecayHdlPtr</name>
      <anchor>a124</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::pointer</type>
      <name>PileHdlPtr</name>
      <anchor>a125</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::const_pointer</type>
      <name>cPileHdlPtr</name>
      <anchor>a126</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_pointer</type>
      <name>tPileHdlPtr</name>
      <anchor>a127</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_const_pointer</type>
      <name>tcPileHdlPtr</name>
      <anchor>a128</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::pointer</type>
      <name>LumiFnPtr</name>
      <anchor>a129</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::const_pointer</type>
      <name>cLumiFnPtr</name>
      <anchor>a130</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_pointer</type>
      <name>tLumiFnPtr</name>
      <anchor>a131</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_const_pointer</type>
      <name>tcLumiFnPtr</name>
      <anchor>a132</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::pointer</type>
      <name>KinCutPtr</name>
      <anchor>a133</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::const_pointer</type>
      <name>cKinCutPtr</name>
      <anchor>a134</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_pointer</type>
      <name>tKinCutPtr</name>
      <anchor>a135</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_const_pointer</type>
      <name>tcKinCutPtr</name>
      <anchor>a136</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::pointer</type>
      <name>PExtrPtr</name>
      <anchor>a137</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::const_pointer</type>
      <name>cPExtrPtr</name>
      <anchor>a138</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_pointer</type>
      <name>tPExtrPtr</name>
      <anchor>a139</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_const_pointer</type>
      <name>tcPExtrPtr</name>
      <anchor>a140</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::pointer</type>
      <name>RanGenPtr</name>
      <anchor>a141</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::const_pointer</type>
      <name>cRanGenPtr</name>
      <anchor>a142</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_pointer</type>
      <name>tRanGenPtr</name>
      <anchor>a143</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_const_pointer</type>
      <name>tcRanGenPtr</name>
      <anchor>a144</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::pointer</type>
      <name>AnaPtr</name>
      <anchor>a145</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::const_pointer</type>
      <name>cAnaPtr</name>
      <anchor>a146</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_pointer</type>
      <name>tAnaPtr</name>
      <anchor>a147</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_const_pointer</type>
      <name>tcAnaPtr</name>
      <anchor>a148</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::pointer</type>
      <name>EvtManipPtr</name>
      <anchor>a149</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::const_pointer</type>
      <name>cEvtManipPtr</name>
      <anchor>a150</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_pointer</type>
      <name>tEvtManipPtr</name>
      <anchor>a151</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_const_pointer</type>
      <name>tcEvtManipPtr</name>
      <anchor>a152</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::pointer</type>
      <name>DecayerPtr</name>
      <anchor>a153</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::const_pointer</type>
      <name>cDecayerPtr</name>
      <anchor>a154</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_pointer</type>
      <name>tDecayerPtr</name>
      <anchor>a155</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_const_pointer</type>
      <name>tcDecayerPtr</name>
      <anchor>a156</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::pointer</type>
      <name>EventPtr</name>
      <anchor>a157</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::const_pointer</type>
      <name>cEventPtr</name>
      <anchor>a158</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_pointer</type>
      <name>tEventPtr</name>
      <anchor>a159</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_const_pointer</type>
      <name>tcEventPtr</name>
      <anchor>a160</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::pointer</type>
      <name>CollPtr</name>
      <anchor>a161</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::const_pointer</type>
      <name>cCollPtr</name>
      <anchor>a162</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_pointer</type>
      <name>tCollPtr</name>
      <anchor>a163</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_const_pointer</type>
      <name>tcCollPtr</name>
      <anchor>a164</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::pointer</type>
      <name>StepPtr</name>
      <anchor>a165</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::const_pointer</type>
      <name>cStepPtr</name>
      <anchor>a166</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_pointer</type>
      <name>tStepPtr</name>
      <anchor>a167</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_const_pointer</type>
      <name>tcStepPtr</name>
      <anchor>a168</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::pointer</type>
      <name>SubProPtr</name>
      <anchor>a169</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::const_pointer</type>
      <name>cSubProPtr</name>
      <anchor>a170</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_pointer</type>
      <name>tSubProPtr</name>
      <anchor>a171</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_const_pointer</type>
      <name>tcSubProPtr</name>
      <anchor>a172</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::pointer</type>
      <name>StrategyPtr</name>
      <anchor>a173</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::const_pointer</type>
      <name>cStrategyPtr</name>
      <anchor>a174</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_pointer</type>
      <name>tStrategyPtr</name>
      <anchor>a175</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_const_pointer</type>
      <name>tcStrategyPtr</name>
      <anchor>a176</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::pointer</type>
      <name>XCombPtr</name>
      <anchor>a177</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::const_pointer</type>
      <name>cXCombPtr</name>
      <anchor>a178</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_pointer</type>
      <name>tXCombPtr</name>
      <anchor>a179</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_const_pointer</type>
      <name>tcXCombPtr</name>
      <anchor>a180</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::pointer</type>
      <name>SBinPtr</name>
      <anchor>a181</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::const_pointer</type>
      <name>cSBinPtr</name>
      <anchor>a182</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::transient_pointer</type>
      <name>tSBinPtr</name>
      <anchor>a183</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::transient_const_pointer</type>
      <name>tcSBinPtr</name>
      <anchor>a184</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::pointer</type>
      <name>RemHPtr</name>
      <anchor>a185</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::const_pointer</type>
      <name>cRemHPtr</name>
      <anchor>a186</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_pointer</type>
      <name>tRemHPtr</name>
      <anchor>a187</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_const_pointer</type>
      <name>tcRemHPtr</name>
      <anchor>a188</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::pointer</type>
      <name>PDFPtr</name>
      <anchor>a189</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::const_pointer</type>
      <name>cPDFPtr</name>
      <anchor>a190</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_pointer</type>
      <name>tPDFPtr</name>
      <anchor>a191</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_const_pointer</type>
      <name>tcPDFPtr</name>
      <anchor>a192</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::pointer</type>
      <name>MEPtr</name>
      <anchor>a193</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::const_pointer</type>
      <name>cMEPtr</name>
      <anchor>a194</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::transient_pointer</type>
      <name>tMEPtr</name>
      <anchor>a195</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::transient_const_pointer</type>
      <name>tcMEPtr</name>
      <anchor>a196</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::pointer</type>
      <name>PSPtr</name>
      <anchor>a197</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::const_pointer</type>
      <name>cPSPtr</name>
      <anchor>a198</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::transient_pointer</type>
      <name>tPSPtr</name>
      <anchor>a199</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::transient_const_pointer</type>
      <name>tcPSPtr</name>
      <anchor>a200</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::pointer</type>
      <name>SMPtr</name>
      <anchor>a201</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::const_pointer</type>
      <name>cSMPtr</name>
      <anchor>a202</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_pointer</type>
      <name>tSMPtr</name>
      <anchor>a203</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_const_pointer</type>
      <name>tcSMPtr</name>
      <anchor>a204</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::pointer</type>
      <name>PBPtr</name>
      <anchor>a205</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::const_pointer</type>
      <name>cPBPtr</name>
      <anchor>a206</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::transient_pointer</type>
      <name>tPBPtr</name>
      <anchor>a207</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::transient_const_pointer</type>
      <name>tcPBPtr</name>
      <anchor>a208</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::pointer</type>
      <name>CBPtr</name>
      <anchor>a209</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::const_pointer</type>
      <name>cCBPtr</name>
      <anchor>a210</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_pointer</type>
      <name>tCBPtr</name>
      <anchor>a211</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_const_pointer</type>
      <name>tcCBPtr</name>
      <anchor>a212</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::pointer</type>
      <name>SpinPtr</name>
      <anchor>a213</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::const_pointer</type>
      <name>cSpinPtr</name>
      <anchor>a214</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_pointer</type>
      <name>tSpinPtr</name>
      <anchor>a215</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_const_pointer</type>
      <name>tcSpinPtr</name>
      <anchor>a216</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::pointer</type>
      <name>EIPtr</name>
      <anchor>a217</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::const_pointer</type>
      <name>cEIPtr</name>
      <anchor>a218</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_pointer</type>
      <name>tEIPtr</name>
      <anchor>a219</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_const_pointer</type>
      <name>tcEIPtr</name>
      <anchor>a220</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::pointer</type>
      <name>ReweightPtr</name>
      <anchor>a221</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::const_pointer</type>
      <name>cReweightPtr</name>
      <anchor>a222</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_pointer</type>
      <name>tReweightPtr</name>
      <anchor>a223</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_const_pointer</type>
      <name>tcReweightPtr</name>
      <anchor>a224</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::pointer</type>
      <name>ColinePtr</name>
      <anchor>a225</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::const_pointer</type>
      <name>cColinePtr</name>
      <anchor>a226</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_pointer</type>
      <name>tColinePtr</name>
      <anchor>a227</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_const_pointer</type>
      <name>tcColinePtr</name>
      <anchor>a228</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>a229</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>a230</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>a231</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>a232</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>RandBreitWigner.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandBreitWigner_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandExponential.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandExponential_8h</filename>
  </compound>
  <compound kind="file">
    <name>RandomEngine.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>RandomEngine_8h</filename>
  </compound>
  <compound kind="file">
    <name>Rotation.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>Rotation_8h</filename>
  </compound>
  <compound kind="file">
    <name>sstream.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Utilities/</path>
    <filename>sstream_8h</filename>
    <includes id="ThePEG_8h" name="ThePEG.h" local="yes">ThePEG/Config/ThePEG.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="class">ThePEG::ostringstream</class>
    <class kind="class">ThePEG::istringstream</class>
  </compound>
  <compound kind="file">
    <name>StandardMatchers.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/PDT/</path>
    <filename>StandardMatchers_8h</filename>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::AnyMatcher</class>
    <class kind="struct">ThePEG::ChargedMatcher</class>
    <class kind="struct">ThePEG::PositiveMatcher</class>
    <class kind="struct">ThePEG::NeutralMatcher</class>
    <class kind="struct">ThePEG::NegativeMatcher</class>
    <class kind="struct">ThePEG::BaryonMatcher</class>
    <class kind="struct">ThePEG::MesonMatcher</class>
    <class kind="struct">ThePEG::DiquarkMatcher</class>
    <class kind="struct">ThePEG::QuarkMatcher</class>
    <class kind="struct">ThePEG::LeptonMatcher</class>
    <class kind="struct">ThePEG::LightQuarkMatcher</class>
    <class kind="struct">ThePEG::LightAntiQuarkMatcher</class>
    <class kind="struct">ThePEG::StandardQCDPartonMatcher</class>
    <class kind="struct">ThePEG::PseudoScalarMesonMatcher</class>
    <class kind="struct">ThePEG::VectorMesonMatcher</class>
    <member kind="typedef">
      <type>Matcher&lt; AnyMatcher &gt;</type>
      <name>MatchAny</name>
      <anchor>a300</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; ChargedMatcher &gt;</type>
      <name>MatchCharged</name>
      <anchor>a301</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PositiveMatcher &gt;</type>
      <name>MatchPositive</name>
      <anchor>a302</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NeutralMatcher &gt;</type>
      <name>MatchNeutral</name>
      <anchor>a303</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NegativeMatcher &gt;</type>
      <name>MatchNegative</name>
      <anchor>a304</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; BaryonMatcher &gt;</type>
      <name>MatchBaryon</name>
      <anchor>a305</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; MesonMatcher &gt;</type>
      <name>MatchMeson</name>
      <anchor>a306</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; DiquarkMatcher &gt;</type>
      <name>MatchDiquark</name>
      <anchor>a307</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; QuarkMatcher &gt;</type>
      <name>MatchQuark</name>
      <anchor>a308</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LeptonMatcher &gt;</type>
      <name>MatchLepton</name>
      <anchor>a309</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightQuarkMatcher &gt;</type>
      <name>MatchLightQuark</name>
      <anchor>a310</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightAntiQuarkMatcher &gt;</type>
      <name>MatchLightAntiQuark</name>
      <anchor>a311</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; StandardQCDPartonMatcher &gt;</type>
      <name>MatchStandardQCDParton</name>
      <anchor>a312</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PseudoScalarMesonMatcher &gt;</type>
      <name>MatchPseudoScalarMeson</name>
      <anchor>a313</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; VectorMesonMatcher &gt;</type>
      <name>MatchVectorMeson</name>
      <anchor>a314</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>StandardSelectors.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/EventRecord/</path>
    <filename>StandardSelectors_8h</filename>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::AllSelector</class>
    <class kind="struct">ThePEG::FinalStateSelector</class>
    <class kind="struct">ThePEG::IntermediateSelector</class>
    <class kind="struct">ThePEG::PrimaryCollisionSelector</class>
    <class kind="struct">ThePEG::ChargedSelector</class>
    <member kind="typedef">
      <type>ParticleSelector&lt; AllSelector &gt;</type>
      <name>SelectAll</name>
      <anchor>a256</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; FinalStateSelector &gt;</type>
      <name>SelectFinalState</name>
      <anchor>a257</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; PrimaryCollisionSelector &gt;</type>
      <name>SelectPrimaryCollision</name>
      <anchor>a258</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; ChargedSelector &gt;</type>
      <name>SelectCharged</name>
      <anchor>a259</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>std.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Config/</path>
    <filename>std_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_SET</name>
      <anchor>a0</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_MULTISET</name>
      <anchor>a1</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DECLARE_MAP</name>
      <anchor>a2</anchor>
      <arglist>(KEYTYPE, VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_IMPLEMENT_SET</name>
      <anchor>a3</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_IMPLEMENT_MULTISET</name>
      <anchor>a4</anchor>
      <arglist>(VALTYPE, NAME)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_IMPLEMENT_MAP</name>
      <anchor>a5</anchor>
      <arglist>(KEYTYPE, VALTYPE, NAME)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a368</anchor>
      <arglist>(const Container &amp;c, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a369</anchor>
      <arglist>(const vector&lt; T &gt; &amp;v, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>std::insert_iterator&lt; Cont &gt;</type>
      <name>inserter</name>
      <anchor>a370</anchor>
      <arglist>(Cont &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>left</name>
      <anchor>a371</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>right</name>
      <anchor>a372</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>SystemOfUnits.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>SystemOfUnits_8h</filename>
  </compound>
  <compound kind="file">
    <name>ThePEG.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/Config/</path>
    <filename>ThePEG_8h</filename>
    <includes id="std_8h" name="std.h" local="yes">std.h</includes>
    <includes id="Pointers_8h" name="Pointers.h" local="yes">Pointers.h</includes>
    <includes id="Containers_8h" name="Containers.h" local="yes">Containers.h</includes>
    <namespace>ThePEG</namespace>
    <class kind="struct">ThePEG::Base</class>
    <class kind="struct">ThePEG::TraitsType</class>
    <class kind="struct">ThePEG::Veto</class>
    <class kind="struct">ThePEG::Stop</class>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_THROW_SPEC</name>
      <anchor>a0</anchor>
      <arglist>(classes)</arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DEBUG_LEVEL</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="define">
      <type>#define</type>
      <name>ThePEG_DEBUG_ITEM</name>
      <anchor>a2</anchor>
      <arglist>(item)</arglist>
    </member>
    <member kind="typedef">
      <type>Base</type>
      <name>PersistentBase</name>
      <anchor>a233</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>MultiplicationTraits&lt; T &gt;::ResultType</type>
      <name>sqr</name>
      <anchor>a373</anchor>
      <arglist>(const T &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>abs</name>
      <anchor>a374</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
  </compound>
  <compound kind="file">
    <name>ThreeVector.h</name>
    <path>/home/shakespeare/alberto/ThePEG/ThePEG/CLHEPWrap/</path>
    <filename>ThreeVector_8h</filename>
    <namespace>ThePEG</namespace>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a336</anchor>
      <arglist>(OStream &amp;os, const Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a337</anchor>
      <arglist>(IStream &amp;is, Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
  </compound>
  <compound kind="group">
    <name>Persistency</name>
    <title>Persistency classes</title>
    <filename>group__Persistency.html</filename>
    <class kind="class">ThePEG::InputDescription</class>
    <class kind="class">ThePEG::PersistentIStream</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingClass</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingObject</class>
    <class kind="struct">ThePEG::PersistentIStream::ReadFailior</class>
    <class kind="class">ThePEG::PersistentOStream</class>
    <class kind="struct">ThePEG::PersistentOStream::MissingClass</class>
  </compound>
  <compound kind="namespace">
    <name>ACDCGenerator</name>
    <filename>namespaceACDCGenerator.html</filename>
    <class kind="class">ACDCGenerator::ACDCGen</class>
    <class kind="struct">ACDCGenerator::ACDCGen::Level</class>
    <class kind="struct">ACDCGenerator::ACDCGen::Slicer</class>
    <class kind="class">ACDCGenerator::ACDCGenCell</class>
    <class kind="struct">ACDCGenerator::ACDCGenCellInfo</class>
    <class kind="struct">ACDCGenerator::ACDCTraitsType</class>
    <class kind="struct">ACDCGenerator::ACDCFncTraits</class>
    <class kind="struct">ACDCGenerator::ACDCRandomTraits</class>
    <class kind="struct">ACDCGenerator::DRAND48</class>
    <class kind="struct">ACDCGenerator::ACDCRandomTraits&lt; DRAND48 &gt;</class>
    <class kind="struct">ACDCGenerator::ACDCFncTraits&lt; ThePEG::tEHPtr &gt;</class>
    <class kind="struct">ACDCGenerator::ACDCRandomTraits&lt; ThePEG::RandomGenerator &gt;</class>
    <member kind="typedef">
      <type>short</type>
      <name>DimType</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ACDCGenerator::ACDCGen</name>
    <filename>classACDCGenerator_1_1ACDCGen.html</filename>
    <templarg>Rnd</templarg>
    <templarg>FncPtr</templarg>
    <member kind="typedef">
      <type>Rnd</type>
      <name>RndType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ACDCRandomTraits&lt; RndType &gt;</type>
      <name>RndTraits</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>FncPtr</type>
      <name>FncPtrType</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ACDCGenCell * &gt;</type>
      <name>CellVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; FncPtrType &gt;</type>
      <name>FncVector</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; DimType &gt;</type>
      <name>DimVector</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DimVector::size_type</type>
      <name>size_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ACDCFncTraits&lt; FncPtrType &gt;</type>
      <name>FncTraits</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCGen</name>
      <anchor>a0</anchor>
      <arglist>(Rnd &amp;r)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCGen</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addFunction</name>
      <anchor>a2</anchor>
      <arglist>(DimType dim, FncPtrType f)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>FncPtrType</type>
      <name>generate</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reject</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const DVector &amp;</type>
      <name>lastPoint</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastF</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FncPtrType</type>
      <name>lastFunction</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>last</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a10</anchor>
      <arglist>(POStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a11</anchor>
      <arglist>(PIStream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>eps</name>
      <anchor>z1_0</anchor>
      <arglist>(double newEps)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>margin</name>
      <anchor>z1_1</anchor>
      <arglist>(double newMargin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>nTry</name>
      <anchor>z1_2</anchor>
      <arglist>(size_type newNTry)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>maxTry</name>
      <anchor>z1_3</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>integral</name>
      <anchor>z3_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>n</name>
      <anchor>z3_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>N</name>
      <anchor>z3_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>efficiency</name>
      <anchor>z3_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nBins</name>
      <anchor>z3_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>depth</name>
      <anchor>z3_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxInt</name>
      <anchor>z3_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>z5_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>margin</name>
      <anchor>z5_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>nTry</name>
      <anchor>z5_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxTry</name>
      <anchor>z5_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>cheapRandom</name>
      <anchor>z5_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>z5_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>compensating</name>
      <anchor>z5_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; ACDCGenCellInfo &gt;</type>
      <name>extractCellInfo</name>
      <anchor>z5_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cheapRandom</name>
      <anchor>z7_0</anchor>
      <arglist>(bool b)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRnd</name>
      <anchor>z7_1</anchor>
      <arglist>(Rnd &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z7_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z7_3</anchor>
      <arglist>(double lo, double up) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rnd</name>
      <anchor>z7_4</anchor>
      <arglist>(const DVector &amp;lo, const DVector &amp;up, DVector &amp;r) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rnd</name>
      <anchor>z7_5</anchor>
      <arglist>(DimType D, DVector &amp;r) const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>rndInt</name>
      <anchor>z7_6</anchor>
      <arglist>(long x) const</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>size_type</type>
      <name>maxsize</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; Level &gt;</type>
      <name>LevelVector</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>doMaxInt</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const FncVector &amp;</type>
      <name>functions</name>
      <anchor>d1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FncPtrType</type>
      <name>function</name>
      <anchor>d2</anchor>
      <arglist>(size_type i) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const DimVector &amp;</type>
      <name>dimensions</name>
      <anchor>d3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DimType</type>
      <name>dimension</name>
      <anchor>d4</anchor>
      <arglist>(size_type i) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DimType</type>
      <name>lastDimension</name>
      <anchor>d5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const CellVector &amp;</type>
      <name>cells</name>
      <anchor>d6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell *</type>
      <name>cell</name>
      <anchor>d7</anchor>
      <arglist>(size_type i) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell *</type>
      <name>lastPrimary</name>
      <anchor>d8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const DVector &amp;</type>
      <name>sumMaxInts</name>
      <anchor>d9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell *</type>
      <name>lastCell</name>
      <anchor>d10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>chooseCell</name>
      <anchor>d11</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>compensate</name>
      <anchor>d12</anchor>
      <arglist>(const DVector &amp;lo, const DVector &amp;up)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ACDCGen</name>
      <anchor>d13</anchor>
      <arglist>(const ACDCGen &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGen &amp;</type>
      <name>operator=</name>
      <anchor>d14</anchor>
      <arglist>(const ACDCGen &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RndType *</type>
      <name>theRnd</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNAcc</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theN</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMargin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theNTry</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theMaxTry</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useCheapRandom</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FncVector</type>
      <name>theFunctions</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DimVector</type>
      <name>theDimensions</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CellVector</type>
      <name>thePrimaryCells</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theSumMaxInts</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theLast</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ACDCGenCell *</type>
      <name>theLastCell</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theLastPoint</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastF</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LevelVector</type>
      <name>levels</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Level</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Level.html</filename>
    <member kind="variable">
      <type>long</type>
      <name>lastN</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>cell</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>size_type</type>
      <name>index</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Slicer</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Slicer.html</filename>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a0</anchor>
      <arglist>(DimType, ACDCGen &amp;, const DVector &amp;, const DVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a1</anchor>
      <arglist>(DimType Din, const Slicer &amp;s, ACDCGenCell *cellin, const DVector &amp;loin, const DVector &amp;xselin, const DVector &amp;upin, double fselin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>divideandconquer</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>slice</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>shiftmaxmin</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dohalf</name>
      <anchor>a6</anchor>
      <arglist>(DimType)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>checkdiag</name>
      <anchor>a7</anchor>
      <arglist>(ACDCGenCell *cell, DimType d, double lod, double upd)</arglist>
    </member>
    <member kind="variable">
      <type>DimType</type>
      <name>D</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcl</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcu</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhl</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhu</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhl</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhu</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xsel</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>fsel</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>current</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>first</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstlo</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstup</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>FncPtr</type>
      <name>f</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>epsilon</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>margin</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>multimap&lt; double, DimType &gt;</type>
      <name>rateslice</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>minf</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>wholecomp</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Level</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Level.html</filename>
    <member kind="variable">
      <type>long</type>
      <name>lastN</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>cell</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>size_type</type>
      <name>index</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGen::Slicer</name>
    <filename>structACDCGenerator_1_1ACDCGen_1_1Slicer.html</filename>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a0</anchor>
      <arglist>(DimType, ACDCGen &amp;, const DVector &amp;, const DVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Slicer</name>
      <anchor>a1</anchor>
      <arglist>(DimType Din, const Slicer &amp;s, ACDCGenCell *cellin, const DVector &amp;loin, const DVector &amp;xselin, const DVector &amp;upin, double fselin)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>divideandconquer</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>slice</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>shiftmaxmin</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>dohalf</name>
      <anchor>a6</anchor>
      <arglist>(DimType)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>checkdiag</name>
      <anchor>a7</anchor>
      <arglist>(ACDCGenCell *cell, DimType d, double lod, double upd)</arglist>
    </member>
    <member kind="variable">
      <type>DimType</type>
      <name>D</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcl</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xcu</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhl</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xhu</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhl</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>fhu</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>xsel</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>fsel</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>current</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>first</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstlo</name>
      <anchor>o13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>firstup</name>
      <anchor>o14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>FncPtr</type>
      <name>f</name>
      <anchor>o15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>epsilon</name>
      <anchor>o16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>margin</name>
      <anchor>o17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>multimap&lt; double, DimType &gt;</type>
      <name>rateslice</name>
      <anchor>o18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>minf</name>
      <anchor>o19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>wholecomp</name>
      <anchor>o20</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ACDCGenerator::ACDCGenCell</name>
    <filename>classACDCGenerator_1_1ACDCGenCell.html</filename>
    <member kind="function">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>a0</anchor>
      <arglist>(double newG)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>a1</anchor>
      <arglist>(double newG, double newV)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ACDCGenCell</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>generate</name>
      <anchor>a3</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up, RndType &amp;rnd)</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>generate</name>
      <anchor>a4</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up, DVector &amp;rndv)</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>getCell</name>
      <anchor>a5</anchor>
      <arglist>(DVector &amp;lo, const DVector &amp;x, DVector &amp;up)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isSplit</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>doMaxInt</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxInt</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>splitme</name>
      <anchor>a9</anchor>
      <arglist>(double lo, double newDiv, double up, DimType newDim)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>g</name>
      <anchor>a10</anchor>
      <arglist>(double newG)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>g</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>v</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>DimType</type>
      <name>dim</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>div</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>upper</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>lower</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nBins</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>depth</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>extract</name>
      <anchor>a19</anchor>
      <arglist>(DVector &amp;lo, DVector &amp;up, vector&lt; ACDCGenCellInfo &gt; &amp;v) const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>getIndex</name>
      <anchor>a20</anchor>
      <arglist>(const ACDCGenCell *c) const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>getIndex</name>
      <anchor>a21</anchor>
      <arglist>(const ACDCGenCell *c, long &amp;indx) const</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>getCell</name>
      <anchor>a22</anchor>
      <arglist>(long i)</arglist>
    </member>
    <member kind="function">
      <type>ACDCGenCell *</type>
      <name>getCell</name>
      <anchor>a23</anchor>
      <arglist>(long i, long &amp;indx)</arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>theG</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>theV</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>theUpper</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ACDCGenCell *</type>
      <name>theLower</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>theDivision</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DimType</type>
      <name>theSplitDimension</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ACDCGenCell</name>
      <anchor>d1</anchor>
      <arglist>(const ACDCGenCell &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCGenCell &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ACDCGenCell &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCGenCellInfo</name>
    <filename>structACDCGenerator_1_1ACDCGenCellInfo.html</filename>
    <member kind="typedef">
      <type>vector&lt; ACDCGenCellInfo &gt;::size_type</type>
      <name>Index</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>g</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>double</type>
      <name>v</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>up</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>DVector</type>
      <name>lo</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Index</type>
      <name>iup</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Index</type>
      <name>ilo</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCTraitsType</name>
    <filename>structACDCGenerator_1_1ACDCTraitsType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCFncTraits</name>
    <filename>structACDCGenerator_1_1ACDCFncTraits.html</filename>
    <templarg>FncPtr</templarg>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>value</name>
      <anchor>e0</anchor>
      <arglist>(const FncPtr &amp;f, const DVector &amp;x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCRandomTraits</name>
    <filename>structACDCGenerator_1_1ACDCRandomTraits.html</filename>
    <templarg>Rnd</templarg>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e0</anchor>
      <arglist>(Rnd &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>(Rnd &amp;r, double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(Rnd &amp;r, InputIterator l, InputIterator lend, InputIterator u, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(Rnd &amp;r, int D, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e4</anchor>
      <arglist>(Rnd &amp;r, double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e5</anchor>
      <arglist>(Rnd &amp;r, double x, double y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>rndInt</name>
      <anchor>e6</anchor>
      <arglist>(Rnd &amp;r, long x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::DRAND48</name>
    <filename>structACDCGenerator_1_1DRAND48.html</filename>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCRandomTraits&lt; DRAND48 &gt;</name>
    <filename>structACDCGenerator_1_1ACDCRandomTraits_3_01DRAND48_01_4.html</filename>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e0</anchor>
      <arglist>(DRAND48 &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>(DRAND48 &amp;r, double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(DRAND48 &amp;r, InputIterator l, InputIterator lend, InputIterator u, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(DRAND48 &amp;r, int D, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e4</anchor>
      <arglist>(DRAND48 &amp;r, double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e5</anchor>
      <arglist>(DRAND48 &amp;r, double x, double y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>rndInt</name>
      <anchor>e6</anchor>
      <arglist>(DRAND48 &amp;r, long x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCFncTraits&lt; ThePEG::tEHPtr &gt;</name>
    <filename>structACDCGenerator_1_1ACDCFncTraits_3_01ThePEG_1_1tEHPtr_01_4.html</filename>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::tEHPtr</type>
      <name>tEHPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>value</name>
      <anchor>e0</anchor>
      <arglist>(const tEHPtr &amp;eh, const DVector &amp;x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ACDCGenerator::ACDCRandomTraits&lt; ThePEG::RandomGenerator &gt;</name>
    <filename>structACDCGenerator_1_1ACDCRandomTraits_3_01ThePEG_1_1RandomGenerator_01_4.html</filename>
    <base>ACDCGenerator::ACDCTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::RandomGenerator</type>
      <name>RandomGenerator</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e0</anchor>
      <arglist>(RandomGenerator &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>(RandomGenerator &amp;r, double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(RandomGenerator &amp;r, InputIterator l, InputIterator lend, InputIterator u, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(RandomGenerator &amp;r, int D, OutputIterator res)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e4</anchor>
      <arglist>(RandomGenerator &amp;r, double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndBool</name>
      <anchor>e5</anchor>
      <arglist>(RandomGenerator &amp;r, double x, double y)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>rndInt</name>
      <anchor>e6</anchor>
      <arglist>(RandomGenerator &amp;r, long x)</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>CLHEP</name>
    <filename>namespaceCLHEP.html</filename>
    <member kind="typedef">
      <type>HepJamesRandom</type>
      <name>JamesRandom</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepLorentzRotation</type>
      <name>LorentzRotation</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepLorentzVector</type>
      <name>LorentzVector</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepMatrix</type>
      <name>Matrix</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepSymMatrix</type>
      <name>SymMatrix</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepVector</type>
      <name>Vector</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RandBreitWigner</type>
      <name>ThePEGRandBreitWigner</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RandExponential</type>
      <name>ThePEGRandExponential</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepRandomEngine</type>
      <name>RandomEngine</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>HepRotation</type>
      <name>Rotation</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Hep3Vector</type>
      <name>Vector3</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG</name>
    <filename>namespaceThePEG.html</filename>
    <class kind="class">ThePEG::GenEventConverter</class>
    <class kind="struct">ThePEG::GenEventConverter::GenEventConverterException</class>
    <class kind="struct">ThePEG::GenEventConverter::Vertex</class>
    <class kind="class">ThePEG::Lorentz5Vector</class>
    <class kind="class">ThePEG::Transverse</class>
    <class kind="struct">ThePEG::IteratorRange</class>
    <class kind="struct">ThePEG::Base</class>
    <class kind="struct">ThePEG::TraitsType</class>
    <class kind="struct">ThePEG::Veto</class>
    <class kind="struct">ThePEG::Stop</class>
    <class kind="struct">ThePEG::MultiplicationTraits</class>
    <class kind="struct">ThePEG::MultiplicationTraits&lt; Lorentz5Vector&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::MultiplicationTraits&lt; LorentzVector &gt;</class>
    <class kind="struct">ThePEG::MultiplicationTraits&lt; Vector3 &gt;</class>
    <class kind="class">ThePEG::Collision</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Collision, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Collision &gt;</class>
    <class kind="class">ThePEG::ColourBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ColourBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ColourBase &gt;</class>
    <class kind="class">ThePEG::ColourLine</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ColourLine, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ColourLine &gt;</class>
    <class kind="class">ThePEG::ColourSinglet</class>
    <class kind="class">ThePEG::ColourSinglet::ColourSingletException</class>
    <class kind="class">ThePEG::Event</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Event, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Event &gt;</class>
    <class kind="struct">ThePEG::EventConfig</class>
    <class kind="class">ThePEG::EventInfoBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventInfoBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventInfoBase &gt;</class>
    <class kind="class">ThePEG::Particle</class>
    <class kind="struct">ThePEG::Particle::ParticleRep</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Particle, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Particle &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; PPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; cPPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; tPPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; tcPPtr &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; LorentzMomentum &gt;</class>
    <class kind="struct">ThePEG::ParticleTraits&lt; Lorentz5Momentum &gt;</class>
    <class kind="struct">ThePEG::Transformer</class>
    <class kind="class">ThePEG::SelectorBase</class>
    <class kind="struct">ThePEG::ParticleSelector</class>
    <class kind="class">ThePEG::SelectIfNot</class>
    <class kind="class">ThePEG::SelectIfBoth</class>
    <class kind="class">ThePEG::SelectIfEither</class>
    <class kind="class">ThePEG::SpinBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SpinBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SpinBase &gt;</class>
    <class kind="struct">ThePEG::AllSelector</class>
    <class kind="struct">ThePEG::FinalStateSelector</class>
    <class kind="struct">ThePEG::IntermediateSelector</class>
    <class kind="struct">ThePEG::PrimaryCollisionSelector</class>
    <class kind="struct">ThePEG::ChargedSelector</class>
    <class kind="class">ThePEG::Step</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Step, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Step &gt;</class>
    <class kind="class">ThePEG::SubProcess</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SubProcess, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SubProcess &gt;</class>
    <class kind="class">ThePEG::ACDCSampler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ACDCSampler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ACDCSampler &gt;</class>
    <class kind="class">ThePEG::AnalysisHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; AnalysisHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; AnalysisHandler &gt;</class>
    <class kind="class">ThePEG::CascadeHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; CascadeHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; CascadeHandler &gt;</class>
    <class kind="class">ThePEG::ClusterCollapser</class>
    <class kind="class">ThePEG::ClusterCollapser::ClusterException</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ClusterCollapser, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ClusterCollapser &gt;</class>
    <class kind="class">ThePEG::CollisionHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; CollisionHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; CollisionHandler &gt;</class>
    <class kind="struct">ThePEG::CollHdlExtractorError</class>
    <class kind="struct">ThePEG::CollHdlInitWarning</class>
    <class kind="class">ThePEG::DecayHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DecayHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DecayHandler &gt;</class>
    <class kind="struct">ThePEG::DecHdlNoDecayMode</class>
    <class kind="struct">ThePEG::DecHdlNoDecayer</class>
    <class kind="struct">ThePEG::DecHdlDecayFailed</class>
    <class kind="struct">ThePEG::DecHdlChildFail</class>
    <class kind="class">ThePEG::EventHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventHandler &gt;</class>
    <class kind="struct">ThePEG::EventInitException</class>
    <class kind="struct">ThePEG::EventLumiFnErr</class>
    <class kind="struct">ThePEG::EventInitNoXSec</class>
    <class kind="struct">ThePEG::EventLoopException</class>
    <class kind="class">ThePEG::EventManipulator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventManipulator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventManipulator &gt;</class>
    <class kind="class">ThePEG::FixedCMSLuminosity</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FixedCMSLuminosity, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FixedCMSLuminosity &gt;</class>
    <class kind="class">ThePEG::FlavourGenerator</class>
    <class kind="class">ThePEG::FlavourGeneratorException</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FlavourGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FlavourGenerator &gt;</class>
    <class kind="class">ThePEG::GaussianPtGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GaussianPtGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GaussianPtGenerator &gt;</class>
    <class kind="class">ThePEG::HadronizationHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; HadronizationHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; HadronizationHandler &gt;</class>
    <class kind="class">ThePEG::HandlerBaseT</class>
    <class kind="class">ThePEG::HandlerBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; HandlerBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; HandlerBase &gt;</class>
    <class kind="class">ThePEG::HandlerGroupBase</class>
    <class kind="class">ThePEG::HandlerGroup</class>
    <class kind="class">ThePEG::Hint</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Hint, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Hint &gt;</class>
    <class kind="class">ThePEG::KinematicalCuts</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; KinematicalCuts, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; KinematicalCuts &gt;</class>
    <class kind="struct">ThePEG::KinCutSetup</class>
    <class kind="struct">ThePEG::KinCutZeroInterval</class>
    <class kind="class">ThePEG::LastXCombInfoBase</class>
    <class kind="class">ThePEG::LastXCombInfo</class>
    <class kind="class">ThePEG::LuminosityFunction</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LuminosityFunction, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LuminosityFunction &gt;</class>
    <class kind="class">ThePEG::MultipleInteractionHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MultipleInteractionHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MultipleInteractionHandler &gt;</class>
    <class kind="class">ThePEG::PartialCollisionHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartialCollisionHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartialCollisionHandler &gt;</class>
    <class kind="struct">ThePEG::CollHdlStepException</class>
    <class kind="class">ThePEG::PtGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PtGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PtGenerator &gt;</class>
    <class kind="class">ThePEG::SamplerBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SamplerBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SamplerBase &gt;</class>
    <class kind="class">ThePEG::SimpleFlavour</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SimpleFlavour, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SimpleFlavour &gt;</class>
    <class kind="class">ThePEG::SimpleZGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SimpleZGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SimpleZGenerator &gt;</class>
    <class kind="class">ThePEG::StepHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StepHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StepHandler &gt;</class>
    <class kind="class">ThePEG::SubProcessHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SubProcessHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SubProcessHandler &gt;</class>
    <class kind="class">ThePEG::Two2NCuts</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Two2NCuts, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Two2NCuts &gt;</class>
    <class kind="struct">ThePEG::KinCutCmdFail1</class>
    <class kind="struct">ThePEG::KinCutCmdFail2</class>
    <class kind="struct">ThePEG::KinCutCmdFail3</class>
    <class kind="class">ThePEG::XComb</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; XComb, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; XComb &gt;</class>
    <class kind="class">ThePEG::ZGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ZGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ZGenerator &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::FermionSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::FermionSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::HelicityVertex, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::HelicityVertex &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::ScalarSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::ScalarSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::SpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::SpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::TensorSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::TensorSpinInfo &gt;</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEG::Helicity::VectorSpinInfo, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEG::Helicity::VectorSpinInfo &gt;</class>
    <class kind="class">ThePEG::ClassDocumentationBase</class>
    <class kind="class">ThePEG::ClassDocumentation</class>
    <class kind="class">ThePEG::CommandBase</class>
    <class kind="class">ThePEG::Command</class>
    <class kind="struct">ThePEG::CmdExUnknown</class>
    <class kind="class">ThePEG::InterfaceBase</class>
    <class kind="class">ThePEG::RefInterfaceBase</class>
    <class kind="struct">ThePEG::InterfaceException</class>
    <class kind="struct">ThePEG::InterExClass</class>
    <class kind="struct">ThePEG::InterExSetup</class>
    <class kind="struct">ThePEG::InterExUnknown</class>
    <class kind="struct">ThePEG::InterExReadOnly</class>
    <class kind="struct">ThePEG::InterExNoNull</class>
    <class kind="class">ThePEG::Interfaced</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Interfaced, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Interfaced &gt;</class>
    <class kind="class">ThePEG::InterfacedBase</class>
    <class kind="struct">ThePEG::InterfacedBase::UpdateChecker</class>
    <class kind="struct">ThePEG::InterfacedBase::UpdateMapChecker</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; InterfacedBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; InterfacedBase &gt;</class>
    <class kind="struct">ThePEG::SetupException</class>
    <class kind="struct">ThePEG::UpdateException</class>
    <class kind="struct">ThePEG::RebindException</class>
    <class kind="struct">ThePEG::InitException</class>
    <class kind="class">ThePEG::ParameterBase</class>
    <class kind="class">ThePEG::ParameterTBase</class>
    <class kind="class">ThePEG::Parameter</class>
    <class kind="class">ThePEG::ParameterTBase&lt; string &gt;</class>
    <class kind="class">ThePEG::Parameter&lt; T, string &gt;</class>
    <class kind="struct">ThePEG::ParExSetLimit</class>
    <class kind="struct">ThePEG::ParExSetUnknown</class>
    <class kind="struct">ThePEG::ParExGetUnknown</class>
    <class kind="class">ThePEG::ParVectorBase</class>
    <class kind="class">ThePEG::ParVectorTBase</class>
    <class kind="class">ThePEG::ParVector</class>
    <class kind="struct">ThePEG::ParVExLimit</class>
    <class kind="struct">ThePEG::ParVExUnknown</class>
    <class kind="struct">ThePEG::ParVExIndex</class>
    <class kind="struct">ThePEG::ParVExFixed</class>
    <class kind="struct">ThePEG::ParVExDelUnknown</class>
    <class kind="struct">ThePEG::ParVExGetUnknown</class>
    <class kind="class">ThePEG::ReferenceBase</class>
    <class kind="class">ThePEG::Reference</class>
    <class kind="struct">ThePEG::RefExSetRefClass</class>
    <class kind="struct">ThePEG::RefExSetUnknown</class>
    <class kind="struct">ThePEG::RefExGetUnknown</class>
    <class kind="struct">ThePEG::RefExSetNoobj</class>
    <class kind="struct">ThePEG::RefExSetMessage</class>
    <class kind="class">ThePEG::RefVectorBase</class>
    <class kind="class">ThePEG::RefVector</class>
    <class kind="struct">ThePEG::RefVExRefClass</class>
    <class kind="struct">ThePEG::RefVExSetUnknown</class>
    <class kind="struct">ThePEG::RefVExSetUnfound</class>
    <class kind="struct">ThePEG::RefVExIndex</class>
    <class kind="struct">ThePEG::RefVExFixed</class>
    <class kind="struct">ThePEG::RefVExDelUnknown</class>
    <class kind="struct">ThePEG::RefVExGetUnknown</class>
    <class kind="struct">ThePEG::RefVExNoSet</class>
    <class kind="struct">ThePEG::RefVExNoIns</class>
    <class kind="struct">ThePEG::RefVExNoDel</class>
    <class kind="class">ThePEG::SwitchOption</class>
    <class kind="class">ThePEG::SwitchBase</class>
    <class kind="class">ThePEG::Switch</class>
    <class kind="struct">ThePEG::SwExSetOpt</class>
    <class kind="struct">ThePEG::SwExSetUnknown</class>
    <class kind="struct">ThePEG::SwExGetUnknown</class>
    <class kind="class">ThePEG::LesHouchesEventHandler</class>
    <class kind="class">ThePEG::LesHouchesEventHandler::LesHouchesInitError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LesHouchesEventHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LesHouchesEventHandler &gt;</class>
    <class kind="class">ThePEG::LesHouchesFileReader</class>
    <class kind="class">ThePEG::LesHouchesFileReader::LesHouchesFileError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LesHouchesFileReader, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LesHouchesFileReader &gt;</class>
    <class kind="class">ThePEG::LesHouchesReader</class>
    <class kind="class">ThePEG::LesHouchesReader::LesHouchesInconsistencyError</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LesHouchesReader, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LesHouchesReader &gt;</class>
    <class kind="class">ThePEG::MadGraphReader</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MadGraphReader, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MadGraphReader &gt;</class>
    <class kind="class">ThePEG::Amplitude</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Amplitude, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Amplitude &gt;</class>
    <class kind="class">ThePEG::ColourLines</class>
    <class kind="struct">ThePEG::ColourGeometryException</class>
    <class kind="class">ThePEG::DiagramBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DiagramBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DiagramBase &gt;</class>
    <class kind="struct">ThePEG::DiagramBaseSetupException</class>
    <class kind="class">ThePEG::ME2to2Base</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ME2to2Base, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ME2to2Base &gt;</class>
    <class kind="class">ThePEG::ME2to2QCD</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ME2to2QCD, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ME2to2QCD &gt;</class>
    <class kind="class">ThePEG::MEBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEBase &gt;</class>
    <class kind="class">ThePEG::MECuts</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MECuts, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MECuts &gt;</class>
    <class kind="struct">ThePEG::MECutSetup</class>
    <class kind="struct">ThePEG::MECutZeroInterval</class>
    <class kind="class">ThePEG::MEee2gZ2qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEee2gZ2qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEee2gZ2qq &gt;</class>
    <class kind="class">ThePEG::MEGG2GG</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEGG2GG, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEGG2GG &gt;</class>
    <class kind="class">ThePEG::MEGG2QQ</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEGG2QQ, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEGG2QQ &gt;</class>
    <class kind="class">ThePEG::MEQG2QG</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQG2QG, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQG2QG &gt;</class>
    <class kind="class">ThePEG::MEQQ2GG</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQQ2GG, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQQ2GG &gt;</class>
    <class kind="class">ThePEG::MEQQ2QQ</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQQ2QQ, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQQ2QQ &gt;</class>
    <class kind="class">ThePEG::MEQQ2qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQQ2qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQQ2qq &gt;</class>
    <class kind="class">ThePEG::MEQq2Qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEQq2Qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEQq2Qq &gt;</class>
    <class kind="class">ThePEG::MEqq2qq</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MEqq2qq, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MEqq2qq &gt;</class>
    <class kind="class">ThePEG::ReweightBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ReweightBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ReweightBase &gt;</class>
    <class kind="class">ThePEG::ReweightMinPT</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ReweightMinPT, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ReweightMinPT &gt;</class>
    <class kind="class">ThePEG::Tree2toNDiagram</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Tree2toNDiagram, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Tree2toNDiagram &gt;</class>
    <class kind="struct">ThePEG::Tree2toNDiagramError</class>
    <class kind="class">ThePEG::BaryonRemnants</class>
    <class kind="struct">ThePEG::BaryonRemInfo</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; BaryonRemnants, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; BaryonRemnants &gt;</class>
    <class kind="class">ThePEG::BeamParticleData</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; BeamParticleData, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; BeamParticleData &gt;</class>
    <class kind="struct">ThePEG::BeamParticleWrongPDF</class>
    <class kind="class">ThePEG::GRV94L</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GRV94L, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GRV94L &gt;</class>
    <class kind="class">ThePEG::GRV94M</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GRV94M, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GRV94M &gt;</class>
    <class kind="class">ThePEG::GRVBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; GRVBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; GRVBase &gt;</class>
    <class kind="class">ThePEG::LeptonLeptonPDF</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LeptonLeptonPDF, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LeptonLeptonPDF &gt;</class>
    <class kind="class">ThePEG::LeptonLeptonRemnant</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; LeptonLeptonRemnant, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; LeptonLeptonRemnant &gt;</class>
    <class kind="class">ThePEG::NoPDF</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; NoPDF, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; NoPDF &gt;</class>
    <class kind="class">ThePEG::NoRemnants</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; NoRemnants, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; NoRemnants &gt;</class>
    <class kind="class">ThePEG::PartonBin</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartonBin, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartonBin &gt;</class>
    <class kind="class">ThePEG::PartonBinInstance</class>
    <class kind="struct">ThePEG::RemInfoBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartonBinInstance, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartonBinInstance &gt;</class>
    <class kind="class">ThePEG::PartonExtractor</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartonExtractor, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartonExtractor &gt;</class>
    <class kind="struct">ThePEG::RemColException</class>
    <class kind="class">ThePEG::PDF</class>
    <class kind="class">ThePEG::PDFBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PDFBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PDFBase &gt;</class>
    <class kind="struct">ThePEG::RemnantHandlerCantHandle</class>
    <class kind="struct">ThePEG::PDFWrongParticle</class>
    <class kind="struct">ThePEG::PDFRange</class>
    <class kind="class">ThePEG::PDFCuts</class>
    <class kind="class">ThePEG::RemnantHandler</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; RemnantHandler, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; RemnantHandler &gt;</class>
    <class kind="struct">ThePEG::RemnantHandlerException</class>
    <class kind="class">ThePEG::BreitWignerMass</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; BreitWignerMass, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; BreitWignerMass &gt;</class>
    <class kind="class">ThePEG::ColourPairDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ColourPairDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ColourPairDecayer &gt;</class>
    <class kind="struct">ThePEG::AndMatcher</class>
    <class kind="struct">ThePEG::OrMatcher</class>
    <class kind="struct">ThePEG::NotMatcher</class>
    <class kind="class">ThePEG::ConstituentParticleData</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ConstituentParticleData, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ConstituentParticleData &gt;</class>
    <class kind="class">ThePEG::DalitzDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DalitzDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DalitzDecayer &gt;</class>
    <class kind="class">ThePEG::Decayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Decayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Decayer &gt;</class>
    <class kind="class">ThePEG::DecayMode</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DecayMode, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DecayMode &gt;</class>
    <class kind="class">ThePEG::DecModNoAccept</class>
    <class kind="class">ThePEG::DecModSetupNoAccept</class>
    <class kind="class">ThePEG::DecModRebind</class>
    <class kind="class">ThePEG::DummyDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; DummyDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; DummyDecayer &gt;</class>
    <class kind="class">ThePEG::FlatDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FlatDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FlatDecayer &gt;</class>
    <class kind="class">ThePEG::MassGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MassGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MassGenerator &gt;</class>
    <class kind="class">ThePEG::Matcher</class>
    <class kind="struct">ThePEG::MatcherType</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Matcher&lt; T &gt;, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Matcher&lt; T &gt; &gt;</class>
    <class kind="class">ThePEG::MatcherBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MatcherBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MatcherBase &gt;</class>
    <class kind="class">ThePEG::OmegaPhi3PiDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; OmegaPhi3PiDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; OmegaPhi3PiDecayer &gt;</class>
    <class kind="class">ThePEG::Onium3GDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Onium3GDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Onium3GDecayer &gt;</class>
    <class kind="class">ThePEG::ParticleData</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ParticleData, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ParticleData &gt;</class>
    <class kind="struct">ThePEG::ParticleChargeCommand</class>
    <class kind="class">ThePEG::PDT</class>
    <class kind="class">ThePEG::PYDECYDummy</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PYDECYDummy, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PYDECYDummy &gt;</class>
    <class kind="class">ThePEG::QuarksToHadronsDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; QuarksToHadronsDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; QuarksToHadronsDecayer &gt;</class>
    <class kind="struct">ThePEG::AnyMatcher</class>
    <class kind="struct">ThePEG::ChargedMatcher</class>
    <class kind="struct">ThePEG::PositiveMatcher</class>
    <class kind="struct">ThePEG::NeutralMatcher</class>
    <class kind="struct">ThePEG::NegativeMatcher</class>
    <class kind="struct">ThePEG::BaryonMatcher</class>
    <class kind="struct">ThePEG::MesonMatcher</class>
    <class kind="struct">ThePEG::DiquarkMatcher</class>
    <class kind="struct">ThePEG::QuarkMatcher</class>
    <class kind="struct">ThePEG::LeptonMatcher</class>
    <class kind="struct">ThePEG::LightQuarkMatcher</class>
    <class kind="struct">ThePEG::LightAntiQuarkMatcher</class>
    <class kind="struct">ThePEG::StandardQCDPartonMatcher</class>
    <class kind="struct">ThePEG::PseudoScalarMesonMatcher</class>
    <class kind="struct">ThePEG::VectorMesonMatcher</class>
    <class kind="class">ThePEG::Tau2HadronsDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Tau2HadronsDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Tau2HadronsDecayer &gt;</class>
    <class kind="class">ThePEG::V2PPDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; V2PPDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; V2PPDecayer &gt;</class>
    <class kind="class">ThePEG::WeakToHadronsDecayer</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; WeakToHadronsDecayer, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; WeakToHadronsDecayer &gt;</class>
    <class kind="class">ThePEG::WidthGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; WidthGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; WidthGenerator &gt;</class>
    <class kind="class">ThePEG::InputDescription</class>
    <class kind="class">ThePEG::PersistentIStream</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingClass</class>
    <class kind="struct">ThePEG::PersistentIStream::MissingObject</class>
    <class kind="struct">ThePEG::PersistentIStream::ReadFailior</class>
    <class kind="class">ThePEG::PersistentOStream</class>
    <class kind="struct">ThePEG::PersistentOStream::MissingClass</class>
    <class kind="class">ThePEG::BaseRepository</class>
    <class kind="struct">ThePEG::BadClassClone</class>
    <class kind="struct">ThePEG::BadClone</class>
    <class kind="struct">ThePEG::RepoNameException</class>
    <class kind="struct">ThePEG::RepositoryNoDirectory</class>
    <class kind="struct">ThePEG::RepositoryNotFound</class>
    <class kind="struct">ThePEG::RepositoryClassMisMatch</class>
    <class kind="class">ThePEG::CurrentGenerator</class>
    <class kind="class">ThePEG::EventGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; EventGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; EventGenerator &gt;</class>
    <class kind="struct">ThePEG::EGNoPath</class>
    <class kind="class">ThePEG::FullEventGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; FullEventGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; FullEventGenerator &gt;</class>
    <class kind="class">ThePEG::Main</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Main, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Main &gt;</class>
    <class kind="class">ThePEG::MultiEventGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; MultiEventGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; MultiEventGenerator &gt;</class>
    <class kind="class">ThePEG::PartialEventGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; PartialEventGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; PartialEventGenerator &gt;</class>
    <class kind="class">ThePEG::RandomGenerator</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; RandomGenerator, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; RandomGenerator &gt;</class>
    <class kind="class">ThePEG::Repository</class>
    <class kind="class">ThePEG::StandardRandom</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardRandom, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardRandom &gt;</class>
    <class kind="class">ThePEG::Strategy</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; Strategy, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; Strategy &gt;</class>
    <class kind="class">ThePEG::ThePEGStrategy</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; ThePEGStrategy, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; ThePEGStrategy &gt;</class>
    <class kind="class">ThePEG::UseRandom</class>
    <class kind="class">ThePEG::AlphaEMBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; AlphaEMBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; AlphaEMBase &gt;</class>
    <class kind="class">ThePEG::AlphaSBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; AlphaSBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; AlphaSBase &gt;</class>
    <class kind="class">ThePEG::CKMBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; CKMBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; CKMBase &gt;</class>
    <class kind="class">ThePEG::O1AlphaS</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; O1AlphaS, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; O1AlphaS &gt;</class>
    <class kind="class">ThePEG::SimpleAlphaEM</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; SimpleAlphaEM, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; SimpleAlphaEM &gt;</class>
    <class kind="class">ThePEG::StandardCKM</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardCKM, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardCKM &gt;</class>
    <class kind="class">ThePEG::StandardModelBase</class>
    <class kind="struct">ThePEG::BaseClassTrait&lt; StandardModelBase, 1 &gt;</class>
    <class kind="struct">ThePEG::ClassTraits&lt; StandardModelBase &gt;</class>
    <class kind="class">ThePEG::CFileLineReader</class>
    <class kind="class">ThePEG::ClassDescriptionBase</class>
    <class kind="class">ThePEG::ClassDescriptionTBase</class>
    <class kind="class">ThePEG::AbstractClassDescription</class>
    <class kind="class">ThePEG::ClassDescription</class>
    <class kind="class">ThePEG::NoPIOClassDescription</class>
    <class kind="class">ThePEG::AbstractNoPIOClassDescription</class>
    <class kind="struct">ThePEG::ClassDescriptionHelper</class>
    <class kind="struct">ThePEG::ClassDescriptionHelper&lt; T, IBase, int &gt;</class>
    <class kind="struct">ThePEG::ClassTraitsType</class>
    <class kind="struct">ThePEG::ClassTraitsBase</class>
    <class kind="struct">ThePEG::ClassTraits</class>
    <class kind="struct">ThePEG::BaseClassTrait</class>
    <class kind="class">ThePEG::Debug</class>
    <class kind="class">ThePEG::DescriptionList</class>
    <class kind="class">ThePEG::Direction</class>
    <class kind="struct">ThePEG::MultipleDirectionException</class>
    <class kind="struct">ThePEG::UndefinedDirectionException</class>
    <class kind="class">ThePEG::DIterator</class>
    <class kind="class">ThePEG::DynamicLoader</class>
    <class kind="struct">ThePEG::OEnum</class>
    <class kind="struct">ThePEG::IEnum</class>
    <class kind="class">ThePEG::Exception</class>
    <class kind="class">ThePEG::FixedSizeAllocator</class>
    <class kind="struct">ThePEG::FixedSizeAllocator::ChunkStack</class>
    <class kind="struct">ThePEG::SizeOf8</class>
    <class kind="struct">ThePEG::FixedAllocator</class>
    <class kind="class">ThePEG::Allocator</class>
    <class kind="struct">ThePEG::Allocator::rebind</class>
    <class kind="class">ThePEG::HoldFlag</class>
    <class kind="class">ThePEG::HoldFlag&lt; bool &gt;</class>
    <class kind="class">ThePEG::Interval</class>
    <class kind="class">ThePEG::Level</class>
    <class kind="class">ThePEG::LoopGuard</class>
    <class kind="class">ThePEG::Named</class>
    <class kind="class">ThePEG::ObjectIndexer</class>
    <class kind="class">ThePEG::Rebinder</class>
    <class kind="class">ThePEG::Selector</class>
    <class kind="struct">ThePEG::SimplePhaseSpace</class>
    <class kind="struct">ThePEG::ImpossibleKinematics</class>
    <class kind="class">ThePEG::ostringstream</class>
    <class kind="class">ThePEG::istringstream</class>
    <class kind="class">ThePEG::StringUtils</class>
    <class kind="class">ThePEG::SystemUtils</class>
    <class kind="class">ThePEG::TimeCounter</class>
    <class kind="class">ThePEG::MainTimer</class>
    <class kind="class">ThePEG::Timer</class>
    <class kind="struct">ThePEG::Triplet</class>
    <class kind="struct">ThePEG::TypeInfo</class>
    <class kind="struct">ThePEG::OUnit</class>
    <class kind="struct">ThePEG::IUnit</class>
    <class kind="struct">ThePEG::UtilityBase</class>
    <class kind="struct">ThePEG::Utilities</class>
    <class kind="class">ThePEG::VSelector</class>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a355</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a356</anchor>
      <arglist>(vector&lt; T &gt; &amp;tv, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a357</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>stack&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a358</anchor>
      <arglist>(stack&lt; T &gt; &amp;ts, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a359</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>deque&lt; T &gt; &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a360</anchor>
      <arglist>(deque&lt; T &gt; &amp;td, U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>set&lt; T &gt; &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a361</anchor>
      <arglist>(set&lt; T &gt; &amp;ts, const U &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a362</anchor>
      <arglist>(OStream &amp;os, const vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a363</anchor>
      <arglist>(IStream &amp;is, vector&lt; T, Alloc &gt; &amp;v, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a364</anchor>
      <arglist>(OStream &amp;os, const set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a365</anchor>
      <arglist>(IStream &amp;is, set&lt; T, CMP, A &gt; &amp;s, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a366</anchor>
      <arglist>(OStream &amp;os, const map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a367</anchor>
      <arglist>(IStream &amp;is, map&lt; K, T, CMP, A &gt; &amp;m, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a391</anchor>
      <arglist>(PersistentIStream &amp;, pair&lt; T1, T2 &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a392</anchor>
      <arglist>(PersistentIStream &amp;, map&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a393</anchor>
      <arglist>(PersistentIStream &amp;, multimap&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a394</anchor>
      <arglist>(PersistentIStream &amp;, set&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a395</anchor>
      <arglist>(PersistentIStream &amp;, multiset&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a396</anchor>
      <arglist>(PersistentIStream &amp;, list&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a397</anchor>
      <arglist>(PersistentIStream &amp;, vector&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a398</anchor>
      <arglist>(PersistentIStream &amp;, deque&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a403</anchor>
      <arglist>(PersistentOStream &amp;, const pair&lt; T1, T2 &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a404</anchor>
      <arglist>(PersistentOStream &amp;, const multimap&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a405</anchor>
      <arglist>(PersistentOStream &amp;, const map&lt; Key, T, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a406</anchor>
      <arglist>(PersistentOStream &amp;, const set&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a407</anchor>
      <arglist>(PersistentOStream &amp;, const multiset&lt; Key, Cmp, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a408</anchor>
      <arglist>(PersistentOStream &amp;, const list&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a409</anchor>
      <arglist>(PersistentOStream &amp;, const vector&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a410</anchor>
      <arglist>(PersistentOStream &amp;, const deque&lt; T, A &gt; &amp;)</arglist>
    </member>
    <member kind="typedef">
      <type>CLHEP::ThePEGRandBreitWigner</type>
      <name>RandBreitWigner</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEP::ThePEGRandExponential</type>
      <name>RandExponential</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::complex&lt; double &gt;</type>
      <name>Complex</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PDPtr, less&lt; PDPtr &gt;, Allocator&lt; PDPtr &gt; &gt;</type>
      <name>ParticleDataSet</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PDPtr &gt;</type>
      <name>PDVector</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPDPtr &gt;</type>
      <name>cPDVector</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPtr &gt;</type>
      <name>tPDVector</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPDPtr &gt;</type>
      <name>tcPDVector</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PMPtr, less&lt; PMPtr &gt;, Allocator&lt; PMPtr &gt; &gt;</type>
      <name>MatcherSet</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; DMPtr, less&lt; DMPtr &gt;, Allocator&lt; DMPtr &gt; &gt;</type>
      <name>DecayModeSet</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>ObjectSet</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; IBPtr, less&lt; IBPtr &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>DependencySet</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; long, PDPtr, less&lt; long &gt;, Allocator&lt; PDPtr &gt; &gt;</type>
      <name>ParticleMap</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, IBPtr, less&lt; string &gt;, Allocator&lt; IBPtr &gt; &gt;</type>
      <name>ObjectMap</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; IBPtr, DependencySet, less&lt; IBPtr &gt;, Allocator&lt; DependencySet &gt; &gt;</type>
      <name>DependencyMap</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; IBPtr &gt;</type>
      <name>IVector</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cIBPtr &gt;</type>
      <name>CIVector</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>ParticleVector</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PPtr &gt;</type>
      <name>PVector</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; cPPtr &gt;</type>
      <name>cPVector</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tPVector</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tcPPtr &gt;</type>
      <name>tcPVector</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, const InterfaceBase *, less&lt; string &gt;, Allocator&lt; const InterfaceBase * &gt; &gt;</type>
      <name>InterfaceMap</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; InterfacedBase &gt;</type>
      <name>TranslationMap</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, EGPtr, less&lt; string &gt;, Allocator&lt; EGPtr &gt; &gt;</type>
      <name>GeneratorMap</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; AnaPtr &gt;</type>
      <name>AnalysisVector</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PBPtr, PBPtr &gt;</type>
      <name>PBPair</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PDPtr, PDPtr &gt;</type>
      <name>PDPair</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPDPtr, cPDPtr &gt;</type>
      <name>cPDPair</name>
      <anchor>a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPDPtr, tPDPtr &gt;</type>
      <name>tPDPair</name>
      <anchor>a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPDPtr, tcPDPtr &gt;</type>
      <name>tcPDPair</name>
      <anchor>a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PPtr, PPtr &gt;</type>
      <name>PPair</name>
      <anchor>a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; cPPtr, cPPtr &gt;</type>
      <name>cPPair</name>
      <anchor>a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tPPtr, tPPtr &gt;</type>
      <name>tPPair</name>
      <anchor>a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tcPPtr, tcPPtr &gt;</type>
      <name>tcPPair</name>
      <anchor>a34</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Interval&lt; Energy2 &gt;</type>
      <name>SInterval</name>
      <anchor>a35</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Energy2 &gt;</type>
      <name>SVector</name>
      <anchor>a36</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SInterval &gt;</type>
      <name>SIntervalVector</name>
      <anchor>a37</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PBPair &gt;</type>
      <name>PartonPairVec</name>
      <anchor>a38</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPair &gt;</type>
      <name>tPartonPairVec</name>
      <anchor>a39</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; tColinePtr, tColinePtr &gt;</type>
      <name>tColinePair</name>
      <anchor>a40</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; PBPtr &gt;</type>
      <name>PartonVector</name>
      <anchor>a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tDMPtr, less&lt; tDMPtr &gt;, Allocator&lt; tDMPtr &gt; &gt;</type>
      <name>DecaySet</name>
      <anchor>a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; string, less&lt; string &gt;, Allocator&lt; string &gt; &gt;</type>
      <name>StringSet</name>
      <anchor>a43</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Energy &gt;</type>
      <name>EnergyVector</name>
      <anchor>a44</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; EIPtr &gt;</type>
      <name>EIVector</name>
      <anchor>a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; MEPtr &gt;</type>
      <name>MEVector</name>
      <anchor>a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>DVector</name>
      <anchor>a47</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; double, double &gt;</type>
      <name>DPair</name>
      <anchor>a48</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::pointer</type>
      <name>IBPtr</name>
      <anchor>a49</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::const_pointer</type>
      <name>cIBPtr</name>
      <anchor>a50</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_pointer</type>
      <name>tIBPtr</name>
      <anchor>a51</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; InterfacedBase &gt;::transient_const_pointer</type>
      <name>tcIBPtr</name>
      <anchor>a52</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::pointer</type>
      <name>IPtr</name>
      <anchor>a53</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::const_pointer</type>
      <name>cIPtr</name>
      <anchor>a54</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_pointer</type>
      <name>tIPtr</name>
      <anchor>a55</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Interfaced &gt;::transient_const_pointer</type>
      <name>tcIPtr</name>
      <anchor>a56</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::pointer</type>
      <name>PDPtr</name>
      <anchor>a57</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::const_pointer</type>
      <name>cPDPtr</name>
      <anchor>a58</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_pointer</type>
      <name>tPDPtr</name>
      <anchor>a59</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleData &gt;::transient_const_pointer</type>
      <name>tcPDPtr</name>
      <anchor>a60</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::pointer</type>
      <name>PMPtr</name>
      <anchor>a61</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::const_pointer</type>
      <name>cPMPtr</name>
      <anchor>a62</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_pointer</type>
      <name>tPMPtr</name>
      <anchor>a63</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MatcherBase &gt;::transient_const_pointer</type>
      <name>tcPMPtr</name>
      <anchor>a64</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::pointer</type>
      <name>DMPtr</name>
      <anchor>a65</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::const_pointer</type>
      <name>cDMPtr</name>
      <anchor>a66</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_pointer</type>
      <name>tDMPtr</name>
      <anchor>a67</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayMode &gt;::transient_const_pointer</type>
      <name>tcDMPtr</name>
      <anchor>a68</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::pointer</type>
      <name>PPtr</name>
      <anchor>a69</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::const_pointer</type>
      <name>cPPtr</name>
      <anchor>a70</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_pointer</type>
      <name>tPPtr</name>
      <anchor>a71</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Particle &gt;::transient_const_pointer</type>
      <name>tcPPtr</name>
      <anchor>a72</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::pointer</type>
      <name>EHPtr</name>
      <anchor>a73</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::const_pointer</type>
      <name>cEHPtr</name>
      <anchor>a74</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_pointer</type>
      <name>tEHPtr</name>
      <anchor>a75</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventHandler &gt;::transient_const_pointer</type>
      <name>tcEHPtr</name>
      <anchor>a76</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::pointer</type>
      <name>EGPtr</name>
      <anchor>a77</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::const_pointer</type>
      <name>cEGPtr</name>
      <anchor>a78</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_pointer</type>
      <name>tEGPtr</name>
      <anchor>a79</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventGenerator &gt;::transient_const_pointer</type>
      <name>tcEGPtr</name>
      <anchor>a80</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::pointer</type>
      <name>FEGPtr</name>
      <anchor>a81</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::const_pointer</type>
      <name>cFEGPtr</name>
      <anchor>a82</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::transient_pointer</type>
      <name>tFEGPtr</name>
      <anchor>a83</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FullEventGenerator &gt;::transient_const_pointer</type>
      <name>tcFEGPtr</name>
      <anchor>a84</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::pointer</type>
      <name>PEGPtr</name>
      <anchor>a85</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::const_pointer</type>
      <name>cPEGPtr</name>
      <anchor>a86</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::transient_pointer</type>
      <name>tPEGPtr</name>
      <anchor>a87</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialEventGenerator &gt;::transient_const_pointer</type>
      <name>tcPEGPtr</name>
      <anchor>a88</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::pointer</type>
      <name>CollHdlPtr</name>
      <anchor>a89</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::const_pointer</type>
      <name>cCollHdlPtr</name>
      <anchor>a90</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::transient_pointer</type>
      <name>tCollHdlPtr</name>
      <anchor>a91</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CollisionHandler &gt;::transient_const_pointer</type>
      <name>tcCollHdlPtr</name>
      <anchor>a92</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::pointer</type>
      <name>PartCollHdlPtr</name>
      <anchor>a93</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::const_pointer</type>
      <name>cPartCollHdlPtr</name>
      <anchor>a94</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::transient_pointer</type>
      <name>tPartCollHdlPtr</name>
      <anchor>a95</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartialCollisionHandler &gt;::transient_const_pointer</type>
      <name>tcPartCollHdlPtr</name>
      <anchor>a96</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::pointer</type>
      <name>SubHdlPtr</name>
      <anchor>a97</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::const_pointer</type>
      <name>cSubHdlPtr</name>
      <anchor>a98</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::transient_pointer</type>
      <name>tSubHdlPtr</name>
      <anchor>a99</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcessHandler &gt;::transient_const_pointer</type>
      <name>tcSubHdlPtr</name>
      <anchor>a100</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::pointer</type>
      <name>StepHdlPtr</name>
      <anchor>a101</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::const_pointer</type>
      <name>cStepHdlPtr</name>
      <anchor>a102</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_pointer</type>
      <name>tStepHdlPtr</name>
      <anchor>a103</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StepHandler &gt;::transient_const_pointer</type>
      <name>tcStepHdlPtr</name>
      <anchor>a104</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::pointer</type>
      <name>HintPtr</name>
      <anchor>a105</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::const_pointer</type>
      <name>cHintPtr</name>
      <anchor>a106</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_pointer</type>
      <name>tHintPtr</name>
      <anchor>a107</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Hint &gt;::transient_const_pointer</type>
      <name>tcHintPtr</name>
      <anchor>a108</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::pointer</type>
      <name>HadrHdlPtr</name>
      <anchor>a109</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::const_pointer</type>
      <name>cHadrHdlPtr</name>
      <anchor>a110</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_pointer</type>
      <name>tHadrHdlPtr</name>
      <anchor>a111</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HadronizationHandler &gt;::transient_const_pointer</type>
      <name>tcHadrHdlPtr</name>
      <anchor>a112</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::pointer</type>
      <name>CascHdlPtr</name>
      <anchor>a113</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::const_pointer</type>
      <name>cCascHdlPtr</name>
      <anchor>a114</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_pointer</type>
      <name>tCascHdlPtr</name>
      <anchor>a115</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; CascadeHandler &gt;::transient_const_pointer</type>
      <name>tcCascHdlPtr</name>
      <anchor>a116</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::pointer</type>
      <name>MIHdlPtr</name>
      <anchor>a117</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::const_pointer</type>
      <name>cMIHdlPtr</name>
      <anchor>a118</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_pointer</type>
      <name>tMIHdlPtr</name>
      <anchor>a119</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MultipleInteractionHandler &gt;::transient_const_pointer</type>
      <name>tcMIHdlPtr</name>
      <anchor>a120</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::pointer</type>
      <name>DecayHdlPtr</name>
      <anchor>a121</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::const_pointer</type>
      <name>cDecayHdlPtr</name>
      <anchor>a122</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_pointer</type>
      <name>tDecayHdlPtr</name>
      <anchor>a123</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DecayHandler &gt;::transient_const_pointer</type>
      <name>tcDecayHdlPtr</name>
      <anchor>a124</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::pointer</type>
      <name>PileHdlPtr</name>
      <anchor>a125</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::const_pointer</type>
      <name>cPileHdlPtr</name>
      <anchor>a126</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_pointer</type>
      <name>tPileHdlPtr</name>
      <anchor>a127</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PileupHandler &gt;::transient_const_pointer</type>
      <name>tcPileHdlPtr</name>
      <anchor>a128</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::pointer</type>
      <name>LumiFnPtr</name>
      <anchor>a129</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::const_pointer</type>
      <name>cLumiFnPtr</name>
      <anchor>a130</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_pointer</type>
      <name>tLumiFnPtr</name>
      <anchor>a131</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LuminosityFunction &gt;::transient_const_pointer</type>
      <name>tcLumiFnPtr</name>
      <anchor>a132</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::pointer</type>
      <name>KinCutPtr</name>
      <anchor>a133</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::const_pointer</type>
      <name>cKinCutPtr</name>
      <anchor>a134</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_pointer</type>
      <name>tKinCutPtr</name>
      <anchor>a135</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; KinematicalCuts &gt;::transient_const_pointer</type>
      <name>tcKinCutPtr</name>
      <anchor>a136</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::pointer</type>
      <name>PExtrPtr</name>
      <anchor>a137</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::const_pointer</type>
      <name>cPExtrPtr</name>
      <anchor>a138</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_pointer</type>
      <name>tPExtrPtr</name>
      <anchor>a139</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonExtractor &gt;::transient_const_pointer</type>
      <name>tcPExtrPtr</name>
      <anchor>a140</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::pointer</type>
      <name>RanGenPtr</name>
      <anchor>a141</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::const_pointer</type>
      <name>cRanGenPtr</name>
      <anchor>a142</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_pointer</type>
      <name>tRanGenPtr</name>
      <anchor>a143</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RandomGenerator &gt;::transient_const_pointer</type>
      <name>tcRanGenPtr</name>
      <anchor>a144</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::pointer</type>
      <name>AnaPtr</name>
      <anchor>a145</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::const_pointer</type>
      <name>cAnaPtr</name>
      <anchor>a146</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_pointer</type>
      <name>tAnaPtr</name>
      <anchor>a147</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; AnalysisHandler &gt;::transient_const_pointer</type>
      <name>tcAnaPtr</name>
      <anchor>a148</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::pointer</type>
      <name>EvtManipPtr</name>
      <anchor>a149</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::const_pointer</type>
      <name>cEvtManipPtr</name>
      <anchor>a150</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_pointer</type>
      <name>tEvtManipPtr</name>
      <anchor>a151</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventManipulator &gt;::transient_const_pointer</type>
      <name>tcEvtManipPtr</name>
      <anchor>a152</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::pointer</type>
      <name>DecayerPtr</name>
      <anchor>a153</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::const_pointer</type>
      <name>cDecayerPtr</name>
      <anchor>a154</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_pointer</type>
      <name>tDecayerPtr</name>
      <anchor>a155</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Decayer &gt;::transient_const_pointer</type>
      <name>tcDecayerPtr</name>
      <anchor>a156</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::pointer</type>
      <name>EventPtr</name>
      <anchor>a157</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::const_pointer</type>
      <name>cEventPtr</name>
      <anchor>a158</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_pointer</type>
      <name>tEventPtr</name>
      <anchor>a159</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Event &gt;::transient_const_pointer</type>
      <name>tcEventPtr</name>
      <anchor>a160</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::pointer</type>
      <name>CollPtr</name>
      <anchor>a161</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::const_pointer</type>
      <name>cCollPtr</name>
      <anchor>a162</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_pointer</type>
      <name>tCollPtr</name>
      <anchor>a163</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Collision &gt;::transient_const_pointer</type>
      <name>tcCollPtr</name>
      <anchor>a164</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::pointer</type>
      <name>StepPtr</name>
      <anchor>a165</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::const_pointer</type>
      <name>cStepPtr</name>
      <anchor>a166</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_pointer</type>
      <name>tStepPtr</name>
      <anchor>a167</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Step &gt;::transient_const_pointer</type>
      <name>tcStepPtr</name>
      <anchor>a168</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::pointer</type>
      <name>SubProPtr</name>
      <anchor>a169</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::const_pointer</type>
      <name>cSubProPtr</name>
      <anchor>a170</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_pointer</type>
      <name>tSubProPtr</name>
      <anchor>a171</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SubProcess &gt;::transient_const_pointer</type>
      <name>tcSubProPtr</name>
      <anchor>a172</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::pointer</type>
      <name>StrategyPtr</name>
      <anchor>a173</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::const_pointer</type>
      <name>cStrategyPtr</name>
      <anchor>a174</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_pointer</type>
      <name>tStrategyPtr</name>
      <anchor>a175</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Strategy &gt;::transient_const_pointer</type>
      <name>tcStrategyPtr</name>
      <anchor>a176</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::pointer</type>
      <name>XCombPtr</name>
      <anchor>a177</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::const_pointer</type>
      <name>cXCombPtr</name>
      <anchor>a178</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_pointer</type>
      <name>tXCombPtr</name>
      <anchor>a179</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; XComb &gt;::transient_const_pointer</type>
      <name>tcXCombPtr</name>
      <anchor>a180</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::pointer</type>
      <name>SBinPtr</name>
      <anchor>a181</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::const_pointer</type>
      <name>cSBinPtr</name>
      <anchor>a182</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::transient_pointer</type>
      <name>tSBinPtr</name>
      <anchor>a183</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SBin &gt;::transient_const_pointer</type>
      <name>tcSBinPtr</name>
      <anchor>a184</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::pointer</type>
      <name>RemHPtr</name>
      <anchor>a185</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::const_pointer</type>
      <name>cRemHPtr</name>
      <anchor>a186</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_pointer</type>
      <name>tRemHPtr</name>
      <anchor>a187</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemnantHandler &gt;::transient_const_pointer</type>
      <name>tcRemHPtr</name>
      <anchor>a188</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::pointer</type>
      <name>PDFPtr</name>
      <anchor>a189</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::const_pointer</type>
      <name>cPDFPtr</name>
      <anchor>a190</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_pointer</type>
      <name>tPDFPtr</name>
      <anchor>a191</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PDFBase &gt;::transient_const_pointer</type>
      <name>tcPDFPtr</name>
      <anchor>a192</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::pointer</type>
      <name>MEPtr</name>
      <anchor>a193</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::const_pointer</type>
      <name>cMEPtr</name>
      <anchor>a194</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::transient_pointer</type>
      <name>tMEPtr</name>
      <anchor>a195</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MEBase &gt;::transient_const_pointer</type>
      <name>tcMEPtr</name>
      <anchor>a196</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::pointer</type>
      <name>PSPtr</name>
      <anchor>a197</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::const_pointer</type>
      <name>cPSPtr</name>
      <anchor>a198</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::transient_pointer</type>
      <name>tPSPtr</name>
      <anchor>a199</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PhaseSpaceBase &gt;::transient_const_pointer</type>
      <name>tcPSPtr</name>
      <anchor>a200</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::pointer</type>
      <name>SMPtr</name>
      <anchor>a201</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::const_pointer</type>
      <name>cSMPtr</name>
      <anchor>a202</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_pointer</type>
      <name>tSMPtr</name>
      <anchor>a203</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; StandardModelBase &gt;::transient_const_pointer</type>
      <name>tcSMPtr</name>
      <anchor>a204</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::pointer</type>
      <name>PBPtr</name>
      <anchor>a205</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::const_pointer</type>
      <name>cPBPtr</name>
      <anchor>a206</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::transient_pointer</type>
      <name>tPBPtr</name>
      <anchor>a207</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBin &gt;::transient_const_pointer</type>
      <name>tcPBPtr</name>
      <anchor>a208</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::pointer</type>
      <name>CBPtr</name>
      <anchor>a209</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::const_pointer</type>
      <name>cCBPtr</name>
      <anchor>a210</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_pointer</type>
      <name>tCBPtr</name>
      <anchor>a211</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourBase &gt;::transient_const_pointer</type>
      <name>tcCBPtr</name>
      <anchor>a212</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::pointer</type>
      <name>SpinPtr</name>
      <anchor>a213</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::const_pointer</type>
      <name>cSpinPtr</name>
      <anchor>a214</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_pointer</type>
      <name>tSpinPtr</name>
      <anchor>a215</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinBase &gt;::transient_const_pointer</type>
      <name>tcSpinPtr</name>
      <anchor>a216</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::pointer</type>
      <name>EIPtr</name>
      <anchor>a217</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::const_pointer</type>
      <name>cEIPtr</name>
      <anchor>a218</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_pointer</type>
      <name>tEIPtr</name>
      <anchor>a219</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventInfoBase &gt;::transient_const_pointer</type>
      <name>tcEIPtr</name>
      <anchor>a220</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::pointer</type>
      <name>ReweightPtr</name>
      <anchor>a221</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::const_pointer</type>
      <name>cReweightPtr</name>
      <anchor>a222</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_pointer</type>
      <name>tReweightPtr</name>
      <anchor>a223</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ReweightBase &gt;::transient_const_pointer</type>
      <name>tcReweightPtr</name>
      <anchor>a224</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::pointer</type>
      <name>ColinePtr</name>
      <anchor>a225</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::const_pointer</type>
      <name>cColinePtr</name>
      <anchor>a226</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_pointer</type>
      <name>tColinePtr</name>
      <anchor>a227</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ColourLine &gt;::transient_const_pointer</type>
      <name>tcColinePtr</name>
      <anchor>a228</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>a229</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>a230</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>a231</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>a232</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Base</type>
      <name>PersistentBase</name>
      <anchor>a233</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Base</type>
      <name>EventRecordBase</name>
      <anchor>a234</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::pointer</type>
      <name>EventBasePtr</name>
      <anchor>a235</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::const_pointer</type>
      <name>cEventBasePtr</name>
      <anchor>a236</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_pointer</type>
      <name>tEventBasePtr</name>
      <anchor>a237</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; EventRecordBase &gt;::transient_const_pointer</type>
      <name>tcEventBasePtr</name>
      <anchor>a238</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Rebinder&lt; EventRecordBase &gt;</type>
      <name>EventTranslationMap</name>
      <anchor>a239</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Particle</type>
      <name>ParticleClass</name>
      <anchor>a240</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>ParticleDataClass</name>
      <anchor>a241</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::pointer</type>
      <name>EventPDPtr</name>
      <anchor>a242</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::const_pointer</type>
      <name>cEventPDPtr</name>
      <anchor>a243</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_pointer</type>
      <name>tEventPDPtr</name>
      <anchor>a244</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ParticleDataClass &gt;::transient_const_pointer</type>
      <name>tcEventPDPtr</name>
      <anchor>a245</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPPtr &gt;</type>
      <name>tParticleVector</name>
      <anchor>a246</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; PPtr, less&lt; PPtr &gt;, Allocator&lt; PPtr &gt; &gt;</type>
      <name>ParticleSet</name>
      <anchor>a247</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tPPtr, less&lt; tPPtr &gt;, Allocator&lt; tPPtr &gt; &gt;</type>
      <name>tParticleSet</name>
      <anchor>a248</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; tcPPtr, less&lt; tcPPtr &gt;, Allocator&lt; tcPPtr &gt; &gt;</type>
      <name>tcParticleSet</name>
      <anchor>a249</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepPtr &gt;</type>
      <name>StepVector</name>
      <anchor>a250</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; SubProPtr &gt;</type>
      <name>SubProcessVector</name>
      <anchor>a251</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tSubProPtr &gt;</type>
      <name>tSubProcessVector</name>
      <anchor>a252</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; CollPtr &gt;</type>
      <name>CollisionVector</name>
      <anchor>a253</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; StepPtr, less&lt; StepPtr &gt;, Allocator&lt; StepPtr &gt; &gt;</type>
      <name>StepSet</name>
      <anchor>a254</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; SubProPtr, less&lt; SubProPtr &gt;, Allocator&lt; SubProPtr &gt; &gt;</type>
      <name>SubProcessSet</name>
      <anchor>a255</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; AllSelector &gt;</type>
      <name>SelectAll</name>
      <anchor>a256</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; FinalStateSelector &gt;</type>
      <name>SelectFinalState</name>
      <anchor>a257</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; PrimaryCollisionSelector &gt;</type>
      <name>SelectPrimaryCollision</name>
      <anchor>a258</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ParticleSelector&lt; ChargedSelector &gt;</type>
      <name>SelectCharged</name>
      <anchor>a259</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::pointer</type>
      <name>ClusterCollapserPtr</name>
      <anchor>a260</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::const_pointer</type>
      <name>cClusterCollapserPtr</name>
      <anchor>a261</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::transient_pointer</type>
      <name>tClusterCollapserPtr</name>
      <anchor>a262</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ClusterCollapser &gt;::transient_const_pointer</type>
      <name>tcClusterCollapserPtr</name>
      <anchor>a263</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::pointer</type>
      <name>SamplerPtr</name>
      <anchor>a264</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::const_pointer</type>
      <name>cSamplerPtr</name>
      <anchor>a265</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::transient_pointer</type>
      <name>tSamplerPtr</name>
      <anchor>a266</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SamplerBase &gt;::transient_const_pointer</type>
      <name>tcSamplerPtr</name>
      <anchor>a267</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::pointer</type>
      <name>LesHouchesEventHandlerPtr</name>
      <anchor>a268</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::const_pointer</type>
      <name>cLesHouchesEventHandlerPtr</name>
      <anchor>a269</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::transient_pointer</type>
      <name>tLesHouchesEventHandlerPtr</name>
      <anchor>a270</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesEventHandler &gt;::transient_const_pointer</type>
      <name>tcLesHouchesEventHandlerPtr</name>
      <anchor>a271</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::pointer</type>
      <name>LesHouchesReaderPtr</name>
      <anchor>a272</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::const_pointer</type>
      <name>cLesHouchesReaderPtr</name>
      <anchor>a273</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::transient_pointer</type>
      <name>tLesHouchesReaderPtr</name>
      <anchor>a274</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; LesHouchesReader &gt;::transient_const_pointer</type>
      <name>tcLesHouchesReaderPtr</name>
      <anchor>a275</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::pointer</type>
      <name>DiagPtr</name>
      <anchor>a276</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::const_pointer</type>
      <name>cDiagPtr</name>
      <anchor>a277</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::transient_pointer</type>
      <name>tDiagPtr</name>
      <anchor>a278</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; DiagramBase &gt;::transient_const_pointer</type>
      <name>tcDiagPtr</name>
      <anchor>a279</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::pointer</type>
      <name>PBIPtr</name>
      <anchor>a280</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::const_pointer</type>
      <name>cPBIPtr</name>
      <anchor>a281</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::transient_pointer</type>
      <name>tPBIPtr</name>
      <anchor>a282</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PartonBinInstance &gt;::transient_const_pointer</type>
      <name>tcPBIPtr</name>
      <anchor>a283</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; PBIPtr, PBIPtr &gt;</type>
      <name>PBIPair</name>
      <anchor>a284</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::pointer</type>
      <name>RemIPtr</name>
      <anchor>a285</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::const_pointer</type>
      <name>cRemIPtr</name>
      <anchor>a286</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::transient_pointer</type>
      <name>tRemIPtr</name>
      <anchor>a287</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; RemInfoBase &gt;::transient_const_pointer</type>
      <name>tcRemIPtr</name>
      <anchor>a288</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tPDPtr, less&lt; tPDPtr &gt;, Allocator&lt; tPDPtr &gt; &gt;</type>
      <name>ParticleMSet</name>
      <anchor>a289</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tPMPtr, less&lt; tPMPtr &gt;, Allocator&lt; tPMPtr &gt; &gt;</type>
      <name>MatcherMSet</name>
      <anchor>a290</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tDMPtr, less&lt; tDMPtr &gt;, Allocator&lt; tDMPtr &gt; &gt;</type>
      <name>ModeMSet</name>
      <anchor>a291</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::pointer</type>
      <name>MassGenPtr</name>
      <anchor>a292</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::const_pointer</type>
      <name>cMassGenPtr</name>
      <anchor>a293</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::transient_pointer</type>
      <name>tMassGenPtr</name>
      <anchor>a294</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; MassGenerator &gt;::transient_const_pointer</type>
      <name>tcMassGenPtr</name>
      <anchor>a295</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>FlavGenPtr</name>
      <anchor>a296</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::const_pointer</type>
      <name>cFlavGenPtr</name>
      <anchor>a297</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::transient_pointer</type>
      <name>tFlavGenPtr</name>
      <anchor>a298</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::transient_const_pointer</type>
      <name>tcFlavGenPtr</name>
      <anchor>a299</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; AnyMatcher &gt;</type>
      <name>MatchAny</name>
      <anchor>a300</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; ChargedMatcher &gt;</type>
      <name>MatchCharged</name>
      <anchor>a301</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PositiveMatcher &gt;</type>
      <name>MatchPositive</name>
      <anchor>a302</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NeutralMatcher &gt;</type>
      <name>MatchNeutral</name>
      <anchor>a303</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; NegativeMatcher &gt;</type>
      <name>MatchNegative</name>
      <anchor>a304</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; BaryonMatcher &gt;</type>
      <name>MatchBaryon</name>
      <anchor>a305</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; MesonMatcher &gt;</type>
      <name>MatchMeson</name>
      <anchor>a306</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; DiquarkMatcher &gt;</type>
      <name>MatchDiquark</name>
      <anchor>a307</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; QuarkMatcher &gt;</type>
      <name>MatchQuark</name>
      <anchor>a308</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LeptonMatcher &gt;</type>
      <name>MatchLepton</name>
      <anchor>a309</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightQuarkMatcher &gt;</type>
      <name>MatchLightQuark</name>
      <anchor>a310</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; LightAntiQuarkMatcher &gt;</type>
      <name>MatchLightAntiQuark</name>
      <anchor>a311</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; StandardQCDPartonMatcher &gt;</type>
      <name>MatchStandardQCDParton</name>
      <anchor>a312</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; PseudoScalarMesonMatcher &gt;</type>
      <name>MatchPseudoScalarMeson</name>
      <anchor>a313</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Matcher&lt; VectorMesonMatcher &gt;</type>
      <name>MatchVectorMeson</name>
      <anchor>a314</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::pointer</type>
      <name>WidthGeneratorPtr</name>
      <anchor>a315</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::const_pointer</type>
      <name>cWidthGeneratorPtr</name>
      <anchor>a316</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::transient_pointer</type>
      <name>tWidthGeneratorPtr</name>
      <anchor>a317</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; WidthGenerator &gt;::transient_const_pointer</type>
      <name>tcWidthGeneratorPtr</name>
      <anchor>a318</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PersistentIStream &amp;(*</type>
      <name>PersistentIManip</name>
      <anchor>a319</anchor>
      <arglist>)(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="typedef">
      <type>PersistentOStream &amp;(*</type>
      <name>PersistentOManip</name>
      <anchor>a320</anchor>
      <arglist>)(PersistentOStream &amp;)</arglist>
    </member>
    <member kind="typedef">
      <type>Interval&lt; double &gt;</type>
      <name>DInterval</name>
      <anchor>a321</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a322</anchor>
      <arglist>(OStream &amp;os, const Lorentz5Vector&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a323</anchor>
      <arglist>(IStream &amp;is, Lorentz5Vector&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirPlus</name>
      <anchor>a324</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirMinus</name>
      <anchor>a325</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirZ</name>
      <anchor>a326</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirTheta</name>
      <anchor>a327</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>dirCosTheta</name>
      <anchor>a328</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Vector3</type>
      <name>dirBoostVector</name>
      <anchor>a329</anchor>
      <arglist>(const LorentzVector &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a330</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightCone</name>
      <anchor>a331</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a332</anchor>
      <arglist>(FloatType plus, FloatType minus, FloatType x=FloatType(), FloatType y=FloatType())</arglist>
    </member>
    <member kind="function">
      <type>LorentzVector</type>
      <name>lightConeDir</name>
      <anchor>a333</anchor>
      <arglist>(FloatType plus, FloatType minus, Transverse&lt; FloatType &gt; pt)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a334</anchor>
      <arglist>(OStream &amp;os, const LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a335</anchor>
      <arglist>(IStream &amp;is, LorentzVector &amp;p, UnitT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a336</anchor>
      <arglist>(OStream &amp;os, const Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a337</anchor>
      <arglist>(IStream &amp;is, Vector3 &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a338</anchor>
      <arglist>(OStream &amp;os, const Transverse&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a339</anchor>
      <arglist>(IStream &amp;is, Transverse&lt; T &gt; &amp;p, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::iterator &gt;</type>
      <name>range</name>
      <anchor>a340</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_iterator &gt;</type>
      <name>range</name>
      <anchor>a341</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a342</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>IteratorRange&lt; typename Container::const_reverse_iterator &gt;</type>
      <name>rrange</name>
      <anchor>a343</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a344</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find</name>
      <anchor>a345</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Iterator</type>
      <name>find_if</name>
      <anchor>a346</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, Pred p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a347</anchor>
      <arglist>(IteratorRange&lt; Iterator &gt; r, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a348</anchor>
      <arglist>(Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>FNC</type>
      <name>for_each</name>
      <anchor>a349</anchor>
      <arglist>(const Cont &amp;c, FNC f)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find</name>
      <anchor>a350</anchor>
      <arglist>(Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find</name>
      <anchor>a351</anchor>
      <arglist>(const Cont &amp;c, const Type &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Cont::iterator</type>
      <name>find_if</name>
      <anchor>a352</anchor>
      <arglist>(Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>Cont::const_iterator</type>
      <name>find_if</name>
      <anchor>a353</anchor>
      <arglist>(const Cont &amp;c, const Pred &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a354</anchor>
      <arglist>(Cont &amp;c, const T &amp;oval, const T &amp;nval)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a368</anchor>
      <arglist>(const Container &amp;c, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>member</name>
      <anchor>a369</anchor>
      <arglist>(const vector&lt; T &gt; &amp;v, const Key &amp;k)</arglist>
    </member>
    <member kind="function">
      <type>std::insert_iterator&lt; Cont &gt;</type>
      <name>inserter</name>
      <anchor>a370</anchor>
      <arglist>(Cont &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>left</name>
      <anchor>a371</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>right</name>
      <anchor>a372</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>MultiplicationTraits&lt; T &gt;::ResultType</type>
      <name>sqr</name>
      <anchor>a373</anchor>
      <arglist>(const T &amp;x)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>abs</name>
      <anchor>a374</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a375</anchor>
      <arglist>(ostream &amp;, const Collision &amp;)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a376</anchor>
      <arglist>(ostream &amp;, const Event &amp;)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a377</anchor>
      <arglist>(ostream &amp;, const Particle &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>copyIfCheck</name>
      <anchor>a378</anchor>
      <arglist>(OutputIterator r, const Container &amp;c, const SelectorBase &amp;s)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a379</anchor>
      <arglist>(ostream &amp;, const Step &amp;)</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a380</anchor>
      <arglist>(ostream &amp;, const SubProcess &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a381</anchor>
      <arglist>(PersistentOStream &amp;, const HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a382</anchor>
      <arglist>(PersistentIStream &amp;, HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator/</name>
      <anchor>a383</anchor>
      <arglist>(string, string)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>operator *</name>
      <anchor>a384</anchor>
      <arglist>(double, string)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a385</anchor>
      <arglist>(IStream &amp;, PDT::Colour &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a386</anchor>
      <arglist>(IStream &amp;, PDT::Charge &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a387</anchor>
      <arglist>(IStream &amp;, PDT::Spin &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a388</anchor>
      <arglist>(PersistentIStream &amp;, PersistentIManip)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>pedantic</name>
      <anchor>a389</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>tolerant</name>
      <anchor>a390</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a399</anchor>
      <arglist>(PersistentOStream &amp;os, PersistentOManip func)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>flush</name>
      <anchor>a400</anchor>
      <arglist>(PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>push</name>
      <anchor>a401</anchor>
      <arglist>(PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>pop</name>
      <anchor>a402</anchor>
      <arglist>(PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function">
      <type>OEnum&lt; T &gt;</type>
      <name>oenum</name>
      <anchor>a411</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>IEnum&lt; T &gt;</type>
      <name>ienum</name>
      <anchor>a412</anchor>
      <arglist>(T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a413</anchor>
      <arglist>(OStream &amp;os, const OEnum&lt; T &gt; &amp;e)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a414</anchor>
      <arglist>(IStream &amp;is, const IEnum&lt; T &gt; &amp;e)</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T &gt;</type>
      <name>makeInterval</name>
      <anchor>a415</anchor>
      <arglist>(T dn, T up)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a416</anchor>
      <arglist>(OStream &amp;, const Interval&lt; T, CMP &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a417</anchor>
      <arglist>(IStream &amp;, Interval&lt; T, CMP &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a418</anchor>
      <arglist>(OStream &amp;os, const Interval&lt; T, CMP &gt; &amp;i, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a419</anchor>
      <arglist>(IStream &amp;is, Interval&lt; T, CMP &gt; &amp;i, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a420</anchor>
      <arglist>(OStream &amp;, const Selector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a421</anchor>
      <arglist>(IStream &amp;, Selector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Triplet&lt; T1, T2, T3 &gt;</type>
      <name>makeTriplet</name>
      <anchor>a422</anchor>
      <arglist>(const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a423</anchor>
      <arglist>(OStream &amp;os, const Triplet&lt; T1, T2, T3 &gt; &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a424</anchor>
      <arglist>(IStream &amp;is, Triplet&lt; T1, T2, T3 &gt; &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>OUnit&lt; T, UT &gt;</type>
      <name>ounit</name>
      <anchor>a425</anchor>
      <arglist>(const T &amp;t, const UT &amp;ut)</arglist>
    </member>
    <member kind="function">
      <type>IUnit&lt; T, UT &gt;</type>
      <name>iunit</name>
      <anchor>a426</anchor>
      <arglist>(T &amp;t, const UT &amp;ut)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>ounitstream</name>
      <anchor>a427</anchor>
      <arglist>(OStream &amp;os, const T &amp;t, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>iunitstream</name>
      <anchor>a428</anchor>
      <arglist>(IStream &amp;is, T &amp;t, UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a429</anchor>
      <arglist>(OStream &amp;os, const OUnit&lt; T, UT &gt; &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a430</anchor>
      <arglist>(IStream &amp;is, const IUnit&lt; T, UT &gt; &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>OStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a431</anchor>
      <arglist>(OStream &amp;, const VSelector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>IStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a432</anchor>
      <arglist>(IStream &amp;, VSelector&lt; T, WeightType &gt; &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GenEventConverter</name>
    <filename>classThePEG_1_1GenEventConverter.html</filename>
    <member kind="typedef">
      <type>CLHEPMC::GenParticle</type>
      <name>GenParticle</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEPMC::GenEvent</type>
      <name>GenEvent</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>CLHEPMC::GenVertex</type>
      <name>GenVertex</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tcPPtr, GenParticle * &gt;</type>
      <name>ParticleMap</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tcColinePtr, long &gt;</type>
      <name>FlowMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tcPPtr, Vertex * &gt;</type>
      <name>VertexMap</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const Vertex *, GenVertex * &gt;</type>
      <name>GenVertexMap</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>GenEvent *</type>
      <name>convert</name>
      <anchor>e0</anchor>
      <arglist>(const Event &amp;ev)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>GenEventConverter</name>
      <anchor>d0</anchor>
      <arglist>(const Event &amp;ev)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>GenEventConverter</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>GenEventConverter</name>
      <anchor>d2</anchor>
      <arglist>(const GenEventConverter &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GenEventConverter &amp;</type>
      <name>operator=</name>
      <anchor>d3</anchor>
      <arglist>(const GenEventConverter &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GenParticle *</type>
      <name>createParticle</name>
      <anchor>d4</anchor>
      <arglist>(tcPPtr p) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>join</name>
      <anchor>d5</anchor>
      <arglist>(tcPPtr parent, tcPPtr child)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GenVertex *</type>
      <name>createVertex</name>
      <anchor>d6</anchor>
      <arglist>(Vertex *v)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GenEvent *</type>
      <name>geneve</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>pmap</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlowMap</type>
      <name>flowmap</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Vertex &gt;</type>
      <name>vertices</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexMap</type>
      <name>prov</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexMap</type>
      <name>decv</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GenVertexMap</type>
      <name>vmap</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::GenEventConverterException</name>
    <filename>structThePEG_1_1GenEventConverter_1_1GenEventConverterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>GenEventConverterException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::Vertex</name>
    <filename>structThePEG_1_1GenEventConverter_1_1Vertex.html</filename>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>in</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>out</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::GenEventConverterException</name>
    <filename>structThePEG_1_1GenEventConverter_1_1GenEventConverterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>GenEventConverterException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::GenEventConverter::Vertex</name>
    <filename>structThePEG_1_1GenEventConverter_1_1Vertex.html</filename>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>in</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tcParticleSet</type>
      <name>out</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Lorentz5Vector</name>
    <filename>classThePEG_1_1Lorentz5Vector.html</filename>
    <templarg>FloatType</templarg>
    <member kind="typedef">
      <type>FloatType</type>
      <name>FloatType2</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_1</anchor>
      <arglist>(FloatType m)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_2</anchor>
      <arglist>(FloatType x, FloatType y, FloatType z, FloatType t=FloatType())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_3</anchor>
      <arglist>(FloatType x, FloatType y, FloatType z, FloatType t, FloatType tau)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_4</anchor>
      <arglist>(const Vector3 &amp;, FloatType)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_5</anchor>
      <arglist>(FloatType, const Vector3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_6</anchor>
      <arglist>(const Vector3 &amp;, FloatType t, FloatType tau)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_7</anchor>
      <arglist>(const LorentzVector &amp;, FloatType)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_8</anchor>
      <arglist>(const Lorentz5Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Lorentz5Vector</name>
      <anchor>z9_9</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Lorentz5Vector</name>
      <anchor>z9_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTau</name>
      <anchor>z11_0</anchor>
      <arglist>(FloatType)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMass</name>
      <anchor>z11_1</anchor>
      <arglist>(FloatType)</arglist>
    </member>
    <member kind="function">
      <type>Lorentz5Vector &amp;</type>
      <name>operator=</name>
      <anchor>z11_2</anchor>
      <arglist>(const Lorentz5Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Lorentz5Vector &amp;</type>
      <name>operator=</name>
      <anchor>z11_3</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleEnergy</name>
      <anchor>z13_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleRho</name>
      <anchor>z13_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleMass</name>
      <anchor>z13_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>massError</name>
      <anchor>z15_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>energyError</name>
      <anchor>z15_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>rhoError</name>
      <anchor>z15_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>operator()</name>
      <anchor>z17_0</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>operator[]</name>
      <anchor>z17_1</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>FloatType2</type>
      <name>mass2</name>
      <anchor>z17_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType2</type>
      <name>tau2</name>
      <anchor>z17_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>mass</name>
      <anchor>z17_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>tau</name>
      <anchor>z17_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>dirPlus</name>
      <anchor>z17_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>dirMinus</name>
      <anchor>z17_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FloatType</type>
      <name>mm</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Transverse</name>
    <filename>classThePEG_1_1Transverse.html</filename>
    <templarg>FloatType</templarg>
    <member kind="typedef">
      <type>FloatType</type>
      <name>FloatType2</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; FloatType, FloatType &gt;</type>
      <name>BasePair</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_1</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_2</anchor>
      <arglist>(const BasePair &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_3</anchor>
      <arglist>(FloatType x, FloatType y)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_4</anchor>
      <arglist>(const Vector3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_5</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transverse</name>
      <anchor>z19_6</anchor>
      <arglist>(const Lorentz5Vector&lt; FloatType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z21_0</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z21_1</anchor>
      <arglist>(const BasePair &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z21_2</anchor>
      <arglist>(const Vector3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z21_3</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Transverse &amp;</type>
      <name>operator=</name>
      <anchor>z21_4</anchor>
      <arglist>(const Lorentz5Vector&lt; FloatType &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Transverse</type>
      <name>operator-</name>
      <anchor>z23_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Transverse</type>
      <name>operator-</name>
      <anchor>z23_1</anchor>
      <arglist>(const Transverse &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Transverse &amp;</type>
      <name>operator-=</name>
      <anchor>z23_2</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Transverse</type>
      <name>operator+</name>
      <anchor>z23_3</anchor>
      <arglist>(const Transverse &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Transverse &amp;</type>
      <name>operator+=</name>
      <anchor>z23_4</anchor>
      <arglist>(const Transverse &amp;)</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>x</name>
      <anchor>z25_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>y</name>
      <anchor>z25_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType2</type>
      <name>pt2</name>
      <anchor>z25_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FloatType</type>
      <name>pt</name>
      <anchor>z25_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>phi</name>
      <anchor>z25_4</anchor>
      <arglist>() const</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IteratorRange</name>
    <filename>structThePEG_1_1IteratorRange.html</filename>
    <templarg>Iterator</templarg>
    <member kind="typedef">
      <type>std::pair&lt; Iterator, Iterator &gt;</type>
      <name>BaseType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IteratorRange</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IteratorRange</name>
      <anchor>a1</anchor>
      <arglist>(const IteratorRange &amp;ir)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IteratorRange</name>
      <anchor>a2</anchor>
      <arglist>(const BaseType &amp;ir)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Base</name>
    <filename>structThePEG_1_1Base.html</filename>
    <base>ThePEG::Pointer::ReferenceCounted</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Base</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::TraitsType</name>
    <filename>structThePEG_1_1TraitsType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Veto</name>
    <filename>structThePEG_1_1Veto.html</filename>
    <member kind="function">
      <type></type>
      <name>Veto</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Stop</name>
    <filename>structThePEG_1_1Stop.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits</name>
    <filename>structThePEG_1_1MultiplicationTraits.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits&lt; Lorentz5Vector&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1MultiplicationTraits_3_01Lorentz5Vector_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>T</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits&lt; LorentzVector &gt;</name>
    <filename>structThePEG_1_1MultiplicationTraits_3_01LorentzVector_01_4.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultiplicationTraits&lt; Vector3 &gt;</name>
    <filename>structThePEG_1_1MultiplicationTraits_3_01Vector3_01_4.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>ResultType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Collision</name>
    <filename>classThePEG_1_1Collision.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Collision</name>
      <anchor>a2</anchor>
      <arglist>(const PPair &amp;newIncoming, tEventPtr newEvent=tEventPtr(), tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Collision</name>
      <anchor>a3</anchor>
      <arglist>(const Collision &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Collision</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>a5</anchor>
      <arglist>(tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>event</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const LorentzPoint &amp;</type>
      <name>vertex</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>vertex</name>
      <anchor>a9</anchor>
      <arglist>(const LorentzPoint &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>a10</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>m2</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a12</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a13</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z31_0</anchor>
      <arglist>(OutputIterator r, const SelectorBase &amp;s) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>selectFinalState</name>
      <anchor>z31_1</anchor>
      <arglist>(OutputIterator r) const</arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>getFinalState</name>
      <anchor>z31_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tSubProPtr</type>
      <name>primarySubProcess</name>
      <anchor>z31_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const SubProcessVector &amp;</type>
      <name>subProcesses</name>
      <anchor>z31_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcStepPtr</type>
      <name>finalStep</name>
      <anchor>z31_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>finalStep</name>
      <anchor>z31_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const StepVector &amp;</type>
      <name>steps</name>
      <anchor>z31_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcStepPtr</type>
      <name>step</name>
      <anchor>z31_8</anchor>
      <arglist>(unsigned int i) const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>z31_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>getRemnants</name>
      <anchor>z31_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isRemnant</name>
      <anchor>z31_11</anchor>
      <arglist>(tPPtr) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeDecay</name>
      <anchor>z33_0</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeParticle</name>
      <anchor>z33_1</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cleanSteps</name>
      <anchor>z33_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>popStep</name>
      <anchor>z33_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const ParticleSet &amp;</type>
      <name>all</name>
      <anchor>b0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>CollPtr</type>
      <name>clone</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b2</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addStep</name>
      <anchor>z35_0</anchor>
      <arglist>(tStepPtr s)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addSubProcess</name>
      <anchor>z35_1</anchor>
      <arglist>(tSubProPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticles</name>
      <anchor>z35_2</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticle</name>
      <anchor>z35_3</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>z35_4</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Collision</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Collision &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Collision &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepVector</type>
      <name>theSteps</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubProcessVector</type>
      <name>theSubProcesses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>allParticles</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEventPtr</type>
      <name>theEvent</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LorentzPoint</type>
      <name>theVertex</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Collision &gt;</type>
      <name>initCollision</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt; Collision &gt;</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend ostream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>n1</anchor>
      <arglist>(ostream &amp;os, const Collision &amp;c)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Collision, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Collision_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Collision &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Collision_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Collision &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourBase</name>
    <filename>classThePEG_1_1ColourBase.html</filename>
    <base>ThePEG::EventInfoBase</base>
    <member kind="function">
      <type></type>
      <name>ColourBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourBase</name>
      <anchor>a1</anchor>
      <arglist>(const ColourBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>antiColourLine</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>colourLine</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a5</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a6</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a7</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>antiColourLine</name>
      <anchor>d0</anchor>
      <arglist>(tColinePtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>colourLine</name>
      <anchor>d1</anchor>
      <arglist>(tColinePtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ColourBase &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ColourBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ColinePtr</type>
      <name>theAntiColourLine</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ColinePtr</type>
      <name>theColourLine</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ColourBase &gt;</type>
      <name>initColourBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ColourBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ColourBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventInfoBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ColourBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ColourBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ColourBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourLine</name>
    <filename>classThePEG_1_1ColourLine.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>ColourLine</name>
      <anchor>z37_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLine</name>
      <anchor>z37_1</anchor>
      <arglist>(const ColourLine &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tColinePtr</type>
      <name>create</name>
      <anchor>z37_2</anchor>
      <arglist>(tPPtr col, tPPtr anti)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tColinePtr</type>
      <name>create</name>
      <anchor>z37_3</anchor>
      <arglist>(tPPtr p, bool anti=false)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tColinePtr</type>
      <name>createAnti</name>
      <anchor>z37_4</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourLine</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>std::iterator_traits&lt; Iterator &gt;::value_type</type>
      <name>getColouredParticle</name>
      <anchor>a1</anchor>
      <arglist>(Iterator first, Iterator last, bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>write</name>
      <anchor>a2</anchor>
      <arglist>(ostream &amp;os, tcEventPtr event, bool anti)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a3</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a4</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>coloured</name>
      <anchor>z39_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>antiColoured</name>
      <anchor>z39_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>startParticle</name>
      <anchor>z39_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>endParticle</name>
      <anchor>z39_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addAntiColoured</name>
      <anchor>z41_0</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addColoured</name>
      <anchor>z41_1</anchor>
      <arglist>(tPPtr p, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeAntiColoured</name>
      <anchor>z41_2</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeColoured</name>
      <anchor>z41_3</anchor>
      <arglist>(tPPtr p, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>tColinePair</type>
      <name>sinkNeighbours</name>
      <anchor>z43_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tColinePair</type>
      <name>sourceNeighbours</name>
      <anchor>z43_1</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSinkNeighbours</name>
      <anchor>z43_2</anchor>
      <arglist>(tColinePtr, tColinePtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSourceNeighbours</name>
      <anchor>z43_3</anchor>
      <arglist>(tColinePtr, tColinePtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ColourLine &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ColourLine &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theColoured</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theAntiColoured</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tColinePair</type>
      <name>theSourceNeighbours</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tColinePair</type>
      <name>theSinkNeighbours</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ColourLine &gt;</type>
      <name>initColourLine</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ColourLine, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ColourLine_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ColourLine &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ColourLine_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ColourLine &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourSinglet</name>
    <filename>classThePEG_1_1ColourSinglet.html</filename>
    <member kind="typedef">
      <type>deque&lt; tcPPtr &gt;</type>
      <name>StringPiece</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>StringPiece::size_type</type>
      <name>Index</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pair&lt; Index, Index &gt;</type>
      <name>Junction</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>a1</anchor>
      <arglist>(const ColourSinglet &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>a2</anchor>
      <arglist>(tcColinePtr cl, tcParticleSet &amp;left)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ColourSinglet</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const ColourSinglet &amp;)</arglist>
    </member>
    <member kind="function">
      <type>tcPVector &amp;</type>
      <name>partons</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const tcPVector &amp;</type>
      <name>partons</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPPtr</type>
      <name>parton</name>
      <anchor>a7</anchor>
      <arglist>(tcPVector::size_type i) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzMomentum</type>
      <name>momentum</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Index</type>
      <name>nPieces</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>StringPiece &amp;</type>
      <name>piece</name>
      <anchor>a10</anchor>
      <arglist>(Index i)</arglist>
    </member>
    <member kind="function">
      <type>const StringPiece &amp;</type>
      <name>piece</name>
      <anchor>a11</anchor>
      <arglist>(Index i) const</arglist>
    </member>
    <member kind="function">
      <type>Junction &amp;</type>
      <name>junction</name>
      <anchor>a12</anchor>
      <arglist>(Index i, bool forward)</arglist>
    </member>
    <member kind="function">
      <type>const Junction &amp;</type>
      <name>junction</name>
      <anchor>a13</anchor>
      <arglist>(Index i, bool forward) const</arglist>
    </member>
    <member kind="function">
      <type>Junction &amp;</type>
      <name>sink</name>
      <anchor>a14</anchor>
      <arglist>(Index i)</arglist>
    </member>
    <member kind="function">
      <type>const Junction &amp;</type>
      <name>sink</name>
      <anchor>a15</anchor>
      <arglist>(Index i) const</arglist>
    </member>
    <member kind="function">
      <type>Junction &amp;</type>
      <name>source</name>
      <anchor>a16</anchor>
      <arglist>(Index i)</arglist>
    </member>
    <member kind="function">
      <type>const Junction &amp;</type>
      <name>source</name>
      <anchor>a17</anchor>
      <arglist>(Index i) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDVector</type>
      <name>getTripletData</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitInternal</name>
      <anchor>a19</anchor>
      <arglist>(Index sp=0)</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitInternal</name>
      <anchor>a20</anchor>
      <arglist>(Index sp, Index sa, Index sc, const vector&lt; bool &gt; &amp;assing)</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitDiQuarkJunction</name>
      <anchor>a21</anchor>
      <arglist>(Index sp, tcPPtr diq, tcPPair qq, const vector&lt; bool &gt; &amp;assign=vector&lt; bool &gt;())</arglist>
    </member>
    <member kind="function">
      <type>ColourSinglet</type>
      <name>splitDiDiQuark</name>
      <anchor>a22</anchor>
      <arglist>(tcPPair qq1, tcPPair qq2, const vector&lt; bool &gt; &amp;assign=vector&lt; bool &gt;())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a23</anchor>
      <arglist>(ColourSinglet &amp;x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; ColourSinglet &gt;</type>
      <name>getSinglets</name>
      <anchor>e0</anchor>
      <arglist>(tcParticleSet &amp;left)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; ColourSinglet &gt;</type>
      <name>getSinglets</name>
      <anchor>e1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ColourSinglet</name>
      <anchor>b0</anchor>
      <arglist>(const ColourSinglet &amp;cs, Index si)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>fill</name>
      <anchor>d0</anchor>
      <arglist>(Index s0, bool forward, tcColinePtr first, tcParticleSet &amp;left)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>fill</name>
      <anchor>d1</anchor>
      <arglist>(Index i0, bool forward, const ColourSinglet &amp;cs, Index i1)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Index</type>
      <name>addPiece</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Junction</type>
      <name>addJunction</name>
      <anchor>d3</anchor>
      <arglist>(Index s0, bool forward)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcPVector</type>
      <name>thePartons</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; StringPiece &gt;</type>
      <name>thePieces</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Junction &gt;</type>
      <name>theSources</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Junction &gt;</type>
      <name>theSinks</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourSinglet::ColourSingletException</name>
    <filename>classThePEG_1_1ColourSinglet_1_1ColourSingletException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourSinglet::ColourSingletException</name>
    <filename>classThePEG_1_1ColourSinglet_1_1ColourSingletException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::Event</name>
    <filename>classThePEG_1_1Event.html</filename>
    <base>ThePEG::Base</base>
    <base>ThePEG::Named</base>
    <member kind="typedef">
      <type>map&lt; tcColinePtr, int &gt;</type>
      <name>ColourLineMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Event</name>
      <anchor>a2</anchor>
      <arglist>(const PPair &amp;newIncoming, tcEventBasePtr newHandler=tcEventBasePtr(), string newName=&quot;&quot;, long newNumber=-1, double weight=1.0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Event</name>
      <anchor>a3</anchor>
      <arglist>(const Event &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Event</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>clone</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>newCollision</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>a9</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>number</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>colourLineIndex</name>
      <anchor>a11</anchor>
      <arglist>(tcColinePtr) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>weight</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>weight</name>
      <anchor>a13</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a14</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a15</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>z45_0</anchor>
      <arglist>(OutputIterator r, const SelectorBase &amp;s) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>selectFinalState</name>
      <anchor>z45_1</anchor>
      <arglist>(OutputIterator r) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getFinalState</name>
      <anchor>z45_2</anchor>
      <arglist>(Container c) const</arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>getFinalState</name>
      <anchor>z45_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>primaryCollision</name>
      <anchor>z45_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const CollisionVector &amp;</type>
      <name>collisions</name>
      <anchor>z45_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tSubProPtr</type>
      <name>primarySubProcess</name>
      <anchor>z45_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>z45_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeDecay</name>
      <anchor>z47_0</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeParticle</name>
      <anchor>z47_1</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cleanSteps</name>
      <anchor>z47_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setInfo</name>
      <anchor>b0</anchor>
      <arglist>(tcEventBasePtr newHandler, string newName, long newNumber, double weight)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addCollision</name>
      <anchor>b1</anchor>
      <arglist>(tCollPtr c)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>primaryCollision</name>
      <anchor>b2</anchor>
      <arglist>(tCollPtr c)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticles</name>
      <anchor>b3</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addParticle</name>
      <anchor>b4</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addSubProcess</name>
      <anchor>b5</anchor>
      <arglist>(tSubProPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addStep</name>
      <anchor>b6</anchor>
      <arglist>(tStepPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>b7</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b8</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Event</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Event &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Event &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CollisionVector</type>
      <name>theCollisions</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepSet</type>
      <name>allSteps</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubProcessSet</type>
      <name>allSubProcesses</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>allParticles</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ColourLineMap</type>
      <name>theColourLines</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNumber</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theWeight</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Event &gt;</type>
      <name>initEvent</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt; Event &gt;</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Event, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Event_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Event &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Event_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Event &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventConfig</name>
    <filename>structThePEG_1_1EventConfig.html</filename>
    <member kind="function" static="yes">
      <type>void</type>
      <name>putHandler</name>
      <anchor>e0</anchor>
      <arglist>(PersistentOStream &amp;os, tcEventBasePtr h)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>getHandler</name>
      <anchor>e1</anchor>
      <arglist>(PersistentIStream &amp;is, tcEventBasePtr &amp;h)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>putParticleData</name>
      <anchor>e2</anchor>
      <arglist>(PersistentOStream &amp;os, tcEventPDPtr pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>getParticleData</name>
      <anchor>e3</anchor>
      <arglist>(PersistentIStream &amp;is, cEventPDPtr &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>nameHandler</name>
      <anchor>e4</anchor>
      <arglist>(tcEventBasePtr h)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>tcEventBasePtr</type>
      <name>currentGenerator</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventInfoBase</name>
    <filename>classThePEG_1_1EventInfoBase.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>EventInfoBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventInfoBase</name>
      <anchor>a1</anchor>
      <arglist>(const EventInfoBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventInfoBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a3</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventInfoBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const EventInfoBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; EventInfoBase &gt;</type>
      <name>initEventInfoBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventInfoBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventInfoBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventInfoBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventInfoBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventInfoBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Particle</name>
    <filename>classThePEG_1_1Particle.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>z49_0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>z49_1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Particle</name>
      <anchor>z49_2</anchor>
      <arglist>(tcEventPDPtr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Particle</name>
      <anchor>z49_3</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Particle</name>
      <anchor>z49_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>decayed</name>
      <anchor>z51_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleVector &amp;</type>
      <name>children</name>
      <anchor>z51_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addChild</name>
      <anchor>z51_2</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>abandonChild</name>
      <anchor>z51_3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>const tParticleVector &amp;</type>
      <name>parents</name>
      <anchor>z51_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>siblings</name>
      <anchor>z51_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>undecay</name>
      <anchor>z51_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>decayMode</name>
      <anchor>z51_7</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function">
      <type>tDMPtr</type>
      <name>decayMode</name>
      <anchor>z51_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>next</name>
      <anchor>z51_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>previous</name>
      <anchor>z51_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPPtr</type>
      <name>original</name>
      <anchor>z51_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>original</name>
      <anchor>z51_12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcPPtr</type>
      <name>final</name>
      <anchor>z51_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>final</name>
      <anchor>z51_14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>birthStep</name>
      <anchor>z53_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>number</name>
      <anchor>z53_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleDataClass &amp;</type>
      <name>data</name>
      <anchor>z55_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcEventPDPtr</type>
      <name>dataPtr</name>
      <anchor>z55_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>PDGName</name>
      <anchor>z55_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>id</name>
      <anchor>z55_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>momentum</name>
      <anchor>z57_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>z57_1</anchor>
      <arglist>(const Momentum3 &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>z57_2</anchor>
      <arglist>(const LorentzMomentum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>z57_3</anchor>
      <arglist>(const Lorentz5Momentum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mass</name>
      <anchor>z57_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>nominalMass</name>
      <anchor>z57_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scale</name>
      <anchor>z57_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>z57_7</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>mt2</name>
      <anchor>z57_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mt</name>
      <anchor>z57_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>perpmass2</name>
      <anchor>z57_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>perpmass</name>
      <anchor>z57_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rapidity</name>
      <anchor>z57_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eta</name>
      <anchor>z57_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>Pplus</name>
      <anchor>z57_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>Pminus</name>
      <anchor>z57_15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const LorentzPoint &amp;</type>
      <name>vertex</name>
      <anchor>z59_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPoint</type>
      <name>labVertex</name>
      <anchor>z59_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPoint</type>
      <name>decayVertex</name>
      <anchor>z59_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPoint</type>
      <name>labDecayVertex</name>
      <anchor>z59_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Distance &amp;</type>
      <name>lifeLength</name>
      <anchor>z59_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVertex</name>
      <anchor>z59_5</anchor>
      <arglist>(const LorentzPoint &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLabVertex</name>
      <anchor>z59_6</anchor>
      <arglist>(const LorentzPoint &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLifeLength</name>
      <anchor>z59_7</anchor>
      <arglist>(const Distance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLifeLength</name>
      <anchor>z59_8</anchor>
      <arglist>(const LorentzDistance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLifeLength</name>
      <anchor>z59_9</anchor>
      <arglist>(const Lorentz5Distance &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Time</type>
      <name>lifeTime</name>
      <anchor>z59_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>z61_0</anchor>
      <arglist>(const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>boost</name>
      <anchor>z61_1</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>boost</name>
      <anchor>z61_2</anchor>
      <arglist>(const Vector3 &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotateX</name>
      <anchor>z61_3</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotateY</name>
      <anchor>z61_4</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotateZ</name>
      <anchor>z61_5</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rotate</name>
      <anchor>z61_6</anchor>
      <arglist>(double a, const Vector3 &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>mirror</name>
      <anchor>z61_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepTransform</name>
      <anchor>z61_8</anchor>
      <arglist>(const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepBoost</name>
      <anchor>z61_9</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepBoost</name>
      <anchor>z61_10</anchor>
      <arglist>(const Vector3 &amp;b)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotateX</name>
      <anchor>z61_11</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotateY</name>
      <anchor>z61_12</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotateZ</name>
      <anchor>z61_13</anchor>
      <arglist>(double a)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deepRotate</name>
      <anchor>z61_14</anchor>
      <arglist>(double a, const Vector3 &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>massError</name>
      <anchor>z63_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>energyError</name>
      <anchor>z63_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>rhoError</name>
      <anchor>z63_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleEnergy</name>
      <anchor>z63_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleRho</name>
      <anchor>z63_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rescaleMass</name>
      <anchor>z63_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasColourInfo</name>
      <anchor>z65_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>antiColourLine</name>
      <anchor>z65_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tColinePtr</type>
      <name>colourLine</name>
      <anchor>z65_2</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>coloured</name>
      <anchor>z65_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasColour</name>
      <anchor>z65_4</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAntiColour</name>
      <anchor>z65_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcCBPtr</type>
      <name>colourInfo</name>
      <anchor>z65_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tCBPtr</type>
      <name>colourInfo</name>
      <anchor>z65_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourInfo</name>
      <anchor>z65_8</anchor>
      <arglist>(tCBPtr)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>colourNeighbour</name>
      <anchor>z65_9</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>antiColourNeighbour</name>
      <anchor>z65_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourNeighbour</name>
      <anchor>z65_11</anchor>
      <arglist>(tPPtr, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>antiColourNeighbour</name>
      <anchor>z65_12</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>antiColourConnect</name>
      <anchor>z65_13</anchor>
      <arglist>(tPPtr neighbour)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourConnect</name>
      <anchor>z65_14</anchor>
      <arglist>(tPPtr neighbour, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>incomingColour</name>
      <anchor>z65_15</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>incomingAntiColour</name>
      <anchor>z65_16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>incomingColour</name>
      <anchor>z65_17</anchor>
      <arglist>(tPPtr, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>incomingAntiColour</name>
      <anchor>z65_18</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>outgoingColour</name>
      <anchor>z65_19</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>outgoingAntiColour</name>
      <anchor>z65_20</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outgoingColour</name>
      <anchor>z65_21</anchor>
      <arglist>(tPPtr, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>outgoingAntiColour</name>
      <anchor>z65_22</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>colourFlow</name>
      <anchor>z65_23</anchor>
      <arglist>(tPPtr child, bool anti=false)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>antiColourFlow</name>
      <anchor>z65_24</anchor>
      <arglist>(tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetColour</name>
      <anchor>z65_25</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcSpinPtr</type>
      <name>spinInfo</name>
      <anchor>z67_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tSpinPtr</type>
      <name>spinInfo</name>
      <anchor>z67_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>spinInfo</name>
      <anchor>z67_2</anchor>
      <arglist>(tSpinPtr s)</arglist>
    </member>
    <member kind="function">
      <type>const EIVector &amp;</type>
      <name>getInfo</name>
      <anchor>z69_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>EIVector &amp;</type>
      <name>getInfo</name>
      <anchor>z69_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasRep</name>
      <anchor>z71_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initFull</name>
      <anchor>z71_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z73_0</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z73_1</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PrintParticles</name>
      <anchor>e0</anchor>
      <arglist>(ostream &amp;os, Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PrintParticles</name>
      <anchor>e1</anchor>
      <arglist>(ostream &amp;os, const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>string</type>
      <name>outputFormat</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual PPtr</type>
      <name>clone</name>
      <anchor>d0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>d1</anchor>
      <arglist>(const EventTranslationMap &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>number</name>
      <anchor>d2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>removeChild</name>
      <anchor>d3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>removeParent</name>
      <anchor>d4</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>mass</name>
      <anchor>d5</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>lifeTime</name>
      <anchor>d6</anchor>
      <arglist>(Length)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleRep &amp;</type>
      <name>rep</name>
      <anchor>d7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ParticleRep &amp;</type>
      <name>rep</name>
      <anchor>d8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Particle</name>
      <anchor>d9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Particle &amp;</type>
      <name>operator=</name>
      <anchor>d10</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cEventPDPtr</type>
      <name>theData</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>theMomentum</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleRep *</type>
      <name>theRep</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Particle &gt;</type>
      <name>initParticle</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt; Particle &gt;</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Particle::ParticleRep</name>
    <filename>structThePEG_1_1Particle_1_1ParticleRep.html</filename>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleRep &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>tParticleVector</type>
      <name>theParents</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleVector</type>
      <name>theChildren</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tPPtr</type>
      <name>thePrevious</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>PPtr</type>
      <name>theNext</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tDMPtr</type>
      <name>theDecayMode</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tStepPtr</type>
      <name>theBirthStep</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>LorentzPoint</type>
      <name>theVertex</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Lorentz5Distance</type>
      <name>theLifeLength</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Energy2</type>
      <name>theScale</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>theNumber</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>CBPtr</type>
      <name>theColourInfo</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpinPtr</type>
      <name>theSpinInfo</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>EIVector</type>
      <name>theExtraInfo</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Particle::ParticleRep</name>
    <filename>structThePEG_1_1Particle_1_1ParticleRep.html</filename>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleRep</name>
      <anchor>a3</anchor>
      <arglist>(const ParticleRep &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>tParticleVector</type>
      <name>theParents</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>ParticleVector</type>
      <name>theChildren</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tPPtr</type>
      <name>thePrevious</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>PPtr</type>
      <name>theNext</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tDMPtr</type>
      <name>theDecayMode</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>tStepPtr</type>
      <name>theBirthStep</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>LorentzPoint</type>
      <name>theVertex</name>
      <anchor>o6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Lorentz5Distance</type>
      <name>theLifeLength</name>
      <anchor>o7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>Energy2</type>
      <name>theScale</name>
      <anchor>o8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>theNumber</name>
      <anchor>o9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>CBPtr</type>
      <name>theColourInfo</name>
      <anchor>o10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>SpinPtr</type>
      <name>theSpinInfo</name>
      <anchor>o11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>EIVector</type>
      <name>theExtraInfo</name>
      <anchor>o12</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Particle, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Particle_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Particle &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Particle_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Particle &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits</name>
    <filename>structThePEG_1_1ParticleTraits.html</filename>
    <templarg>PType</templarg>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>PType &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(PType &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzMomentum</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(PType &amp;p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(PType &amp;p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e6</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; PPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01PPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(tPPtr p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(tPPtr p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(tPPtr p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e6</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; cPPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01cPPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>const Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tcPPtr &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e3</anchor>
      <arglist>(tcPPtr &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; tPPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01tPPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(tPPtr p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(tPPtr p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(tPPtr p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e6</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; tcPPtr &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01tcPPtr_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>const Particle &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>iCharge</name>
      <anchor>e3</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; LorentzMomentum &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01LorentzMomentum_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>LorentzMomentum &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(LorentzMomentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(const LorentzMomentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const LorentzMomentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(LorentzMomentum &amp;p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(LorentzMomentum &amp;p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(LorentzMomentum &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleTraits&lt; Lorentz5Momentum &gt;</name>
    <filename>structThePEG_1_1ParticleTraits_3_01Lorentz5Momentum_01_4.html</filename>
    <base>ThePEG::TraitsType</base>
    <member kind="function" static="yes">
      <type>Lorentz5Momentum &amp;</type>
      <name>ref</name>
      <anchor>e0</anchor>
      <arglist>(Lorentz5Momentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const LorentzMomentum &amp;</type>
      <name>momentum</name>
      <anchor>e1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e3</anchor>
      <arglist>(Lorentz5Momentum &amp;p, const LorentzRotation &amp;r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set5Momentum</name>
      <anchor>e4</anchor>
      <arglist>(Lorentz5Momentum &amp;p, const Lorentz5Momentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set3Momentum</name>
      <anchor>e5</anchor>
      <arglist>(Lorentz5Momentum &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Transformer</name>
    <filename>structThePEG_1_1Transformer.html</filename>
    <member kind="function">
      <type></type>
      <name>Transformer</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzRotation &amp;rin)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Transformer</name>
      <anchor>a1</anchor>
      <arglist>(const Transformer &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const PType &amp;p)</arglist>
    </member>
    <member kind="variable">
      <type>const LorentzRotation &amp;</type>
      <name>r</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectorBase</name>
    <filename>classThePEG_1_1SelectorBase.html</filename>
    <member kind="function">
      <type></type>
      <name>SelectorBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SelectorBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleSelector</name>
    <filename>structThePEG_1_1ParticleSelector.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>ParticleSelector</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParticleSelector</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectIfNot</name>
    <filename>classThePEG_1_1SelectIfNot.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>SelectIfNot</name>
      <anchor>a0</anchor>
      <arglist>(const SelectorBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SelectIfNot</name>
      <anchor>a1</anchor>
      <arglist>(const SelectIfNot &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SelectIfNot</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectIfBoth</name>
    <filename>classThePEG_1_1SelectIfBoth.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>SelectIfBoth</name>
      <anchor>a0</anchor>
      <arglist>(const SelectorBase &amp;, const SelectorBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SelectIfBoth</name>
      <anchor>a1</anchor>
      <arglist>(const SelectIfBoth &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SelectIfBoth</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s1</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SelectIfEither</name>
    <filename>classThePEG_1_1SelectIfEither.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function">
      <type></type>
      <name>SelectIfEither</name>
      <anchor>a0</anchor>
      <arglist>(const SelectorBase &amp;, const SelectorBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SelectIfEither</name>
      <anchor>a1</anchor>
      <arglist>(const SelectIfEither &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>finalState</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>intermediate</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allSteps</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>allCollisions</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SelectIfEither</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s1</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const SelectorBase &amp;</type>
      <name>s2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SpinBase</name>
    <filename>classThePEG_1_1SpinBase.html</filename>
    <base>ThePEG::EventInfoBase</base>
    <member kind="function">
      <type></type>
      <name>SpinBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinBase</name>
      <anchor>a1</anchor>
      <arglist>(const SpinBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SpinBase</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>hasPolarization</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DPair</type>
      <name>polarization</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>transform</name>
      <anchor>a5</anchor>
      <arglist>(const LorentzMomentum &amp;, LorentzRotation r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a6</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SpinBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SpinBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; SpinBase &gt;</type>
      <name>initSpinBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SpinBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SpinBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventInfoBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SpinBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SpinBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SpinBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::AllSelector</name>
    <filename>structThePEG_1_1AllSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FinalStateSelector</name>
    <filename>structThePEG_1_1FinalStateSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IntermediateSelector</name>
    <filename>structThePEG_1_1IntermediateSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PrimaryCollisionSelector</name>
    <filename>structThePEG_1_1PrimaryCollisionSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Intermediate</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>FinalState</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllSteps</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>AllCollisions</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ChargedSelector</name>
    <filename>structThePEG_1_1ChargedSelector.html</filename>
    <base>ThePEG::SelectorBase</base>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const Particle &amp;p)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Step</name>
    <filename>classThePEG_1_1Step.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Step</name>
      <anchor>a2</anchor>
      <arglist>(tCollPtr newCollision=tCollPtr(), tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Step</name>
      <anchor>a3</anchor>
      <arglist>(const Step &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Step</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>collision</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>a7</anchor>
      <arglist>(OutputIterator r, const SelectorBase &amp;s) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>selectFinalState</name>
      <anchor>a8</anchor>
      <arglist>(OutputIterator r) const</arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>getFinalState</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>all</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>particles</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleSet &amp;</type>
      <name>intermediates</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const SubProcessVector &amp;</type>
      <name>subProcesses</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>find</name>
      <anchor>a15</anchor>
      <arglist>(tcPPtr) const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>copyParticle</name>
      <anchor>a16</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>setCopy</name>
      <anchor>a17</anchor>
      <arglist>(tcPPtr pold, tPPtr pnew)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>insertCopy</name>
      <anchor>a18</anchor>
      <arglist>(tcPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a19</anchor>
      <arglist>(tcPPtr parent, tPPtr child, bool fixColour=true)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a20</anchor>
      <arglist>(tcPPtr parent, CIterator firstChild, CIterator lastChild, bool fixColour=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addDecayNoCheck</name>
      <anchor>a21</anchor>
      <arglist>(tPPtr parent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addDecayProduct</name>
      <anchor>a22</anchor>
      <arglist>(tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>removeDecayProduct</name>
      <anchor>a23</anchor>
      <arglist>(tcPPtr parent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>removeDecayProduct</name>
      <anchor>a24</anchor>
      <arglist>(tcPPtr parent, CIterator firstChild, CIterator lastChild)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a25</anchor>
      <arglist>(Iterator firstParent, Iterator lastParent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>addDecayProduct</name>
      <anchor>a26</anchor>
      <arglist>(PIterator firstParent, PIterator lastParent, CIterator firstChild, CIterator lastChild)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>fixColourFlow</name>
      <anchor>a27</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>colourNeighbour</name>
      <anchor>a28</anchor>
      <arglist>(tcPPtr particle, bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>antiColourNeighbour</name>
      <anchor>a29</anchor>
      <arglist>(tcPPtr particle) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addParticles</name>
      <anchor>a30</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addParticle</name>
      <anchor>a31</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIntermediates</name>
      <anchor>a32</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIntermediate</name>
      <anchor>a33</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>insertIntermediate</name>
      <anchor>a34</anchor>
      <arglist>(tPPtr p, tPPtr parent, tPPtr child)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addSubProcess</name>
      <anchor>a35</anchor>
      <arglist>(tSubProPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeParticle</name>
      <anchor>a36</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>nullStep</name>
      <anchor>a37</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>getCurrent</name>
      <anchor>a38</anchor>
      <arglist>(const Cont &amp;c) const</arglist>
    </member>
    <member kind="function">
      <type>tParticleSet</type>
      <name>getCurrent</name>
      <anchor>a39</anchor>
      <arglist>(Iterator first, Iterator last) const</arglist>
    </member>
    <member kind="function">
      <type>StepPtr</type>
      <name>clone</name>
      <anchor>a40</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a41</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a42</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; tPVector &gt;</type>
      <name>getSinglets</name>
      <anchor>e0</anchor>
      <arglist>(PIterator first, PIterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>b0</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addIfFinal</name>
      <anchor>b2</anchor>
      <arglist>(Inserter o, PPointer p)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>vector&lt; tPVector &gt;</type>
      <name>getSinglets</name>
      <anchor>f0</anchor>
      <arglist>(tParticleSet &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Step &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Step &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>collision</name>
      <anchor>d1</anchor>
      <arglist>(tCollPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>handler</name>
      <anchor>d2</anchor>
      <arglist>(tcEventBasePtr)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>theParticles</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>theIntermediates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubProcessVector</type>
      <name>theSubProcesses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleSet</type>
      <name>allParticles</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tCollPtr</type>
      <name>theCollision</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Step &gt;</type>
      <name>initStep</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Step, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Step_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Step &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Step_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Step &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SubProcess</name>
    <filename>classThePEG_1_1SubProcess.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>void *</type>
      <name>operator new</name>
      <anchor>a0</anchor>
      <arglist>(size_t)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator delete</name>
      <anchor>a1</anchor>
      <arglist>(void *, size_t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcess</name>
      <anchor>a2</anchor>
      <arglist>(const PPair &amp;newIncoming, tCollPtr newCollision=tCollPtr(), tcEventBasePtr newHandler=tcEventBasePtr())</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcess</name>
      <anchor>a3</anchor>
      <arglist>(const SubProcess &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~SubProcess</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcEventBasePtr</type>
      <name>handler</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>collision</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleVector &amp;</type>
      <name>intermediates</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleVector &amp;</type>
      <name>outgoing</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setOutgoing</name>
      <anchor>a10</anchor>
      <arglist>(InputIterator, InputIterator)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addOutgoing</name>
      <anchor>a11</anchor>
      <arglist>(tPPtr p, bool fixrelations=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setIntermediates</name>
      <anchor>a12</anchor>
      <arglist>(InputIterator, InputIterator)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIntermediate</name>
      <anchor>a13</anchor>
      <arglist>(tPPtr p, bool fixrelations=true)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>removeEntry</name>
      <anchor>a14</anchor>
      <arglist>(tPPtr p)</arglist>
    </member>
    <member kind="function">
      <type>SubProPtr</type>
      <name>clone</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>transform</name>
      <anchor>a16</anchor>
      <arglist>(const LorentzRotation &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>shat</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>that</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uhat</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a20</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a21</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>rebind</name>
      <anchor>b0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>SubProcess</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SubProcess &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const SubProcess &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcEventBasePtr</type>
      <name>theHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tCollPtr</type>
      <name>theCollision</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleVector</type>
      <name>theIntermediates</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleVector</type>
      <name>theOutgoing</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SubProcess &gt;</type>
      <name>initSubProcess</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="friend" protection="private">
      <type>friend class</type>
      <name>ClassTraits&lt; SubProcess &gt;</name>
      <anchor>n0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SubProcess, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SubProcess_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventRecordBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SubProcess &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SubProcess_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SubProcess &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ACDCSampler</name>
    <filename>classThePEG_1_1ACDCSampler.html</filename>
    <base>ThePEG::SamplerBase</base>
    <member kind="typedef">
      <type>ACDCGenerator::ACDCGen&lt; RandomGenerator, tEHPtr &gt;</type>
      <name>SamplerType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCSampler</name>
      <anchor>z75_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ACDCSampler</name>
      <anchor>z75_1</anchor>
      <arglist>(const ACDCSampler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ACDCSampler</name>
      <anchor>z75_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z77_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z77_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>lastBin</name>
      <anchor>z77_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rejectLast</name>
      <anchor>z77_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>integratedXSec</name>
      <anchor>z77_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>sumWeights</name>
      <anchor>z77_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z79_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z79_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z81_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z81_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z83_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z83_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z83_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z83_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z83_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z83_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ACDCSampler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ACDCSampler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SamplerType</type>
      <name>theSampler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMargin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNTry</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ACDCSampler &gt;</type>
      <name>initACDCSampler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ACDCSampler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ACDCSampler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>SamplerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ACDCSampler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ACDCSampler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ACDCSampler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AnalysisHandler</name>
    <filename>classThePEG_1_1AnalysisHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z93_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z93_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z93_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z93_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z93_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z93_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AnalysisVector</type>
      <name>theSlaves</name>
      <anchor>z93_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AnalysisHandler</name>
      <anchor>z85_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AnalysisHandler</name>
      <anchor>z85_1</anchor>
      <arglist>(const AnalysisHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~AnalysisHandler</name>
      <anchor>z85_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>analyze</name>
      <anchor>z87_0</anchor>
      <arglist>(tEventPtr event, long ieve, int loop, int state)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual LorentzRotation</type>
      <name>transform</name>
      <anchor>z87_1</anchor>
      <arglist>(tEventPtr event) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>analyze</name>
      <anchor>z87_2</anchor>
      <arglist>(const tPVector &amp;particles)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>analyze</name>
      <anchor>z87_3</anchor>
      <arglist>(tPPtr particle)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z89_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z89_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z91_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z91_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; AnalysisHandler &gt;</type>
      <name>initAnalysisHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; AnalysisHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01AnalysisHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; AnalysisHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01AnalysisHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; AnalysisHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CascadeHandler</name>
    <filename>classThePEG_1_1CascadeHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>cascade</name>
      <anchor>a0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CascadeHandler</name>
      <anchor>z95_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CascadeHandler</name>
      <anchor>z95_1</anchor>
      <arglist>(const CascadeHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CascadeHandler</name>
      <anchor>z95_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z97_0</anchor>
      <arglist>(PartialCollisionHandler &amp;ch, const tPVector &amp;tagged, const Hint &amp;hint)</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>tagged</name>
      <anchor>z99_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const Hint &amp;</type>
      <name>hint</name>
      <anchor>z99_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PDF &amp;</type>
      <name>firstPDF</name>
      <anchor>z99_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PDF &amp;</type>
      <name>secondPDF</name>
      <anchor>z99_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const pair&lt; PDF, PDF &gt; &amp;</type>
      <name>pdfs</name>
      <anchor>z99_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPartCollHdlPtr</type>
      <name>collisionHandler</name>
      <anchor>z99_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z101_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z101_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z101_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z101_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z101_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z101_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CascadeHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const CascadeHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const tPVector *</type>
      <name>theTagged</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const Hint *</type>
      <name>theHint</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pair&lt; PDF, PDF &gt;</type>
      <name>thePDFs</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPartCollHdlPtr</type>
      <name>theCollisionHandler</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; CascadeHandler &gt;</type>
      <name>initCascadeHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; CascadeHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01CascadeHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; CascadeHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01CascadeHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; CascadeHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClusterCollapser</name>
    <filename>classThePEG_1_1ClusterCollapser.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>FlavGenPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; ColourSinglet &gt;</type>
      <name>collapse</name>
      <anchor>a0</anchor>
      <arglist>(tPVector tagged, tStepPtr newstep)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual multimap&lt; Energy, ColourSinglet &gt;</type>
      <name>getSinglets</name>
      <anchor>a1</anchor>
      <arglist>(const tPVector &amp;tagged) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ColourSinglet</type>
      <name>splitDiQuarkJunction</name>
      <anchor>a2</anchor>
      <arglist>(ColourSinglet &amp;cs, tStepPtr newStep) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ColourSinglet</type>
      <name>splitDiDiQuark</name>
      <anchor>a3</anchor>
      <arglist>(ColourSinglet &amp;cs, tStepPtr newStep) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>cut</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nTry2</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>pickFlavour</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ClusterCollapser</name>
      <anchor>z103_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ClusterCollapser</name>
      <anchor>z103_1</anchor>
      <arglist>(const ClusterCollapser &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClusterCollapser</name>
      <anchor>z103_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z105_0</anchor>
      <arglist>(PartialCollisionHandler &amp;ch, const tPVector &amp;tagged, const Hint &amp;hint)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z107_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z107_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>diQuarkJunction</name>
      <anchor>e0</anchor>
      <arglist>(const ColourSinglet &amp;cs)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>diDiQuark</name>
      <anchor>e1</anchor>
      <arglist>(const ColourSinglet &amp;cs)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>mass</name>
      <anchor>e2</anchor>
      <arglist>(const ColourSinglet &amp;cl)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>collapse</name>
      <anchor>b0</anchor>
      <arglist>(tStepPtr newStep, const ColourSinglet &amp;cs, const tPVector &amp;tagged) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>collapse2</name>
      <anchor>b1</anchor>
      <arglist>(tStepPtr newStep, const ColourSinglet &amp;cs) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tPVector</type>
      <name>getCompensators</name>
      <anchor>b2</anchor>
      <arglist>(Energy mh, const ColourSinglet &amp;cs, const tPVector &amp;tagged, tStepPtr newStep) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>b3</anchor>
      <arglist>(const ColourSinglet &amp;cs) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPair</type>
      <name>getHadrons</name>
      <anchor>b4</anchor>
      <arglist>(const ColourSinglet &amp;cs) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z109_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z109_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z111_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z111_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z111_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z111_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z111_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z111_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Exception::Severity</type>
      <name>errorlevel</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>pStrange</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>ClusterCollapser &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ClusterCollapser &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theEnergyCut</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNTry2</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlavGenPtr</type>
      <name>flavGen</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ClusterCollapser &gt;</type>
      <name>initClusterCollapser</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClusterCollapser::ClusterException</name>
    <filename>classThePEG_1_1ClusterCollapser_1_1ClusterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>ClusterException</name>
      <anchor>a0</anchor>
      <arglist>(const ClusterCollapser &amp;cc)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClusterCollapser::ClusterException</name>
    <filename>classThePEG_1_1ClusterCollapser_1_1ClusterException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>ClusterException</name>
      <anchor>a0</anchor>
      <arglist>(const ClusterCollapser &amp;cc)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ClusterCollapser, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ClusterCollapser_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ClusterCollapser &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ClusterCollapser_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ClusterCollapser &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CollisionHandler</name>
    <filename>classThePEG_1_1CollisionHandler.html</filename>
    <base>ThePEG::PartialCollisionHandler</base>
    <member kind="typedef">
      <type>vector&lt; SubHdlPtr &gt;</type>
      <name>SubHandlerList</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Selector&lt; XCombPtr &gt;</type>
      <name>XSelector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; XCombPtr &gt;</type>
      <name>XVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; CrossSection &gt;</type>
      <name>XSVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; tMEPtr, XVector &gt;</type>
      <name>MEXMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initialize</name>
      <anchor>a0</anchor>
      <arglist>(Energy maxEnergy)</arglist>
    </member>
    <member kind="function">
      <type>const LorentzRotation &amp;</type>
      <name>currentEventBoost</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>dSigDR</name>
      <anchor>a2</anchor>
      <arglist>(const pair&lt; double, double &gt; ll, Energy2 maxS, int ibin, int nr, const double *r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>select</name>
      <anchor>a3</anchor>
      <arglist>(int bin, double weight)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CollisionHandler</name>
      <anchor>z113_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CollisionHandler</name>
      <anchor>z113_1</anchor>
      <arglist>(const CollisionHandler &amp;ch)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CollisionHandler</name>
      <anchor>z113_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>incoming</name>
      <anchor>z115_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>cuts</name>
      <anchor>z115_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nBins</name>
      <anchor>z115_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxDim</name>
      <anchor>z115_3</anchor>
      <arglist>(int bin) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z117_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z117_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z117_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z119_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z119_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addME</name>
      <anchor>b0</anchor>
      <arglist>(Energy maxEnergy, tSubHdlPtr sub, tPExtrPtr extractor, tKinCutPtr cuts, tMEPtr me, const PBPair &amp;pBins)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tCollPtr</type>
      <name>performCollision</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>initGroups</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>LorentzRotation &amp;</type>
      <name>currentEventBoost</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>createIncoming</name>
      <anchor>b4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setScale</name>
      <anchor>b5</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const XVector &amp;</type>
      <name>xCombs</name>
      <anchor>b6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>XVector &amp;</type>
      <name>xCombs</name>
      <anchor>b7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const XSVector &amp;</type>
      <name>xSecs</name>
      <anchor>b8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>XSVector &amp;</type>
      <name>xSecs</name>
      <anchor>b9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>int</type>
      <name>binStrategy</name>
      <anchor>b10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z121_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z121_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const SubHandlerList &amp;</type>
      <name>subProcesses</name>
      <anchor>d0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SubHandlerList &amp;</type>
      <name>subProcesses</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const CollisionHandler &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const CollisionHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>theIncomingA</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>theIncomingB</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>theIncoming</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubHandlerList</type>
      <name>theSubProcesses</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>XVector</type>
      <name>theXCombs</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>XSVector</type>
      <name>theXSecs</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theBinStrategy</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MEXMap</type>
      <name>theMEXMap</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>theMaxDims</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LorentzRotation</type>
      <name>theCurrentEventBoost</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; CollisionHandler &gt;</type>
      <name>initCollisionHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; CollisionHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01CollisionHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PartialCollisionHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; CollisionHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01CollisionHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; CollisionHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CollHdlExtractorError</name>
    <filename>structThePEG_1_1CollHdlExtractorError.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>CollHdlExtractorError</name>
      <anchor>a0</anchor>
      <arglist>(const CollisionHandler &amp;, const SubProcessHandler &amp;, const PartonExtractor &amp;, const cPDPair &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CollHdlInitWarning</name>
    <filename>structThePEG_1_1CollHdlInitWarning.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecayHandler</name>
    <filename>classThePEG_1_1DecayHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="function">
      <type>void</type>
      <name>performDecay</name>
      <anchor>a0</anchor>
      <arglist>(tPPtr parent, Step &amp;s) const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxLoop</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayHandler</name>
      <anchor>z123_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayHandler</name>
      <anchor>z123_1</anchor>
      <arglist>(const DecayHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DecayHandler</name>
      <anchor>z123_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z125_0</anchor>
      <arglist>(PartialCollisionHandler &amp;ch, const tPVector &amp;tagged, const Hint &amp;hint)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z127_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z127_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z129_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z129_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z131_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z131_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z131_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z131_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z131_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DecayHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theMaxLoop</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; DecayHandler &gt;</type>
      <name>initDecayHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DecayHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DecayHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DecayHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DecayHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DecayHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlNoDecayMode</name>
    <filename>structThePEG_1_1DecHdlNoDecayMode.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlNoDecayMode</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlNoDecayer</name>
    <filename>structThePEG_1_1DecHdlNoDecayer.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlNoDecayer</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;, const Interfaced &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlDecayFailed</name>
    <filename>structThePEG_1_1DecHdlDecayFailed.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlDecayFailed</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;, long n)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DecHdlChildFail</name>
    <filename>structThePEG_1_1DecHdlChildFail.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DecHdlChildFail</name>
      <anchor>a0</anchor>
      <arglist>(const Interfaced &amp;, const Interfaced &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventHandler</name>
    <filename>classThePEG_1_1EventHandler.html</filename>
    <base>ThePEG::CollisionHandler</base>
    <member kind="function">
      <type></type>
      <name>EventHandler</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventHandler</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~EventHandler</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>statistics</name>
      <anchor>a4</anchor>
      <arglist>(ostream &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>dSigDR</name>
      <anchor>z133_0</anchor>
      <arglist>(const vector&lt; double &gt; &amp;r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>generateEvent</name>
      <anchor>z133_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>continueEvent</name>
      <anchor>z133_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxLoop</name>
      <anchor>z135_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>statLevel</name>
      <anchor>z135_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>weighted</name>
      <anchor>z135_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>compensating</name>
      <anchor>z135_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const LuminosityFunction &amp;</type>
      <name>lumiFn</name>
      <anchor>z135_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>lumiDim</name>
      <anchor>z135_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nDim</name>
      <anchor>z135_6</anchor>
      <arglist>(int bin) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z137_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z137_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z137_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z137_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z139_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z139_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>LuminosityFunction &amp;</type>
      <name>lumiFn</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>reject</name>
      <anchor>b1</anchor>
      <arglist>(double weight)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tSamplerPtr</type>
      <name>sampler</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tcSamplerPtr</type>
      <name>sampler</name>
      <anchor>b3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z141_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z141_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>lumiFn</name>
      <anchor>d0</anchor>
      <arglist>(LumiFnPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const EventHandler &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LumiFnPtr</type>
      <name>theLumiFn</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>weightedEvents</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theMaxLoop</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theStatLevel</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SamplerPtr</type>
      <name>theSampler</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theLumiDim</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNDim</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; EventHandler &gt;</type>
      <name>initEventHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>CollisionHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventInitException</name>
    <filename>structThePEG_1_1EventInitException.html</filename>
    <base>ThePEG::InitException</base>
    <member kind="function">
      <type></type>
      <name>EventInitException</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventLumiFnErr</name>
    <filename>structThePEG_1_1EventLumiFnErr.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>EventLumiFnErr</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;, const LuminosityFunction &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventInitNoXSec</name>
    <filename>structThePEG_1_1EventInitNoXSec.html</filename>
    <base>ThePEG::InitException</base>
    <member kind="function">
      <type></type>
      <name>EventInitNoXSec</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EventLoopException</name>
    <filename>structThePEG_1_1EventLoopException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>EventLoopException</name>
      <anchor>a0</anchor>
      <arglist>(const EventHandler &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventManipulator</name>
    <filename>classThePEG_1_1EventManipulator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function" virtualness="pure">
      <type>virtual int</type>
      <name>manipulate</name>
      <anchor>a0</anchor>
      <arglist>(tEHPtr eh, tEventPtr event)=0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventManipulator</name>
      <anchor>z143_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventManipulator</name>
      <anchor>z143_1</anchor>
      <arglist>(const EventManipulator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventManipulator</name>
      <anchor>z143_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z145_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z145_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z145_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z145_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z145_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventManipulator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const EventManipulator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; EventManipulator &gt;</type>
      <name>initEventManipulator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventManipulator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventManipulator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventManipulator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventManipulator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventManipulator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FixedCMSLuminosity</name>
    <filename>classThePEG_1_1FixedCMSLuminosity.html</filename>
    <base>ThePEG::LuminosityFunction</base>
    <member kind="function">
      <type>Energy</type>
      <name>energy</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FixedCMSLuminosity</name>
      <anchor>z147_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FixedCMSLuminosity</name>
      <anchor>z147_1</anchor>
      <arglist>(const FixedCMSLuminosity &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FixedCMSLuminosity</name>
      <anchor>z147_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z149_0</anchor>
      <arglist>(const cPDPair &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z149_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z151_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z151_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z151_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z151_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z151_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z153_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z153_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z155_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z155_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FixedCMSLuminosity &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FixedCMSLuminosity &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theEnergy</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; FixedCMSLuminosity &gt;</type>
      <name>initFixedCMSLuminosity</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FixedCMSLuminosity, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FixedCMSLuminosity_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>LuminosityFunction</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FixedCMSLuminosity &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FixedCMSLuminosity_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FixedCMSLuminosity &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FlavourGenerator</name>
    <filename>classThePEG_1_1FlavourGenerator.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>FlavourGenerator</name>
      <anchor>z157_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FlavourGenerator</name>
      <anchor>z157_1</anchor>
      <arglist>(const FlavourGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FlavourGenerator</name>
      <anchor>z157_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tcPDPair</type>
      <name>generateHadron</name>
      <anchor>z159_0</anchor>
      <arglist>(tcPDPtr quark) const =0</arglist>
    </member>
    <member kind="function">
      <type>tcPDPair</type>
      <name>alwaysGenerateHadron</name>
      <anchor>z159_1</anchor>
      <arglist>(tcPDPtr quark) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>z159_2</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>z159_3</anchor>
      <arglist>(long iq1, long iq2) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetHadron</name>
      <anchor>z159_4</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetHadron</name>
      <anchor>z159_5</anchor>
      <arglist>(long iq1, long iq2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getBaryon</name>
      <anchor>z159_6</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2, tcPDPtr q3) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getBaryon</name>
      <anchor>z159_7</anchor>
      <arglist>(long q1, long q2, long q3) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetBaryon</name>
      <anchor>z159_8</anchor>
      <arglist>(tcPDPtr q1, tcPDPtr q2, tcPDPtr q3) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>alwaysGetBaryon</name>
      <anchor>z159_9</anchor>
      <arglist>(long q1, long q2, long q3) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>selectQuark</name>
      <anchor>z159_10</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>selectFlavour</name>
      <anchor>z159_11</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z161_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z161_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlavourGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FlavourGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; FlavourGenerator &gt;</type>
      <name>initFlavourGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FlavourGeneratorException</name>
    <filename>classThePEG_1_1FlavourGeneratorException.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FlavourGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FlavourGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FlavourGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FlavourGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FlavourGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GaussianPtGenerator</name>
    <filename>classThePEG_1_1GaussianPtGenerator.html</filename>
    <base>ThePEG::PtGenerator</base>
    <member kind="function">
      <type></type>
      <name>GaussianPtGenerator</name>
      <anchor>z163_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GaussianPtGenerator</name>
      <anchor>z163_1</anchor>
      <arglist>(const GaussianPtGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GaussianPtGenerator</name>
      <anchor>z163_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual TransverseMomentum</type>
      <name>generate</name>
      <anchor>z165_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z167_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z167_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z169_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z169_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z171_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z171_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z171_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z171_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z171_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z171_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GaussianPtGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GaussianPtGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theSigma</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theUpperCut</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; GaussianPtGenerator &gt;</type>
      <name>initGaussianPtGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GaussianPtGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GaussianPtGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PtGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GaussianPtGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GaussianPtGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GaussianPtGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HadronizationHandler</name>
    <filename>classThePEG_1_1HadronizationHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="function">
      <type></type>
      <name>HadronizationHandler</name>
      <anchor>z173_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HadronizationHandler</name>
      <anchor>z173_1</anchor>
      <arglist>(const HadronizationHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HadronizationHandler</name>
      <anchor>z173_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z175_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z175_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z175_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z175_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z175_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HadronizationHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HadronizationHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; HadronizationHandler &gt;</type>
      <name>initHadronizationHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; HadronizationHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01HadronizationHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; HadronizationHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01HadronizationHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; HadronizationHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerBaseT</name>
    <filename>classThePEG_1_1HandlerBaseT.html</filename>
    <templarg>I</templarg>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>a1</anchor>
      <arglist>(double xu) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>a2</anchor>
      <arglist>(double xl, double xu) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>a4</anchor>
      <arglist>(double p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>a5</anchor>
      <arglist>(double p1, double p2) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rndsign</name>
      <anchor>a6</anchor>
      <arglist>(double p1, double p2, double p3) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd2</name>
      <anchor>a7</anchor>
      <arglist>(double p0, double p1) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd3</name>
      <anchor>a8</anchor>
      <arglist>(double p0, double p1, double p2) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd4</name>
      <anchor>a9</anchor>
      <arglist>(double p0, double p1, double p2, double p3) const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>irnd</name>
      <anchor>a10</anchor>
      <arglist>(long xu=2) const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>irnd</name>
      <anchor>a11</anchor>
      <arglist>(long xl, long xu) const</arglist>
    </member>
    <member kind="function">
      <type>const StandardModelBase &amp;</type>
      <name>SM</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tSMPtr</type>
      <name>standardModel</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HandlerBaseT</name>
      <anchor>z177_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HandlerBaseT</name>
      <anchor>z177_1</anchor>
      <arglist>(const HandlerBaseT &amp;)</arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual</type>
      <name>~HandlerBaseT</name>
      <anchor>z177_2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerBase</name>
    <filename>classThePEG_1_1HandlerBase.html</filename>
    <base>ThePEG::HandlerBaseT&lt; 0 &gt;</base>
    <member kind="function">
      <type></type>
      <name>HandlerBase</name>
      <anchor>z179_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerBase</name>
      <anchor>z179_1</anchor>
      <arglist>(const HandlerBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HandlerBase</name>
      <anchor>z179_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z181_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z181_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z181_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z181_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z181_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HandlerBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HandlerBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; HandlerBase &gt;</type>
      <name>initHandlerBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; HandlerBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01HandlerBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; HandlerBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01HandlerBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; HandlerBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerGroupBase</name>
    <filename>classThePEG_1_1HandlerGroupBase.html</filename>
    <member kind="typedef">
      <type>pair&lt; StepHdlPtr, HintPtr &gt;</type>
      <name>StepWithHint</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>StepVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; StepWithHint &gt;</type>
      <name>StepHintVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>deque&lt; HintPtr &gt;</type>
      <name>HintVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerGroupBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HandlerGroupBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>a3</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type>StepWithHint</type>
      <name>next</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPreHandler</name>
      <anchor>a5</anchor>
      <arglist>(tStepHdlPtr sh, tHintPtr hint, const HandlerGroupBase &amp;ext)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPostHandler</name>
      <anchor>a6</anchor>
      <arglist>(tStepHdlPtr sh, tHintPtr hint, const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addHint</name>
      <anchor>a7</anchor>
      <arglist>(tHintPtr hint, const HandlerGroupBase &amp;ext)</arglist>
    </member>
    <member kind="function">
      <type>StepVector &amp;</type>
      <name>preHandlers</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const StepVector &amp;</type>
      <name>preHandlers</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tStepHdlPtr</type>
      <name>defaultHandler</name>
      <anchor>a10</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>StepVector &amp;</type>
      <name>postHandlers</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const StepVector &amp;</type>
      <name>postHandlers</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tStepHdlPtr</type>
      <name>handler</name>
      <anchor>a13</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setHandler</name>
      <anchor>a14</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>setHandler</name>
      <anchor>a15</anchor>
      <arglist>(tStepHdlPtr, const HandlerGroupBase &amp;ext)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>refillDefaultHandler</name>
      <anchor>a16</anchor>
      <arglist>(tStepHdlPtr)=0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>refillDefaults</name>
      <anchor>a17</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clear</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>handlerClass</name>
      <anchor>a19</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceSetPrehandler</name>
      <anchor>a20</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceInsertPrehandler</name>
      <anchor>a21</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceErasePrehandler</name>
      <anchor>a22</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPrehandlers</name>
      <anchor>a23</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceSetPosthandler</name>
      <anchor>a24</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceInsertPosthandler</name>
      <anchor>a25</anchor>
      <arglist>(StepHdlPtr p, int i)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceErasePosthandler</name>
      <anchor>a26</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPosthandlers</name>
      <anchor>a27</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>write</name>
      <anchor>a28</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>read</name>
      <anchor>a29</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>HandlerGroupBase</name>
      <anchor>b0</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isEmpty</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepVector</type>
      <name>theDefaultPreHandlers</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepVector</type>
      <name>theDefaultPostHandlers</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepHintVector</type>
      <name>thePreHandlers</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HintVector</type>
      <name>theHints</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>StepHintVector</type>
      <name>thePostHandlers</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>checkInsert</name>
      <anchor>d0</anchor>
      <arglist>(StepHintVector &amp;current, const StepVector &amp;def)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HandlerGroupBase &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const HandlerGroupBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HandlerGroup</name>
    <filename>classThePEG_1_1HandlerGroup.html</filename>
    <templarg>HDLR</templarg>
    <base>ThePEG::HandlerGroupBase</base>
    <member kind="typedef">
      <type>Ptr&lt; HDLR &gt;::pointer</type>
      <name>HdlPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HDLR &gt;::transient_pointer</type>
      <name>tHdlPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerGroup</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HandlerGroup</name>
      <anchor>a1</anchor>
      <arglist>(const HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HandlerGroup</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>setHandler</name>
      <anchor>a3</anchor>
      <arglist>(tStepHdlPtr, const HandlerGroupBase &amp;ext)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setHandler</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tStepHdlPtr</type>
      <name>handler</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tStepHdlPtr</type>
      <name>defaultHandler</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>refillDefaultHandler</name>
      <anchor>a7</anchor>
      <arglist>(tStepHdlPtr)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clear</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>handlerClass</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>interfaceSetHandler</name>
      <anchor>a10</anchor>
      <arglist>(HdlPtr)</arglist>
    </member>
    <member kind="function">
      <type>HdlPtr</type>
      <name>interfaceGetHandler</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>write</name>
      <anchor>a12</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>read</name>
      <anchor>a13</anchor>
      <arglist>(PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HandlerGroup&lt; HDLR &gt; &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HandlerGroup&lt; HDLR &gt; &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HdlPtr</type>
      <name>theDefaultHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HdlPtr</type>
      <name>theHandler</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Hint</name>
    <filename>classThePEG_1_1Hint.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type>bool</type>
      <name>tagged</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPVector</type>
      <name>tagged</name>
      <anchor>a1</anchor>
      <arglist>(const Step &amp;s) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>tag</name>
      <anchor>a2</anchor>
      <arglist>(InputIterator first, InputIterator last)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>tag</name>
      <anchor>a3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a4</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>stop</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>a6</anchor>
      <arglist>(const Scale &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const Scale &amp;</type>
      <name>scale</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Hint</name>
      <anchor>z183_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Hint</name>
      <anchor>z183_1</anchor>
      <arglist>(const Hint &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Hint</name>
      <anchor>z183_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z185_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z185_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tHintPtr</type>
      <name>Default</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const Hint &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Hint &amp;h)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theTagged</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Scale</type>
      <name>theScale</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theStopFlag</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>Hint</type>
      <name>theDefaultHint</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Hint &gt;</type>
      <name>initHint</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Hint, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Hint_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Hint &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Hint_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Hint &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::KinematicalCuts</name>
    <filename>classThePEG_1_1KinematicalCuts.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>KinematicalCuts</name>
      <anchor>z187_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>KinematicalCuts</name>
      <anchor>z187_1</anchor>
      <arglist>(const KinematicalCuts &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~KinematicalCuts</name>
      <anchor>z187_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cut</name>
      <anchor>z189_0</anchor>
      <arglist>(const SubProcess &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cut</name>
      <anchor>z189_1</anchor>
      <arglist>(const Collision &amp;, const LorentzRotation &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMin</name>
      <anchor>z191_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMax</name>
      <anchor>z191_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMin</name>
      <anchor>z191_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMax</name>
      <anchor>z191_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>mHat</name>
      <anchor>z191_4</anchor>
      <arglist>(Energy mhat) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>sHat</name>
      <anchor>z191_5</anchor>
      <arglist>(Energy2 shat) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMin</name>
      <anchor>z191_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMax</name>
      <anchor>z191_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>pTHat</name>
      <anchor>z191_8</anchor>
      <arglist>(Energy pt) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatSingularMin</name>
      <anchor>z191_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>singularMassMax</name>
      <anchor>z191_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yStarMin</name>
      <anchor>z193_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>yStarMax</name>
      <anchor>z193_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>yStar</name>
      <anchor>z193_2</anchor>
      <arglist>(double y) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxYMin</name>
      <anchor>z193_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxYMax</name>
      <anchor>z193_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>maxY</name>
      <anchor>z193_5</anchor>
      <arglist>(double y) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minYMin</name>
      <anchor>z193_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minYMax</name>
      <anchor>z193_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>minY</name>
      <anchor>z193_8</anchor>
      <arglist>(double y) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxEtaMin</name>
      <anchor>z193_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxEtaMax</name>
      <anchor>z193_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>maxEta</name>
      <anchor>z193_11</anchor>
      <arglist>(double eta) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minEtaMin</name>
      <anchor>z193_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minEtaMax</name>
      <anchor>z193_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>minEta</name>
      <anchor>z193_14</anchor>
      <arglist>(double eta) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxCTMin</name>
      <anchor>z193_15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxCTMax</name>
      <anchor>z193_16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>maxCT</name>
      <anchor>z193_17</anchor>
      <arglist>(double ct) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minCTMin</name>
      <anchor>z193_18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>minCTMax</name>
      <anchor>z193_19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>minCT</name>
      <anchor>z193_20</anchor>
      <arglist>(double ct) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x1Min</name>
      <anchor>z193_21</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x1Max</name>
      <anchor>z193_22</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>x1</name>
      <anchor>z193_23</anchor>
      <arglist>(double x) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x2Min</name>
      <anchor>z193_24</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x2Max</name>
      <anchor>z193_25</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>x2</name>
      <anchor>z193_26</anchor>
      <arglist>(double x) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xFMin</name>
      <anchor>z193_27</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xFMax</name>
      <anchor>z193_28</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>xF</name>
      <anchor>z193_29</anchor>
      <arglist>(double x) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMin</name>
      <anchor>z193_30</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMax</name>
      <anchor>z193_31</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>cTH</name>
      <anchor>z193_32</anchor>
      <arglist>(double cth) const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMin</name>
      <anchor>z193_33</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMax</name>
      <anchor>z193_34</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>tHat</name>
      <anchor>z193_35</anchor>
      <arglist>(Energy2 that) const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMin</name>
      <anchor>z193_36</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMax</name>
      <anchor>z193_37</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>uHat</name>
      <anchor>z193_38</anchor>
      <arglist>(Energy2 uhat) const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMin</name>
      <anchor>z193_39</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>z193_40</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>scale</name>
      <anchor>z193_41</anchor>
      <arglist>(Energy2 sc) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton1EnergyMin</name>
      <anchor>z195_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton1EnergyMax</name>
      <anchor>z195_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton1AngleMin</name>
      <anchor>z195_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton1AngleMax</name>
      <anchor>z195_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ21Min</name>
      <anchor>z195_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ21Max</name>
      <anchor>z195_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton2EnergyMin</name>
      <anchor>z195_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>DISLepton2EnergyMax</name>
      <anchor>z195_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton2AngleMin</name>
      <anchor>z195_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>DISLepton2AngleMax</name>
      <anchor>z195_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ22Min</name>
      <anchor>z195_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISQ22Max</name>
      <anchor>z195_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISW2Min</name>
      <anchor>z195_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>DISW2Max</name>
      <anchor>z195_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z197_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z197_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>z199_0</anchor>
      <arglist>(const SubProcess &amp;) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>z199_1</anchor>
      <arglist>(const Collision &amp;, const LorentzRotation &amp;) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z201_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z201_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z201_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z203_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z203_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>isLepton</name>
      <anchor>d0</anchor>
      <arglist>(const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>maxYMinMax</name>
      <anchor>d1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>minYMaxMin</name>
      <anchor>d2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>maxEtaMinMax</name>
      <anchor>d3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>minEtaMaxMin</name>
      <anchor>d4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>maxCTMinMax</name>
      <anchor>d5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>double</type>
      <name>minCTMaxMin</name>
      <anchor>d6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>KinematicalCuts &amp;</type>
      <name>operator=</name>
      <anchor>d7</anchor>
      <arglist>(const KinematicalCuts &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMax</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatSingularMin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theSingularMassMax</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theYStarMin</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theYStarMax</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxYMin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxYMax</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinYMin</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinYMax</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxEtaMin</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxEtaMax</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinEtaMin</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinEtaMax</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxCTMin</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMaxCTMax</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinCTMin</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theMinCTMax</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX1Min</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX1Max</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX2Min</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX2Max</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theXFMin</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theXFMax</name>
      <anchor>r25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMin</name>
      <anchor>r26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMax</name>
      <anchor>r27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMin</name>
      <anchor>r28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMax</name>
      <anchor>r29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMin</name>
      <anchor>r30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMax</name>
      <anchor>r31</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMin</name>
      <anchor>r32</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMax</name>
      <anchor>r33</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useLeptoCuts</name>
      <anchor>r34</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton1EnergyMin</name>
      <anchor>r35</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton1EnergyMax</name>
      <anchor>r36</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton1AngleMin</name>
      <anchor>r37</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton1AngleMax</name>
      <anchor>r38</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ21Min</name>
      <anchor>r39</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ21Max</name>
      <anchor>r40</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton2EnergyMin</name>
      <anchor>r41</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDISLepton2EnergyMax</name>
      <anchor>r42</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton2AngleMin</name>
      <anchor>r43</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDISLepton2AngleMax</name>
      <anchor>r44</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ22Min</name>
      <anchor>r45</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISQ22Max</name>
      <anchor>r46</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISW2Min</name>
      <anchor>r47</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theDISW2Max</name>
      <anchor>r48</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; MatchLepton &gt;::pointer</type>
      <name>theLeptonMatcher</name>
      <anchor>r49</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; KinematicalCuts &gt;</type>
      <name>initKinematicalCuts</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; KinematicalCuts, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01KinematicalCuts_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; KinematicalCuts &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01KinematicalCuts_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; KinematicalCuts &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutSetup</name>
    <filename>structThePEG_1_1KinCutSetup.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>KinCutSetup</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutZeroInterval</name>
    <filename>structThePEG_1_1KinCutZeroInterval.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>KinCutZeroInterval</name>
      <anchor>a0</anchor>
      <arglist>(const KinematicalCuts &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LastXCombInfoBase</name>
    <filename>classThePEG_1_1LastXCombInfoBase.html</filename>
    <member kind="function">
      <type></type>
      <name>LastXCombInfoBase</name>
      <anchor>z205_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LastXCombInfoBase</name>
      <anchor>z205_1</anchor>
      <arglist>(const LastXCombInfoBase &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LastXCombInfoBase</name>
      <anchor>z205_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>XCombPtr</type>
      <name>theLastXComb</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LastXCombInfo</name>
    <filename>classThePEG_1_1LastXCombInfo.html</filename>
    <templarg>I</templarg>
    <base>ThePEG::LastXCombInfoBase</base>
    <member kind="function">
      <type></type>
      <name>LastXCombInfo</name>
      <anchor>z207_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LastXCombInfo</name>
      <anchor>z207_1</anchor>
      <arglist>(const LastXCombInfo&lt; I &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LastXCombInfo &amp;</type>
      <name>operator=</name>
      <anchor>z207_2</anchor>
      <arglist>(const LastXCombInfo&lt; I &gt; &amp;)</arglist>
    </member>
    <member kind="function">
      <type>const XComb &amp;</type>
      <name>lastXComb</name>
      <anchor>z209_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tXCombPtr</type>
      <name>lastXCombPtr</name>
      <anchor>z209_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const CollisionHandler &amp;</type>
      <name>lastCollisionHandler</name>
      <anchor>z211_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const SubProcessHandler &amp;</type>
      <name>lastSubHandler</name>
      <anchor>z211_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>lastExtractor</name>
      <anchor>z211_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tMEPtr</type>
      <name>lastME</name>
      <anchor>z211_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDF</type>
      <name>pdf</name>
      <anchor>z211_4</anchor>
      <arglist>(tcPPtr parton) const</arglist>
    </member>
    <member kind="function">
      <type>const KinematicalCuts &amp;</type>
      <name>lastCuts</name>
      <anchor>z211_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>lastCutsPtr</name>
      <anchor>z211_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastParticles</name>
      <anchor>z213_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastS</name>
      <anchor>z213_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastPartons</name>
      <anchor>z213_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastSHat</name>
      <anchor>z213_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastTau</name>
      <anchor>z213_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastY</name>
      <anchor>z213_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP1</name>
      <anchor>z213_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP2</name>
      <anchor>z213_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL1</name>
      <anchor>z213_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL2</name>
      <anchor>z213_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX1</name>
      <anchor>z213_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX2</name>
      <anchor>z213_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE1</name>
      <anchor>z213_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE2</name>
      <anchor>z213_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastFL1L2</name>
      <anchor>z213_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastScale</name>
      <anchor>z215_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>z215_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>mePartons</name>
      <anchor>z215_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>mePartonData</name>
      <anchor>z215_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const DVector &amp;</type>
      <name>meInfo</name>
      <anchor>z215_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>meInfo</name>
      <anchor>z215_5</anchor>
      <arglist>(const DVector &amp;info) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LuminosityFunction</name>
    <filename>classThePEG_1_1LuminosityFunction.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="function">
      <type></type>
      <name>LuminosityFunction</name>
      <anchor>z217_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LuminosityFunction</name>
      <anchor>z217_1</anchor>
      <arglist>(const LuminosityFunction &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LuminosityFunction</name>
      <anchor>z217_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z219_0</anchor>
      <arglist>(const cPDPair &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z219_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual LorentzRotation</type>
      <name>getBoost</name>
      <anchor>z219_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z219_3</anchor>
      <arglist>(const cPDPair &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>value</name>
      <anchor>z219_4</anchor>
      <arglist>(const cPDPair &amp;, double l1, double l2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual pair&lt; double, double &gt;</type>
      <name>generateLL</name>
      <anchor>z219_5</anchor>
      <arglist>(const double *r, double &amp;jacobian) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z221_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z221_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>select</name>
      <anchor>b0</anchor>
      <arglist>(tXCombPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LuminosityFunction &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LuminosityFunction &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; LuminosityFunction &gt;</type>
      <name>initLuminosityFunction</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LuminosityFunction, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LuminosityFunction_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LuminosityFunction &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LuminosityFunction_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LuminosityFunction &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MultipleInteractionHandler</name>
    <filename>classThePEG_1_1MultipleInteractionHandler.html</filename>
    <base>ThePEG::StepHandler</base>
    <member kind="function">
      <type></type>
      <name>MultipleInteractionHandler</name>
      <anchor>z223_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultipleInteractionHandler</name>
      <anchor>z223_1</anchor>
      <arglist>(const MultipleInteractionHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MultipleInteractionHandler</name>
      <anchor>z223_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z225_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z225_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z225_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z225_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z225_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MultipleInteractionHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MultipleInteractionHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; MultipleInteractionHandler &gt;</type>
      <name>initMultipleInteractionHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MultipleInteractionHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MultipleInteractionHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>StepHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MultipleInteractionHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MultipleInteractionHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MultipleInteractionHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartialCollisionHandler</name>
    <filename>classThePEG_1_1PartialCollisionHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="typedef">
      <type>vector&lt; HandlerGroupBase * &gt;</type>
      <name>GroupVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>partialCollision</name>
      <anchor>a0</anchor>
      <arglist>(tEventPtr e)</arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>partialCollision</name>
      <anchor>a1</anchor>
      <arglist>(tStepPtr s)</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>continueCollision</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clearEvent</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>empty</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>performStep</name>
      <anchor>a5</anchor>
      <arglist>(tStepHdlPtr handler, tHintPtr hint)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addStep</name>
      <anchor>a6</anchor>
      <arglist>(Group::Level, Group::Handler, tStepHdlPtr=tStepHdlPtr(), tHintPtr=tHintPtr())</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>a7</anchor>
      <arglist>(tcStepHdlPtr sh=tcStepHdlPtr())</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>popStep</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initGroups</name>
      <anchor>a9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tEventPtr</type>
      <name>currentEvent</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentEvent</name>
      <anchor>a11</anchor>
      <arglist>(tEventPtr e)</arglist>
    </member>
    <member kind="function">
      <type>tCollPtr</type>
      <name>currentCollision</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentCollision</name>
      <anchor>a13</anchor>
      <arglist>(tCollPtr c)</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>currentStep</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentStep</name>
      <anchor>a15</anchor>
      <arglist>(tStepPtr s)</arglist>
    </member>
    <member kind="function">
      <type>tStepHdlPtr</type>
      <name>currentStepHandler</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentStepHandler</name>
      <anchor>a17</anchor>
      <arglist>(tStepHdlPtr sh)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>throwCurrent</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clean</name>
      <anchor>a19</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartialCollisionHandler</name>
      <anchor>z227_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartialCollisionHandler</name>
      <anchor>z227_1</anchor>
      <arglist>(const PartialCollisionHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartialCollisionHandler</name>
      <anchor>z227_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z229_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z229_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setupGroups</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>GroupVector &amp;</type>
      <name>groups</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const GroupVector &amp;</type>
      <name>groups</name>
      <anchor>b2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z231_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z231_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z233_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z233_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z233_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z233_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z233_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; SubProcessHandler &gt;</type>
      <name>optSubprocessGroup</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; CascadeHandler &gt;</type>
      <name>optCascadeGroup</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; MultipleInteractionHandler &gt;</type>
      <name>optMultiGroup</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; HadronizationHandler &gt;</type>
      <name>optHadronizationGroup</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>HandlerGroup&lt; DecayHandler &gt;</type>
      <name>optDecayGroup</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>GroupVector</type>
      <name>optGroups</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostSubProcessHandler</name>
      <anchor>d0</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostSubProcessHandler</name>
      <anchor>d1</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostSubProcessHandler</name>
      <anchor>d2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostSubProcessHandler</name>
      <anchor>d3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreCascadeHandler</name>
      <anchor>d4</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreCascadeHandler</name>
      <anchor>d5</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreCascadeHandler</name>
      <anchor>d6</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreCascadeHandler</name>
      <anchor>d7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetCascadeHandler</name>
      <anchor>d8</anchor>
      <arglist>(CascHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CascHdlPtr</type>
      <name>interfaceGetCascadeHandler</name>
      <anchor>d9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostCascadeHandler</name>
      <anchor>d10</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostCascadeHandler</name>
      <anchor>d11</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostCascadeHandler</name>
      <anchor>d12</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostCascadeHandler</name>
      <anchor>d13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreMultipleInteractionHandler</name>
      <anchor>d14</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreMultipleInteractionHandler</name>
      <anchor>d15</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreMultipleInteractionHandler</name>
      <anchor>d16</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreMultipleInteractionHandler</name>
      <anchor>d17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetMultipleInteractionHandler</name>
      <anchor>d18</anchor>
      <arglist>(MIHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MIHdlPtr</type>
      <name>interfaceGetMultipleInteractionHandler</name>
      <anchor>d19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostMultipleInteractionHandler</name>
      <anchor>d20</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostMultipleInteractionHandler</name>
      <anchor>d21</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostMultipleInteractionHandler</name>
      <anchor>d22</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostMultipleInteractionHandler</name>
      <anchor>d23</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreHadronizationHandler</name>
      <anchor>d24</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreHadronizationHandler</name>
      <anchor>d25</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreHadronizationHandler</name>
      <anchor>d26</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreHadronizationHandler</name>
      <anchor>d27</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetHadronizationHandler</name>
      <anchor>d28</anchor>
      <arglist>(HadrHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HadrHdlPtr</type>
      <name>interfaceGetHadronizationHandler</name>
      <anchor>d29</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostHadronizationHandler</name>
      <anchor>d30</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostHadronizationHandler</name>
      <anchor>d31</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostHadronizationHandler</name>
      <anchor>d32</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostHadronizationHandler</name>
      <anchor>d33</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreDecayHandler</name>
      <anchor>d34</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreDecayHandler</name>
      <anchor>d35</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreDecayHandler</name>
      <anchor>d36</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreDecayHandler</name>
      <anchor>d37</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetDecayHandler</name>
      <anchor>d38</anchor>
      <arglist>(DecayHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayHdlPtr</type>
      <name>interfaceGetDecayHandler</name>
      <anchor>d39</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostDecayHandler</name>
      <anchor>d40</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostDecayHandler</name>
      <anchor>d41</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostDecayHandler</name>
      <anchor>d42</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostDecayHandler</name>
      <anchor>d43</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartialCollisionHandler &amp;</type>
      <name>operator=</name>
      <anchor>d44</anchor>
      <arglist>(const PartialCollisionHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; SubProcessHandler &gt;</type>
      <name>theSubprocessGroup</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; CascadeHandler &gt;</type>
      <name>theCascadeGroup</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; MultipleInteractionHandler &gt;</type>
      <name>theMultiGroup</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; HadronizationHandler &gt;</type>
      <name>theHadronizationGroup</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; DecayHandler &gt;</type>
      <name>theDecayGroup</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GroupVector</type>
      <name>theGroups</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>EventPtr</type>
      <name>theCurrentEvent</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CollPtr</type>
      <name>theCurrentCollision</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepPtr</type>
      <name>theCurrentStep</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StepHdlPtr</type>
      <name>theCurrentStepHandler</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartialCollisionHandler &gt;</type>
      <name>initPartialCollisionHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartialCollisionHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartialCollisionHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartialCollisionHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartialCollisionHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartialCollisionHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CollHdlStepException</name>
    <filename>structThePEG_1_1CollHdlStepException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>CollHdlStepException</name>
      <anchor>a0</anchor>
      <arglist>(const PartialCollisionHandler &amp;, const StepHandler &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PtGenerator</name>
    <filename>classThePEG_1_1PtGenerator.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>PtGenerator</name>
      <anchor>z235_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PtGenerator</name>
      <anchor>z235_1</anchor>
      <arglist>(const PtGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PtGenerator</name>
      <anchor>z235_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual TransverseMomentum</type>
      <name>generate</name>
      <anchor>z237_0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PtGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PtGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; PtGenerator &gt;</type>
      <name>initPtGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PtGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PtGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PtGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PtGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PtGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SamplerBase</name>
    <filename>classThePEG_1_1SamplerBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>void</type>
      <name>setEventHandler</name>
      <anchor>a0</anchor>
      <arglist>(tEHPtr eh)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SamplerBase</name>
      <anchor>z239_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SamplerBase</name>
      <anchor>z239_1</anchor>
      <arglist>(const SamplerBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SamplerBase</name>
      <anchor>z239_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>z241_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z241_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>rejectLast</name>
      <anchor>z241_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; double &gt; &amp;</type>
      <name>lastPoint</name>
      <anchor>z241_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>lastBin</name>
      <anchor>z241_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual CrossSection</type>
      <name>integratedXSec</name>
      <anchor>z241_5</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>sumWeights</name>
      <anchor>z241_6</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z243_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z243_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>vector&lt; double &gt; &amp;</type>
      <name>lastPoint</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tEHPtr</type>
      <name>eventHandler</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z245_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z245_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z245_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z245_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z245_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z245_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SamplerBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SamplerBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEHPtr</type>
      <name>theEventHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; double &gt;</type>
      <name>theLastPoint</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; SamplerBase &gt;</type>
      <name>initSamplerBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SamplerBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SamplerBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SamplerBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SamplerBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SamplerBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SimpleFlavour</name>
    <filename>classThePEG_1_1SimpleFlavour.html</filename>
    <base>ThePEG::FlavourGenerator</base>
    <member kind="typedef">
      <type>map&lt; long, VSelector&lt; pair&lt; long, long &gt; &gt; &gt;</type>
      <name>ProbabilityMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleFlavour</name>
      <anchor>z247_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleFlavour</name>
      <anchor>z247_1</anchor>
      <arglist>(const SimpleFlavour &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SimpleFlavour</name>
      <anchor>z247_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPair</type>
      <name>generateHadron</name>
      <anchor>z249_0</anchor>
      <arglist>(tcPDPtr quark) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getHadron</name>
      <anchor>z249_1</anchor>
      <arglist>(long iq1, long iq2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>getBaryon</name>
      <anchor>z249_2</anchor>
      <arglist>(long q1, long q2, long q3) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>selectQuark</name>
      <anchor>z249_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>selectFlavour</name>
      <anchor>z249_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sSup</name>
      <anchor>z251_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diSup</name>
      <anchor>z251_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>di1Sup</name>
      <anchor>z251_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diSSup</name>
      <anchor>z251_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>etaSup</name>
      <anchor>z251_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>etaPSup</name>
      <anchor>z251_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>baryon10Sup</name>
      <anchor>z251_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pSpin1</name>
      <anchor>z251_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pSpinS1</name>
      <anchor>z251_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pSpinC1</name>
      <anchor>z251_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z253_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z253_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>setProbabilities</name>
      <anchor>b0</anchor>
      <arglist>(long iq) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>vectorMesonProbability</name>
      <anchor>b1</anchor>
      <arglist>(long iq1, long iq2) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>baryonDecupletProbability</name>
      <anchor>b2</anchor>
      <arglist>(long iq1, long iq2) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>pseudoScalarMeson</name>
      <anchor>b3</anchor>
      <arglist>(long iq, long iqbar) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>vectorMeson</name>
      <anchor>b4</anchor>
      <arglist>(long iq, long iqbar) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>baryonOctet</name>
      <anchor>b5</anchor>
      <arglist>(long iq, long idq) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual tcPDPtr</type>
      <name>baryonDecuplet</name>
      <anchor>b6</anchor>
      <arglist>(long iq, long idq) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>pseudoScalarId</name>
      <anchor>b7</anchor>
      <arglist>(long iqh, long iql) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>vectorId</name>
      <anchor>b8</anchor>
      <arglist>(long iqh, long iql) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>baryonOctetId</name>
      <anchor>b9</anchor>
      <arglist>(long iqa, long iqb, long iqc, long iq, bool dqs1) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual long</type>
      <name>baryonDecupletId</name>
      <anchor>b10</anchor>
      <arglist>(long iqa, long iqb, long iqc) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>pseudoScalarIds</name>
      <anchor>b11</anchor>
      <arglist>(long iqh, long iql) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>vectorIds</name>
      <anchor>b12</anchor>
      <arglist>(long iqh, long iql) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>baryonOctetIds</name>
      <anchor>b13</anchor>
      <arglist>(long iqa, long iqb, long iqc, long iq, bool dqs1) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual vector&lt; pair&lt; long, double &gt; &gt;</type>
      <name>baryonDecupletIds</name>
      <anchor>b14</anchor>
      <arglist>(long iqa, long iqb, long iqc) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>clear</name>
      <anchor>b15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z255_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z255_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z257_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z257_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z257_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z257_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z257_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z257_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>double</type>
      <name>weightSU6QDiQSpin</name>
      <anchor>f0</anchor>
      <arglist>(long iq, long idq, int spin)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SimpleFlavour &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SimpleFlavour &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSSup</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDiSup</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDi1Sup</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theDiSSup</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEtaSup</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEtaPSup</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theBaryon10Sup</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thePSpin1</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thePSpinS1</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thePSpinC1</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VSelector&lt; long &gt;</type>
      <name>theFlavourSelector</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ProbabilityMap</type>
      <name>theProbabilities</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SimpleFlavour &gt;</type>
      <name>initSimpleFlavour</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SimpleFlavour, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SimpleFlavour_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlavourGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SimpleFlavour &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SimpleFlavour_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SimpleFlavour &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SimpleZGenerator</name>
    <filename>classThePEG_1_1SimpleZGenerator.html</filename>
    <base>ThePEG::ZGenerator</base>
    <member kind="function">
      <type></type>
      <name>SimpleZGenerator</name>
      <anchor>z259_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleZGenerator</name>
      <anchor>z259_1</anchor>
      <arglist>(const SimpleZGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SimpleZGenerator</name>
      <anchor>z259_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z261_0</anchor>
      <arglist>(cPDPtr q1, cPDPtr q2, Energy2 mT2) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z263_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z263_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z265_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z265_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z267_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z267_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z267_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z267_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z267_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z267_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SimpleZGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SimpleZGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SimpleZGenerator &gt;</type>
      <name>initSimpleZGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SimpleZGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SimpleZGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ZGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SimpleZGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SimpleZGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SimpleZGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StepHandler</name>
    <filename>classThePEG_1_1StepHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>StepHandler</name>
      <anchor>z269_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StepHandler</name>
      <anchor>z269_1</anchor>
      <arglist>(const StepHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StepHandler</name>
      <anchor>z269_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>handle</name>
      <anchor>z271_0</anchor>
      <arglist>(PartialCollisionHandler &amp;ch, const tPVector &amp;tagged, const Hint &amp;hint)=0</arglist>
    </member>
    <member kind="function">
      <type>tPartCollHdlPtr</type>
      <name>collisionHandler</name>
      <anchor>z273_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>collisionHandler</name>
      <anchor>z273_1</anchor>
      <arglist>(tPartCollHdlPtr)</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>newStep</name>
      <anchor>z273_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tStepPtr</type>
      <name>currentStep</name>
      <anchor>z273_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>createNewStep</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z275_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z275_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z275_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z275_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z275_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StepHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StepHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPartCollHdlPtr</type>
      <name>theCollisionHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStepPtr</type>
      <name>theNewStep</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStepPtr</type>
      <name>theCurrentStep</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; StepHandler &gt;</type>
      <name>initStepHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StepHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StepHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StepHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StepHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StepHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SubProcessHandler</name>
    <filename>classThePEG_1_1SubProcessHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="typedef">
      <type>vector&lt; HandlerGroupBase * &gt;</type>
      <name>GroupVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ReweightPtr &gt;</type>
      <name>ReweightVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcessHandler</name>
      <anchor>z277_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SubProcessHandler</name>
      <anchor>z277_1</anchor>
      <arglist>(const SubProcessHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SubProcessHandler</name>
      <anchor>z277_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>pExtractor</name>
      <anchor>z279_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const MEVector &amp;</type>
      <name>MEs</name>
      <anchor>z279_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>cuts</name>
      <anchor>z279_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const HandlerGroupBase &amp;</type>
      <name>handlerGroup</name>
      <anchor>z279_3</anchor>
      <arglist>(Group::Handler) const</arglist>
    </member>
    <member kind="function">
      <type>const GroupVector &amp;</type>
      <name>groups</name>
      <anchor>z279_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>MEVector &amp;</type>
      <name>MEs</name>
      <anchor>z279_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z281_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z281_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z283_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z283_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z285_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z285_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z285_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setupGroups</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostSubProcessHandler</name>
      <anchor>d1</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostSubProcessHandler</name>
      <anchor>d2</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostSubProcessHandler</name>
      <anchor>d3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostSubProcessHandler</name>
      <anchor>d4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreCascadeHandler</name>
      <anchor>d5</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreCascadeHandler</name>
      <anchor>d6</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreCascadeHandler</name>
      <anchor>d7</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreCascadeHandler</name>
      <anchor>d8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetCascadeHandler</name>
      <anchor>d9</anchor>
      <arglist>(CascHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CascHdlPtr</type>
      <name>interfaceGetCascadeHandler</name>
      <anchor>d10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostCascadeHandler</name>
      <anchor>d11</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostCascadeHandler</name>
      <anchor>d12</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostCascadeHandler</name>
      <anchor>d13</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostCascadeHandler</name>
      <anchor>d14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreMultipleInteractionHandler</name>
      <anchor>d15</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreMultipleInteractionHandler</name>
      <anchor>d16</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreMultipleInteractionHandler</name>
      <anchor>d17</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreMultipleInteractionHandler</name>
      <anchor>d18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetMultipleInteractionHandler</name>
      <anchor>d19</anchor>
      <arglist>(MIHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MIHdlPtr</type>
      <name>interfaceGetMultipleInteractionHandler</name>
      <anchor>d20</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostMultipleInteractionHandler</name>
      <anchor>d21</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostMultipleInteractionHandler</name>
      <anchor>d22</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostMultipleInteractionHandler</name>
      <anchor>d23</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostMultipleInteractionHandler</name>
      <anchor>d24</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreHadronizationHandler</name>
      <anchor>d25</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreHadronizationHandler</name>
      <anchor>d26</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreHadronizationHandler</name>
      <anchor>d27</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreHadronizationHandler</name>
      <anchor>d28</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetHadronizationHandler</name>
      <anchor>d29</anchor>
      <arglist>(HadrHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HadrHdlPtr</type>
      <name>interfaceGetHadronizationHandler</name>
      <anchor>d30</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostHadronizationHandler</name>
      <anchor>d31</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostHadronizationHandler</name>
      <anchor>d32</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostHadronizationHandler</name>
      <anchor>d33</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostHadronizationHandler</name>
      <anchor>d34</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPreDecayHandler</name>
      <anchor>d35</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPreDecayHandler</name>
      <anchor>d36</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePreDecayHandler</name>
      <anchor>d37</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPreDecayHandler</name>
      <anchor>d38</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetDecayHandler</name>
      <anchor>d39</anchor>
      <arglist>(DecayHdlPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayHdlPtr</type>
      <name>interfaceGetDecayHandler</name>
      <anchor>d40</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceSetPostDecayHandler</name>
      <anchor>d41</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceInsertPostDecayHandler</name>
      <anchor>d42</anchor>
      <arglist>(StepHdlPtr, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>interfaceErasePostDecayHandler</name>
      <anchor>d43</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; StepHdlPtr &gt;</type>
      <name>interfaceGetPostDecayHandler</name>
      <anchor>d44</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const SubProcessHandler &amp;</type>
      <name>operator=</name>
      <anchor>d45</anchor>
      <arglist>(const SubProcessHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PExtrPtr</type>
      <name>thePartonExtractor</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MEVector</type>
      <name>theMEs</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; SubProcessHandler &gt;</type>
      <name>theSubprocessGroup</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; CascadeHandler &gt;</type>
      <name>theCascadeGroup</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; MultipleInteractionHandler &gt;</type>
      <name>theMultiGroup</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; HadronizationHandler &gt;</type>
      <name>theHadronizationGroup</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>HandlerGroup&lt; DecayHandler &gt;</type>
      <name>theDecayGroup</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GroupVector</type>
      <name>theGroups</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>reweights</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>preweights</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; SubProcessHandler &gt;</type>
      <name>initSubProcessHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SubProcessHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SubProcessHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SubProcessHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SubProcessHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SubProcessHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Two2NCuts</name>
    <filename>classThePEG_1_1Two2NCuts.html</filename>
    <base>ThePEG::KinematicalCuts</base>
    <member kind="function">
      <type></type>
      <name>Two2NCuts</name>
      <anchor>z286_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Two2NCuts</name>
      <anchor>z286_1</anchor>
      <arglist>(const Two2NCuts &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Two2NCuts</name>
      <anchor>z286_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>massMin</name>
      <anchor>z288_0</anchor>
      <arglist>(int n, int i) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>massMax</name>
      <anchor>z288_1</anchor>
      <arglist>(int n, int i) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pTMin</name>
      <anchor>z288_2</anchor>
      <arglist>(int n, int i) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pTMax</name>
      <anchor>z288_3</anchor>
      <arglist>(int n, int i) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diMassMin</name>
      <anchor>z288_4</anchor>
      <arglist>(int n, int i, int j) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>diMassMax</name>
      <anchor>z288_5</anchor>
      <arglist>(int n, int i, int j) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z290_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z290_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>b0</anchor>
      <arglist>(const SubProcess &amp;) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z292_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z292_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z294_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z294_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z294_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z294_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z294_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; pair&lt; int, int &gt;, Energy &gt;</type>
      <name>Limits2Map</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; Triplet&lt; int, int, int &gt;, Energy &gt;</type>
      <name>Limits3Map</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; Energy &gt;</type>
      <name>LimitsVector</name>
      <anchor>y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetMassMins</name>
      <anchor>d0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMassMins</name>
      <anchor>d1</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insMassMins</name>
      <anchor>d2</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delMassMins</name>
      <anchor>d3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getMassMins</name>
      <anchor>d4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetMassMins</name>
      <anchor>d5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetMassMaxs</name>
      <anchor>d6</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMassMaxs</name>
      <anchor>d7</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insMassMaxs</name>
      <anchor>d8</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delMassMaxs</name>
      <anchor>d9</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getMassMaxs</name>
      <anchor>d10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetMassMaxs</name>
      <anchor>d11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetPTMins</name>
      <anchor>d12</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPTMins</name>
      <anchor>d13</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insPTMins</name>
      <anchor>d14</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delPTMins</name>
      <anchor>d15</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getPTMins</name>
      <anchor>d16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetPTMins</name>
      <anchor>d17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetPTMaxs</name>
      <anchor>d18</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPTMaxs</name>
      <anchor>d19</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insPTMaxs</name>
      <anchor>d20</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delPTMaxs</name>
      <anchor>d21</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getPTMaxs</name>
      <anchor>d22</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetPTMaxs</name>
      <anchor>d23</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetDiMassMins</name>
      <anchor>d24</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setDiMassMins</name>
      <anchor>d25</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insDiMassMins</name>
      <anchor>d26</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delDiMassMins</name>
      <anchor>d27</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getDiMassMins</name>
      <anchor>d28</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetDiMassMins</name>
      <anchor>d29</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetDiMassMaxs</name>
      <anchor>d30</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setDiMassMaxs</name>
      <anchor>d31</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insDiMassMaxs</name>
      <anchor>d32</anchor>
      <arglist>(Energy, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delDiMassMaxs</name>
      <anchor>d33</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LimitsVector</type>
      <name>getDiMassMaxs</name>
      <anchor>d34</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StringVector</type>
      <name>sgetDiMassMaxs</name>
      <anchor>d35</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>pair&lt; int, int &gt;</type>
      <name>get2index</name>
      <anchor>d36</anchor>
      <arglist>(int k) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Triplet&lt; int, int, int &gt;</type>
      <name>get3index</name>
      <anchor>d37</anchor>
      <arglist>(int k) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>index2</name>
      <anchor>d38</anchor>
      <arglist>(const pair&lt; int, int &gt; &amp;) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>index3</name>
      <anchor>d39</anchor>
      <arglist>(const Triplet&lt; int, int, int &gt; &amp;) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Two2NCuts &amp;</type>
      <name>operator=</name>
      <anchor>d40</anchor>
      <arglist>(const Two2NCuts &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>theMassMins</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>theMassMaxs</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>thePTMins</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits2Map</type>
      <name>thePTMaxs</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits3Map</type>
      <name>theDiMassMins</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Limits3Map</type>
      <name>theDiMassMaxs</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Two2NCuts &gt;</type>
      <name>initTwo2NCuts</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Two2NCuts, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Two2NCuts_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>KinematicalCuts</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Two2NCuts &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Two2NCuts_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Two2NCuts &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutCmdFail1</name>
    <filename>structThePEG_1_1KinCutCmdFail1.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>KinCutCmdFail1</name>
      <anchor>a0</anchor>
      <arglist>(const Two2NCuts &amp;, string, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutCmdFail2</name>
    <filename>structThePEG_1_1KinCutCmdFail2.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>KinCutCmdFail2</name>
      <anchor>a0</anchor>
      <arglist>(const Two2NCuts &amp;, string, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::KinCutCmdFail3</name>
    <filename>structThePEG_1_1KinCutCmdFail3.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>KinCutCmdFail3</name>
      <anchor>a0</anchor>
      <arglist>(const Two2NCuts &amp;, string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::XComb</name>
    <filename>classThePEG_1_1XComb.html</filename>
    <base>ThePEG::Base</base>
    <member kind="typedef">
      <type>MEBase::DiagramVector</type>
      <name>DiagramVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MEBase::DiagramIndex</type>
      <name>DiagramIndex</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z296_0</anchor>
      <arglist>(Energy newMaxEnergy, const cPDPair &amp;inc, tCollHdlPtr newCollisionHandler, tSubHdlPtr newSubProcessHandler, tPExtrPtr newExtractor, const PBPair &amp;newPartonBins, tKinCutPtr newCuts, tMEPtr newME, const DiagramVector &amp;newDiagrams, bool mir)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z296_1</anchor>
      <arglist>(const XComb &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z296_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~XComb</name>
      <anchor>z296_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>XComb</name>
      <anchor>z296_4</anchor>
      <arglist>(tMEPtr me, const tPVector &amp;parts, DiagramIndex i)</arglist>
    </member>
    <member kind="function">
      <type>const CollisionHandler &amp;</type>
      <name>collisionHandler</name>
      <anchor>z298_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const SubProcessHandler &amp;</type>
      <name>subProcessHandler</name>
      <anchor>z298_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPExtrPtr</type>
      <name>pExtractor</name>
      <anchor>z298_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tMEPtr</type>
      <name>matrixElement</name>
      <anchor>z298_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tKinCutPtr</type>
      <name>cuts</name>
      <anchor>z298_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>particles</name>
      <anchor>z300_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>partons</name>
      <anchor>z300_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PBPair &amp;</type>
      <name>partonBins</name>
      <anchor>z300_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>maxEnergy</name>
      <anchor>z300_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>z300_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>nAccepted</name>
      <anchor>z302_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>nAttempted</name>
      <anchor>z302_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sumWeight</name>
      <anchor>z302_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>accept</name>
      <anchor>z302_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>sumWeight</name>
      <anchor>z302_4</anchor>
      <arglist>(double w)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>unAccept</name>
      <anchor>z302_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z302_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clean</name>
      <anchor>z304_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastParticles</name>
      <anchor>z304_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>lastPartons</name>
      <anchor>z304_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PBIPair &amp;</type>
      <name>partonBinInstances</name>
      <anchor>z304_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastS</name>
      <anchor>z304_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastSHat</name>
      <anchor>z304_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastTau</name>
      <anchor>z304_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastY</name>
      <anchor>z304_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP1</name>
      <anchor>z304_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastP2</name>
      <anchor>z304_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL1</name>
      <anchor>z304_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastL2</name>
      <anchor>z304_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX1</name>
      <anchor>z304_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastX2</name>
      <anchor>z304_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE1</name>
      <anchor>z304_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lastE2</name>
      <anchor>z304_15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lastScale</name>
      <anchor>z304_16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lastScale</name>
      <anchor>z304_17</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>checkInit</name>
      <anchor>z306_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nDim</name>
      <anchor>z306_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>prepare</name>
      <anchor>z306_2</anchor>
      <arglist>(const PPair &amp;)</arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>dSigDR</name>
      <anchor>z306_3</anchor>
      <arglist>(const pair&lt; double, double &gt; ll, int nr, const double *r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>construct</name>
      <anchor>z306_4</anchor>
      <arglist>(tSubProPtr)</arglist>
    </member>
    <member kind="function">
      <type>const DiagramVector &amp;</type>
      <name>diagrams</name>
      <anchor>z308_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>mirror</name>
      <anchor>z308_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>z308_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const tPVector &amp;</type>
      <name>mePartons</name>
      <anchor>z308_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>mePartonData</name>
      <anchor>z308_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcDiagPtr</type>
      <name>lastDiagram</name>
      <anchor>z308_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>DiagramIndex</type>
      <name>lastDiagramIndex</name>
      <anchor>z308_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const DVector &amp;</type>
      <name>meInfo</name>
      <anchor>z308_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>meInfo</name>
      <anchor>z308_8</anchor>
      <arglist>(const DVector &amp;info)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z310_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z310_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tPVector &amp;</type>
      <name>mePartons</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>lastDiagramIndex</name>
      <anchor>b2</anchor>
      <arglist>(DiagramIndex)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setPartonBinInfo</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>XComb &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const XComb &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tCollHdlPtr</type>
      <name>theCollisionHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SubHdlPtr</type>
      <name>theSubProcessHandler</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PExtrPtr</type>
      <name>thePartonExtractor</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>KinCutPtr</type>
      <name>theCuts</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>theParticles</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>thePartons</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBPair</type>
      <name>thePartonBins</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBPair</type>
      <name>theParticleBins</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBIPair</type>
      <name>thePartonBinInstances</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNAttempted</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNAccepted</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSumWeight</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theLastParticles</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPair</type>
      <name>theLastPartons</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastS</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastSHat</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastY</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastP1P2</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastL1L2</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastX1X2</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DPair</type>
      <name>theLastE1E2</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastScale</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Lorentz5Momentum &gt;</type>
      <name>theLastOutgoing</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMaxEnergy</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tMEPtr</type>
      <name>theME</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiagramVector</type>
      <name>theDiagrams</name>
      <anchor>r25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isMirror</name>
      <anchor>r26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNDim</name>
      <anchor>r27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pair&lt; int, int &gt;</type>
      <name>partonDims</name>
      <anchor>r28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Lorentz5Momentum &gt;</type>
      <name>theMEMomenta</name>
      <anchor>r29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPVector</type>
      <name>theMEPartons</name>
      <anchor>r30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>theMEPartonData</name>
      <anchor>r31</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiagramIndex</type>
      <name>theLastDiagramIndex</name>
      <anchor>r32</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DVector</type>
      <name>theMEInfo</name>
      <anchor>r33</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; XComb &gt;</type>
      <name>initXComb</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; XComb, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01XComb_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; XComb &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01XComb_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; XComb &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ZGenerator</name>
    <filename>classThePEG_1_1ZGenerator.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>ZGenerator</name>
      <anchor>z312_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ZGenerator</name>
      <anchor>z312_1</anchor>
      <arglist>(const ZGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ZGenerator</name>
      <anchor>z312_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>generate</name>
      <anchor>z314_0</anchor>
      <arglist>(cPDPtr q1, cPDPtr q2, Energy2 mT2) const =0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ZGenerator &gt;</type>
      <name>initZGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ZGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ZGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ZGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ZGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ZGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::FermionSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1FermionSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::FermionSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1FermionSpinInfo_01_4.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::HelicityVertex, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1HelicityVertex_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventInfoBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::HelicityVertex &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1HelicityVertex_01_4.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::ScalarSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1ScalarSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::ScalarSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1ScalarSpinInfo_01_4.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::SpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1SpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>SpinBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::SpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1SpinInfo_01_4.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::TensorSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1TensorSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::TensorSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1TensorSpinInfo_01_4.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEG::Helicity::VectorSpinInfo, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEG_1_1Helicity_1_1VectorSpinInfo_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ThePEG::Helicity::SpinInfo</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEG::Helicity::VectorSpinInfo &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEG_1_1Helicity_1_1VectorSpinInfo_01_4.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDocumentationBase</name>
    <filename>classThePEG_1_1ClassDocumentationBase.html</filename>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDocumentationBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>documentation</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>modelDescription</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>modelReferences</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ClassDocumentationBase</name>
      <anchor>b0</anchor>
      <arglist>(string newDocumentation, string newModelDescription, string newModelReferences, const type_info &amp;newTypeInfo)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentationBase</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentationBase</name>
      <anchor>d1</anchor>
      <arglist>(const ClassDocumentationBase &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ClassDocumentationBase &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ClassDocumentationBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDocumentation</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theModelDescription</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theModelReferences</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDocumentation</name>
    <filename>classThePEG_1_1ClassDocumentation.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDocumentationBase</base>
    <member kind="function">
      <type></type>
      <name>ClassDocumentation</name>
      <anchor>a0</anchor>
      <arglist>(string newDocumentation, string newModelDescription=&quot;&quot;, string newModelReferences=&quot;&quot;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDocumentation</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentation</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ClassDocumentation</name>
      <anchor>d1</anchor>
      <arglist>(const ClassDocumentation &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ClassDocumentation &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const ClassDocumentation &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CommandBase</name>
    <filename>classThePEG_1_1CommandBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>CommandBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CommandBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>cmd</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, string c) const =0</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Command</name>
    <filename>classThePEG_1_1Command.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::CommandBase</base>
    <member kind="typedef">
      <type>string(T::*</type>
      <name>ExeFn</name>
      <anchor>w0</anchor>
      <arglist>)(string)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Command</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, ExeFn newExeFn, bool depSafe=false)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Command</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>cmd</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ExeFn</type>
      <name>theExeFn</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::CmdExUnknown</name>
    <filename>structThePEG_1_1CmdExUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>CmdExUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::InterfaceBase</name>
    <filename>classThePEG_1_1InterfaceBase.html</filename>
    <base>ThePEG::Named</base>
    <member kind="function">
      <type></type>
      <name>InterfaceBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~InterfaceBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, const TranslationMap &amp;trans, const IVector &amp;defs=IVector()) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;is) const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>description</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>fullDescription</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;stream) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>className</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>dependencySafe</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDependencySafe</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDependencySensitive</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>readOnly</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setReadOnly</name>
      <anchor>a15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setReadWrite</name>
      <anchor>a16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>anonymous</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>bool</type>
      <name>NoReadOnly</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isDependencySafe</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isReadOnly</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDescription</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theClassName</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RefInterfaceBase</name>
    <filename>classThePEG_1_1RefInterfaceBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>RefInterfaceBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, string newRefClassName, const type_info &amp;newRefTypeInfo, bool depSafe, bool readonly, bool norebind, bool nullable, bool defnull)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>refClassName</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const type_info &amp;</type>
      <name>refTypeInfo</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>noRebind</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNoRebind</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setRebind</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>noNull</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNullable</name>
      <anchor>a7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNotNullable</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>defaultIfNull</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultIfNull</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setNoDefaultIfNull</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theRefClassName</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const type_info &amp;</type>
      <name>theRefTypeInfo</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>dontRebind</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isNullable</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theDefaultIfNull</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfaceException</name>
    <filename>structThePEG_1_1InterfaceException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>InterfaceException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExClass</name>
    <filename>structThePEG_1_1InterExClass.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExClass</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExSetup</name>
    <filename>structThePEG_1_1InterExSetup.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExSetup</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExUnknown</name>
    <filename>structThePEG_1_1InterExUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExReadOnly</name>
    <filename>structThePEG_1_1InterExReadOnly.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExReadOnly</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterExNoNull</name>
    <filename>structThePEG_1_1InterExNoNull.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InterExNoNull</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Interfaced</name>
    <filename>classThePEG_1_1Interfaced.html</filename>
    <base>ThePEG::InterfacedBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Interfaced</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>debug</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>getParticle</name>
      <anchor>z384_0</anchor>
      <arglist>(long) const</arglist>
    </member>
    <member kind="function">
      <type>PDPtr</type>
      <name>getParticleData</name>
      <anchor>z384_1</anchor>
      <arglist>(long) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>used</name>
      <anchor>z384_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>useMe</name>
      <anchor>z384_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z386_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z386_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>Interfaced</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>Interfaced</name>
      <anchor>b1</anchor>
      <arglist>(string newName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>Interfaced</name>
      <anchor>b2</anchor>
      <arglist>(const Interfaced &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tEGPtr</type>
      <name>generator</name>
      <anchor>b3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z388_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z388_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z388_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z388_3</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>registerRepository</name>
      <anchor>f0</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>registerRepository</name>
      <anchor>f1</anchor>
      <arglist>(IBPtr, string newName)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setUsed</name>
      <anchor>d0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Interfaced &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Interfaced &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tEGPtr</type>
      <name>theGenerator</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>theUseFlag</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; Interfaced &gt;</type>
      <name>initInterfaced</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Interfaced, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Interfaced_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>InterfacedBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Interfaced &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Interfaced_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Interfaced &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::InterfacedBase</name>
    <filename>classThePEG_1_1InterfacedBase.html</filename>
    <base>ThePEG::Base</base>
    <base>ThePEG::Named</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~InterfacedBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>fullName</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>name</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>path</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>comment</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setup</name>
      <anchor>a5</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>z392_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>init</name>
      <anchor>z392_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initrun</name>
      <anchor>z392_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finish</name>
      <anchor>z392_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>touch</name>
      <anchor>z392_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z392_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>z392_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>locked</name>
      <anchor>z392_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>touched</name>
      <anchor>z392_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z394_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z394_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>b0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>InterfacedBase</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>InterfacedBase</name>
      <anchor>b2</anchor>
      <arglist>(string newName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>InterfacedBase</name>
      <anchor>b3</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>z390_0</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z390_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z390_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z390_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z390_4</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z390_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z390_6</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="enumeration">
      <name>InitState</name>
      <anchor>y4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>initializing</name>
      <anchor>y4y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>uninitialized</name>
      <anchor>y4y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>initialized</name>
      <anchor>y4y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>runready</name>
      <anchor>y4y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>name</name>
      <anchor>d0</anchor>
      <arglist>(string newName)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>lock</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>unlock</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>untouch</name>
      <anchor>d3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>addComment</name>
      <anchor>d4</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>InterfacedBase &amp;</type>
      <name>operator=</name>
      <anchor>d5</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isLocked</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isTouched</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>InitState</type>
      <name>initState</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theComment</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; InterfacedBase &gt;</type>
      <name>initInterfacedBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ptr &amp;i)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(tIBPtr, bool &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateMapChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateMapChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateMapChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ref &amp;i)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ptr &amp;i)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(tIBPtr, bool &amp;)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InterfacedBase::UpdateMapChecker</name>
    <filename>structThePEG_1_1InterfacedBase_1_1UpdateMapChecker.html</filename>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;touched)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UpdateMapChecker</name>
      <anchor>a1</anchor>
      <arglist>(const UpdateMapChecker &amp;uc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(const ref &amp;i)</arglist>
    </member>
    <member kind="variable">
      <type>bool &amp;</type>
      <name>isTouched</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; InterfacedBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01InterfacedBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PersistentBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; InterfacedBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01InterfacedBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; InterfacedBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SetupException</name>
    <filename>structThePEG_1_1SetupException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SetupException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::UpdateException</name>
    <filename>structThePEG_1_1UpdateException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>UpdateException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RebindException</name>
    <filename>structThePEG_1_1RebindException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RebindException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::InitException</name>
    <filename>structThePEG_1_1InitException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>InitException</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParameterBase</name>
    <filename>classThePEG_1_1ParameterBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>ParameterBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly, bool islimited)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParameterBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>fullDescription</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>get</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a9</anchor>
      <arglist>(InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>limited</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimited</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUnlimited</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isLimited</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParameterTBase</name>
    <filename>classThePEG_1_1ParameterTBase.html</filename>
    <templarg>Type</templarg>
    <base>ThePEG::ParameterBase</base>
    <member kind="function">
      <type></type>
      <name>ParameterTBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, Type newUnit, bool depSafe, bool readonly, bool islimited)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParameterTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, string newValue) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, Type) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tget</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a12</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a13</anchor>
      <arglist>(InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function">
      <type>Type</type>
      <name>unit</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>unit</name>
      <anchor>a15</anchor>
      <arglist>(Type u)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>putUnit</name>
      <anchor>b0</anchor>
      <arglist>(ostream &amp;, Type val) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theUnit</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Parameter</name>
    <filename>classThePEG_1_1Parameter.html</filename>
    <templarg>T</templarg>
    <templarg>Type</templarg>
    <base>ThePEG::ParameterTBase</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(Type)</arglist>
    </member>
    <member kind="typedef">
      <type>Type(T::*</type>
      <name>GetFn</name>
      <anchor>w1</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>Type T::*</type>
      <name>Member</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool islimited=true, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newMinFn=0, GetFn newMaxFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newUnit, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool islimited=true, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newMinFn=0, GetFn newMaxFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Parameter</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tget</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a8</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a9</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a10</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMinFunction</name>
      <anchor>a11</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxFunction</name>
      <anchor>a12</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a13</anchor>
      <arglist>(ostream &amp;stream) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theDefFn</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theMinFn</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theMaxFn</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParameterTBase&lt; string &gt;</name>
    <filename>classThePEG_1_1ParameterTBase_3_01string_01_4.html</filename>
    <base>ThePEG::ParameterBase</base>
    <member kind="function">
      <type></type>
      <name>ParameterTBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonlyd)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParameterTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, string newValue) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>tget</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>tdef</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a11</anchor>
      <arglist>(InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Parameter&lt; T, string &gt;</name>
    <filename>classThePEG_1_1Parameter_3_01T_00_01string_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ParameterTBase&lt; string &gt;</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(string)</arglist>
    </member>
    <member kind="typedef">
      <type>string(T::*</type>
      <name>GetFn</name>
      <anchor>w1</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>string T::*</type>
      <name>Member</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Parameter</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, string newDef, bool depSafe=false, bool readonly=false, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Parameter</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string val) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>tget</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>tdef</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a5</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a6</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a7</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;stream) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theDefFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParExSetLimit</name>
    <filename>structThePEG_1_1ParExSetLimit.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParExSetLimit</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParExSetUnknown</name>
    <filename>structThePEG_1_1ParExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T val)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParExGetUnknown</name>
    <filename>structThePEG_1_1ParExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, const char *)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParVectorBase</name>
    <filename>classThePEG_1_1ParVectorBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVectorBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, int newSize, bool depSafe, bool readonly, bool islimited)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParVectorBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;, string action, string arguments) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual StringVector</type>
      <name>get</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a10</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>limited</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setLimited</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setUnlimited</name>
      <anchor>a13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSize</name>
      <anchor>a15</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVariableSize</name>
      <anchor>a16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isLimited</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theSize</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParVectorTBase</name>
    <filename>classThePEG_1_1ParVectorTBase.html</filename>
    <templarg>Type</templarg>
    <base>ThePEG::ParVectorBase</base>
    <member kind="typedef">
      <type>vector&lt; Type &gt;</type>
      <name>TypeVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVectorTBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, Type newUnit, int newSize, bool depSafe, bool readonly, bool islimited)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParVectorTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a6</anchor>
      <arglist>(InterfacedBase &amp;ib, string val, int i) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>tinsert</name>
      <anchor>a7</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual StringVector</type>
      <name>get</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual TypeVector</type>
      <name>tget</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>minimum</name>
      <anchor>a10</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>maximum</name>
      <anchor>a12</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a13</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>def</name>
      <anchor>a14</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a15</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setDef</name>
      <anchor>a16</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function">
      <type>Type</type>
      <name>unit</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>unit</name>
      <anchor>a18</anchor>
      <arglist>(Type u)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>putUnit</name>
      <anchor>b0</anchor>
      <arglist>(ostream &amp;, Type val) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theUnit</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParVector</name>
    <filename>classThePEG_1_1ParVector.html</filename>
    <templarg>T</templarg>
    <templarg>Type</templarg>
    <base>ThePEG::ParVectorTBase</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(Type, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>InsFn</name>
      <anchor>w1</anchor>
      <arglist>)(Type, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>DelFn</name>
      <anchor>w2</anchor>
      <arglist>)(int)</arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Type &gt;</type>
      <name>TypeVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TypeVector(T::*</type>
      <name>GetFn</name>
      <anchor>w4</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>StringVector(T::*</type>
      <name>StringGetFn</name>
      <anchor>w6</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>Type(T::*</type>
      <name>DefFn</name>
      <anchor>w7</anchor>
      <arglist>)(int) const</arglist>
    </member>
    <member kind="typedef">
      <type>TypeVector T::*</type>
      <name>Member</name>
      <anchor>w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVector</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool islimited=true, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, DefFn newDefFn=0, DefFn newMinFn=0, DefFn newMaxFn=0, StringGetFn newStringGetFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParVector</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Type newUnit, int newSize, Type newDef, Type newMin, Type newMax, bool depSafe=false, bool readonly=false, bool islimited=true, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, DefFn newDefFn=0, DefFn newMinFn=0, DefFn newMaxFn=0, StringGetFn newStringGetFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tset</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>tinsert</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, Type val, int i) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual StringVector</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual TypeVector</type>
      <name>tget</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tminimum</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tmaximum</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Type</type>
      <name>tdef</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;, int) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a10</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setInsertFunction</name>
      <anchor>a11</anchor>
      <arglist>(InsFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a12</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setEraseFunction</name>
      <anchor>a13</anchor>
      <arglist>(DelFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a14</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMinFunction</name>
      <anchor>a15</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setMaxFunction</name>
      <anchor>a16</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setStringGetFunction</name>
      <anchor>a17</anchor>
      <arglist>(StringGetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a18</anchor>
      <arglist>(ostream &amp;stream) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Type</type>
      <name>theMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>InsFn</type>
      <name>theInsFn</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DelFn</type>
      <name>theDelFn</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DefFn</type>
      <name>theDefFn</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DefFn</type>
      <name>theMinFn</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DefFn</type>
      <name>theMaxFn</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringGetFn</type>
      <name>theStringGetFn</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExLimit</name>
    <filename>structThePEG_1_1ParVExLimit.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExLimit</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExUnknown</name>
    <filename>structThePEG_1_1ParVExUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, T v, int j, const char *s)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExIndex</name>
    <filename>structThePEG_1_1ParVExIndex.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExIndex</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int index)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExFixed</name>
    <filename>structThePEG_1_1ParVExFixed.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExFixed</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExDelUnknown</name>
    <filename>structThePEG_1_1ParVExDelUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExDelUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int j)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParVExGetUnknown</name>
    <filename>structThePEG_1_1ParVExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParVExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, const char *s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReferenceBase</name>
    <filename>classThePEG_1_1ReferenceBase.html</filename>
    <base>ThePEG::RefInterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>ReferenceBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, string newRefClassName, const type_info &amp;newRefTypeInfo, bool depSafe, bool readonly, bool norebind, bool nullable, bool defnull)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReferenceBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, bool chk=true) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual IBPtr</type>
      <name>get</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a7</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr ip) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a8</anchor>
      <arglist>(InterfacedBase &amp;ib, const TranslationMap &amp;trans, const IVector &amp;defs) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Reference</name>
    <filename>classThePEG_1_1Reference.html</filename>
    <templarg>T</templarg>
    <templarg>R</templarg>
    <base>ThePEG::ReferenceBase</base>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::pointer</type>
      <name>RefPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::const_pointer</type>
      <name>cRefPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w2</anchor>
      <arglist>)(RefPtr)</arglist>
    </member>
    <member kind="typedef">
      <type>bool(T::*</type>
      <name>CheckFn</name>
      <anchor>w3</anchor>
      <arglist>)(cRefPtr) const</arglist>
    </member>
    <member kind="typedef">
      <type>RefPtr(T::*</type>
      <name>GetFn</name>
      <anchor>w4</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>RefPtr T::*</type>
      <name>Member</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Reference</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, bool depSafe=false, bool readonly=false, bool rebind=true, bool nullable=true, SetFn newSetFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Reference</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, bool depSafe, bool readonly, bool rebind, bool nullable, bool defnull, SetFn newSetFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, bool chk=true) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>get</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr newRef) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a5</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a6</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setCheckFunction</name>
      <anchor>a7</anchor>
      <arglist>(CheckFn)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CheckFn</type>
      <name>theCheckFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetRefClass</name>
    <filename>structThePEG_1_1RefExSetRefClass.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetRefClass</name>
      <anchor>a0</anchor>
      <arglist>(const RefInterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetUnknown</name>
    <filename>structThePEG_1_1RefExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExGetUnknown</name>
    <filename>structThePEG_1_1RefExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetNoobj</name>
    <filename>structThePEG_1_1RefExSetNoobj.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetNoobj</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefExSetMessage</name>
    <filename>structThePEG_1_1RefExSetMessage.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefExSetMessage</name>
      <anchor>a0</anchor>
      <arglist>(string ref, const InterfacedBase &amp;o, const InterfacedBase &amp;o2, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RefVectorBase</name>
    <filename>classThePEG_1_1RefVectorBase.html</filename>
    <base>ThePEG::RefInterfaceBase</base>
    <member kind="function">
      <type></type>
      <name>RefVectorBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, string newRefClassName, const type_info &amp;newRefTypeInfo, int newSize, bool depSafe, bool readonly, bool norebind, bool nullable, bool defnull)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RefVectorBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a5</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a6</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a7</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual IVector</type>
      <name>get</name>
      <anchor>a8</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a9</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr ip, int i) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a10</anchor>
      <arglist>(InterfacedBase &amp;ib, const TranslationMap &amp;trans, const IVector &amp;defs) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>a11</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>size</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSize</name>
      <anchor>a13</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setVariableSize</name>
      <anchor>a14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theSize</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RefVector</name>
    <filename>classThePEG_1_1RefVector.html</filename>
    <templarg>T</templarg>
    <templarg>R</templarg>
    <base>ThePEG::RefVectorBase</base>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::pointer</type>
      <name>RefPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; R &gt;::const_pointer</type>
      <name>cRefPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w2</anchor>
      <arglist>)(RefPtr, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>InsFn</name>
      <anchor>w3</anchor>
      <arglist>)(RefPtr, int)</arglist>
    </member>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>DelFn</name>
      <anchor>w4</anchor>
      <arglist>)(int)</arglist>
    </member>
    <member kind="typedef">
      <type>bool(T::*</type>
      <name>CheckFn</name>
      <anchor>w5</anchor>
      <arglist>)(cRefPtr, int) const</arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; RefPtr &gt;(T::*</type>
      <name>GetFn</name>
      <anchor>w6</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; RefPtr &gt; T::*</type>
      <name>Member</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RefVector</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, bool depSafe=false, bool readonly=false, bool rebind=true, bool nullable=true, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RefVector</name>
      <anchor>a1</anchor>
      <arglist>(string newName, string newDescription, Member newMember, int newSize, bool depSafe, bool readonly, bool rebind, bool nullable, bool defnull, SetFn newSetFn=0, InsFn newInsFn=0, DelFn newDelFn=0, GetFn newGetFn=0, CheckFn newCheckFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>insert</name>
      <anchor>a3</anchor>
      <arglist>(InterfacedBase &amp;ib, IBPtr ip, int i, bool chk=true) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>erase</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, int i) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual IVector</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib, cIBPtr, int i) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a7</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setInsertFunction</name>
      <anchor>a8</anchor>
      <arglist>(InsFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a9</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setEraseFunction</name>
      <anchor>a10</anchor>
      <arglist>(DelFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setCheckFunction</name>
      <anchor>a11</anchor>
      <arglist>(CheckFn)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>InsFn</type>
      <name>theInsFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DelFn</type>
      <name>theDelFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CheckFn</type>
      <name>theCheckFn</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExRefClass</name>
    <filename>structThePEG_1_1RefVExRefClass.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExRefClass</name>
      <anchor>a0</anchor>
      <arglist>(const RefInterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r, const char *)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExSetUnknown</name>
    <filename>structThePEG_1_1RefVExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const RefInterfaceBase &amp;i, const InterfacedBase &amp;o, cIBPtr r, int j, const char *)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExSetUnfound</name>
    <filename>structThePEG_1_1RefVExSetUnfound.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExSetUnfound</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExIndex</name>
    <filename>structThePEG_1_1RefVExIndex.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExIndex</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int j)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExFixed</name>
    <filename>structThePEG_1_1RefVExFixed.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExFixed</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExDelUnknown</name>
    <filename>structThePEG_1_1RefVExDelUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExDelUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, int j)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExGetUnknown</name>
    <filename>structThePEG_1_1RefVExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExNoSet</name>
    <filename>structThePEG_1_1RefVExNoSet.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExNoSet</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExNoIns</name>
    <filename>structThePEG_1_1RefVExNoIns.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExNoIns</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RefVExNoDel</name>
    <filename>structThePEG_1_1RefVExNoDel.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RefVExNoDel</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SwitchOption</name>
    <filename>classThePEG_1_1SwitchOption.html</filename>
    <base>ThePEG::Named</base>
    <member kind="function">
      <type></type>
      <name>SwitchOption</name>
      <anchor>a0</anchor>
      <arglist>(SwitchBase &amp;theSwitch, string newName, string newDescription, long newValue)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SwitchOption</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SwitchOption</name>
      <anchor>a2</anchor>
      <arglist>(const SwitchOption &amp;o)</arglist>
    </member>
    <member kind="function">
      <type>const SwitchOption &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const SwitchOption &amp;o)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>description</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>value</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator long</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theDescription</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theValue</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SwitchBase</name>
    <filename>classThePEG_1_1SwitchBase.html</filename>
    <base>ThePEG::InterfaceBase</base>
    <member kind="typedef">
      <type>map&lt; long, SwitchOption &gt;</type>
      <name>OptionMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, SwitchOption &gt;</type>
      <name>StringMap</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SwitchBase</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, string newClassName, const type_info &amp;newTypeInfo, bool depSafe, bool readonly)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SwitchBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>exec</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, string action, string arguments) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>type</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a4</anchor>
      <arglist>(InterfacedBase &amp;ib, long val) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>get</name>
      <anchor>a5</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual long</type>
      <name>def</name>
      <anchor>a6</anchor>
      <arglist>(const InterfacedBase &amp;ib) const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDef</name>
      <anchor>a7</anchor>
      <arglist>(InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>check</name>
      <anchor>a8</anchor>
      <arglist>(long val) const</arglist>
    </member>
    <member kind="function">
      <type>const OptionMap &amp;</type>
      <name>options</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual string</type>
      <name>doxygenType</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>registerOption</name>
      <anchor>b0</anchor>
      <arglist>(const SwitchOption &amp;o)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>OptionMap</type>
      <name>theOptions</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringMap</type>
      <name>theOptionNames</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Switch</name>
    <filename>classThePEG_1_1Switch.html</filename>
    <templarg>T</templarg>
    <templarg>Int</templarg>
    <base>ThePEG::SwitchBase</base>
    <member kind="typedef">
      <type>void(T::*</type>
      <name>SetFn</name>
      <anchor>w0</anchor>
      <arglist>)(Int)</arglist>
    </member>
    <member kind="typedef">
      <type>Int(T::*</type>
      <name>GetFn</name>
      <anchor>w1</anchor>
      <arglist>)() const</arglist>
    </member>
    <member kind="typedef">
      <type>Int T::*</type>
      <name>Member</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Switch</name>
      <anchor>a0</anchor>
      <arglist>(string newName, string newDescription, Member newMember, Int newDef, bool depSafe=false, bool readonly=false, SetFn newSetFn=0, GetFn newGetFn=0, GetFn newDefFn=0)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Switch</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>set</name>
      <anchor>a2</anchor>
      <arglist>(InterfacedBase &amp;ib, long val) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>get</name>
      <anchor>a3</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual long</type>
      <name>def</name>
      <anchor>a4</anchor>
      <arglist>(const InterfacedBase &amp;ib) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSetFunction</name>
      <anchor>a5</anchor>
      <arglist>(SetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setGetFunction</name>
      <anchor>a6</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDefaultFunction</name>
      <anchor>a7</anchor>
      <arglist>(GetFn)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>doxygenDescription</name>
      <anchor>a8</anchor>
      <arglist>(ostream &amp;stream) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Member</type>
      <name>theMember</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Int</type>
      <name>theDef</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SetFn</type>
      <name>theSetFn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theGetFn</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>GetFn</type>
      <name>theDefFn</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SwExSetOpt</name>
    <filename>structThePEG_1_1SwExSetOpt.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SwExSetOpt</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, long v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SwExSetUnknown</name>
    <filename>structThePEG_1_1SwExSetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SwExSetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, long v)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SwExGetUnknown</name>
    <filename>structThePEG_1_1SwExGetUnknown.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>SwExGetUnknown</name>
      <anchor>a0</anchor>
      <arglist>(const InterfaceBase &amp;i, const InterfacedBase &amp;o, const char *s)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesEventHandler</name>
    <filename>classThePEG_1_1LesHouchesEventHandler.html</filename>
    <base>ThePEG::EventHandler</base>
    <member kind="typedef">
      <type>vector&lt; LesHouchesReaderPtr &gt;</type>
      <name>ReaderVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; vector&lt; long &gt; &gt;</type>
      <name>AcceptVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>VSelector&lt; CrossSection, int &gt;</type>
      <name>ReaderSelector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>WeightOpt</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unitweight</name>
      <anchor>w7w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unitnegweight</name>
      <anchor>w7w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>varweight</name>
      <anchor>w7w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>varnegweight</name>
      <anchor>w7w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>initialize</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>statistics</name>
      <anchor>a1</anchor>
      <arglist>(ostream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>WeightOpt</type>
      <name>weightOption</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ReaderVector &amp;</type>
      <name>readers</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>NAttempted</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const AcceptVector &amp;</type>
      <name>accepted</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ReaderSelector &amp;</type>
      <name>selector</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesEventHandler</name>
      <anchor>z396_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesEventHandler</name>
      <anchor>z396_1</anchor>
      <arglist>(const LesHouchesEventHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LesHouchesEventHandler</name>
      <anchor>z396_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>generateEvent</name>
      <anchor>z398_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>continueEvent</name>
      <anchor>z398_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z400_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z400_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>initGroups</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ReaderVector &amp;</type>
      <name>readers</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>NAttempted</name>
      <anchor>b2</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>newAttempt</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>AcceptVector &amp;</type>
      <name>accepted</name>
      <anchor>b4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ReaderSelector &amp;</type>
      <name>selector</name>
      <anchor>b5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z402_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z402_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z404_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z404_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z404_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z404_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z404_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z404_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LesHouchesEventHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LesHouchesEventHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReaderVector</type>
      <name>theReaders</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNAttempted</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AcceptVector</type>
      <name>theAccepted</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReaderSelector</type>
      <name>theSelector</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightOpt</type>
      <name>theWeightOption</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; LesHouchesEventHandler &gt;</type>
      <name>initLesHouchesEventHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LesHouchesEventHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LesHouchesEventHandler_00_011_01_4.html</filename>
    <member kind="typedef">
      <type>EventHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LesHouchesEventHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LesHouchesEventHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LesHouchesEventHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesFileReader</name>
    <filename>classThePEG_1_1LesHouchesFileReader.html</filename>
    <base>ThePEG::LesHouchesReader</base>
    <member kind="function">
      <type>string</type>
      <name>filename</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FILE *</type>
      <name>file</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesFileReader</name>
      <anchor>z406_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesFileReader</name>
      <anchor>z406_1</anchor>
      <arglist>(const LesHouchesFileReader &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LesHouchesFileReader</name>
      <anchor>z406_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>open</name>
      <anchor>z408_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>close</name>
      <anchor>z408_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z410_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z410_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z412_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z412_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z412_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z412_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z412_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z412_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>CFileLineReader</type>
      <name>cfile</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>LesHouchesFileReader &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LesHouchesFileReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FILE *</type>
      <name>theFile</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theFileName</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; LesHouchesFileReader &gt;</type>
      <name>initLesHouchesFileReader</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesFileReader::LesHouchesFileError</name>
    <filename>classThePEG_1_1LesHouchesFileReader_1_1LesHouchesFileError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesFileReader::LesHouchesFileError</name>
    <filename>classThePEG_1_1LesHouchesFileReader_1_1LesHouchesFileError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LesHouchesFileReader, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LesHouchesFileReader_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>LesHouchesReader</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LesHouchesFileReader &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LesHouchesFileReader_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LesHouchesFileReader &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader</name>
    <filename>classThePEG_1_1LesHouchesReader.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>LesHouchesReader</name>
      <anchor>z414_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LesHouchesReader</name>
      <anchor>z414_1</anchor>
      <arglist>(const LesHouchesReader &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LesHouchesReader</name>
      <anchor>z414_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>open</name>
      <anchor>z416_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>readEvent</name>
      <anchor>z416_1</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>close</name>
      <anchor>z416_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>scan</name>
      <anchor>z416_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>convertEvent</name>
      <anchor>z416_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>beams</name>
      <anchor>z418_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PPair &amp;</type>
      <name>incoming</name>
      <anchor>z418_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>outgoing</name>
      <anchor>z418_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>intermediates</name>
      <anchor>z418_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>xSec</name>
      <anchor>z420_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>CrossSection</type>
      <name>maxXSec</name>
      <anchor>z420_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>maxWeight</name>
      <anchor>z420_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>NEvents</name>
      <anchor>z420_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>maxScan</name>
      <anchor>z420_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>weighted</name>
      <anchor>z420_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>negativeWeights</name>
      <anchor>z420_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z424_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z424_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>createParticles</name>
      <anchor>z422_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>createBeams</name>
      <anchor>z422_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>connectMothers</name>
      <anchor>z422_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>xSec</name>
      <anchor>z426_0</anchor>
      <arglist>(CrossSection)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>weighted</name>
      <anchor>z426_1</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>maxXSec</name>
      <anchor>z426_2</anchor>
      <arglist>(CrossSection)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>NEvents</name>
      <anchor>z426_3</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>maxWeight</name>
      <anchor>z426_4</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>negativeWeights</name>
      <anchor>z426_5</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z428_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z428_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z428_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z428_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z428_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z428_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>pair&lt; long, long &gt;</type>
      <name>IDBMUP</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>pair&lt; double, double &gt;</type>
      <name>EBMUP</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>pair&lt; int, int &gt;</type>
      <name>PDFGUP</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>pair&lt; int, int &gt;</type>
      <name>PDFSUP</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PDFPtr</type>
      <name>thePDFA</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PDFPtr</type>
      <name>thePDFB</name>
      <anchor>p5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>IDWTUP</name>
      <anchor>p6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>NRUP</name>
      <anchor>p7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>XSECUP</name>
      <anchor>p8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>XERRUP</name>
      <anchor>p9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>XMAXUP</name>
      <anchor>p10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; int &gt;</type>
      <name>LPRUP</name>
      <anchor>p11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>NUP</name>
      <anchor>p12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>IDPRUP</name>
      <anchor>p13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>XWGTUP</name>
      <anchor>p14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>SCALUP</name>
      <anchor>p15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>AQEDUP</name>
      <anchor>p16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>AQCDUP</name>
      <anchor>p17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; long &gt;</type>
      <name>IDUP</name>
      <anchor>p18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; int &gt;</type>
      <name>ISTUP</name>
      <anchor>p19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; pair&lt; int, int &gt; &gt;</type>
      <name>MOTHUP</name>
      <anchor>p20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; pair&lt; int, int &gt; &gt;</type>
      <name>ICOLUP</name>
      <anchor>p21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; vector&lt; double &gt; &gt;</type>
      <name>PUP</name>
      <anchor>p22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>VTIMUP</name>
      <anchor>p23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>SPINUP</name>
      <anchor>p24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>CrossSection</type>
      <name>theXSec</name>
      <anchor>p25</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>CrossSection</type>
      <name>theMaxXSec</name>
      <anchor>p26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>theMaxWeight</name>
      <anchor>p27</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>theNEvents</name>
      <anchor>p28</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>theMaxScan</name>
      <anchor>p29</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>isWeighted</name>
      <anchor>p30</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>bool</type>
      <name>hasNegativeWeights</name>
      <anchor>p31</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ObjectIndexer&lt; long, ColourLine &gt;</type>
      <name>colourIndex</name>
      <anchor>p32</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ObjectIndexer&lt; long, Particle &gt;</type>
      <name>particleIndex</name>
      <anchor>p33</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PPair</type>
      <name>theBeams</name>
      <anchor>p34</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PPair</type>
      <name>theIncoming</name>
      <anchor>p35</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PVector</type>
      <name>theOutgoing</name>
      <anchor>p36</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>PVector</type>
      <name>theIntermediates</name>
      <anchor>p37</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBeamA</name>
      <anchor>d0</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getBeamA</name>
      <anchor>d1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBeamB</name>
      <anchor>d2</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getBeamB</name>
      <anchor>d3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setEBeamA</name>
      <anchor>d4</anchor>
      <arglist>(Energy e)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getEBeamA</name>
      <anchor>d5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setEBeamB</name>
      <anchor>d6</anchor>
      <arglist>(Energy e)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getEBeamB</name>
      <anchor>d7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LesHouchesReader &amp;</type>
      <name>operator=</name>
      <anchor>d8</anchor>
      <arglist>(const LesHouchesReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; LesHouchesReader &gt;</type>
      <name>initLesHouchesReader</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesInconsistencyError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesInconsistencyError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::LesHouchesReader::LesHouchesInconsistencyError</name>
    <filename>classThePEG_1_1LesHouchesReader_1_1LesHouchesInconsistencyError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LesHouchesReader, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LesHouchesReader_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LesHouchesReader &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LesHouchesReader_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LesHouchesReader &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MadGraphReader</name>
    <filename>classThePEG_1_1MadGraphReader.html</filename>
    <base>ThePEG::LesHouchesFileReader</base>
    <member kind="function">
      <type></type>
      <name>MadGraphReader</name>
      <anchor>z430_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MadGraphReader</name>
      <anchor>z430_1</anchor>
      <arglist>(const MadGraphReader &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MadGraphReader</name>
      <anchor>z430_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>open</name>
      <anchor>z432_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>readEvent</name>
      <anchor>z432_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>scan</name>
      <anchor>z432_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z434_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z434_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z436_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z436_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z438_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z438_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z438_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z438_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z438_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z438_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>neve</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>ieve</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MadGraphReader &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MadGraphReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MadGraphReader &gt;</type>
      <name>initMadGraphReader</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MadGraphReader, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MadGraphReader_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>LesHouchesFileReader</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MadGraphReader &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MadGraphReader_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MadGraphReader &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Amplitude</name>
    <filename>classThePEG_1_1Amplitude.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type></type>
      <name>Amplitude</name>
      <anchor>z440_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Amplitude</name>
      <anchor>z440_1</anchor>
      <arglist>(const Amplitude &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Amplitude</name>
      <anchor>z440_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Complex</type>
      <name>value</name>
      <anchor>z442_0</anchor>
      <arglist>(const tcPDVector &amp;particles, const vector&lt; Lorentz5Momentum &gt; &amp;momenta, const vector&lt; int &gt; &amp;helicities)=0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Complex</type>
      <name>overestimateValue</name>
      <anchor>z442_1</anchor>
      <arglist>(const tcPDVector &amp;particles, const vector&lt; Lorentz5Momentum &gt; &amp;momenta, const vector&lt; int &gt; &amp;helicities)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>value</name>
      <anchor>z444_0</anchor>
      <arglist>(const PVector &amp;particles, const vector&lt; int &gt; &amp;helicities)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>overestimateValue</name>
      <anchor>z444_1</anchor>
      <arglist>(const PVector &amp;particles, const vector&lt; int &gt; &amp;helicities)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z446_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z446_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>Amplitude &amp;</type>
      <name>operator=</name>
      <anchor>b0</anchor>
      <arglist>(const Amplitude &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z448_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z448_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z448_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z448_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z448_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected" static="yes">
      <type>AbstractClassDescription&lt; Amplitude &gt;</type>
      <name>initAmplitude</name>
      <anchor>t0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Amplitude, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Amplitude_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Amplitude &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Amplitude_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Amplitude &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourLines</name>
    <filename>classThePEG_1_1ColourLines.html</filename>
    <base>ThePEG::Base</base>
    <member kind="typedef">
      <type>vector&lt; int &gt;</type>
      <name>Line</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Line &gt;</type>
      <name>LineVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ColinePtr &gt;</type>
      <name>Vertex</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; Vertex &gt;</type>
      <name>VertexVector</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>connect</name>
      <anchor>a0</anchor>
      <arglist>(const tPVector &amp;partons) const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLines</name>
      <anchor>z450_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLines</name>
      <anchor>z450_1</anchor>
      <arglist>(const ColourLines &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourLines</name>
      <anchor>z450_2</anchor>
      <arglist>(string s)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourLines</name>
      <anchor>z450_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LineVector</type>
      <name>theLines</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ColourGeometryException</name>
    <filename>structThePEG_1_1ColourGeometryException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>ColourGeometryException</name>
      <anchor>a0</anchor>
      <arglist>(const tPVector &amp;, const vector&lt; int &gt; &amp;=vector&lt; int &gt;())</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DiagramBase</name>
    <filename>classThePEG_1_1DiagramBase.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>DiagramBase</name>
      <anchor>z452_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DiagramBase</name>
      <anchor>z452_1</anchor>
      <arglist>(const DiagramBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DiagramBase</name>
      <anchor>z452_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tPVector</type>
      <name>construct</name>
      <anchor>z454_0</anchor>
      <arglist>(SubProPtr sb, const XComb &amp;, const ColourLines &amp;) const =0</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nIncoming</name>
      <anchor>z456_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>partons</name>
      <anchor>z456_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>id</name>
      <anchor>z456_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>getTag</name>
      <anchor>z456_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z458_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z458_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>partons</name>
      <anchor>b0</anchor>
      <arglist>(int ninc, const cPDVector &amp;parts, int newId)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>done</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DiagramBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DiagramBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNIncoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>thePartons</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theId</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; DiagramBase &gt;</type>
      <name>initDiagramBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DiagramBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DiagramBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DiagramBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DiagramBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DiagramBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DiagramBaseSetupException</name>
    <filename>structThePEG_1_1DiagramBaseSetupException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>DiagramBaseSetupException</name>
      <anchor>a0</anchor>
      <arglist>(const DiagramBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ME2to2Base</name>
    <filename>classThePEG_1_1ME2to2Base.html</filename>
    <base>ThePEG::MEBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>getCosTheta</name>
      <anchor>a0</anchor>
      <arglist>(double cthmin, double cthmax, const double *r)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>scaleChoice</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ME2to2Base</name>
      <anchor>z460_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ME2to2Base</name>
      <anchor>z460_1</anchor>
      <arglist>(const ME2to2Base &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ME2to2Base</name>
      <anchor>z460_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z462_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>generateKinematics</name>
      <anchor>z462_1</anchor>
      <arglist>(const double *r)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual CrossSection</type>
      <name>dSigHatDR</name>
      <anchor>z462_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>scale</name>
      <anchor>z462_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setKinematics</name>
      <anchor>z462_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHat</name>
      <anchor>z464_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHat</name>
      <anchor>z464_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>phi</name>
      <anchor>z464_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z466_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z466_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z468_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z468_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z468_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z468_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z468_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>Switch&lt; ME2to2Base, int &gt; &amp;</type>
      <name>interfaceScaleChoice</name>
      <anchor>f0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ME2to2Base &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ME2to2Base &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theScaleChoice</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastTHat</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastUHat</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastPhi</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ME2to2Base &gt;</type>
      <name>initME2to2Base</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ME2to2Base, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ME2to2Base_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>MEBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ME2to2Base &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ME2to2Base_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ME2to2Base &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ME2to2QCD</name>
    <filename>classThePEG_1_1ME2to2QCD.html</filename>
    <base>ThePEG::ME2to2Base</base>
    <member kind="function">
      <type></type>
      <name>ME2to2QCD</name>
      <anchor>z470_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ME2to2QCD</name>
      <anchor>z470_1</anchor>
      <arglist>(const ME2to2QCD &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ME2to2QCD</name>
      <anchor>z470_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaS</name>
      <anchor>z472_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaEW</name>
      <anchor>z472_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>comfac</name>
      <anchor>z472_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxFlavour</name>
      <anchor>z472_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>Kfac</name>
      <anchor>z472_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>KfacA</name>
      <anchor>z472_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>interference</name>
      <anchor>z472_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isQuark</name>
      <anchor>z472_7</anchor>
      <arglist>(const ParticleData &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>quark</name>
      <anchor>z472_8</anchor>
      <arglist>(int i) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z474_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z474_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z476_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z476_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z476_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z476_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z476_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ME2to2QCD &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ME2to2QCD &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theMaxFlavour</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theKfac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theKfacA</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>useInterference</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ME2to2QCD &gt;</type>
      <name>initME2to2QCD</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ME2to2QCD, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ME2to2QCD_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ME2to2QCD &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ME2to2QCD_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ME2to2QCD &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEBase</name>
    <filename>classThePEG_1_1MEBase.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="typedef">
      <type>vector&lt; DiagPtr &gt;</type>
      <name>DiagramVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>DiagramVector::size_type</type>
      <name>DiagramIndex</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; ReweightPtr &gt;</type>
      <name>ReweightVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEBase</name>
      <anchor>z478_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEBase</name>
      <anchor>z478_1</anchor>
      <arglist>(const MEBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEBase</name>
      <anchor>z478_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual unsigned int</type>
      <name>orderInAlphaS</name>
      <anchor>z480_0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual unsigned int</type>
      <name>orderInAlphaEW</name>
      <anchor>z480_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z480_2</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy2</type>
      <name>scale</name>
      <anchor>z480_3</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>z480_4</anchor>
      <arglist>(tPPair in, const PVector &amp;out)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setKinematics</name>
      <anchor>z480_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>constructVertex</name>
      <anchor>z480_6</anchor>
      <arglist>(tSubProPtr sub)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z480_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>generateKinematics</name>
      <anchor>z480_8</anchor>
      <arglist>(const double *r)=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual CrossSection</type>
      <name>dSigHatDR</name>
      <anchor>z480_9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>generateSubCollision</name>
      <anchor>z480_10</anchor>
      <arglist>(SubProcess &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clearKinematics</name>
      <anchor>z480_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z480_12</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>const DiagramVector &amp;</type>
      <name>diagrams</name>
      <anchor>z480_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z480_14</anchor>
      <arglist>(tcDiagPtr diag) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual const ColourLines &amp;</type>
      <name>selectColourGeometry</name>
      <anchor>z480_15</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z480_16</anchor>
      <arglist>(const DiagramVector &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DiagramIndex</type>
      <name>diagram</name>
      <anchor>z480_17</anchor>
      <arglist>(const DiagramVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>reWeight</name>
      <anchor>z480_18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>preWeight</name>
      <anchor>z480_19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addReweighter</name>
      <anchor>z480_20</anchor>
      <arglist>(tReweightPtr rw)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addPreweighter</name>
      <anchor>z480_21</anchor>
      <arglist>(tReweightPtr rw)</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>amplitude</name>
      <anchor>z480_22</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>sHat</name>
      <anchor>z482_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>preweight</name>
      <anchor>z482_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setXComb</name>
      <anchor>z482_2</anchor>
      <arglist>(tXCombPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z484_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z484_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>add</name>
      <anchor>b0</anchor>
      <arglist>(DiagPtr) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>meMomenta</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>jacobian</name>
      <anchor>b2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>jacobian</name>
      <anchor>b3</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z486_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z486_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z486_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z486_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z486_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiagramVector</type>
      <name>theDiagrams</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastSHat</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>reweights</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ReweightVector</type>
      <name>preweights</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>lastPreweight</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>theAmplitude</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLastJacobian</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; MEBase &gt;</type>
      <name>initMEBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MECuts</name>
    <filename>classThePEG_1_1MECuts.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>MECuts</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MECuts</name>
      <anchor>a1</anchor>
      <arglist>(const MECuts &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MECuts</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>cut</name>
      <anchor>a3</anchor>
      <arglist>(const SubProcess &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMin</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mHatMax</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMin</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>sHatMax</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMin</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatMax</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>pTHatSingularMin</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>singularMassMax</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMin</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>cTHMax</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMin</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>tHatMax</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMin</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>uHatMax</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMin</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>a20</anchor>
      <arglist>(PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>a21</anchor>
      <arglist>(PersistentIStream &amp;, int)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>newcut</name>
      <anchor>b0</anchor>
      <arglist>(const SubProcess &amp;) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>b1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>b4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MECuts &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MECuts &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMHatMax</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMin</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatMax</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>thePTHatSingularMin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theSingularMassMax</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMin</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theCTHMax</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theTHatMax</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMin</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theUHatMax</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMin</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScaleMax</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MECuts &gt;</type>
      <name>initMECuts</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MECuts, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MECuts_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MECuts &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MECuts_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MECuts &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MECutSetup</name>
    <filename>structThePEG_1_1MECutSetup.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>MECutSetup</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MECutZeroInterval</name>
    <filename>structThePEG_1_1MECutZeroInterval.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>MECutZeroInterval</name>
      <anchor>a0</anchor>
      <arglist>(const MECuts &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEee2gZ2qq</name>
    <filename>classThePEG_1_1MEee2gZ2qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEee2gZ2qq</name>
      <anchor>z488_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEee2gZ2qq</name>
      <anchor>z488_1</anchor>
      <arglist>(const MEee2gZ2qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEee2gZ2qq</name>
      <anchor>z488_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaS</name>
      <anchor>z490_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual unsigned int</type>
      <name>orderInAlphaEW</name>
      <anchor>z490_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z490_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z490_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z490_4</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z490_5</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>scale</name>
      <anchor>z490_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z492_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z492_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z494_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z494_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z496_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>vector&lt; double &gt;</type>
      <name>coefs</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Energy2</type>
      <name>mZ2</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>Energy2</type>
      <name>GZ2</name>
      <anchor>p2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>lastCont</name>
      <anchor>p3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>double</type>
      <name>lastBW</name>
      <anchor>p4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEee2gZ2qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEee2gZ2qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MEee2gZ2qq &gt;</type>
      <name>initMEee2gZ2qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEee2gZ2qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEee2gZ2qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEee2gZ2qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEee2gZ2qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEee2gZ2qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEGG2GG</name>
    <filename>classThePEG_1_1MEGG2GG.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEGG2GG</name>
      <anchor>z498_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEGG2GG</name>
      <anchor>z498_1</anchor>
      <arglist>(const MEGG2GG &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEGG2GG</name>
      <anchor>z498_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z500_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z500_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z500_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z500_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA1</name>
      <anchor>z502_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB1</name>
      <anchor>z502_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colC1</name>
      <anchor>z502_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA2</name>
      <anchor>z502_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB2</name>
      <anchor>z502_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colC2</name>
      <anchor>z502_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z504_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z504_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEGG2GG &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEGG2GG &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEGG2GG &gt;</type>
      <name>initMEGG2GG</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEGG2GG, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEGG2GG_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEGG2GG &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEGG2GG_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEGG2GG &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEGG2QQ</name>
    <filename>classThePEG_1_1MEGG2QQ.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEGG2QQ</name>
      <anchor>z506_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEGG2QQ</name>
      <anchor>z506_1</anchor>
      <arglist>(const MEGG2QQ &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEGG2QQ</name>
      <anchor>z506_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z508_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z508_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z508_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z508_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z510_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z510_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z512_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z512_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEGG2QQ &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEGG2QQ &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEGG2QQ &gt;</type>
      <name>initMEGG2QQ</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEGG2QQ, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEGG2QQ_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEGG2QQ &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEGG2QQ_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEGG2QQ &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQG2QG</name>
    <filename>classThePEG_1_1MEQG2QG.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQG2QG</name>
      <anchor>z514_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQG2QG</name>
      <anchor>z514_1</anchor>
      <arglist>(const MEQG2QG &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQG2QG</name>
      <anchor>z514_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z516_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z516_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z516_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z516_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA1</name>
      <anchor>z518_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB1</name>
      <anchor>z518_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA2</name>
      <anchor>z518_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB2</name>
      <anchor>z518_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z520_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z520_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQG2QG &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQG2QG &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQG2QG &gt;</type>
      <name>initMEQG2QG</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQG2QG, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQG2QG_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQG2QG &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQG2QG_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQG2QG &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQQ2GG</name>
    <filename>classThePEG_1_1MEQQ2GG.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQQ2GG</name>
      <anchor>z522_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQQ2GG</name>
      <anchor>z522_1</anchor>
      <arglist>(const MEQQ2GG &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQQ2GG</name>
      <anchor>z522_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z524_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z524_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z524_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z524_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z526_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z526_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z528_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z528_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQQ2GG &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQQ2GG &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQQ2GG &gt;</type>
      <name>initMEQQ2GG</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQQ2GG, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQQ2GG_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQQ2GG &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQQ2GG_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQQ2GG &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQQ2QQ</name>
    <filename>classThePEG_1_1MEQQ2QQ.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQQ2QQ</name>
      <anchor>z530_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQQ2QQ</name>
      <anchor>z530_1</anchor>
      <arglist>(const MEQQ2QQ &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQQ2QQ</name>
      <anchor>z530_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z532_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z532_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z532_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z532_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z534_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z534_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z536_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z536_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQQ2QQ &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQQ2QQ &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQQ2QQ &gt;</type>
      <name>initMEQQ2QQ</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQQ2QQ, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQQ2QQ_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQQ2QQ &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQQ2QQ_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQQ2QQ &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQQ2qq</name>
    <filename>classThePEG_1_1MEQQ2qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQQ2qq</name>
      <anchor>z538_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQQ2qq</name>
      <anchor>z538_1</anchor>
      <arglist>(const MEQQ2qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQQ2qq</name>
      <anchor>z538_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z540_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z540_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z540_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z540_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z542_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z544_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z544_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQQ2qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQQ2qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQQ2qq &gt;</type>
      <name>initMEQQ2qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQQ2qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQQ2qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQQ2qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQQ2qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQQ2qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEQq2Qq</name>
    <filename>classThePEG_1_1MEQq2Qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEQq2Qq</name>
      <anchor>z546_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEQq2Qq</name>
      <anchor>z546_1</anchor>
      <arglist>(const MEQq2Qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEQq2Qq</name>
      <anchor>z546_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z548_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z548_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z548_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z548_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z550_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z552_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z552_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEQq2Qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEQq2Qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEQq2Qq &gt;</type>
      <name>initMEQq2Qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEQq2Qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEQq2Qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEQq2Qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEQq2Qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEQq2Qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MEqq2qq</name>
    <filename>classThePEG_1_1MEqq2qq.html</filename>
    <base>ThePEG::ME2to2QCD</base>
    <member kind="function">
      <type></type>
      <name>MEqq2qq</name>
      <anchor>z554_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MEqq2qq</name>
      <anchor>z554_1</anchor>
      <arglist>(const MEqq2qq &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MEqq2qq</name>
      <anchor>z554_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>me2</name>
      <anchor>z556_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>getDiagrams</name>
      <anchor>z556_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; const ColourLines * &gt;</type>
      <name>colourGeometries</name>
      <anchor>z556_2</anchor>
      <arglist>(tcDiagPtr diag) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Selector&lt; DiagramIndex &gt;</type>
      <name>diagrams</name>
      <anchor>z556_3</anchor>
      <arglist>(const DiagramVector &amp;dv) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colA</name>
      <anchor>z558_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>colB</name>
      <anchor>z558_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z560_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z560_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MEqq2qq &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MEqq2qq &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; MEqq2qq &gt;</type>
      <name>initMEqq2qq</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MEqq2qq, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MEqq2qq_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ME2to2QCD</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MEqq2qq &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MEqq2qq_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MEqq2qq &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReweightBase</name>
    <filename>classThePEG_1_1ReweightBase.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>weight</name>
      <anchor>a0</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>a1</anchor>
      <arglist>(Energy2 shat, tcPDPair in, const cPDVector &amp;out, const Lorentz5Momentum &amp;pina, const Lorentz5Momentum &amp;pinb, const vector&lt; Lorentz5Momentum &gt; &amp;pout)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>a2</anchor>
      <arglist>(tPPair in, const PVector &amp;out)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setKinematics</name>
      <anchor>a3</anchor>
      <arglist>(const SubProcess &amp;sub)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXComb</name>
      <anchor>a4</anchor>
      <arglist>(tXCombPtr)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setKinematics</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>clearKinematics</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>sHat</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDPair &amp;</type>
      <name>inData</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>outData</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>inMomentumA</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>inMomentumB</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; Lorentz5Momentum &gt; &amp;</type>
      <name>outMomentum</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightBase</name>
      <anchor>z562_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightBase</name>
      <anchor>z562_1</anchor>
      <arglist>(const ReweightBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReweightBase</name>
      <anchor>z562_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z564_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z564_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z566_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z566_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z566_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z566_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z566_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ReweightBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ReweightBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLastSHat</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPair</type>
      <name>theLastInData</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>theLastOutData</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>theLastInMomentumA</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>theLastInMomentumB</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Lorentz5Momentum &gt;</type>
      <name>theLastOutMomentum</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; ReweightBase &gt;</type>
      <name>initReweightBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ReweightBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ReweightBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ReweightBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ReweightBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ReweightBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ReweightMinPT</name>
    <filename>classThePEG_1_1ReweightMinPT.html</filename>
    <base>ThePEG::ReweightBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>weight</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightMinPT</name>
      <anchor>z568_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ReweightMinPT</name>
      <anchor>z568_1</anchor>
      <arglist>(const ReweightMinPT &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ReweightMinPT</name>
      <anchor>z568_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z570_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z570_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z572_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z572_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z574_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z574_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z574_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z574_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z574_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ReweightMinPT &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ReweightMinPT &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>power</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ReweightMinPT &gt;</type>
      <name>initReweightMinPT</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ReweightMinPT, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ReweightMinPT_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ReweightBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ReweightMinPT &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ReweightMinPT_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ReweightMinPT &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Tree2toNDiagram</name>
    <filename>classThePEG_1_1Tree2toNDiagram.html</filename>
    <base>ThePEG::DiagramBase</base>
    <member kind="typedef">
      <type>cPDVector::size_type</type>
      <name>size_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>multiset&lt; tcPDPtr &gt;</type>
      <name>PDMSet</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a0</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a1</anchor>
      <arglist>(PDPtr)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a2</anchor>
      <arglist>(cPDPtr)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a3</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator,</name>
      <anchor>a4</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tPVector</type>
      <name>construct</name>
      <anchor>a5</anchor>
      <arglist>(SubProPtr sb, const XComb &amp;, const ColourLines &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPair</type>
      <name>incoming</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const cPDVector &amp;</type>
      <name>allPartons</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPDVector</type>
      <name>outgoing</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPDVector</type>
      <name>external</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>parent</name>
      <anchor>a10</anchor>
      <arglist>(int i) const</arglist>
    </member>
    <member kind="function">
      <type>pair&lt; int, int &gt;</type>
      <name>children</name>
      <anchor>a11</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nSpace</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nOutgoing</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagram</name>
      <anchor>z576_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagram</name>
      <anchor>z576_1</anchor>
      <arglist>(const Tree2toNDiagram &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Tree2toNDiagram</name>
      <anchor>z576_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagram</name>
      <anchor>z576_3</anchor>
      <arglist>(int space)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z578_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z578_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>check</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addSpacelike</name>
      <anchor>d1</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addTimelike</name>
      <anchor>d2</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addTimelike</name>
      <anchor>d3</anchor>
      <arglist>(tcPDPtr, size_type origin)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Tree2toNDiagram &amp;</type>
      <name>add</name>
      <anchor>d4</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Tree2toNDiagram &amp;</type>
      <name>operator=</name>
      <anchor>d5</anchor>
      <arglist>(const Tree2toNDiagram &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theNSpace</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theNOutgoing</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>nextOrig</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDVector</type>
      <name>thePartons</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; int &gt;</type>
      <name>theParents</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Tree2toNDiagram &gt;</type>
      <name>initTree2toNDiagram</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Tree2toNDiagram, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Tree2toNDiagram_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>DiagramBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Tree2toNDiagram &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Tree2toNDiagram_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Tree2toNDiagram &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Tree2toNDiagramError</name>
    <filename>structThePEG_1_1Tree2toNDiagramError.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>Tree2toNDiagramError</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::BaryonRemnants</name>
    <filename>classThePEG_1_1BaryonRemnants.html</filename>
    <base>ThePEG::RemnantHandler</base>
    <member kind="typedef">
      <type>Ptr&lt; PtGenerator &gt;::pointer</type>
      <name>PtGPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ZGenerator &gt;::pointer</type>
      <name>ZGPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>FlGPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>margin</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BaryonRemnants</name>
      <anchor>z580_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BaryonRemnants</name>
      <anchor>z580_1</anchor>
      <arglist>(const BaryonRemnants &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~BaryonRemnants</name>
      <anchor>z580_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z582_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z582_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>createRemnants</name>
      <anchor>z582_2</anchor>
      <arglist>(PartonBinInstance &amp;pb) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z584_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z584_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ZGenerator &amp;</type>
      <name>zGenerator</name>
      <anchor>b0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PtGenerator &amp;</type>
      <name>ptGeneratorQ</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PtGenerator &amp;</type>
      <name>ptGeneratorR</name>
      <anchor>b2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>FlavourGenerator &amp;</type>
      <name>flavourGenerator</name>
      <anchor>b3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z586_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z586_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z588_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z588_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z588_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z588_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z588_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>BaryonRemnants &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const BaryonRemnants &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; PtGenerator &gt;::pointer</type>
      <name>thePtGeneratorQ</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; PtGenerator &gt;::pointer</type>
      <name>thePtGeneratorR</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; ZGenerator &gt;::pointer</type>
      <name>theZGenerator</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; FlavourGenerator &gt;::pointer</type>
      <name>theFlavourGenerator</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMargin</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; BaryonRemnants &gt;</type>
      <name>initBaryonRemnants</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaryonRemInfo</name>
    <filename>structThePEG_1_1BaryonRemInfo.html</filename>
    <base>ThePEG::RemInfoBase</base>
    <member kind="variable">
      <type>int</type>
      <name>iq</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>int</type>
      <name>sign</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>flav</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>vector&lt; int &gt;</type>
      <name>vflav</name>
      <anchor>o3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>VSelector&lt; pair&lt; int, int &gt; &gt;</type>
      <name>flavsel</name>
      <anchor>o4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>bool</type>
      <name>mayval</name>
      <anchor>o5</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; BaryonRemnants, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01BaryonRemnants_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RemnantHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; BaryonRemnants &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01BaryonRemnants_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; BaryonRemnants &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::BeamParticleData</name>
    <filename>classThePEG_1_1BeamParticleData.html</filename>
    <base virtualness="virtual">ThePEG::ParticleData</base>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>pdf</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BeamParticleData</name>
      <anchor>z590_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BeamParticleData</name>
      <anchor>z590_1</anchor>
      <arglist>(const BeamParticleData &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~BeamParticleData</name>
      <anchor>z590_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z594_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z594_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>Create</name>
      <anchor>z592_0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPair</type>
      <name>Create</name>
      <anchor>z592_1</anchor>
      <arglist>(long newId, string newPDGName, string newAntiPDGName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>BeamParticleData</name>
      <anchor>b0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual PDPtr</type>
      <name>pdclone</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z596_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z596_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z596_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z596_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z596_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPDF</name>
      <anchor>d0</anchor>
      <arglist>(PDFPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>BeamParticleData &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const BeamParticleData &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDFPtr</type>
      <name>thePDF</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; BeamParticleData &gt;</type>
      <name>initBeamParticleData</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; BeamParticleData, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01BeamParticleData_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; BeamParticleData &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01BeamParticleData_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; BeamParticleData &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BeamParticleWrongPDF</name>
    <filename>structThePEG_1_1BeamParticleWrongPDF.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>BeamParticleWrongPDF</name>
      <anchor>a0</anchor>
      <arglist>(string p, string pdf)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GRV94L</name>
    <filename>classThePEG_1_1GRV94L.html</filename>
    <base>ThePEG::GRVBase</base>
    <member kind="function">
      <type>Energy2</type>
      <name>mu2</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lam2</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94L</name>
      <anchor>z598_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94L</name>
      <anchor>z598_1</anchor>
      <arglist>(const GRV94L &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GRV94L</name>
      <anchor>z598_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(double l, Energy2 scale) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>uv</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>dv</name>
      <anchor>b2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>del</name>
      <anchor>b3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>udb</name>
      <anchor>b4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>sb</name>
      <anchor>b5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>cb</name>
      <anchor>b6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>bb</name>
      <anchor>b7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>gl</name>
      <anchor>b8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z600_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z600_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z602_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z602_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z602_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z602_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z602_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GRV94L &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GRV94L &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; GRV94L &gt;</type>
      <name>initGRV94L</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GRV94L, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GRV94L_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>GRVBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GRV94L &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GRV94L_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GRV94L &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GRV94M</name>
    <filename>classThePEG_1_1GRV94M.html</filename>
    <base>ThePEG::GRVBase</base>
    <member kind="function">
      <type>Energy2</type>
      <name>mu2</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>lam2</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94M</name>
      <anchor>z604_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRV94M</name>
      <anchor>z604_1</anchor>
      <arglist>(const GRV94M &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GRV94M</name>
      <anchor>z604_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(double l, Energy2 scale) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>uv</name>
      <anchor>b1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>dv</name>
      <anchor>b2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>del</name>
      <anchor>b3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>udb</name>
      <anchor>b4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>sb</name>
      <anchor>b5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>cb</name>
      <anchor>b6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>bb</name>
      <anchor>b7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>gl</name>
      <anchor>b8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z606_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z606_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z608_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z608_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z608_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z608_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z608_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GRV94M &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GRV94M &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; GRV94M &gt;</type>
      <name>initGRV94M</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GRV94M, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GRV94M_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>GRVBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GRV94M &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GRV94M_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GRV94M &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::GRVBase</name>
    <filename>classThePEG_1_1GRVBase.html</filename>
    <base>ThePEG::PDFBase</base>
    <member kind="function">
      <type></type>
      <name>GRVBase</name>
      <anchor>z610_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>GRVBase</name>
      <anchor>z610_1</anchor>
      <arglist>(const GRVBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~GRVBase</name>
      <anchor>z610_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z612_0</anchor>
      <arglist>(tcPDPtr particle) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z612_1</anchor>
      <arglist>(tcPDPtr p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z612_2</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvl</name>
      <anchor>z612_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>S</name>
      <anchor>z614_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>S2</name>
      <anchor>z614_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>S3</name>
      <anchor>z614_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rootS</name>
      <anchor>z614_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x</name>
      <anchor>z614_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lx</name>
      <anchor>z614_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>z614_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rootx</name>
      <anchor>z614_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(double l, Energy2 scale) const =0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setup</name>
      <anchor>b1</anchor>
      <arglist>(double l, Energy2 scale, Energy mu2, Energy2 lam2) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>valens</name>
      <anchor>b2</anchor>
      <arglist>(double N, double ak, double bk, double a, double b, double c, double d) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>lightsea</name>
      <anchor>b3</anchor>
      <arglist>(double al, double be, double ak, double bk, double a, double b, double c, double d, double e, double es) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>heavysea</name>
      <anchor>b4</anchor>
      <arglist>(double sth, double al, double be, double ak, double ag, double b, double d, double e, double es) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>uv</name>
      <anchor>b5</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>dv</name>
      <anchor>b6</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>del</name>
      <anchor>b7</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>udb</name>
      <anchor>b8</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>sb</name>
      <anchor>b9</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>cb</name>
      <anchor>b10</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>bb</name>
      <anchor>b11</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual double</type>
      <name>gl</name>
      <anchor>b12</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fuv</name>
      <anchor>b13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fdv</name>
      <anchor>b14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fdel</name>
      <anchor>b15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fudb</name>
      <anchor>b16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fsb</name>
      <anchor>b17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fcb</name>
      <anchor>b18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fbb</name>
      <anchor>b19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>double</type>
      <name>fgl</name>
      <anchor>b20</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z616_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z616_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z616_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z616_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z616_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>GRVBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const GRVBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLx</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>thex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theRootx</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>Q2</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theLam2</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theMu2</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theS</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theS2</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theS3</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theRootS</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>uvSave</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>dvSave</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>delSave</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>udbSave</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>sbSave</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>cbSave</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>bbSave</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>glSave</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; GRVBase &gt;</type>
      <name>initGRVBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; GRVBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01GRVBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PDFBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; GRVBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01GRVBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; GRVBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LeptonLeptonPDF</name>
    <filename>classThePEG_1_1LeptonLeptonPDF.html</filename>
    <base>ThePEG::PDFBase</base>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonPDF</name>
      <anchor>z618_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonPDF</name>
      <anchor>z618_1</anchor>
      <arglist>(const LeptonLeptonPDF &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LeptonLeptonPDF</name>
      <anchor>z618_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z620_0</anchor>
      <arglist>(tcPDPtr particle) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z620_1</anchor>
      <arglist>(tcPDPtr p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z620_2</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvl</name>
      <anchor>z620_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvx</name>
      <anchor>z620_4</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double x, double eps, Energy2 particleScale) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>flattenL</name>
      <anchor>z620_5</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, const PDFCuts &amp;, double z, double &amp;jacobian) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z622_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z622_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z624_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z624_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z624_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z624_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z624_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LeptonLeptonPDF &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LeptonLeptonPDF &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; LeptonLeptonPDF &gt;</type>
      <name>initLeptonLeptonPDF</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LeptonLeptonPDF, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LeptonLeptonPDF_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PDFBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LeptonLeptonPDF &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LeptonLeptonPDF_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LeptonLeptonPDF &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LeptonLeptonRemnant</name>
    <filename>classThePEG_1_1LeptonLeptonRemnant.html</filename>
    <base>ThePEG::RemnantHandler</base>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonRemnant</name>
      <anchor>z626_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LeptonLeptonRemnant</name>
      <anchor>z626_1</anchor>
      <arglist>(const LeptonLeptonRemnant &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~LeptonLeptonRemnant</name>
      <anchor>z626_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z628_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z628_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z630_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z630_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z632_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z632_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z634_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z634_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z634_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z634_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z634_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>LeptonLeptonRemnant &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const LeptonLeptonRemnant &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>minX</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>photon</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; LeptonLeptonRemnant &gt;</type>
      <name>initLeptonLeptonRemnant</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; LeptonLeptonRemnant, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01LeptonLeptonRemnant_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RemnantHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; LeptonLeptonRemnant &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01LeptonLeptonRemnant_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; LeptonLeptonRemnant &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::NoPDF</name>
    <filename>classThePEG_1_1NoPDF.html</filename>
    <base>ThePEG::PDFBase</base>
    <member kind="function">
      <type></type>
      <name>NoPDF</name>
      <anchor>z636_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>NoPDF</name>
      <anchor>z636_1</anchor>
      <arglist>(const NoPDF &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~NoPDF</name>
      <anchor>z636_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z638_0</anchor>
      <arglist>(tcPDPtr particle) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z638_1</anchor>
      <arglist>(tcPDPtr particle) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z638_2</anchor>
      <arglist>(tcPDPtr p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z638_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z640_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z640_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z642_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z642_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z642_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z642_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z642_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>NoPDF &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const NoPDF &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; NoPDF &gt;</type>
      <name>initNoPDF</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; NoPDF, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01NoPDF_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>PDFBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; NoPDF &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01NoPDF_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; NoPDF &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::NoRemnants</name>
    <filename>classThePEG_1_1NoRemnants.html</filename>
    <base>ThePEG::RemnantHandler</base>
    <member kind="function">
      <type></type>
      <name>NoRemnants</name>
      <anchor>z644_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>NoRemnants</name>
      <anchor>z644_1</anchor>
      <arglist>(const NoRemnants &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~NoRemnants</name>
      <anchor>z644_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z646_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z646_1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;p) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z648_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z648_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z650_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z650_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z650_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z650_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z650_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>NoRemnants &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const NoRemnants &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; NoRemnants &gt;</type>
      <name>initNoRemnants</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; NoRemnants, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01NoRemnants_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RemnantHandler</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; NoRemnants &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01NoRemnants_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; NoRemnants &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartonBin</name>
    <filename>classThePEG_1_1PartonBin.html</filename>
    <base>ThePEG::Base</base>
    <member kind="typedef">
      <type>vector&lt; PBPtr &gt;</type>
      <name>PBVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBin</name>
      <anchor>z652_0</anchor>
      <arglist>(tcPDPtr p, tPBPtr prev, tcPDPtr pi, tcPDFPtr pdf, const PDFCuts &amp;newCuts)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBin</name>
      <anchor>z652_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBin</name>
      <anchor>z652_2</anchor>
      <arglist>(const PartonBin &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartonBin</name>
      <anchor>z652_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>particle</name>
      <anchor>z654_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPBPtr</type>
      <name>incoming</name>
      <anchor>z654_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PBVector &amp;</type>
      <name>outgoing</name>
      <anchor>z654_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addOutgoing</name>
      <anchor>z654_3</anchor>
      <arglist>(tPBPtr)</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>parton</name>
      <anchor>z654_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>pdf</name>
      <anchor>z654_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcRemHPtr</type>
      <name>remnantHandler</name>
      <anchor>z654_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>nDim</name>
      <anchor>z654_7</anchor>
      <arglist>(bool doscale)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>pdfDim</name>
      <anchor>z654_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>remDim</name>
      <anchor>z654_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>prepare</name>
      <anchor>z656_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>generate</name>
      <anchor>z656_1</anchor>
      <arglist>(const double *r)</arglist>
    </member>
    <member kind="function">
      <type>const PDFCuts &amp;</type>
      <name>cuts</name>
      <anchor>z656_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fullFn</name>
      <anchor>z656_3</anchor>
      <arglist>(Energy2 newScale=-1.0 *GeV2)</arglist>
    </member>
    <member kind="function">
      <type>tPBPtr</type>
      <name>getFirst</name>
      <anchor>z656_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z658_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z658_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartonBin &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PartonBin &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPtr</type>
      <name>theParticle</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPBPtr</type>
      <name>theIncomingBin</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBVector</type>
      <name>theOutgoing</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDPtr</type>
      <name>theParton</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPDFPtr</type>
      <name>thePDF</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cRemHPtr</type>
      <name>theRemnantHandler</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>thePDFDim</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theRemDim</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDFCuts</type>
      <name>theCuts</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartonBin &gt;</type>
      <name>initPartonBin</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartonBin, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartonBin_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartonBin &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartonBin_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartonBin &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartonBinInstance</name>
    <filename>classThePEG_1_1PartonBinInstance.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z660_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z660_1</anchor>
      <arglist>(const PartonBinInstance &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartonBinInstance</name>
      <anchor>z660_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonBinInstance</name>
      <anchor>z660_3</anchor>
      <arglist>(tcPBPtr, tPBIPtr=tPBIPtr())</arglist>
    </member>
    <member kind="function">
      <type>tcPBPtr</type>
      <name>bin</name>
      <anchor>z662_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PartonVector &amp;</type>
      <name>bins</name>
      <anchor>z662_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>particleData</name>
      <anchor>z662_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>partonData</name>
      <anchor>z662_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPBIPtr</type>
      <name>incoming</name>
      <anchor>z662_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPBIPtr</type>
      <name>getFirst</name>
      <anchor>z662_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tcPDFPtr</type>
      <name>pdf</name>
      <anchor>z662_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcRemHPtr</type>
      <name>remnantHandler</name>
      <anchor>z662_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reset</name>
      <anchor>z664_0</anchor>
      <arglist>(double lx=0, Energy2 Q2=0.0 *GeV2)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>prepare</name>
      <anchor>z664_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>generate</name>
      <anchor>z664_2</anchor>
      <arglist>(const double *r)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>fullFn</name>
      <anchor>z664_3</anchor>
      <arglist>(Energy2 newScale=-GeV2)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>jacobian</name>
      <anchor>z664_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>jacobian</name>
      <anchor>z664_5</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>particle</name>
      <anchor>z666_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>particle</name>
      <anchor>z666_1</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>tPPtr</type>
      <name>parton</name>
      <anchor>z666_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>parton</name>
      <anchor>z666_3</anchor>
      <arglist>(tPPtr)</arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>partons</name>
      <anchor>z666_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xi</name>
      <anchor>z666_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eps</name>
      <anchor>z666_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>li</name>
      <anchor>z666_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>li</name>
      <anchor>z666_8</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>x</name>
      <anchor>z666_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>l</name>
      <anchor>z666_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>l</name>
      <anchor>z666_11</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scale</name>
      <anchor>z666_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>scale</name>
      <anchor>z666_13</anchor>
      <arglist>(Energy2)</arglist>
    </member>
    <member kind="function">
      <type>const TransverseMomentum &amp;</type>
      <name>kT</name>
      <anchor>z666_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>remnantWeight</name>
      <anchor>z666_15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>remnantWeight</name>
      <anchor>z666_16</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>const PVector &amp;</type>
      <name>remnants</name>
      <anchor>z666_17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>remnants</name>
      <anchor>z666_18</anchor>
      <arglist>(const PVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>tRemIPtr</type>
      <name>remnantInfo</name>
      <anchor>z666_19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>remnantInfo</name>
      <anchor>z666_20</anchor>
      <arglist>(tRemIPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z668_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z668_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartonBinInstance &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PartonBinInstance &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>cPBPtr</type>
      <name>theBin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PartonVector</type>
      <name>theBins</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PBIPtr</type>
      <name>theIncoming</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theJacobian</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPtr</type>
      <name>theParticle</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PPtr</type>
      <name>theParton</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PVector</type>
      <name>thePartons</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theXi</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEps</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theLi</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theX</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theL</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theScale</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>TransverseMomentum</type>
      <name>theKT</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theRemnantWeight</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PVector</type>
      <name>theRemnants</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RemIPtr</type>
      <name>theRemInfo</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartonBinInstance &gt;</type>
      <name>initPartonBinInstance</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemInfoBase</name>
    <filename>structThePEG_1_1RemInfoBase.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RemInfoBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartonBinInstance, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartonBinInstance_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Base</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartonBinInstance &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartonBinInstance_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartonBinInstance &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartonExtractor</name>
    <filename>classThePEG_1_1PartonExtractor.html</filename>
    <base>ThePEG::HandlerBase</base>
    <base>ThePEG::LastXCombInfo&lt;&gt;</base>
    <member kind="typedef">
      <type>map&lt; cPPtr, PBIPtr &gt;</type>
      <name>PartonBinInstanceMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>maxTries</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonExtractor</name>
      <anchor>z670_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartonExtractor</name>
      <anchor>z670_1</anchor>
      <arglist>(const PartonExtractor &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartonExtractor</name>
      <anchor>z670_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z672_0</anchor>
      <arglist>(const cPDPair &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PartonPairVec</type>
      <name>getPartons</name>
      <anchor>z672_1</anchor>
      <arglist>(Energy maxEnergy, const cPDPair &amp;, const KinematicalCuts &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>newScale</name>
      <anchor>z672_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>colourConnect</name>
      <anchor>z672_3</anchor>
      <arglist>(tPPtr particle, tPPtr parton, const tPVector &amp;remnants) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PBIPair</type>
      <name>newRemnants</name>
      <anchor>z672_4</anchor>
      <arglist>(tPPair oldp, tPPair newp, tStepPtr step)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual pair&lt; int, int &gt;</type>
      <name>nDims</name>
      <anchor>z672_5</anchor>
      <arglist>(const PBPair &amp;pbins)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>prepare</name>
      <anchor>z672_6</anchor>
      <arglist>(const PBIPair &amp;pbins)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>generateL</name>
      <anchor>z672_7</anchor>
      <arglist>(const PBIPair &amp;pbins, const double *r1, const double *r2)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>generateSHat</name>
      <anchor>z672_8</anchor>
      <arglist>(Energy2 s, const PBIPair &amp;pbins, const double *r1, const double *r2)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>fullFn</name>
      <anchor>z672_9</anchor>
      <arglist>(const PBIPair &amp;pbins, Energy2 scale)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>construct</name>
      <anchor>z672_10</anchor>
      <arglist>(const PBIPair &amp;pbins, tStepPtr step)</arglist>
    </member>
    <member kind="function">
      <type>const PartonBinInstanceMap &amp;</type>
      <name>partonBinInstances</name>
      <anchor>z674_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPBIPtr</type>
      <name>partonBinInstance</name>
      <anchor>z674_1</anchor>
      <arglist>(tcPPtr) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z676_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z676_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>generateL</name>
      <anchor>b0</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>generate</name>
      <anchor>b1</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, const Lorentz5Momentum &amp;first)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>fullFn</name>
      <anchor>b2</anchor>
      <arglist>(const PartonBinInstance &amp;pb)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>construct</name>
      <anchor>b3</anchor>
      <arglist>(PartonBinInstance &amp;pb, tStepPtr step)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PBIPtr</type>
      <name>newRemnants</name>
      <anchor>b4</anchor>
      <arglist>(tPBIPtr oldpb, tPPtr newp)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addNewRemnants</name>
      <anchor>b5</anchor>
      <arglist>(tPBIPtr oldpb, tPBIPtr newpb, tStepPtr step)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>addPartons</name>
      <anchor>b6</anchor>
      <arglist>(tPBPtr incoming, const PDFCuts &amp;cuts, PartonVector &amp;pbins) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tcPDFPtr</type>
      <name>getPDF</name>
      <anchor>b7</anchor>
      <arglist>(tcPDPtr particle) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tcPDFPtr</type>
      <name>noPDF</name>
      <anchor>b8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>PartonBinInstanceMap &amp;</type>
      <name>partonBinInstances</name>
      <anchor>b9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>findConnect</name>
      <anchor>b10</anchor>
      <arglist>(tColinePtr line, tPPtr parton, bool anti, Iterator first, Iterator last) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z678_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z678_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z680_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z680_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z680_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z680_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z680_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>select</name>
      <anchor>d0</anchor>
      <arglist>(tXCombPtr newXComb)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartonExtractor &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const PartonExtractor &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PartonBinInstanceMap</type>
      <name>thePartonBinInstances</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; PDFPtr &gt;</type>
      <name>theSpecialDensities</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDFPtr</type>
      <name>theNoPDF</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theMaxTries</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>flatSHatY</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartonExtractor &gt;</type>
      <name>initPartonExtractor</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartonExtractor, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartonExtractor_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartonExtractor &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartonExtractor_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartonExtractor &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemColException</name>
    <filename>structThePEG_1_1RemColException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>RemColException</name>
      <anchor>a0</anchor>
      <arglist>(const PartonExtractor &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDF</name>
    <filename>classThePEG_1_1PDF.html</filename>
    <member kind="function">
      <type></type>
      <name>PDF</name>
      <anchor>z682_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDF</name>
      <anchor>z682_1</anchor>
      <arglist>(const PDF &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDF</name>
      <anchor>z682_2</anchor>
      <arglist>(tcPBIPtr)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PDF</name>
      <anchor>z682_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PDF &amp;</type>
      <name>operator=</name>
      <anchor>z682_4</anchor>
      <arglist>(const PDF &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfl</name>
      <anchor>z684_0</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfx</name>
      <anchor>z684_1</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvl</name>
      <anchor>z684_2</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvx</name>
      <anchor>z684_3</anchor>
      <arglist>(tcPPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfl</name>
      <anchor>z684_4</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfx</name>
      <anchor>z684_5</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvl</name>
      <anchor>z684_6</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xfvx</name>
      <anchor>z684_7</anchor>
      <arglist>(tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcPDFPtr</type>
      <name>thePDF</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tcPDPtr</type>
      <name>theParticle</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDFBase</name>
    <filename>classThePEG_1_1PDFBase.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="enumeration">
      <name>RangeException</name>
      <anchor>z692_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rangeZero</name>
      <anchor>z692_0x1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rangeThrow</name>
      <anchor>z692_0x2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z692_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z692_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z692_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z692_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z692_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RemHPtr</type>
      <name>theRemnantHandler</name>
      <anchor>z692_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>RangeException</type>
      <name>rangeException</name>
      <anchor>z692_7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>PDFBase &amp;</type>
      <name>operator=</name>
      <anchor>z692_8</anchor>
      <arglist>(const PDFBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; PDFBase &gt;</type>
      <name>initPDFBase</name>
      <anchor>z692_9</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>tcRemHPtr</type>
      <name>remnantHandler</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFBase</name>
      <anchor>z686_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFBase</name>
      <anchor>z686_1</anchor>
      <arglist>(const PDFBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PDFBase</name>
      <anchor>z686_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>canHandleParticle</name>
      <anchor>z688_0</anchor>
      <arglist>(tcPDPtr particle) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z688_1</anchor>
      <arglist>(tcPDPtr particle) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual cPDVector</type>
      <name>partons</name>
      <anchor>z688_2</anchor>
      <arglist>(tcPDPtr particle) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfl</name>
      <anchor>z688_3</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfx</name>
      <anchor>z688_4</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvl</name>
      <anchor>z688_5</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double l, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>xfvx</name>
      <anchor>z688_6</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, Energy2 partonScale, double x, double eps=0.0, Energy2 particleScale=0.0 *GeV2) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>flattenL</name>
      <anchor>z688_7</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, const PDFCuts &amp;cut, double z, double &amp;jacobian) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy2</type>
      <name>flattenScale</name>
      <anchor>z688_8</anchor>
      <arglist>(tcPDPtr particle, tcPDPtr parton, const PDFCuts &amp;cut, double l, double z, Energy2 &amp;jacobian) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z690_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z690_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PDFBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PDFBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PDFBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PDFBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PDFBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemnantHandlerCantHandle</name>
    <filename>structThePEG_1_1RemnantHandlerCantHandle.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RemnantHandlerCantHandle</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PDFWrongParticle</name>
    <filename>structThePEG_1_1PDFWrongParticle.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>PDFWrongParticle</name>
      <anchor>a0</anchor>
      <arglist>(string p, string pdf, string mess)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PDFRange</name>
    <filename>structThePEG_1_1PDFRange.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>PDFRange</name>
      <anchor>a0</anchor>
      <arglist>(string pdf, string var, double val, double lim)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDFCuts</name>
    <filename>classThePEG_1_1PDFCuts.html</filename>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z694_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z694_1</anchor>
      <arglist>(const PDFCuts &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PDFCuts</name>
      <anchor>z694_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z694_3</anchor>
      <arglist>(const Interval&lt; double &gt; &amp;newL, const SInterval &amp;newScale, const Energy2 &amp;newSMax)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z694_4</anchor>
      <arglist>(const KinematicalCuts &amp;, bool first, const SInterval &amp;S, const SInterval &amp;sHat)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PDFCuts</name>
      <anchor>z694_5</anchor>
      <arglist>(const KinematicalCuts &amp;, bool first, Energy maxEnergy)</arglist>
    </member>
    <member kind="function">
      <type>PDFCuts &amp;</type>
      <name>operator=</name>
      <anchor>z694_6</anchor>
      <arglist>(const PDFCuts &amp;)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lMin</name>
      <anchor>z696_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lMax</name>
      <anchor>z696_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xMin</name>
      <anchor>z696_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>xMax</name>
      <anchor>z696_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMin</name>
      <anchor>z696_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>z696_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMax</name>
      <anchor>z696_6</anchor>
      <arglist>(double x) const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>scaleMaxL</name>
      <anchor>z696_7</anchor>
      <arglist>(double l) const</arglist>
    </member>
    <member kind="function">
      <type>Energy2</type>
      <name>sMax</name>
      <anchor>z696_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Interval&lt; double &gt;</type>
      <name>theL</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SInterval</type>
      <name>theScale</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy2</type>
      <name>theSMax</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RemnantHandler</name>
    <filename>classThePEG_1_1RemnantHandler.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type>bool</type>
      <name>multiCapable</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RemnantHandler</name>
      <anchor>z698_0</anchor>
      <arglist>(bool multi=false)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RemnantHandler</name>
      <anchor>z698_1</anchor>
      <arglist>(const RemnantHandler &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RemnantHandler</name>
      <anchor>z698_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>canHandle</name>
      <anchor>z700_0</anchor>
      <arglist>(tcPDPtr particle, const cPDVector &amp;partons) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>nDim</name>
      <anchor>z700_1</anchor>
      <arglist>(const PartonBin &amp;pb, bool doScale) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Lorentz5Momentum</type>
      <name>generate</name>
      <anchor>z700_2</anchor>
      <arglist>(PartonBinInstance &amp;pb, const double *r, Energy2 scale, const LorentzMomentum &amp;parent) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>createRemnants</name>
      <anchor>z700_3</anchor>
      <arglist>(PartonBinInstance &amp;pb) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>recreateRemnants</name>
      <anchor>z700_4</anchor>
      <arglist>(PartonBinInstance &amp;pb, tPPtr oldp, tPPtr newp, double newl, Energy2 scale, const LorentzMomentum &amp;p, const PVector &amp;prev=PVector()) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z702_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z702_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z704_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z704_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z704_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z704_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z704_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RemnantHandler &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const RemnantHandler &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isMultiCapable</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; RemnantHandler &gt;</type>
      <name>initRemnantHandler</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; RemnantHandler, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01RemnantHandler_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; RemnantHandler &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01RemnantHandler_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; RemnantHandler &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RemnantHandlerException</name>
    <filename>structThePEG_1_1RemnantHandlerException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>RemnantHandlerException</name>
      <anchor>a0</anchor>
      <arglist>(string p0, string p, string r, string mess)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::BreitWignerMass</name>
    <filename>classThePEG_1_1BreitWignerMass.html</filename>
    <base>ThePEG::MassGenerator</base>
    <member kind="function">
      <type></type>
      <name>BreitWignerMass</name>
      <anchor>z706_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>BreitWignerMass</name>
      <anchor>z706_1</anchor>
      <arglist>(const BreitWignerMass &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~BreitWignerMass</name>
      <anchor>z706_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z708_0</anchor>
      <arglist>(const ParticleData &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>mass</name>
      <anchor>z708_1</anchor>
      <arglist>(const ParticleData &amp;) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z710_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z710_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z712_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z712_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z712_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z712_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z712_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>BreitWignerMass &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const BreitWignerMass &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; BreitWignerMass &gt;</type>
      <name>initBreitWignerMass</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; BreitWignerMass, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01BreitWignerMass_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>MassGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; BreitWignerMass &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01BreitWignerMass_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; BreitWignerMass &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ColourPairDecayer</name>
    <filename>classThePEG_1_1ColourPairDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type>bool</type>
      <name>shower</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourPairDecayer</name>
      <anchor>z714_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ColourPairDecayer</name>
      <anchor>z714_1</anchor>
      <arglist>(const ColourPairDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ColourPairDecayer</name>
      <anchor>z714_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z716_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>getChildren</name>
      <anchor>z716_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z718_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z718_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z720_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z720_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z722_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z722_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z722_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z722_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z722_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z722_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ColourPairDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ColourPairDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>doShower</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ColourPairDecayer &gt;</type>
      <name>initColourPairDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ColourPairDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ColourPairDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ColourPairDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ColourPairDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ColourPairDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::AndMatcher</name>
    <filename>structThePEG_1_1AndMatcher.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>AndMatcher&lt; typename T1::CC, typename T2::CC &gt;</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::OrMatcher</name>
    <filename>structThePEG_1_1OrMatcher.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>OrMatcher&lt; typename T1::CC, typename T2::CC &gt;</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::NotMatcher</name>
    <filename>structThePEG_1_1NotMatcher.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>NotMatcher&lt; typename T::CC &gt;</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ConstituentParticleData</name>
    <filename>classThePEG_1_1ConstituentParticleData.html</filename>
    <base virtualness="virtual">ThePEG::ParticleData</base>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>constituentMass</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstituentParticleData</name>
      <anchor>z724_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstituentParticleData</name>
      <anchor>z724_1</anchor>
      <arglist>(const ConstituentParticleData &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ConstituentParticleData</name>
      <anchor>z724_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z728_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z728_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>Create</name>
      <anchor>z726_0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPair</type>
      <name>Create</name>
      <anchor>z726_1</anchor>
      <arglist>(long newId, string newPDGName, string newAntiPDGName)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ConstituentParticleData</name>
      <anchor>b0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b1</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual PDPtr</type>
      <name>pdclone</name>
      <anchor>b2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z730_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z730_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z730_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z730_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z730_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setConstituentMass</name>
      <anchor>d0</anchor>
      <arglist>(Energy m)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defConstituentMass</name>
      <anchor>d1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxConstituentMass</name>
      <anchor>d2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ConstituentParticleData &amp;</type>
      <name>operator=</name>
      <anchor>d3</anchor>
      <arglist>(const ConstituentParticleData &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theConstituentMass</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefaultConstituentMass</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ConstituentParticleData &gt;</type>
      <name>initConstituentParticleData</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ConstituentParticleData, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ConstituentParticleData_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>ParticleData</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ConstituentParticleData &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ConstituentParticleData_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ConstituentParticleData &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DalitzDecayer</name>
    <filename>classThePEG_1_1DalitzDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>DalitzDecayer</name>
      <anchor>z732_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DalitzDecayer</name>
      <anchor>z732_1</anchor>
      <arglist>(const DalitzDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DalitzDecayer</name>
      <anchor>z732_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z734_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z734_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z736_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z736_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z738_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z738_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z740_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z740_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z740_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z740_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z740_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z740_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DalitzDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DalitzDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDPtr</type>
      <name>rho</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; DalitzDecayer &gt;</type>
      <name>initDalitzDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DalitzDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DalitzDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DalitzDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DalitzDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DalitzDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Decayer</name>
    <filename>classThePEG_1_1Decayer.html</filename>
    <base>ThePEG::HandlerBase</base>
    <member kind="function">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>amplitude</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Decayer</name>
      <anchor>z742_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Decayer</name>
      <anchor>z742_1</anchor>
      <arglist>(const Decayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Decayer</name>
      <anchor>z742_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z744_0</anchor>
      <arglist>(const DecayMode &amp;dm) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z744_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z744_2</anchor>
      <arglist>(const DecayMode &amp;dm, const ParticleData &amp;pd, double oldbrat) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z744_3</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p, double oldbrat) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>getChildren</name>
      <anchor>z744_4</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>finalBoost</name>
      <anchor>z744_5</anchor>
      <arglist>(const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setScales</name>
      <anchor>z744_6</anchor>
      <arglist>(const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z746_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z746_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Decayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Decayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Ptr&lt; Amplitude &gt;::pointer</type>
      <name>theAmplitude</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; Decayer &gt;</type>
      <name>initDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Decayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Decayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>HandlerBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Decayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Decayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Decayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecayMode</name>
    <filename>classThePEG_1_1DecayMode.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>vector&lt; tcDMPtr &gt;</type>
      <name>ModeVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; tPDPair &gt;</type>
      <name>LinkVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DMPtr</type>
      <name>clone</name>
      <anchor>a0</anchor>
      <arglist>(tPDPtr pd) const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>tag</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcPDPtr</type>
      <name>parent</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleMSet &amp;</type>
      <name>products</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const PDVector &amp;</type>
      <name>orderedProducts</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PVector</type>
      <name>produceProducts</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ModeMSet &amp;</type>
      <name>cascadeProducts</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const MatcherMSet &amp;</type>
      <name>productMatchers</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPMPtr</type>
      <name>wildProductMatcher</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleMSet &amp;</type>
      <name>excluded</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>brat</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>brat</name>
      <anchor>a11</anchor>
      <arglist>(const Particle &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>tDecayerPtr</type>
      <name>decayer</name>
      <anchor>a12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>includes</name>
      <anchor>a13</anchor>
      <arglist>(const DecayMode &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>tDMPtr</type>
      <name>CC</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a15</anchor>
      <arglist>(const DecayMode &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>const LinkVector &amp;</type>
      <name>links</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ModeVector &amp;</type>
      <name>overlap</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>synchronize</name>
      <anchor>a18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayMode</name>
      <anchor>z748_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DecayMode</name>
      <anchor>z748_1</anchor>
      <arglist>(const DecayMode &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~DecayMode</name>
      <anchor>z748_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z750_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z750_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>DMPtr</type>
      <name>constructDecayMode</name>
      <anchor>e0</anchor>
      <arglist>(string &amp;tag)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>parent</name>
      <anchor>b0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>brat</name>
      <anchor>b1</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>switchOn</name>
      <anchor>b2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>switchOff</name>
      <anchor>b3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>decayer</name>
      <anchor>b4</anchor>
      <arglist>(tDecayerPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addProduct</name>
      <anchor>b5</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addLink</name>
      <anchor>b6</anchor>
      <arglist>(tPDPtr a, tPDPtr b)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addCascadeProduct</name>
      <anchor>b7</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addProductMatcher</name>
      <anchor>b8</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setWildMatcher</name>
      <anchor>b9</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addExcluded</name>
      <anchor>b10</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>DecayMode</name>
      <anchor>b11</anchor>
      <arglist>(tPDPtr newParticle, double newBrat, bool newOn)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>DMPtr</type>
      <name>dmclone</name>
      <anchor>b12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b13</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ParticleMSet &amp;</type>
      <name>products</name>
      <anchor>b14</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ModeMSet &amp;</type>
      <name>cascadeProducts</name>
      <anchor>b15</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>MatcherMSet &amp;</type>
      <name>productMatchers</name>
      <anchor>b16</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>tPMPtr &amp;</type>
      <name>wildProductMatcher</name>
      <anchor>b17</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ParticleMSet &amp;</type>
      <name>excluded</name>
      <anchor>b18</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z752_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z752_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z752_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z752_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z752_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z754_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z754_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DMPtr</type>
      <name>Create</name>
      <anchor>f0</anchor>
      <arglist>(tPDPtr newParent, double newBrat=0.0, bool newOn=false)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>addOverlap</name>
      <anchor>d0</anchor>
      <arglist>(tcDMPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>resetOverlap</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>compareId</name>
      <anchor>d2</anchor>
      <arglist>(const ParticleMSet &amp;, const ParticleMSet &amp;) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleMSet::const_iterator</type>
      <name>findId</name>
      <anchor>d3</anchor>
      <arglist>(const ParticleMSet &amp;, const ParticleData &amp;) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>makeTag</name>
      <anchor>d4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>resetTag</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setOn</name>
      <anchor>d6</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getOn</name>
      <anchor>d7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setDecayer</name>
      <anchor>d8</anchor>
      <arglist>(DecayerPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DecayMode &amp;</type>
      <name>operator=</name>
      <anchor>d9</anchor>
      <arglist>(const DecayMode &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theTag</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theBrat</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isOn</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPDPtr</type>
      <name>theParent</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMSet</type>
      <name>theProducts</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDVector</type>
      <name>theOrderedProducts</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ModeMSet</type>
      <name>theCascadeProducts</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MatcherMSet</type>
      <name>theMatchers</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPMPtr</type>
      <name>theWildMatcher</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMSet</type>
      <name>theExcluded</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ModeVector</type>
      <name>theOverlap</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DecayerPtr</type>
      <name>theDecayer</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tDMPtr</type>
      <name>theAntiPartner</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>LinkVector</type>
      <name>theLinks</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; DecayMode &gt;</type>
      <name>initDecayMode</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DecayMode, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DecayMode_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DecayMode &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DecayMode_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DecayMode &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecModNoAccept</name>
    <filename>classThePEG_1_1DecModNoAccept.html</filename>
    <base>ThePEG::UpdateException</base>
    <member kind="function">
      <type></type>
      <name>DecModNoAccept</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecModSetupNoAccept</name>
    <filename>classThePEG_1_1DecModSetupNoAccept.html</filename>
    <base>ThePEG::SetupException</base>
    <member kind="function">
      <type></type>
      <name>DecModSetupNoAccept</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DecModRebind</name>
    <filename>classThePEG_1_1DecModRebind.html</filename>
    <base>ThePEG::RebindException</base>
    <member kind="function">
      <type></type>
      <name>DecModRebind</name>
      <anchor>a0</anchor>
      <arglist>(string, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DummyDecayer</name>
    <filename>classThePEG_1_1DummyDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>DummyDecayer</name>
      <anchor>z756_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DummyDecayer</name>
      <anchor>z756_1</anchor>
      <arglist>(const DummyDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~DummyDecayer</name>
      <anchor>z756_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z758_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z758_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z758_2</anchor>
      <arglist>(const DecayMode &amp;, const ParticleData &amp;, double) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>z758_3</anchor>
      <arglist>(const DecayMode &amp;, const Particle &amp;, double) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z760_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z760_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z762_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z762_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z762_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z762_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z762_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z762_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>DummyDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const DummyDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; DummyDecayer &gt;</type>
      <name>initDummyDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; DummyDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01DummyDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; DummyDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01DummyDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; DummyDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FlatDecayer</name>
    <filename>classThePEG_1_1FlatDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>FlatDecayer</name>
      <anchor>z764_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FlatDecayer</name>
      <anchor>z764_1</anchor>
      <arglist>(const FlatDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FlatDecayer</name>
      <anchor>z764_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z766_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z766_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z766_2</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z768_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z768_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z770_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z770_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z770_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z770_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z770_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z770_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FlatDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FlatDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; FlatDecayer &gt;</type>
      <name>initFlatDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FlatDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FlatDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FlatDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FlatDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FlatDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MassGenerator</name>
    <filename>classThePEG_1_1MassGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>MassGenerator</name>
      <anchor>z772_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MassGenerator</name>
      <anchor>z772_1</anchor>
      <arglist>(const MassGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MassGenerator</name>
      <anchor>z772_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z774_0</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy</type>
      <name>mass</name>
      <anchor>z774_1</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z776_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z776_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z776_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z776_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z776_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MassGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MassGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; MassGenerator &gt;</type>
      <name>initMassGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MassGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MassGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MassGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MassGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MassGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Matcher</name>
    <filename>classThePEG_1_1Matcher.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::MatcherBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual PMPtr</type>
      <name>pmclone</name>
      <anchor>z780_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PMPtr</type>
      <name>Create</name>
      <anchor>z780_1</anchor>
      <arglist>(const string &amp;newName, string antiName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>z784_0</anchor>
      <arglist>(const ParticleData &amp;pd) const</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>z784_1</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matcher</name>
      <anchor>z778_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Matcher</name>
      <anchor>z778_1</anchor>
      <arglist>(const Matcher&lt; T &gt; &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Matcher</name>
      <anchor>z778_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setCC</name>
      <anchor>b0</anchor>
      <arglist>(tPMPtr, tPMPtr) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z782_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z782_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; Matcher&lt; T &gt; &gt;</type>
      <name>initMatcher</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MatcherType</name>
    <filename>structThePEG_1_1MatcherType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Matcher&lt; T &gt;, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Matcher_3_01T_01_4_00_011_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>MatcherBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Matcher&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Matcher_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsBase&lt; Matcher&lt; T &gt; &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MatcherBase</name>
    <filename>classThePEG_1_1MatcherBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>tPMPtr</type>
      <name>CC</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MatcherBase</name>
      <anchor>z786_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MatcherBase</name>
      <anchor>z786_1</anchor>
      <arglist>(const MatcherBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MatcherBase</name>
      <anchor>z786_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>check</name>
      <anchor>z788_0</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual PMPtr</type>
      <name>pmclone</name>
      <anchor>z788_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>checkp</name>
      <anchor>z790_0</anchor>
      <arglist>(const Particle &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>matches</name>
      <anchor>z790_1</anchor>
      <arglist>(const ParticleData &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>matches</name>
      <anchor>z790_2</anchor>
      <arglist>(const Particle &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>matches</name>
      <anchor>z790_3</anchor>
      <arglist>(const MatcherBase &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleDataSet &amp;</type>
      <name>particles</name>
      <anchor>z792_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const MatcherSet &amp;</type>
      <name>matchers</name>
      <anchor>z792_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>minMass</name>
      <anchor>z794_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>maxMass</name>
      <anchor>z794_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mass</name>
      <anchor>z794_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>z794_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>cTau</name>
      <anchor>z794_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Charge</type>
      <name>iCharge</name>
      <anchor>z794_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>charged</name>
      <anchor>z794_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>positive</name>
      <anchor>z794_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>negative</name>
      <anchor>z794_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>z794_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Color</type>
      <name>iColor</name>
      <anchor>z794_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>colored</name>
      <anchor>z794_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>stable</name>
      <anchor>z794_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z796_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z796_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addPIfMatch</name>
      <anchor>b0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMIfMatch</name>
      <anchor>b1</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addPIfMatch</name>
      <anchor>b2</anchor>
      <arglist>(Iterator, Iterator)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addPIfMatchFrom</name>
      <anchor>b3</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMIfMatch</name>
      <anchor>b4</anchor>
      <arglist>(Iterator, Iterator)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>addMIfMatchFrom</name>
      <anchor>b5</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>clear</name>
      <anchor>b6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setCC</name>
      <anchor>b7</anchor>
      <arglist>(tPMPtr, tPMPtr) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z798_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z798_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z798_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z798_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MatcherBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MatcherBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleDataSet</type>
      <name>matchingParticles</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MatcherSet</type>
      <name>matchingMatchers</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMaxMass</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMinMass</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>commonMass</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>commonWidth</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Length</type>
      <name>commonCTau</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Charge</type>
      <name>commonCharge</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>commonSpin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Color</type>
      <name>commonColor</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>commonStable</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPMPtr</type>
      <name>theAntiPartner</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; MatcherBase &gt;</type>
      <name>initMatcherBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MatcherBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MatcherBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MatcherBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MatcherBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MatcherBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::OmegaPhi3PiDecayer</name>
    <filename>classThePEG_1_1OmegaPhi3PiDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type></type>
      <name>OmegaPhi3PiDecayer</name>
      <anchor>z800_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OmegaPhi3PiDecayer</name>
      <anchor>z800_1</anchor>
      <arglist>(const OmegaPhi3PiDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~OmegaPhi3PiDecayer</name>
      <anchor>z800_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z802_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z802_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z804_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z804_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z806_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z806_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z808_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z808_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z808_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z808_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z808_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z808_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>OmegaPhi3PiDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const OmegaPhi3PiDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>margin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; OmegaPhi3PiDecayer &gt;</type>
      <name>initOmegaPhi3PiDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; OmegaPhi3PiDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01OmegaPhi3PiDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; OmegaPhi3PiDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01OmegaPhi3PiDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; OmegaPhi3PiDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Onium3GDecayer</name>
    <filename>classThePEG_1_1Onium3GDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type>bool</type>
      <name>shower</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>minGGMass</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Onium3GDecayer</name>
      <anchor>z810_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Onium3GDecayer</name>
      <anchor>z810_1</anchor>
      <arglist>(const Onium3GDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Onium3GDecayer</name>
      <anchor>z810_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z812_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z812_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z812_2</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z814_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z814_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z816_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z816_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z818_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z818_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z818_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z818_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z818_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z818_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Onium3GDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Onium3GDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>doShower</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMinGGMass</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Onium3GDecayer &gt;</type>
      <name>initOnium3GDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Onium3GDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Onium3GDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Onium3GDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Onium3GDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Onium3GDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ParticleData</name>
    <filename>classThePEG_1_1ParticleData.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>Selector&lt; tDMPtr &gt;</type>
      <name>DecaySelector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>mass</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>massMax</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>massMin</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>constituentMass</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>a4</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthCut</name>
      <anchor>a6</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthCut</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthUpCut</name>
      <anchor>a8</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthUpCut</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthLoCut</name>
      <anchor>a10</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>widthLoCut</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>cTau</name>
      <anchor>a12</anchor>
      <arglist>(Length)</arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>cTau</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Charge</type>
      <name>iCharge</name>
      <anchor>a14</anchor>
      <arglist>(PDT::Charge)</arglist>
    </member>
    <member kind="function">
      <type>Charge</type>
      <name>charge</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Charge</type>
      <name>iCharge</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>charged</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>positive</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>negative</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>a20</anchor>
      <arglist>(PDT::Spin)</arglist>
    </member>
    <member kind="function">
      <type>AngularMomentum</type>
      <name>spin</name>
      <anchor>a21</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Spin</type>
      <name>iSpin</name>
      <anchor>a22</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Color</type>
      <name>iColor</name>
      <anchor>a23</anchor>
      <arglist>(PDT::Color)</arglist>
    </member>
    <member kind="function">
      <type>PDT::Colour</type>
      <name>iColour</name>
      <anchor>a24</anchor>
      <arglist>(PDT::Colour)</arglist>
    </member>
    <member kind="function">
      <type>PDT::Color</type>
      <name>iColor</name>
      <anchor>a25</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PDT::Colour</type>
      <name>iColour</name>
      <anchor>a26</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>colored</name>
      <anchor>a27</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>coloured</name>
      <anchor>a28</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasColour</name>
      <anchor>a29</anchor>
      <arglist>(bool anti=false) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>hasAntiColour</name>
      <anchor>a30</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stable</name>
      <anchor>a31</anchor>
      <arglist>(bool stab)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>stable</name>
      <anchor>a32</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPDPtr</type>
      <name>CC</name>
      <anchor>a33</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>synchronized</name>
      <anchor>a34</anchor>
      <arglist>(bool sync)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>synchronized</name>
      <anchor>a35</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>synchronize</name>
      <anchor>a36</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>massGenerator</name>
      <anchor>a37</anchor>
      <arglist>(tMassGenPtr)</arglist>
    </member>
    <member kind="function">
      <type>tMassGenPtr</type>
      <name>massGenerator</name>
      <anchor>a38</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>widthGenerator</name>
      <anchor>a39</anchor>
      <arglist>(tWidthGeneratorPtr)</arglist>
    </member>
    <member kind="function">
      <type>tWidthGeneratorPtr</type>
      <name>widthGenerator</name>
      <anchor>a40</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleData</name>
      <anchor>z820_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ParticleData</name>
      <anchor>z820_1</anchor>
      <arglist>(const ParticleData &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ParticleData</name>
      <anchor>z820_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>id</name>
      <anchor>z824_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>PDGName</name>
      <anchor>z824_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>genericName</name>
      <anchor>z824_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z826_0</anchor>
      <arglist>(const Lorentz5Momentum &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z826_1</anchor>
      <arglist>(const LorentzMomentum &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z826_2</anchor>
      <arglist>(const LorentzMomentum &amp;, Energy m) const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z826_3</anchor>
      <arglist>(const Momentum3 &amp;pp=Momentum3()) const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z826_4</anchor>
      <arglist>(Energy m, const Momentum3 &amp;pp=Momentum3()) const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>produceParticle</name>
      <anchor>z826_5</anchor>
      <arglist>(Energy plus, Energy minus, Energy px, Energy py) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>generateMass</name>
      <anchor>z826_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>generateWidth</name>
      <anchor>z826_7</anchor>
      <arglist>(Energy mass) const</arglist>
    </member>
    <member kind="function">
      <type>Length</type>
      <name>generateLifeTime</name>
      <anchor>z826_8</anchor>
      <arglist>(Energy mass, Energy width) const</arglist>
    </member>
    <member kind="function">
      <type>const DecaySelector &amp;</type>
      <name>decaySelector</name>
      <anchor>z828_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tDMPtr</type>
      <name>selectMode</name>
      <anchor>z828_1</anchor>
      <arglist>(Particle &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z830_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z830_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>Create</name>
      <anchor>z822_0</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPair</type>
      <name>Create</name>
      <anchor>z822_1</anchor>
      <arglist>(long newId, string newPDGName, string newAntiPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual PDPtr</type>
      <name>pdclone</name>
      <anchor>b0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ParticleData</name>
      <anchor>b1</anchor>
      <arglist>(long newId, string newPDGName)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b2</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z832_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z832_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z834_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z834_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z834_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z834_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z834_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>antiSetup</name>
      <anchor>f0</anchor>
      <arglist>(const PDPair &amp;pap)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>addDecayMode</name>
      <anchor>d0</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>removeDecayMode</name>
      <anchor>d1</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMass</name>
      <anchor>d2</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defMass</name>
      <anchor>d3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxMass</name>
      <anchor>d4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setWidth</name>
      <anchor>d5</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getWidth</name>
      <anchor>d6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defWidth</name>
      <anchor>d7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxWidth</name>
      <anchor>d8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setCut</name>
      <anchor>d9</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getCut</name>
      <anchor>d10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>defCut</name>
      <anchor>d11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>maxCut</name>
      <anchor>d12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setUpCut</name>
      <anchor>d13</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getUpCut</name>
      <anchor>d14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setLoCut</name>
      <anchor>d15</anchor>
      <arglist>(Energy)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Energy</type>
      <name>getLoCut</name>
      <anchor>d16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setCTau</name>
      <anchor>d17</anchor>
      <arglist>(Length)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Length</type>
      <name>getCTau</name>
      <anchor>d18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Length</type>
      <name>defCTau</name>
      <anchor>d19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Length</type>
      <name>maxCTau</name>
      <anchor>d20</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setStable</name>
      <anchor>d21</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getStable</name>
      <anchor>d22</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setSync</name>
      <anchor>d23</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getSync</name>
      <anchor>d24</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>doSync</name>
      <anchor>d25</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setMassGenerator</name>
      <anchor>d26</anchor>
      <arglist>(MassGenPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setWidthGenerator</name>
      <anchor>d27</anchor>
      <arglist>(WidthGeneratorPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setCharge</name>
      <anchor>d28</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>ssetCharge</name>
      <anchor>d29</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>getCharge</name>
      <anchor>d30</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>defCharge</name>
      <anchor>d31</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setSpin</name>
      <anchor>d32</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>getSpin</name>
      <anchor>d33</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>int</type>
      <name>defSpin</name>
      <anchor>d34</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setColour</name>
      <anchor>d35</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>getColour</name>
      <anchor>d36</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>long</type>
      <name>defColour</name>
      <anchor>d37</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insDecayModes</name>
      <anchor>d38</anchor>
      <arglist>(DMPtr dm, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delDecayModes</name>
      <anchor>d39</anchor>
      <arglist>(int i)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; DMPtr &gt;</type>
      <name>getDecayModes</name>
      <anchor>d40</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theId</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>thePDGName</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theMass</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theWidth</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theWidthUpCut</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theWidthLoCut</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Length</type>
      <name>theCTau</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Charge</type>
      <name>theCharge</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>theSpin</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Color</type>
      <name>theColor</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MassGenPtr</type>
      <name>theMassGenerator</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isStable</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DecaySelector</type>
      <name>theDecaySelector</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DecaySet</type>
      <name>theDecayModes</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WidthGeneratorPtr</type>
      <name>theWidthGenerator</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>variableRatio</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPDPtr</type>
      <name>theAntiPartner</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>syncAnti</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefMass</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefWidth</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theDefCut</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Length</type>
      <name>theDefCTau</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Charge</type>
      <name>theDefCharge</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Spin</type>
      <name>theDefSpin</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDT::Colour</type>
      <name>theDefColour</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; ParticleData &gt;</type>
      <name>initParticleData</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ParticleData, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ParticleData_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ParticleData &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ParticleData_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ParticleData &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ParticleChargeCommand</name>
    <filename>structThePEG_1_1ParticleChargeCommand.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>ParticleChargeCommand</name>
      <anchor>a0</anchor>
      <arglist>(const ParticleData &amp;, string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PDT</name>
    <filename>classThePEG_1_1PDT.html</filename>
    <member kind="typedef">
      <type>Colour</type>
      <name>Color</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Spin</name>
      <anchor>w64</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SpinNA</name>
      <anchor>w64w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SpinUnknown</name>
      <anchor>w64w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SpinUndefined</name>
      <anchor>w64w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin0</name>
      <anchor>w64w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin1Half</name>
      <anchor>w64w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin1</name>
      <anchor>w64w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin3Half</name>
      <anchor>w64w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin2</name>
      <anchor>w64w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin5Half</name>
      <anchor>w64w9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin3</name>
      <anchor>w64w10</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin7Half</name>
      <anchor>w64w11</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Spin4</name>
      <anchor>w64w12</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Charge</name>
      <anchor>w65</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ChargeUnknown</name>
      <anchor>w65w13</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ChargeUndefined</name>
      <anchor>w65w14</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Charged</name>
      <anchor>w65w15</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Positive</name>
      <anchor>w65w16</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Negative</name>
      <anchor>w65w17</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ChargeNeutral</name>
      <anchor>w65w18</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Charge0</name>
      <anchor>w65w19</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus1Third</name>
      <anchor>w65w20</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus2Third</name>
      <anchor>w65w21</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus1</name>
      <anchor>w65w22</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus1Third</name>
      <anchor>w65w23</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus2Third</name>
      <anchor>w65w24</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus1</name>
      <anchor>w65w25</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus4Third</name>
      <anchor>w65w26</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus5Third</name>
      <anchor>w65w27</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus2</name>
      <anchor>w65w28</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus4Third</name>
      <anchor>w65w29</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus5Third</name>
      <anchor>w65w30</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus2</name>
      <anchor>w65w31</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus7Third</name>
      <anchor>w65w32</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus8Third</name>
      <anchor>w65w33</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus3</name>
      <anchor>w65w34</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus7Third</name>
      <anchor>w65w35</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus8Third</name>
      <anchor>w65w36</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus3</name>
      <anchor>w65w37</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus4</name>
      <anchor>w65w38</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus5</name>
      <anchor>w65w39</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus6</name>
      <anchor>w65w40</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus7</name>
      <anchor>w65w41</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Plus8</name>
      <anchor>w65w42</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus4</name>
      <anchor>w65w43</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus5</name>
      <anchor>w65w44</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus6</name>
      <anchor>w65w45</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus7</name>
      <anchor>w65w46</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Minus8</name>
      <anchor>w65w47</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Colour</name>
      <anchor>w66</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColourUnknown</name>
      <anchor>w66w48</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColourUndefined</name>
      <anchor>w66w49</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColourNeutral</name>
      <anchor>w66w50</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour0</name>
      <anchor>w66w51</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Coloured</name>
      <anchor>w66w52</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour3</name>
      <anchor>w66w53</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour3bar</name>
      <anchor>w66w54</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colour8</name>
      <anchor>w66w55</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColorUnknown</name>
      <anchor>w66w56</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColorUndefined</name>
      <anchor>w66w57</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ColorNeutral</name>
      <anchor>w66w58</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color0</name>
      <anchor>w66w59</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Colored</name>
      <anchor>w66w60</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color3</name>
      <anchor>w66w61</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color3bar</name>
      <anchor>w66w62</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Color8</name>
      <anchor>w66w63</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>charged</name>
      <anchor>e0</anchor>
      <arglist>(Charge c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>positive</name>
      <anchor>e1</anchor>
      <arglist>(Charge c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>negative</name>
      <anchor>e2</anchor>
      <arglist>(Charge c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>colored</name>
      <anchor>e3</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>coloured</name>
      <anchor>e4</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Color</type>
      <name>antiColor</name>
      <anchor>e5</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Colour</type>
      <name>antiColour</name>
      <anchor>e6</anchor>
      <arglist>(Color c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e7</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e8</anchor>
      <arglist>(tcPDPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e9</anchor>
      <arglist>(tcPPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e10</anchor>
      <arglist>(const ParticleData &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; long &gt;</type>
      <name>flavourContent</name>
      <anchor>e11</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PYDECYDummy</name>
    <filename>classThePEG_1_1PYDECYDummy.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function">
      <type></type>
      <name>PYDECYDummy</name>
      <anchor>z836_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PYDECYDummy</name>
      <anchor>z836_1</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PYDECYDummy</name>
      <anchor>z836_2</anchor>
      <arglist>(const PYDECYDummy &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PYDECYDummy</name>
      <anchor>z836_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>b0</anchor>
      <arglist>(const DecayMode &amp;, const ParticleData &amp;, double) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual double</type>
      <name>brat</name>
      <anchor>b1</anchor>
      <arglist>(const DecayMode &amp;, const Particle &amp;, double) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>readSetup</name>
      <anchor>b2</anchor>
      <arglist>(istream &amp;is)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z838_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z838_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z838_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z838_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z838_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z840_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z840_1</anchor>
      <arglist>(const DecayMode &amp;, const Particle &amp;) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z842_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z842_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z844_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z844_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>f0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PYDECYDummy &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PYDECYDummy &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theME</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PYDECYDummy &gt;</type>
      <name>initPYDECYDummy</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PYDECYDummy, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PYDECYDummy_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PYDECYDummy &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PYDECYDummy_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PYDECYDummy &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::QuarksToHadronsDecayer</name>
    <filename>classThePEG_1_1QuarksToHadronsDecayer.html</filename>
    <base>ThePEG::Decayer</base>
    <member kind="function" virtualness="virtual">
      <type>virtual int</type>
      <name>getN</name>
      <anchor>a0</anchor>
      <arglist>(Energy m0, Energy summq, int Nq) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PVector</type>
      <name>getHadrons</name>
      <anchor>a1</anchor>
      <arglist>(int Nh, tcPDVector quarks) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>distribute</name>
      <anchor>a2</anchor>
      <arglist>(const Particle &amp;parent, PVector &amp;children) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>a3</anchor>
      <arglist>(const Particle &amp;parent, const PVector &amp;children) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>fixedN</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>minN</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>c1</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>c2</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>c3</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tcFlavGenPtr</type>
      <name>flavourGenerator</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QuarksToHadronsDecayer</name>
      <anchor>z846_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>QuarksToHadronsDecayer</name>
      <anchor>z846_1</anchor>
      <arglist>(const QuarksToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~QuarksToHadronsDecayer</name>
      <anchor>z846_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z848_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z848_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z850_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z850_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z852_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z852_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z854_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z854_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z854_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z854_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z854_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z854_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>QuarksToHadronsDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const QuarksToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theFixedN</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theMinN</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theC1</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theC2</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theC3</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FlavGenPtr</type>
      <name>theFlavourGenerator</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; QuarksToHadronsDecayer &gt;</type>
      <name>initQuarksToHadronsDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; QuarksToHadronsDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01QuarksToHadronsDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Decayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; QuarksToHadronsDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01QuarksToHadronsDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; QuarksToHadronsDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::AnyMatcher</name>
    <filename>structThePEG_1_1AnyMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>AnyMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ChargedMatcher</name>
    <filename>structThePEG_1_1ChargedMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>ChargedMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PositiveMatcher</name>
    <filename>structThePEG_1_1PositiveMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>NegativeMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::NeutralMatcher</name>
    <filename>structThePEG_1_1NeutralMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>NeutralMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::NegativeMatcher</name>
    <filename>structThePEG_1_1NegativeMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>PositiveMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaryonMatcher</name>
    <filename>structThePEG_1_1BaryonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>BaryonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MesonMatcher</name>
    <filename>structThePEG_1_1MesonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>MesonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::DiquarkMatcher</name>
    <filename>structThePEG_1_1DiquarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>DiquarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::QuarkMatcher</name>
    <filename>structThePEG_1_1QuarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>QuarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::LeptonMatcher</name>
    <filename>structThePEG_1_1LeptonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>LeptonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::LightQuarkMatcher</name>
    <filename>structThePEG_1_1LightQuarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>LightAntiQuarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::LightAntiQuarkMatcher</name>
    <filename>structThePEG_1_1LightAntiQuarkMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>LightQuarkMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::StandardQCDPartonMatcher</name>
    <filename>structThePEG_1_1StandardQCDPartonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>StandardQCDPartonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PseudoScalarMesonMatcher</name>
    <filename>structThePEG_1_1PseudoScalarMesonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>PseudoScalarMesonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::VectorMesonMatcher</name>
    <filename>structThePEG_1_1VectorMesonMatcher.html</filename>
    <base>ThePEG::MatcherType</base>
    <member kind="typedef">
      <type>VectorMesonMatcher</type>
      <name>CC</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e0</anchor>
      <arglist>(const ParticleData &amp;pd)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>Check</name>
      <anchor>e1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Tau2HadronsDecayer</name>
    <filename>classThePEG_1_1Tau2HadronsDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type></type>
      <name>Tau2HadronsDecayer</name>
      <anchor>z856_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Tau2HadronsDecayer</name>
      <anchor>z856_1</anchor>
      <arglist>(const Tau2HadronsDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Tau2HadronsDecayer</name>
      <anchor>z856_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z858_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z858_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z860_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z860_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z862_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z862_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z864_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z864_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z864_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z864_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z864_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z864_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Tau2HadronsDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Tau2HadronsDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Tau2HadronsDecayer &gt;</type>
      <name>initTau2HadronsDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Tau2HadronsDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Tau2HadronsDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Tau2HadronsDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Tau2HadronsDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Tau2HadronsDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::V2PPDecayer</name>
    <filename>classThePEG_1_1V2PPDecayer.html</filename>
    <base>ThePEG::FlatDecayer</base>
    <member kind="function">
      <type></type>
      <name>V2PPDecayer</name>
      <anchor>z866_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>V2PPDecayer</name>
      <anchor>z866_1</anchor>
      <arglist>(const V2PPDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~V2PPDecayer</name>
      <anchor>z866_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z868_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual ParticleVector</type>
      <name>decay</name>
      <anchor>z868_1</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;p) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z868_2</anchor>
      <arglist>(const DecayMode &amp;dm, const Particle &amp;parent, const ParticleVector &amp;children) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z870_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z870_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z872_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z872_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z874_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z874_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z874_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z874_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z874_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z874_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>V2PPDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const V2PPDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPPtr</type>
      <name>grandParent</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPPtr</type>
      <name>sibling</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; V2PPDecayer &gt;</type>
      <name>initV2PPDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; V2PPDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01V2PPDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FlatDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; V2PPDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01V2PPDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; V2PPDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::WeakToHadronsDecayer</name>
    <filename>classThePEG_1_1WeakToHadronsDecayer.html</filename>
    <base>ThePEG::QuarksToHadronsDecayer</base>
    <member kind="function">
      <type></type>
      <name>WeakToHadronsDecayer</name>
      <anchor>z876_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>WeakToHadronsDecayer</name>
      <anchor>z876_1</anchor>
      <arglist>(const WeakToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~WeakToHadronsDecayer</name>
      <anchor>z876_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z878_0</anchor>
      <arglist>(const DecayMode &amp;dm) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>reweight</name>
      <anchor>z878_1</anchor>
      <arglist>(const Particle &amp;parent, const PVector &amp;children) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual PVector</type>
      <name>getHadrons</name>
      <anchor>z878_2</anchor>
      <arglist>(int Nh, tcPDVector quarks) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z880_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z880_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z882_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z882_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z884_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z884_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z884_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z884_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z884_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z884_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>WeakToHadronsDecayer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const WeakToHadronsDecayer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; WeakToHadronsDecayer &gt;</type>
      <name>initWeakToHadronsDecayer</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; WeakToHadronsDecayer, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01WeakToHadronsDecayer_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>QuarksToHadronsDecayer</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; WeakToHadronsDecayer &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01WeakToHadronsDecayer_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; WeakToHadronsDecayer &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::WidthGenerator</name>
    <filename>classThePEG_1_1WidthGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>Selector&lt; tDMPtr &gt;</type>
      <name>DecayMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>WidthGenerator</name>
      <anchor>z886_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>WidthGenerator</name>
      <anchor>z886_1</anchor>
      <arglist>(const WidthGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~WidthGenerator</name>
      <anchor>z886_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual bool</type>
      <name>accept</name>
      <anchor>z888_0</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>width</name>
      <anchor>z888_1</anchor>
      <arglist>(const Particle &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual Energy</type>
      <name>width</name>
      <anchor>z888_2</anchor>
      <arglist>(const ParticleData &amp;, Energy m) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Length</type>
      <name>lifeTime</name>
      <anchor>z888_3</anchor>
      <arglist>(const ParticleData &amp;, Energy m, Energy w) const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual DecayMap</type>
      <name>rate</name>
      <anchor>z888_4</anchor>
      <arglist>(const ParticleData &amp;) const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual DecayMap</type>
      <name>rate</name>
      <anchor>z888_5</anchor>
      <arglist>(const Particle &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>WidthGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const WidthGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; WidthGenerator &gt;</type>
      <name>initWidthGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; WidthGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01WidthGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; WidthGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01WidthGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; WidthGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::InputDescription</name>
    <filename>classThePEG_1_1InputDescription.html</filename>
    <base>ThePEG::Named</base>
    <member kind="typedef">
      <type>vector&lt; const InputDescription * &gt;</type>
      <name>DescriptionVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>InputDescription</name>
      <anchor>a0</anchor>
      <arglist>(string newName, int version)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDescription</name>
      <anchor>a1</anchor>
      <arglist>(const ClassDescriptionBase *)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addBaseClass</name>
      <anchor>a2</anchor>
      <arglist>(const InputDescription *)</arglist>
    </member>
    <member kind="function">
      <type>const DescriptionVector &amp;</type>
      <name>descriptions</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>BPtr</type>
      <name>create</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a5</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DescriptionVector</type>
      <name>theBaseClasses</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const ClassDescriptionBase *</type>
      <name>theDescription</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theVersion</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PersistentIStream</name>
    <filename>classThePEG_1_1PersistentIStream.html</filename>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; BPtr &gt;</type>
      <name>ObjectVector</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>InputDescription::DescriptionVector</type>
      <name>DescriptionVector</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>a0</anchor>
      <arglist>(istream &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>a1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PersistentIStream</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a3</anchor>
      <arglist>(RCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a4</anchor>
      <arglist>(ConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a5</anchor>
      <arglist>(TransientRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>a6</anchor>
      <arglist>(TransientConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getContainer</name>
      <anchor>a7</anchor>
      <arglist>(Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>BPtr</type>
      <name>getObject</name>
      <anchor>a8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>getObjectPart</name>
      <anchor>a9</anchor>
      <arglist>(tBPtr obj, const InputDescription *pid)</arglist>
    </member>
    <member kind="function">
      <type>const InputDescription *</type>
      <name>getClass</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>setPedantic</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>setTolerant</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>good</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator bool</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>pedantic</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_0</anchor>
      <arglist>(string &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_1</anchor>
      <arglist>(char &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_2</anchor>
      <arglist>(signed char &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_3</anchor>
      <arglist>(unsigned char &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_4</anchor>
      <arglist>(int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_5</anchor>
      <arglist>(unsigned int &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_6</anchor>
      <arglist>(long &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_7</anchor>
      <arglist>(unsigned long &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_8</anchor>
      <arglist>(short &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_9</anchor>
      <arglist>(unsigned short &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_10</anchor>
      <arglist>(double &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_11</anchor>
      <arglist>(float &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_12</anchor>
      <arglist>(bool &amp;)</arglist>
    </member>
    <member kind="function">
      <type>PersistentIStream &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z892_13</anchor>
      <arglist>(Complex &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>init</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>char</type>
      <name>get</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>char</type>
      <name>escaped</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBadState</name>
      <anchor>d3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>getSep</name>
      <anchor>d4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>skipField</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>beginObject</name>
      <anchor>d6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endObject</name>
      <anchor>d7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endBase</name>
      <anchor>d8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>istream &amp;</type>
      <name>is</name>
      <anchor>d9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const istream &amp;</type>
      <name>is</name>
      <anchor>d10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>d11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentIStream</name>
      <anchor>d12</anchor>
      <arglist>(const PersistentIStream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PersistentIStream &amp;</type>
      <name>operator=</name>
      <anchor>d13</anchor>
      <arglist>(const PersistentIStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectVector</type>
      <name>readObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DescriptionVector</type>
      <name>readClasses</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>istream *</type>
      <name>theIStream</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>isPedantic</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>allocStream</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>badState</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>version</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>subVersion</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tBegin</name>
      <anchor>z894_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tEnd</name>
      <anchor>z894_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNext</name>
      <anchor>z894_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNull</name>
      <anchor>z894_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tSep</name>
      <anchor>z894_4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNoSep</name>
      <anchor>z894_5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tYes</name>
      <anchor>z894_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNo</name>
      <anchor>z894_7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingObject</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingObject.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::ReadFailior</name>
    <filename>structThePEG_1_1PersistentIStream_1_1ReadFailior.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::MissingObject</name>
    <filename>structThePEG_1_1PersistentIStream_1_1MissingObject.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentIStream::ReadFailior</name>
    <filename>structThePEG_1_1PersistentIStream_1_1ReadFailior.html</filename>
  </compound>
  <compound kind="class">
    <name>ThePEG::PersistentOStream</name>
    <filename>classThePEG_1_1PersistentOStream.html</filename>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; PersistentBase &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; cBPtr, int, less&lt; cBPtr &gt;, Allocator&lt; int &gt; &gt;</type>
      <name>ObjectMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const ClassDescriptionBase *, int, less&lt; const ClassDescriptionBase * &gt;, Allocator&lt; int &gt; &gt;</type>
      <name>ClassMap</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ClassDescriptionBase::DescriptionVector</type>
      <name>DescriptionVector</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>a0</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>a1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~PersistentOStream</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a3</anchor>
      <arglist>(const RCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a4</anchor>
      <arglist>(const ConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a5</anchor>
      <arglist>(const TransientRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a6</anchor>
      <arglist>(const TransientConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>putContainer</name>
      <anchor>a7</anchor>
      <arglist>(const Container &amp;c)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>outputPointer</name>
      <anchor>a8</anchor>
      <arglist>(tcBPtr)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>putObjectPart</name>
      <anchor>a9</anchor>
      <arglist>(tcBPtr obj, const ClassDescriptionBase *cd)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>flush</name>
      <anchor>a10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>push</name>
      <anchor>a11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>pop</name>
      <anchor>a12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>good</name>
      <anchor>a13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator bool</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_1</anchor>
      <arglist>(char)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_2</anchor>
      <arglist>(signed char)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_3</anchor>
      <arglist>(unsigned char)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_4</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_5</anchor>
      <arglist>(unsigned int)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_6</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_7</anchor>
      <arglist>(unsigned long)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_8</anchor>
      <arglist>(short)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_9</anchor>
      <arglist>(unsigned short)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_10</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_11</anchor>
      <arglist>(float)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_12</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function">
      <type>PersistentOStream &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>z898_13</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>isToken</name>
      <anchor>d0</anchor>
      <arglist>(char c) const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setBadState</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>checkState</name>
      <anchor>d2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ClassDescriptionBase *</type>
      <name>writeClassId</name>
      <anchor>d3</anchor>
      <arglist>(tcBPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>writeClassDescription</name>
      <anchor>d4</anchor>
      <arglist>(const ClassDescriptionBase *)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>beginObject</name>
      <anchor>d5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endObject</name>
      <anchor>d6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>endBase</name>
      <anchor>d7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>put</name>
      <anchor>d8</anchor>
      <arglist>(char)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>escape</name>
      <anchor>d9</anchor>
      <arglist>(char c)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ostream &amp;</type>
      <name>os</name>
      <anchor>d10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ostream &amp;</type>
      <name>os</name>
      <anchor>d11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>init</name>
      <anchor>d12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>d13</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>PersistentOStream</name>
      <anchor>d14</anchor>
      <arglist>(const PersistentOStream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PersistentOStream &amp;</type>
      <name>operator=</name>
      <anchor>d15</anchor>
      <arglist>(const PersistentOStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectMap</type>
      <name>writtenObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>stack&lt; int &gt;</type>
      <name>lastSavedObject</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ClassMap</type>
      <name>writtenClasses</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ostream *</type>
      <name>theOStream</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>badState</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>allocStream</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const int</type>
      <name>version</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const int</type>
      <name>subVersion</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tBegin</name>
      <anchor>z900_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tEnd</name>
      <anchor>z900_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNext</name>
      <anchor>z900_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNull</name>
      <anchor>z900_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tSep</name>
      <anchor>z900_4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNoSep</name>
      <anchor>z900_5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tYes</name>
      <anchor>z900_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const char</type>
      <name>tNo</name>
      <anchor>z900_7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentOStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentOStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::PersistentOStream::MissingClass</name>
    <filename>structThePEG_1_1PersistentOStream_1_1MissingClass.html</filename>
  </compound>
  <compound kind="class">
    <name>ThePEG::BaseRepository</name>
    <filename>classThePEG_1_1BaseRepository.html</filename>
    <member kind="typedef">
      <type>StringSet</type>
      <name>DirectorySet</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>set&lt; const InterfaceBase * &gt;</type>
      <name>InterfaceSet</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const ClassDescriptionBase *, InterfaceSet &gt;</type>
      <name>TypeInterfaceMap</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; const ClassDescriptionBase *, const ClassDocumentationBase * &gt;</type>
      <name>TypeDocumentationMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>exec</name>
      <anchor>e0</anchor>
      <arglist>(string cmd, ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z904_0</anchor>
      <arglist>(const InterfaceBase &amp;, const type_info &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z904_1</anchor>
      <arglist>(const ClassDocumentationBase &amp;, const type_info &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z904_2</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z904_3</anchor>
      <arglist>(IBPtr, string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>remove</name>
      <anchor>z904_4</anchor>
      <arglist>(tIBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>remove</name>
      <anchor>z904_5</anchor>
      <arglist>(const ObjectSet &amp;rmset)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>rename</name>
      <anchor>z904_6</anchor>
      <arglist>(tIBPtr object, string newName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CreateDirectory</name>
      <anchor>z906_0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CheckObjectDirectory</name>
      <anchor>z906_1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CheckDirectory</name>
      <anchor>z906_2</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>DirectoryAppend</name>
      <anchor>z906_3</anchor>
      <arglist>(string &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>ChangeDirectory</name>
      <anchor>z906_4</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PushDirectory</name>
      <anchor>z906_5</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>PopDirectory</name>
      <anchor>z906_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>GetPtr</name>
      <anchor>z908_0</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PtrType</type>
      <name>GetPtr</name>
      <anchor>z908_1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PtrType</type>
      <name>GetObject</name>
      <anchor>z908_2</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>GetPointer</name>
      <anchor>z908_3</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IVector</type>
      <name>SearchDirectory</name>
      <anchor>z908_4</anchor>
      <arglist>(string name, string className=&quot;&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>TraceObject</name>
      <anchor>z908_5</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>getObjectFromNoun</name>
      <anchor>z908_6</anchor>
      <arglist>(string noun)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IVector</type>
      <name>GetObjectsReferingTo</name>
      <anchor>z910_0</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IVector</type>
      <name>DirectReferences</name>
      <anchor>z910_1</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>addReferences</name>
      <anchor>z910_2</anchor>
      <arglist>(tIBPtr obj, ObjectSet &amp;refs)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>InterfaceMap</type>
      <name>getInterfaces</name>
      <anchor>z912_0</anchor>
      <arglist>(const type_info &amp;ti, bool all=true)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const InterfaceBase *</type>
      <name>FindInterface</name>
      <anchor>z912_1</anchor>
      <arglist>(IBPtr object, string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getInterfaceFromNoun</name>
      <anchor>z912_2</anchor>
      <arglist>(string noun)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getPosArgFromNoun</name>
      <anchor>z912_3</anchor>
      <arglist>(string noun)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>update</name>
      <anchor>z914_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>clearAll</name>
      <anchor>z914_1</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>resetAll</name>
      <anchor>z914_2</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>readSetup</name>
      <anchor>z914_3</anchor>
      <arglist>(tIBPtr ip, istream &amp;is)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>lock</name>
      <anchor>z914_4</anchor>
      <arglist>(tIBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unlock</name>
      <anchor>z914_5</anchor>
      <arglist>(tIBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ClassDocumentationBase *</type>
      <name>getDocumentation</name>
      <anchor>z916_0</anchor>
      <arglist>(tcIBPtr ip)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getModelDescription</name>
      <anchor>z916_1</anchor>
      <arglist>(tcIBPtr ip)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getModelReferences</name>
      <anchor>z916_2</anchor>
      <arglist>(tcIBPtr ip)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>cout</name>
      <anchor>z918_0</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>cout</name>
      <anchor>z918_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>cerr</name>
      <anchor>z918_2</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>cerr</name>
      <anchor>z918_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>clog</name>
      <anchor>z918_4</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>clog</name>
      <anchor>z918_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>addInterfaces</name>
      <anchor>f0</anchor>
      <arglist>(const ClassDescriptionBase &amp;, InterfaceMap &amp;, bool all=true)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>clone</name>
      <anchor>z920_0</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>fullclone</name>
      <anchor>z920_1</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>rebind</name>
      <anchor>z920_2</anchor>
      <arglist>(InterfacedBase &amp;obj, const TranslationMap &amp;trans, const IVector &amp;defaults)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ObjectMap &amp;</type>
      <name>objects</name>
      <anchor>z922_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ObjectSet &amp;</type>
      <name>allObjects</name>
      <anchor>z922_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>TypeInterfaceMap &amp;</type>
      <name>interfaces</name>
      <anchor>z922_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>TypeDocumentationMap &amp;</type>
      <name>documentations</name>
      <anchor>z922_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DirectorySet &amp;</type>
      <name>directories</name>
      <anchor>z922_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>StringVector &amp;</type>
      <name>directoryStack</name>
      <anchor>z922_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>bool &amp;</type>
      <name>updating</name>
      <anchor>z922_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ostream *&amp;</type>
      <name>coutp</name>
      <anchor>z922_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ostream *&amp;</type>
      <name>cerrp</name>
      <anchor>z922_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ostream *&amp;</type>
      <name>clogp</name>
      <anchor>z922_9</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BadClassClone</name>
    <filename>structThePEG_1_1BadClassClone.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>BadClassClone</name>
      <anchor>a0</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BadClone</name>
    <filename>structThePEG_1_1BadClone.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>BadClone</name>
      <anchor>a0</anchor>
      <arglist>(const InterfacedBase &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepoNameException</name>
    <filename>structThePEG_1_1RepoNameException.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepoNameException</name>
      <anchor>a0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepositoryNoDirectory</name>
    <filename>structThePEG_1_1RepositoryNoDirectory.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepositoryNoDirectory</name>
      <anchor>a0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepositoryNotFound</name>
    <filename>structThePEG_1_1RepositoryNotFound.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepositoryNotFound</name>
      <anchor>a0</anchor>
      <arglist>(string name)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::RepositoryClassMisMatch</name>
    <filename>structThePEG_1_1RepositoryClassMisMatch.html</filename>
    <base>ThePEG::InterfaceException</base>
    <member kind="function">
      <type></type>
      <name>RepositoryClassMisMatch</name>
      <anchor>a0</anchor>
      <arglist>(const InterfacedBase &amp;o, string name)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CurrentGenerator</name>
    <filename>classThePEG_1_1CurrentGenerator.html</filename>
    <member kind="function">
      <type></type>
      <name>CurrentGenerator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CurrentGenerator</name>
      <anchor>a1</anchor>
      <arglist>(const CurrentGenerator &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CurrentGenerator</name>
      <anchor>a2</anchor>
      <arglist>(const EGPtr &amp;eg)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~CurrentGenerator</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>isVoid</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>EventGenerator &amp;</type>
      <name>current</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tSMPtr</type>
      <name>standardModel</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tStrategyPtr</type>
      <name>strategy</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>out</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>log</name>
      <anchor>e5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>ostream &amp;</type>
      <name>ref</name>
      <anchor>e6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getPtr</name>
      <anchor>e7</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>IBPtr</type>
      <name>getPointer</name>
      <anchor>e8</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getObject</name>
      <anchor>e9</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getDefault</name>
      <anchor>e10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RandomGenerator &amp;</type>
      <name>random</name>
      <anchor>e11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RandomEngine &amp;</type>
      <name>randomEngine</name>
      <anchor>e12</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CurrentGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const CurrentGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>generatorPushed</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; EGPtr &gt;</type>
      <name>theGeneratorStack</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::EventGenerator</name>
    <filename>classThePEG_1_1EventGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>map&lt; const type_info *, int &gt;</type>
      <name>ExceptionMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventGenerator</name>
      <anchor>z924_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>EventGenerator</name>
      <anchor>z924_1</anchor>
      <arglist>(const EventGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~EventGenerator</name>
      <anchor>z924_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tSMPtr</type>
      <name>standardModel</name>
      <anchor>z926_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tStrategyPtr</type>
      <name>strategy</name>
      <anchor>z926_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>tPartCollHdlPtr</type>
      <name>currentCollisionHandler</name>
      <anchor>z926_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentCollisionHandler</name>
      <anchor>z926_3</anchor>
      <arglist>(tPartCollHdlPtr)</arglist>
    </member>
    <member kind="function">
      <type>tStepHdlPtr</type>
      <name>currentStepHandler</name>
      <anchor>z926_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>currentStepHandler</name>
      <anchor>z926_5</anchor>
      <arglist>(tStepHdlPtr)</arglist>
    </member>
    <member kind="function">
      <type>RandomGenerator &amp;</type>
      <name>random</name>
      <anchor>z926_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>RandomEngine &amp;</type>
      <name>randomEngine</name>
      <anchor>z926_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>initialize</name>
      <anchor>z928_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>go</name>
      <anchor>z928_1</anchor>
      <arglist>(long next=1, long maxevent=-1)</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>shoot</name>
      <anchor>z928_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>EventPtr</type>
      <name>partialEvent</name>
      <anchor>z928_3</anchor>
      <arglist>(tEventPtr event)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>finalize</name>
      <anchor>z928_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z928_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>currentEventNumber</name>
      <anchor>z928_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual tcEventPtr</type>
      <name>currentEvent</name>
      <anchor>z928_7</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>dump</name>
      <anchor>z928_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>use</name>
      <anchor>z928_9</anchor>
      <arglist>(const Interfaced &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z928_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>logWarning</name>
      <anchor>z928_11</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function">
      <type>long</type>
      <name>N</name>
      <anchor>z928_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>filename</name>
      <anchor>z930_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>runName</name>
      <anchor>z930_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>path</name>
      <anchor>z930_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>openOutputFiles</name>
      <anchor>z930_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>closeOutputFiles</name>
      <anchor>z930_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ofstream &amp;</type>
      <name>outfile</name>
      <anchor>z930_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ofstream &amp;</type>
      <name>logfile</name>
      <anchor>z930_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ofstream &amp;</type>
      <name>reffile</name>
      <anchor>z930_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>out</name>
      <anchor>z930_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>log</name>
      <anchor>z930_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ostream &amp;</type>
      <name>ref</name>
      <anchor>z930_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ObjectSet &amp;</type>
      <name>objects</name>
      <anchor>z932_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ObjectMap &amp;</type>
      <name>objectMap</name>
      <anchor>z932_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getPtr</name>
      <anchor>z932_2</anchor>
      <arglist>(const T &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>IBPtr</type>
      <name>getPointer</name>
      <anchor>z932_3</anchor>
      <arglist>(string name) const</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getObject</name>
      <anchor>z932_4</anchor>
      <arglist>(string name) const</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>getDefault</name>
      <anchor>z932_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>PPtr</type>
      <name>getParticle</name>
      <anchor>z932_6</anchor>
      <arglist>(long id) const</arglist>
    </member>
    <member kind="function">
      <type>PDPtr</type>
      <name>getParticleData</name>
      <anchor>z932_7</anchor>
      <arglist>(long id) const</arglist>
    </member>
    <member kind="function">
      <type>const MatcherSet &amp;</type>
      <name>matchers</name>
      <anchor>z932_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ParticleMap &amp;</type>
      <name>particles</name>
      <anchor>z932_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const ObjectSet &amp;</type>
      <name>used</name>
      <anchor>z932_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z936_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z936_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setup</name>
      <anchor>b0</anchor>
      <arglist>(string newRunName, ObjectSet &amp;newObjects, ParticleMap &amp;newParticles, MatcherSet &amp;newMatchers)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>printException</name>
      <anchor>b1</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>logException</name>
      <anchor>b2</anchor>
      <arglist>(const Exception &amp;, tcEventPtr)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>N</name>
      <anchor>b3</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>runName</name>
      <anchor>b4</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ObjectSet &amp;</type>
      <name>objects</name>
      <anchor>b5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ObjectMap &amp;</type>
      <name>objectMap</name>
      <anchor>b6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>generateReferences</name>
      <anchor>b7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>int</type>
      <name>count</name>
      <anchor>b8</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doGo</name>
      <anchor>z934_0</anchor>
      <arglist>(long next, long maxevent)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doInitialize</name>
      <anchor>z934_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual EventPtr</type>
      <name>doShoot</name>
      <anchor>z934_2</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="pure">
      <type>virtual EventPtr</type>
      <name>doPartialEvent</name>
      <anchor>z934_3</anchor>
      <arglist>(tEventPtr)=0</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z938_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z938_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z938_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z938_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>long</type>
      <name>ieve</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>int</type>
      <name>theDebugLevel</name>
      <anchor>p1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>const vector&lt; IPtr &gt; &amp;</type>
      <name>defaultObjects</name>
      <anchor>d0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleMap &amp;</type>
      <name>localParticles</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>const ParticleMap &amp;</type>
      <name>localParticles</name>
      <anchor>d2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>path</name>
      <anchor>d3</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>strategy</name>
      <anchor>d4</anchor>
      <arglist>(StrategyPtr)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setLocalParticles</name>
      <anchor>d5</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insLocalParticles</name>
      <anchor>d6</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delLocalParticles</name>
      <anchor>d7</anchor>
      <arglist>(int place)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; PDPtr &gt;</type>
      <name>getLocalParticles</name>
      <anchor>d8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setPath</name>
      <anchor>d9</anchor>
      <arglist>(string newPath)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>string</type>
      <name>defPath</name>
      <anchor>d10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>EventGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d11</anchor>
      <arglist>(const EventGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; IPtr &gt;</type>
      <name>theDefaultObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>theLocalParticles</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SMPtr</type>
      <name>theStandardModel</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StrategyPtr</type>
      <name>theStrategy</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RanGenPtr</type>
      <name>theRandom</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>thePath</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theRunName</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream</type>
      <name>theOutfile</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream</type>
      <name>theLogfile</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ofstream</type>
      <name>theReffile</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theNumberOfEvents</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectSet</type>
      <name>theObjects</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectMap</type>
      <name>theObjectMap</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>theParticles</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PDVector</type>
      <name>theQuickParticles</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theQuickSize</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MatcherSet</type>
      <name>theMatchers</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectSet</type>
      <name>usedObjects</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>maxWarnings</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>maxErrors</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ExceptionMap</type>
      <name>theExceptions</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>UseRandom *</type>
      <name>theCurrentRandom</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CurrentGenerator *</type>
      <name>theCurrentGenerator</name>
      <anchor>r22</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tPartCollHdlPtr</type>
      <name>theCurrentCollisionHandler</name>
      <anchor>r23</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>tStepHdlPtr</type>
      <name>theCurrentStepHandler</name>
      <anchor>r24</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; EventGenerator &gt;</type>
      <name>initEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; EventGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01EventGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; EventGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01EventGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; EventGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::EGNoPath</name>
    <filename>structThePEG_1_1EGNoPath.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>EGNoPath</name>
      <anchor>a0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FullEventGenerator</name>
    <filename>classThePEG_1_1FullEventGenerator.html</filename>
    <base>ThePEG::EventGenerator</base>
    <member kind="function">
      <type></type>
      <name>FullEventGenerator</name>
      <anchor>z940_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FullEventGenerator</name>
      <anchor>z940_1</anchor>
      <arglist>(const FullEventGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FullEventGenerator</name>
      <anchor>z940_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tEHPtr</type>
      <name>eventHandler</name>
      <anchor>z942_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>AnalysisVector &amp;</type>
      <name>analysisHandlers</name>
      <anchor>z942_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>tEvtManipPtr</type>
      <name>manipulator</name>
      <anchor>z942_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual Energy</type>
      <name>maximumCMEnergy</name>
      <anchor>z944_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcEventPtr</type>
      <name>currentEvent</name>
      <anchor>z944_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z946_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z946_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doShoot</name>
      <anchor>z948_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doPartialEvent</name>
      <anchor>z948_1</anchor>
      <arglist>(tEventPtr)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z950_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z950_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z952_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z952_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z952_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z952_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z952_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z952_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FullEventGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FullEventGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>EHPtr</type>
      <name>theEventHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AnalysisVector</type>
      <name>theAnalysisHandlers</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>EvtManipPtr</type>
      <name>theEventManipulator</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>printEvent</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>dumpPeriod</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>debugEvent</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; FullEventGenerator &gt;</type>
      <name>initFullEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; FullEventGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01FullEventGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; FullEventGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01FullEventGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; FullEventGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Main</name>
    <filename>classThePEG_1_1Main.html</filename>
    <base>ThePEG::Base</base>
    <member kind="function">
      <type></type>
      <name>Main</name>
      <anchor>z954_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Main</name>
      <anchor>z954_1</anchor>
      <arglist>(const Main &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Main</name>
      <anchor>z954_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>eventGenerator</name>
      <anchor>e0</anchor>
      <arglist>(tEGPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tEGPtr</type>
      <name>eventGenerator</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>N</name>
      <anchor>e2</anchor>
      <arglist>(long)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>N</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>arguments</name>
      <anchor>e4</anchor>
      <arglist>(const vector&lt; string &gt; &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const vector&lt; string &gt; &amp;</type>
      <name>arguments</name>
      <anchor>e5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Main &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const Main &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>EGPtr</type>
      <name>theEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>long</type>
      <name>theN</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; string &gt;</type>
      <name>theArguments</name>
      <anchor>v2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; Main &gt;</type>
      <name>initMain</name>
      <anchor>v3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Main, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Main_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>int</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Main &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Main_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Main &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MultiEventGenerator</name>
    <filename>classThePEG_1_1MultiEventGenerator.html</filename>
    <base>ThePEG::FullEventGenerator</base>
    <member kind="function">
      <type></type>
      <name>MultiEventGenerator</name>
      <anchor>z956_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>MultiEventGenerator</name>
      <anchor>z956_1</anchor>
      <arglist>(const MultiEventGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~MultiEventGenerator</name>
      <anchor>z956_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z962_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z962_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doGo</name>
      <anchor>z958_0</anchor>
      <arglist>(long next, long maxevent)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>string</type>
      <name>addInterface</name>
      <anchor>z960_0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>string</type>
      <name>removeInterface</name>
      <anchor>z960_1</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z964_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z964_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z966_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z966_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinitrun</name>
      <anchor>z966_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z966_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z966_4</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z966_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>MultiEventGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const MultiEventGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>IVector</type>
      <name>theObjects</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringVector</type>
      <name>theInterfaces</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StringVector</type>
      <name>thePosArgs</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; StringVector &gt;</type>
      <name>theValues</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; MultiEventGenerator &gt;</type>
      <name>initMultiEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; MultiEventGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01MultiEventGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>FullEventGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; MultiEventGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01MultiEventGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; MultiEventGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::PartialEventGenerator</name>
    <filename>classThePEG_1_1PartialEventGenerator.html</filename>
    <base>ThePEG::EventGenerator</base>
    <member kind="function">
      <type>tPartCollHdlPtr</type>
      <name>handler</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual tcEventPtr</type>
      <name>currentEvent</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartialEventGenerator</name>
      <anchor>z968_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>PartialEventGenerator</name>
      <anchor>z968_1</anchor>
      <arglist>(const PartialEventGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~PartialEventGenerator</name>
      <anchor>z968_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z970_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z970_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doShoot</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual EventPtr</type>
      <name>doPartialEvent</name>
      <anchor>b1</anchor>
      <arglist>(tEventPtr)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z972_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z972_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z974_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z974_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z974_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z974_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z974_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>PartialEventGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const PartialEventGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>PartCollHdlPtr</type>
      <name>theHandler</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; PartialEventGenerator &gt;</type>
      <name>initPartialEventGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; PartialEventGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01PartialEventGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>EventGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; PartialEventGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01PartialEventGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; PartialEventGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::RandomGenerator</name>
    <filename>classThePEG_1_1RandomGenerator.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="typedef">
      <type>vector&lt; double &gt;</type>
      <name>RndVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RndVector::size_type</type>
      <name>size_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandomGenerator</name>
      <anchor>z976_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RandomGenerator</name>
      <anchor>z976_1</anchor>
      <arglist>(const RandomGenerator &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RandomGenerator</name>
      <anchor>z976_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual RandomEngine &amp;</type>
      <name>randomGenerator</name>
      <anchor>z978_0</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setSeed</name>
      <anchor>z978_1</anchor>
      <arglist>(long seed)=0</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>rnd</name>
      <anchor>z980_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>operator()</name>
      <anchor>z980_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>z980_2</anchor>
      <arglist>(double p=0.5)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>z980_3</anchor>
      <arglist>(double p1, double p2)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rndsign</name>
      <anchor>z980_4</anchor>
      <arglist>(double p1, double p2, double p3)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd2</name>
      <anchor>z980_5</anchor>
      <arglist>(double p0, double p1)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd3</name>
      <anchor>z980_6</anchor>
      <arglist>(double p0, double p1, double p2)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>rnd4</name>
      <anchor>z980_7</anchor>
      <arglist>(double p0, double p1, double p2, double p3)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>push_back</name>
      <anchor>z982_0</anchor>
      <arglist>(double r)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>pop_back</name>
      <anchor>z982_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>flush</name>
      <anchor>z982_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>rnd</name>
      <anchor>z982_3</anchor>
      <arglist>(OutputIterator, size_type n)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z984_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z984_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>b0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setSize</name>
      <anchor>d0</anchor>
      <arglist>(size_type newSize)</arglist>
    </member>
    <member kind="function" protection="private" virtualness="virtual">
      <type>virtual void</type>
      <name>getFlatNumbers</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>RandomGenerator &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const RandomGenerator &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RndVector</type>
      <name>theNumbers</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RndVector::iterator</type>
      <name>nextNumber</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>size_type</type>
      <name>theSize</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>theSeed</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; RandomGenerator &gt;</type>
      <name>initRandomGenerator</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; RandomGenerator, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01RandomGenerator_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; RandomGenerator &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01RandomGenerator_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; RandomGenerator &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Repository</name>
    <filename>classThePEG_1_1Repository.html</filename>
    <base>ThePEG::BaseRepository</base>
    <member kind="typedef">
      <type>map&lt; string, EGPtr &gt;</type>
      <name>GeneratorMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z986_0</anchor>
      <arglist>(IBPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>z986_1</anchor>
      <arglist>(IBPtr, string newName)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>defaultParticle</name>
      <anchor>z988_0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>PDPtr</type>
      <name>defaultParticle</name>
      <anchor>z988_1</anchor>
      <arglist>(long id)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tPDPtr</type>
      <name>findParticle</name>
      <anchor>z988_2</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ParticleDataSet &amp;</type>
      <name>allParticles</name>
      <anchor>z988_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const MatcherSet &amp;</type>
      <name>allMatchers</name>
      <anchor>z988_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tPMPtr</type>
      <name>findMatcher</name>
      <anchor>z988_5</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tDMPtr</type>
      <name>findDecayMode</name>
      <anchor>z988_6</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>copyParticle</name>
      <anchor>z988_7</anchor>
      <arglist>(tPDPtr, string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>EGPtr</type>
      <name>makeRun</name>
      <anchor>z990_0</anchor>
      <arglist>(tEGPtr eg, string name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>saveRun</name>
      <anchor>z990_1</anchor>
      <arglist>(string EGname, string name, string filename)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>load</name>
      <anchor>z992_0</anchor>
      <arglist>(string filename)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>save</name>
      <anchor>z992_1</anchor>
      <arglist>(string filename)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>save</name>
      <anchor>z992_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>stats</name>
      <anchor>z992_3</anchor>
      <arglist>(ostream &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>read</name>
      <anchor>z994_0</anchor>
      <arglist>(istream &amp;is, ostream &amp;os, string prompt=&quot;&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>exec</name>
      <anchor>z994_1</anchor>
      <arglist>(string cmd, ostream &amp;)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ParticleMap &amp;</type>
      <name>defaultParticles</name>
      <anchor>z996_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>ParticleDataSet &amp;</type>
      <name>particles</name>
      <anchor>z996_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>MatcherSet &amp;</type>
      <name>matchers</name>
      <anchor>z996_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DecayModeSet &amp;</type>
      <name>decayModes</name>
      <anchor>z996_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>GeneratorMap &amp;</type>
      <name>generators</name>
      <anchor>z996_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>string &amp;</type>
      <name>currentFileName</name>
      <anchor>z996_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>registerParticle</name>
      <anchor>h0</anchor>
      <arglist>(tPDPtr)</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>registerMatcher</name>
      <anchor>h1</anchor>
      <arglist>(tPMPtr)</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>registerDecayMode</name>
      <anchor>h2</anchor>
      <arglist>(tDMPtr)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardRandom</name>
    <filename>classThePEG_1_1StandardRandom.html</filename>
    <base>ThePEG::RandomGenerator</base>
    <member kind="function" virtualness="virtual">
      <type>virtual RandomEngine &amp;</type>
      <name>randomGenerator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setSeed</name>
      <anchor>a1</anchor>
      <arglist>(long seed)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardRandom</name>
      <anchor>z998_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardRandom</name>
      <anchor>z998_1</anchor>
      <arglist>(const StandardRandom &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StandardRandom</name>
      <anchor>z998_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1002_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1002_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1000_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1000_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1000_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1000_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1000_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1004_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1004_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardRandom &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardRandom &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>JamesRandom</type>
      <name>theRandomGenerator</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardRandom &gt;</type>
      <name>initStandardRandom</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardRandom, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardRandom_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>RandomGenerator</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardRandom &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardRandom_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardRandom &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Strategy</name>
    <filename>classThePEG_1_1Strategy.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>Strategy</name>
      <anchor>z1006_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Strategy</name>
      <anchor>z1006_1</anchor>
      <arglist>(const Strategy &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Strategy</name>
      <anchor>z1006_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const ParticleMap &amp;</type>
      <name>particles</name>
      <anchor>z1008_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const vector&lt; IPtr &gt; &amp;</type>
      <name>defaultObjects</name>
      <anchor>z1008_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1010_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1010_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1012_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1012_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1014_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1014_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1014_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ParticleMap &amp;</type>
      <name>particles</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>setLocalParticles</name>
      <anchor>d1</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>insLocalParticles</name>
      <anchor>d2</anchor>
      <arglist>(PDPtr pd, int)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>delLocalParticles</name>
      <anchor>d3</anchor>
      <arglist>(int place)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>vector&lt; PDPtr &gt;</type>
      <name>getLocalParticles</name>
      <anchor>d4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Strategy &amp;</type>
      <name>operator=</name>
      <anchor>d5</anchor>
      <arglist>(const Strategy &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ParticleMap</type>
      <name>theParticles</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; IPtr &gt;</type>
      <name>theDefaultObjects</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; Strategy &gt;</type>
      <name>initStrategy</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; Strategy, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01Strategy_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; Strategy &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01Strategy_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; Strategy &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ThePEGStrategy</name>
    <filename>classThePEG_1_1ThePEGStrategy.html</filename>
    <base>ThePEG::Strategy</base>
    <member kind="function">
      <type></type>
      <name>ThePEGStrategy</name>
      <anchor>z1016_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ThePEGStrategy</name>
      <anchor>z1016_1</anchor>
      <arglist>(const ThePEGStrategy &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ThePEGStrategy</name>
      <anchor>z1016_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1018_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1018_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1020_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1020_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1020_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1020_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1020_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ThePEGStrategy &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ThePEGStrategy &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; ThePEGStrategy &gt;</type>
      <name>initThePEGStrategy</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; ThePEGStrategy, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01ThePEGStrategy_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Strategy</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; ThePEGStrategy &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01ThePEGStrategy_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; ThePEGStrategy &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::UseRandom</name>
    <filename>classThePEG_1_1UseRandom.html</filename>
    <member kind="function">
      <type></type>
      <name>UseRandom</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UseRandom</name>
      <anchor>a1</anchor>
      <arglist>(const UseRandom &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>UseRandom</name>
      <anchor>a2</anchor>
      <arglist>(const RanGenPtr &amp;r)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~UseRandom</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RandomGenerator &amp;</type>
      <name>current</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e2</anchor>
      <arglist>(double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>rnd</name>
      <anchor>e3</anchor>
      <arglist>(double xl, double xu)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>e5</anchor>
      <arglist>(double p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>rndbool</name>
      <anchor>e6</anchor>
      <arglist>(double p1, double p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rndsign</name>
      <anchor>e7</anchor>
      <arglist>(double p1, double p2, double p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rnd2</name>
      <anchor>e8</anchor>
      <arglist>(double p0, double p1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rnd3</name>
      <anchor>e9</anchor>
      <arglist>(double p0, double p1, double p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>rnd4</name>
      <anchor>e10</anchor>
      <arglist>(double p0, double p1, double p2, double p3)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>irnd</name>
      <anchor>e11</anchor>
      <arglist>(long xu=2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>long</type>
      <name>irnd</name>
      <anchor>e12</anchor>
      <arglist>(long xl, long xu)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>UseRandom &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const UseRandom &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>randomPushed</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; RanGenPtr &gt;</type>
      <name>theRandomStack</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AlphaEMBase</name>
    <filename>classThePEG_1_1AlphaEMBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>value</name>
      <anchor>a0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;sm) const =0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AlphaEMBase</name>
      <anchor>z1022_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AlphaEMBase</name>
      <anchor>z1022_1</anchor>
      <arglist>(const AlphaEMBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~AlphaEMBase</name>
      <anchor>z1022_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>AlphaEMBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const AlphaEMBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; AlphaEMBase &gt;</type>
      <name>initAlphaEMBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; AlphaEMBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01AlphaEMBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; AlphaEMBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01AlphaEMBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; AlphaEMBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AlphaSBase</name>
    <filename>classThePEG_1_1AlphaSBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type></type>
      <name>AlphaSBase</name>
      <anchor>z1024_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>AlphaSBase</name>
      <anchor>z1024_1</anchor>
      <arglist>(const AlphaSBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~AlphaSBase</name>
      <anchor>z1024_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual double</type>
      <name>value</name>
      <anchor>z1026_0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;sm) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual vector&lt; Energy2 &gt;</type>
      <name>flavourThresholds</name>
      <anchor>z1026_1</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual vector&lt; Energy &gt;</type>
      <name>LambdaQCDs</name>
      <anchor>z1026_2</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>Nf</name>
      <anchor>z1028_0</anchor>
      <arglist>(Energy2 scale) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1028_1</anchor>
      <arglist>(unsigned int nflav) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1028_2</anchor>
      <arglist>(Energy2 scale) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1030_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1030_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1032_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1032_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1032_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>AlphaSBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const AlphaSBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Energy2 &gt;</type>
      <name>theFlavourThresholds</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; Energy &gt;</type>
      <name>theLambdaQCDs</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractClassDescription&lt; AlphaSBase &gt;</type>
      <name>initAlphaSBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; AlphaSBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01AlphaSBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; AlphaSBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01AlphaSBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; AlphaSBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CKMBase</name>
    <filename>classThePEG_1_1CKMBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function" virtualness="pure">
      <type>virtual vector&lt; vector&lt; double &gt; &gt;</type>
      <name>getMatrix</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int nf) const =0</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CKMBase</name>
      <anchor>z1034_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CKMBase</name>
      <anchor>z1034_1</anchor>
      <arglist>(const CKMBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CKMBase</name>
      <anchor>z1034_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CKMBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const CKMBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; CKMBase &gt;</type>
      <name>initCKMBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; CKMBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01CKMBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; CKMBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01CKMBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; CKMBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::O1AlphaS</name>
    <filename>classThePEG_1_1O1AlphaS.html</filename>
    <base>ThePEG::AlphaSBase</base>
    <member kind="function">
      <type>unsigned int</type>
      <name>getMaxFlav</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>O1AlphaS</name>
      <anchor>z1036_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>O1AlphaS</name>
      <anchor>z1036_1</anchor>
      <arglist>(const O1AlphaS &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~O1AlphaS</name>
      <anchor>z1036_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>value</name>
      <anchor>z1038_0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; Energy2 &gt;</type>
      <name>flavourThresholds</name>
      <anchor>z1038_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; Energy &gt;</type>
      <name>LambdaQCDs</name>
      <anchor>z1038_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1040_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1040_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1042_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1042_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1044_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1044_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1044_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1044_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1044_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>O1AlphaS &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const O1AlphaS &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Energy</type>
      <name>theLambdaQCD</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theLambdaFlavour</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theMaxFlav</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; O1AlphaS &gt;</type>
      <name>initO1AlphaS</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; O1AlphaS, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01O1AlphaS_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>AlphaSBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; O1AlphaS &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01O1AlphaS_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; O1AlphaS &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SimpleAlphaEM</name>
    <filename>classThePEG_1_1SimpleAlphaEM.html</filename>
    <base>ThePEG::AlphaEMBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual double</type>
      <name>value</name>
      <anchor>a0</anchor>
      <arglist>(Energy2 scale, const StandardModelBase &amp;) const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleAlphaEM</name>
      <anchor>z1046_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SimpleAlphaEM</name>
      <anchor>z1046_1</anchor>
      <arglist>(const SimpleAlphaEM &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SimpleAlphaEM</name>
      <anchor>z1046_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1048_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1048_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1050_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1050_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1050_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SimpleAlphaEM &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SimpleAlphaEM &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; SimpleAlphaEM &gt;</type>
      <name>initSimpleAlphaEM</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; SimpleAlphaEM, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01SimpleAlphaEM_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>AlphaEMBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; SimpleAlphaEM &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01SimpleAlphaEM_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; SimpleAlphaEM &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardCKM</name>
    <filename>classThePEG_1_1StandardCKM.html</filename>
    <base>ThePEG::CKMBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual vector&lt; vector&lt; double &gt; &gt;</type>
      <name>getMatrix</name>
      <anchor>a0</anchor>
      <arglist>(unsigned int nFamilies) const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardCKM</name>
      <anchor>z1052_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardCKM</name>
      <anchor>z1052_1</anchor>
      <arglist>(const StandardCKM &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StandardCKM</name>
      <anchor>z1052_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1054_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1054_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1056_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1056_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1058_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1058_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1058_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1058_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1058_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardCKM &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardCKM &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theta12</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theta13</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theta23</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>delta</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardCKM &gt;</type>
      <name>initStandardCKM</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardCKM, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardCKM_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>CKMBase</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardCKM &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardCKM_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardCKM &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StandardModelBase</name>
    <filename>classThePEG_1_1StandardModelBase.html</filename>
    <base>ThePEG::Interfaced</base>
    <member kind="function">
      <type>unsigned int</type>
      <name>families</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardModelBase</name>
      <anchor>z1060_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>StandardModelBase</name>
      <anchor>z1060_1</anchor>
      <arglist>(const StandardModelBase &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~StandardModelBase</name>
      <anchor>z1060_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaEM</name>
      <anchor>z1062_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaEM</name>
      <anchor>z1062_1</anchor>
      <arglist>(Energy2 scale) const</arglist>
    </member>
    <member kind="function">
      <type>tAEMPtr</type>
      <name>alphaEMPtr</name>
      <anchor>z1062_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>sin2ThetaW</name>
      <anchor>z1062_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>enu</name>
      <anchor>z1062_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ee</name>
      <anchor>z1062_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>eu</name>
      <anchor>z1062_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ed</name>
      <anchor>z1062_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>vnu</name>
      <anchor>z1062_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ve</name>
      <anchor>z1062_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>vu</name>
      <anchor>z1062_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>vd</name>
      <anchor>z1062_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>anu</name>
      <anchor>z1062_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ae</name>
      <anchor>z1062_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>au</name>
      <anchor>z1062_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>ad</name>
      <anchor>z1062_15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>CKM</name>
      <anchor>z1062_16</anchor>
      <arglist>(unsigned int uf, unsigned int df) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>CKM</name>
      <anchor>z1062_17</anchor>
      <arglist>(const ParticleData &amp;uType, const ParticleData &amp;dType) const</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>Nc</name>
      <anchor>z1064_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>Nf</name>
      <anchor>z1064_1</anchor>
      <arglist>(Energy2 scale) const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaS</name>
      <anchor>z1064_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>alphaS</name>
      <anchor>z1064_3</anchor>
      <arglist>(Energy2 scale) const</arglist>
    </member>
    <member kind="function">
      <type>tASPtr</type>
      <name>alphaSPtr</name>
      <anchor>z1064_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1064_5</anchor>
      <arglist>(unsigned int nflav) const</arglist>
    </member>
    <member kind="function">
      <type>Energy</type>
      <name>LambdaQCD</name>
      <anchor>z1064_6</anchor>
      <arglist>(Energy2 scale) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentOutput</name>
      <anchor>z1066_0</anchor>
      <arglist>(PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>persistentInput</name>
      <anchor>z1066_1</anchor>
      <arglist>(PersistentIStream &amp;is, int version)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>clone</name>
      <anchor>z1068_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IBPtr</type>
      <name>fullclone</name>
      <anchor>z1068_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doupdate</name>
      <anchor>z1070_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>doinit</name>
      <anchor>z1070_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>dofinish</name>
      <anchor>z1070_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z1070_3</anchor>
      <arglist>(const TranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" protection="protected" virtualness="virtual">
      <type>virtual IVector</type>
      <name>getReferences</name>
      <anchor>z1070_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaEMBase &gt;::pointer</type>
      <name>AEMPtr</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaSBase &gt;::pointer</type>
      <name>ASPtr</name>
      <anchor>y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; CKMBase &gt;::pointer</type>
      <name>CKMPtr</name>
      <anchor>y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaEMBase &gt;::transient_pointer</type>
      <name>tAEMPtr</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; AlphaSBase &gt;::transient_pointer</type>
      <name>tASPtr</name>
      <anchor>y4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>Ptr&lt; CKMBase &gt;::transient_pointer</type>
      <name>tCKMPtr</name>
      <anchor>y5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type>StandardModelBase &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const StandardModelBase &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theFamilies</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAlphaEM</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>AEMPtr</type>
      <name>theRunningAlphaEM</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theSin2ThetaW</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEnu</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEe</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEu</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theEd</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVnu</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVe</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVu</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theVd</name>
      <anchor>r11</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAnu</name>
      <anchor>r12</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAe</name>
      <anchor>r13</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAu</name>
      <anchor>r14</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAd</name>
      <anchor>r15</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>recalculateEW</name>
      <anchor>r16</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CKMPtr</type>
      <name>theCKM</name>
      <anchor>r17</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; vector&lt; double &gt; &gt;</type>
      <name>theCKM2Matrix</name>
      <anchor>r18</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNc</name>
      <anchor>r19</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>double</type>
      <name>theAlphaS</name>
      <anchor>r20</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ASPtr</type>
      <name>theRunningAlphaS</name>
      <anchor>r21</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ClassDescription&lt; StandardModelBase &gt;</type>
      <name>initStandardModelBase</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait&lt; StandardModelBase, 1 &gt;</name>
    <filename>structThePEG_1_1BaseClassTrait_3_01StandardModelBase_00_011_01_4.html</filename>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Interfaced</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits&lt; StandardModelBase &gt;</name>
    <filename>structThePEG_1_1ClassTraits_3_01StandardModelBase_01_4.html</filename>
    <base>ThePEG::ClassTraitsBase&lt; StandardModelBase &gt;</base>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::CFileLineReader</name>
    <filename>classThePEG_1_1CFileLineReader.html</filename>
    <member kind="function">
      <type>bool</type>
      <name>readline</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>getline</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>FILE *</type>
      <name>cfile</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator void *</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>skip</name>
      <anchor>a5</anchor>
      <arglist>(char c)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>find</name>
      <anchor>a6</anchor>
      <arglist>(string str) const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>z1072_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>z1072_1</anchor>
      <arglist>(FILE *f, int len=defsize)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>z1072_2</anchor>
      <arglist>(string filename, int len=defsize)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~CFileLineReader</name>
      <anchor>z1072_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>open</name>
      <anchor>z1074_0</anchor>
      <arglist>(FILE *f)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>open</name>
      <anchor>z1074_1</anchor>
      <arglist>(string filename)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>close</name>
      <anchor>z1074_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>char</type>
      <name>getc</name>
      <anchor>z1076_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_1</anchor>
      <arglist>(long &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_2</anchor>
      <arglist>(int &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_3</anchor>
      <arglist>(unsigned long &amp;l)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_4</anchor>
      <arglist>(unsigned int &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_5</anchor>
      <arglist>(double &amp;d)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_6</anchor>
      <arglist>(float &amp;f)</arglist>
    </member>
    <member kind="function">
      <type>CFileLineReader &amp;</type>
      <name>operator&gt;&gt;</name>
      <anchor>z1076_7</anchor>
      <arglist>(std::string &amp;s)</arglist>
    </member>
    <member kind="enumeration">
      <name>StreamType</name>
      <anchor>y3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown</name>
      <anchor>y3y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>plainfile</name>
      <anchor>y3y1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pipe</name>
      <anchor>y3y2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>CFileLineReader</name>
      <anchor>d0</anchor>
      <arglist>(const CFileLineReader &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>CFileLineReader &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const CFileLineReader &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>FILE *</type>
      <name>file</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>bufflen</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char *</type>
      <name>buff</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>char *</type>
      <name>pos</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>bad</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>StreamType</type>
      <name>type</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>const int</type>
      <name>defsize</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDescriptionBase</name>
    <filename>classThePEG_1_1ClassDescriptionBase.html</filename>
    <base>ThePEG::Named</base>
    <member kind="typedef">
      <type>vector&lt; const ClassDescriptionBase * &gt;</type>
      <name>DescriptionVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDescriptionBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const type_info &amp;</type>
      <name>info</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>version</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>library</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>check</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const DescriptionVector &amp;</type>
      <name>descriptions</name>
      <anchor>a5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>a6</anchor>
      <arglist>()=0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a7</anchor>
      <arglist>() const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a8</anchor>
      <arglist>(tcBPtr b, PersistentOStream &amp;os) const =0</arglist>
    </member>
    <member kind="function" virtualness="pure">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a9</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is, int oldVersion) const =0</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>isA</name>
      <anchor>a10</anchor>
      <arglist>(const ClassDescriptionBase &amp;base) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ClassDescriptionBase</name>
      <anchor>b0</anchor>
      <arglist>(string newName, const type_info &amp;newInfo, int newVersion, string newLibrary)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>baseClasses</name>
      <anchor>b1</anchor>
      <arglist>(DescriptionVector::iterator first, DescriptionVector::iterator last)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>theVersion</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theLibrary</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const type_info &amp;</type>
      <name>theInfo</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DescriptionVector</type>
      <name>theBaseClasses</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>done</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDescriptionTBase</name>
    <filename>classThePEG_1_1ClassDescriptionTBase.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ClassDescriptionTBase</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ClassDescriptionTBase</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>setup</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AbstractClassDescription</name>
    <filename>classThePEG_1_1AbstractClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr b, PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is, int oldVersion) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ClassDescription</name>
    <filename>classThePEG_1_1ClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr b, PersistentOStream &amp;os) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr b, PersistentIStream &amp;is, int oldVersion) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::NoPIOClassDescription</name>
    <filename>classThePEG_1_1NoPIOClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr, PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr, PersistentIStream &amp;, int) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::AbstractNoPIOClassDescription</name>
    <filename>classThePEG_1_1AbstractNoPIOClassDescription.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassDescriptionTBase</base>
    <member kind="typedef">
      <type>ClassTraits&lt; T &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual BPtr</type>
      <name>create</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>(tcBPtr, PersistentOStream &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>input</name>
      <anchor>a2</anchor>
      <arglist>(tBPtr, PersistentIStream &amp;, int) const</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassDescriptionHelper</name>
    <filename>structThePEG_1_1ClassDescriptionHelper.html</filename>
    <templarg>T</templarg>
    <templarg>IBase</templarg>
    <templarg>B</templarg>
    <member kind="function" static="yes">
      <type>void</type>
      <name>addBases</name>
      <anchor>e0</anchor>
      <arglist>(vector&lt; const ClassDescriptionBase * &gt; &amp;c)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassDescriptionHelper&lt; T, IBase, int &gt;</name>
    <filename>structThePEG_1_1ClassDescriptionHelper_3_01T_00_01IBase_00_01int_01_4.html</filename>
    <templarg>T</templarg>
    <templarg>IBase</templarg>
    <member kind="function" static="yes">
      <type>void</type>
      <name>addBases</name>
      <anchor>e0</anchor>
      <arglist>(vector&lt; const ClassDescriptionBase * &gt; &amp;c)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraitsType</name>
    <filename>structThePEG_1_1ClassTraitsType.html</filename>
    <base>ThePEG::TraitsType</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraitsBase</name>
    <filename>structThePEG_1_1ClassTraitsBase.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>TPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::const_pointer</type>
      <name>cTPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_pointer</type>
      <name>tTPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_const_pointer</type>
      <name>tcTPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::pointer</type>
      <name>BPtr</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::const_pointer</type>
      <name>cBPtr</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_pointer</type>
      <name>tBPtr</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; Base &gt;::transient_const_pointer</type>
      <name>tcBPtr</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>create</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>className</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>version</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>library</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>output</name>
      <anchor>e4</anchor>
      <arglist>(tcTPtr t, PersistentOStream &amp;os)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>input</name>
      <anchor>e5</anchor>
      <arglist>(tTPtr t, PersistentIStream &amp;is, int oldVersion)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TPtr</type>
      <name>cast</name>
      <anchor>e6</anchor>
      <arglist>(BPtr b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>cTPtr</type>
      <name>cast</name>
      <anchor>e7</anchor>
      <arglist>(cBPtr b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tTPtr</type>
      <name>cast</name>
      <anchor>e8</anchor>
      <arglist>(tBPtr b)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>tcTPtr</type>
      <name>cast</name>
      <anchor>e9</anchor>
      <arglist>(tcBPtr b)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ClassTraits</name>
    <filename>structThePEG_1_1ClassTraits.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::ClassTraitsBase</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::BaseClassTrait</name>
    <filename>structThePEG_1_1BaseClassTrait.html</filename>
    <templarg>Derived</templarg>
    <templarg>BaseN</templarg>
    <base>ThePEG::ClassTraitsType</base>
    <member kind="typedef">
      <type>int</type>
      <name>NthBase</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Debug</name>
    <filename>classThePEG_1_1Debug.html</filename>
    <member kind="enumeration">
      <name>Levels</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>noDebug</name>
      <anchor>w4w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>printSomeEvents</name>
      <anchor>w4w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>printEveryEvent</name>
      <anchor>w4w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>full</name>
      <anchor>w4w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>debugItem</name>
      <anchor>e0</anchor>
      <arglist>(int item, bool on)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setDebug</name>
      <anchor>e1</anchor>
      <arglist>(int ilev)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>debugItem</name>
      <anchor>e2</anchor>
      <arglist>(int item)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuErrors</name>
      <anchor>z1078_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuOverflow</name>
      <anchor>z1078_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuUnderflow</name>
      <anchor>z1078_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuDivZero</name>
      <anchor>z1078_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuDenorm</name>
      <anchor>z1078_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>unmaskFpuInvalid</name>
      <anchor>z1078_5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuErrors</name>
      <anchor>z1078_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuOverflow</name>
      <anchor>z1078_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuUnderflow</name>
      <anchor>z1078_8</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuDivZero</name>
      <anchor>z1078_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuDenorm</name>
      <anchor>z1078_10</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>maskFpuInvalid</name>
      <anchor>z1078_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>int</type>
      <name>level</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>std::vector&lt; bool &gt;</type>
      <name>debugItems</name>
      <anchor>s1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DescriptionList</name>
    <filename>classThePEG_1_1DescriptionList.html</filename>
    <member kind="typedef">
      <type>map&lt; const type_info *, ClassDescriptionBase * &gt;</type>
      <name>DescriptionMap</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; string, ClassDescriptionBase * &gt;</type>
      <name>StringMap</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Register</name>
      <anchor>e0</anchor>
      <arglist>(ClassDescriptionBase &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ClassDescriptionBase *</type>
      <name>find</name>
      <anchor>e1</anchor>
      <arglist>(const type_info &amp;ti)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const ClassDescriptionBase *</type>
      <name>find</name>
      <anchor>e2</anchor>
      <arglist>(const string &amp;name)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>printHierarchies</name>
      <anchor>e3</anchor>
      <arglist>(ostream &amp;os)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>hookup</name>
      <anchor>f0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>void</type>
      <name>insert</name>
      <anchor>f1</anchor>
      <arglist>(ClassDescriptionBase &amp;pb)</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>DescriptionMap &amp;</type>
      <name>descriptionMap</name>
      <anchor>f2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected" static="yes">
      <type>StringMap &amp;</type>
      <name>stringMap</name>
      <anchor>f3</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Direction</name>
    <filename>classThePEG_1_1Direction.html</filename>
    <templarg>I</templarg>
    <member kind="enumeration">
      <name>Dir</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Neg</name>
      <anchor>w5w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Negative</name>
      <anchor>w5w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Undefined</name>
      <anchor>w5w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Pos</name>
      <anchor>w5w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Positive</name>
      <anchor>w5w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Direction</name>
      <anchor>a0</anchor>
      <arglist>(Dir newDirection)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Direction</name>
      <anchor>a1</anchor>
      <arglist>(double rnd)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Direction</name>
      <anchor>a2</anchor>
      <arglist>(bool p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Direction</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>set</name>
      <anchor>e0</anchor>
      <arglist>(Dir newDirection)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>reverse</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>pos</name>
      <anchor>e2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>neg</name>
      <anchor>e3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Dir</type>
      <name>dir</name>
      <anchor>e4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Direction</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Direction</name>
      <anchor>d1</anchor>
      <arglist>(const Direction &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Direction &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const Direction &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>Dir</type>
      <name>theDirection</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::MultipleDirectionException</name>
    <filename>structThePEG_1_1MultipleDirectionException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>MultipleDirectionException</name>
      <anchor>a0</anchor>
      <arglist>(int)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::UndefinedDirectionException</name>
    <filename>structThePEG_1_1UndefinedDirectionException.html</filename>
    <base>ThePEG::Exception</base>
    <member kind="function">
      <type></type>
      <name>UndefinedDirectionException</name>
      <anchor>a0</anchor>
      <arglist>(int)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DIterator</name>
    <filename>classThePEG_1_1DIterator.html</filename>
    <templarg>BaseIterator</templarg>
    <member kind="typedef">
      <type>std::iterator_traits&lt; BaseIterator &gt;</type>
      <name>Traits</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Traits::iterator_category</type>
      <name>iterator_category</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Traits::difference_type</type>
      <name>difference_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Traits::value_type</type>
      <name>PtrType</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>std::iterator_traits&lt; PtrType &gt;</type>
      <name>PtrTraits</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtrTraits::value_type</type>
      <name>value_type</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtrTraits::pointer</type>
      <name>pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>PtrTraits::reference</type>
      <name>reference</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DIterator</name>
      <anchor>a0</anchor>
      <arglist>(const BaseIterator &amp;in)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>DIterator</name>
      <anchor>a1</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator *</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>operator-&gt;</name>
      <anchor>a3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const BaseIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator[]</name>
      <anchor>a6</anchor>
      <arglist>(difference_type n)</arglist>
    </member>
    <member kind="function">
      <type>difference_type</type>
      <name>operator-</name>
      <anchor>a7</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator++</name>
      <anchor>z1080_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator++</name>
      <anchor>z1080_1</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator--</name>
      <anchor>z1080_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator--</name>
      <anchor>z1080_3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator+=</name>
      <anchor>z1080_4</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator+</name>
      <anchor>z1080_5</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>DIterator &amp;</type>
      <name>operator-=</name>
      <anchor>z1080_6</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>DIterator</type>
      <name>operator-</name>
      <anchor>z1080_7</anchor>
      <arglist>(int n)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z1082_0</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>z1082_1</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>z1082_2</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;</name>
      <anchor>z1082_3</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;=</name>
      <anchor>z1082_4</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;=</name>
      <anchor>z1082_5</anchor>
      <arglist>(const DIterator &amp;pi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z1082_6</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>z1082_7</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>z1082_8</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;</name>
      <anchor>z1082_9</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;=</name>
      <anchor>z1082_10</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&gt;=</name>
      <anchor>z1082_11</anchor>
      <arglist>(const BaseIterator &amp;bi)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>DIterator</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>BaseIterator</type>
      <name>i</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::DynamicLoader</name>
    <filename>classThePEG_1_1DynamicLoader.html</filename>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>loadcmd</name>
      <anchor>e0</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>load</name>
      <anchor>e1</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>appendPath</name>
      <anchor>e2</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>prependPath</name>
      <anchor>e3</anchor>
      <arglist>(string)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>string</type>
      <name>lastErrorMessage</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>vector&lt; string &gt;</type>
      <name>defaultPaths</name>
      <anchor>h0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>vector&lt; string &gt;</type>
      <name>paths</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::OEnum</name>
    <filename>structThePEG_1_1OEnum.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>OEnum</name>
      <anchor>a0</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OEnum</name>
      <anchor>a1</anchor>
      <arglist>(const OEnum &amp;oe)</arglist>
    </member>
    <member kind="variable">
      <type>const T &amp;</type>
      <name>theT</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IEnum</name>
    <filename>structThePEG_1_1IEnum.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>IEnum</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IEnum</name>
      <anchor>a1</anchor>
      <arglist>(const IEnum &amp;ie)</arglist>
    </member>
    <member kind="variable">
      <type>T &amp;</type>
      <name>theT</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Exception</name>
    <filename>classThePEG_1_1Exception.html</filename>
    <member kind="enumeration">
      <name>Severity</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown</name>
      <anchor>w7w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>info</name>
      <anchor>w7w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>warning</name>
      <anchor>w7w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eventerror</name>
      <anchor>w7w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>runerror</name>
      <anchor>w7w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>maybeabort</name>
      <anchor>w7w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>abortnow</name>
      <anchor>w7w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a0</anchor>
      <arglist>(const string &amp;str, Severity sev)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Exception</name>
      <anchor>a2</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~Exception</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Exception &amp;</type>
      <name>operator=</name>
      <anchor>a4</anchor>
      <arglist>(const Exception &amp;)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a5</anchor>
      <arglist>(const Exception &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a6</anchor>
      <arglist>(const Exception &amp;) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual const char *</type>
      <name>what</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>message</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>writeMessage</name>
      <anchor>a9</anchor>
      <arglist>(ostream &amp;os=*errstream) const</arglist>
    </member>
    <member kind="function">
      <type>Severity</type>
      <name>severity</name>
      <anchor>a10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>handle</name>
      <anchor>a11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Exception &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a12</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>Exception &amp;</type>
      <name>operator&lt;&lt;</name>
      <anchor>a13</anchor>
      <arglist>(Severity sev)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>severity</name>
      <anchor>b0</anchor>
      <arglist>(Severity)</arglist>
    </member>
    <member kind="variable" protection="protected">
      <type>ostringstream</type>
      <name>theMessage</name>
      <anchor>p0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>handled</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Severity</type>
      <name>theSeverity</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ostream *</type>
      <name>errstream</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::FixedSizeAllocator</name>
    <filename>classThePEG_1_1FixedSizeAllocator.html</filename>
    <templarg>Size</templarg>
    <templarg>ChunkSize</templarg>
    <member kind="function" static="yes">
      <type>void *</type>
      <name>allocate</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>deallocate</name>
      <anchor>e1</anchor>
      <arglist>(void *)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>std::vector&lt; void * &gt;</type>
      <name>FreeStack</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>grow</name>
      <anchor>h0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void *</type>
      <name>newallocate</name>
      <anchor>h1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>ChunkStack</type>
      <name>chunkstack</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>FreeStack</type>
      <name>freestack</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>size_t</type>
      <name>last</name>
      <anchor>v2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FixedSizeAllocator::ChunkStack</name>
    <filename>structThePEG_1_1FixedSizeAllocator_1_1ChunkStack.html</filename>
    <member kind="typedef">
      <type>vector&lt; char * &gt;</type>
      <name>Stack</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ChunkStack</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>Stack</type>
      <name>s</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FixedSizeAllocator::ChunkStack</name>
    <filename>structThePEG_1_1FixedSizeAllocator_1_1ChunkStack.html</filename>
    <member kind="typedef">
      <type>vector&lt; char * &gt;</type>
      <name>Stack</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ChunkStack</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable">
      <type>Stack</type>
      <name>s</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SizeOf8</name>
    <filename>structThePEG_1_1SizeOf8.html</filename>
    <templarg>T</templarg>
    <member kind="variable" static="yes">
      <type>const size_t</type>
      <name>size</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::FixedAllocator</name>
    <filename>structThePEG_1_1FixedAllocator.html</filename>
    <templarg>T</templarg>
    <templarg>ChunkSize</templarg>
    <member kind="typedef">
      <type>FixedSizeAllocator&lt; SizeOf8&lt; T &gt;::size, ChunkSize &gt;</type>
      <name>BaseType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>allocate</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Allocator</name>
    <filename>classThePEG_1_1Allocator.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>std::allocator&lt; T &gt;</type>
      <name>BaseAllocator</name>
      <anchor>z1084_0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::size_type</type>
      <name>size_type</name>
      <anchor>z1084_1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::difference_type</type>
      <name>difference_type</name>
      <anchor>z1084_2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::pointer</type>
      <name>pointer</name>
      <anchor>z1084_3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::const_pointer</type>
      <name>const_pointer</name>
      <anchor>z1084_4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::reference</type>
      <name>reference</name>
      <anchor>z1084_5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::const_reference</type>
      <name>const_reference</name>
      <anchor>z1084_6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>BaseAllocator::value_type</type>
      <name>value_type</name>
      <anchor>z1084_7</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Allocator</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Allocator</name>
      <anchor>a1</anchor>
      <arglist>(const Allocator &amp;x)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Allocator</name>
      <anchor>a2</anchor>
      <arglist>(const Allocator&lt; T1 &gt; &amp;x)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Allocator</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>address</name>
      <anchor>a4</anchor>
      <arglist>(reference x) const</arglist>
    </member>
    <member kind="function">
      <type>const_pointer</type>
      <name>address</name>
      <anchor>a5</anchor>
      <arglist>(const_reference x) const</arglist>
    </member>
    <member kind="function">
      <type>T *</type>
      <name>allocate</name>
      <anchor>a6</anchor>
      <arglist>(size_type n, const void *vp=0)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>deallocate</name>
      <anchor>a7</anchor>
      <arglist>(pointer p, size_type n)</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>max_size</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>construct</name>
      <anchor>a9</anchor>
      <arglist>(pointer p, const T &amp;val)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>destroy</name>
      <anchor>a10</anchor>
      <arglist>(pointer p)</arglist>
    </member>
    <member kind="variable">
      <type>BaseAllocator</type>
      <name>fallback</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Allocator::rebind</name>
    <filename>structThePEG_1_1Allocator_1_1rebind.html</filename>
    <templarg>T1</templarg>
    <member kind="typedef">
      <type>Allocator&lt; T1 &gt;</type>
      <name>other</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Allocator::rebind</name>
    <filename>structThePEG_1_1Allocator_1_1rebind.html</filename>
    <templarg>T1</templarg>
    <member kind="typedef">
      <type>Allocator&lt; T1 &gt;</type>
      <name>other</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HoldFlag</name>
    <filename>classThePEG_1_1HoldFlag.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;newFlag, const T &amp;holdFlag)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a1</anchor>
      <arglist>(T &amp;newFlag, const T &amp;holdFlag, const T &amp;finalFlag)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HoldFlag</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d1</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HoldFlag &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T &amp;</type>
      <name>theFlag</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T</type>
      <name>oldFlag</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::HoldFlag&lt; bool &gt;</name>
    <filename>classThePEG_1_1HoldFlag_3_01bool_01_4.html</filename>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a0</anchor>
      <arglist>(bool &amp;newFlag, bool holdFlag=true)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HoldFlag</name>
      <anchor>a1</anchor>
      <arglist>(bool &amp;newFlag, bool holdFlag, bool finalFlag)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~HoldFlag</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>HoldFlag</name>
      <anchor>d1</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HoldFlag &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const HoldFlag &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool &amp;</type>
      <name>theFlag</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>oldFlag</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Interval</name>
    <filename>classThePEG_1_1Interval.html</filename>
    <templarg>T</templarg>
    <templarg>CMP</templarg>
    <member kind="function">
      <type></type>
      <name>Interval</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Interval</name>
      <anchor>a1</anchor>
      <arglist>(T dn, T up)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Interval</name>
      <anchor>a2</anchor>
      <arglist>(const Interval &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>const Interval &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const Interval &amp;i)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a4</anchor>
      <arglist>(const Interval &amp;i) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a5</anchor>
      <arglist>(const Interval &amp;i) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>check</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator()</name>
      <anchor>a7</anchor>
      <arglist>(T x) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>includes</name>
      <anchor>a8</anchor>
      <arglist>(T x) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>includes</name>
      <anchor>a9</anchor>
      <arglist>(const Interval&lt; T, CMP &gt; &amp;i) const</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>chopUpper</name>
      <anchor>a10</anchor>
      <arglist>(T x)</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>chopLower</name>
      <anchor>a11</anchor>
      <arglist>(T x)</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>overlap</name>
      <anchor>a12</anchor>
      <arglist>(const Interval &amp;i) const</arglist>
    </member>
    <member kind="function">
      <type>Interval&lt; T, CMP &gt;</type>
      <name>sum</name>
      <anchor>a13</anchor>
      <arglist>(const Interval &amp;i) const</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>upper</name>
      <anchor>a14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>lower</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>upper</name>
      <anchor>a16</anchor>
      <arglist>(T up)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>lower</name>
      <anchor>a17</anchor>
      <arglist>(T dn)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>check</name>
      <anchor>e0</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>checkAll</name>
      <anchor>e1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>std::vector&lt; Interval&lt; T, CMP &gt; &gt;</type>
      <name>split</name>
      <anchor>e2</anchor>
      <arglist>(Interval&lt; T, CMP &gt;, T x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>std::vector&lt; Interval&lt; T, CMP &gt; &gt;</type>
      <name>split</name>
      <anchor>e3</anchor>
      <arglist>(Interval&lt; T, CMP &gt;, Iterator first, Iterator last)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>std::pair&lt; T, T &gt;</type>
      <name>theLimits</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>CMP</type>
      <name>cmp</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Level</name>
    <filename>classThePEG_1_1Level.html</filename>
    <templarg>T</templarg>
    <member kind="function">
      <type></type>
      <name>Level</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;newLevel)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Level</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Level</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Level</name>
      <anchor>d1</anchor>
      <arglist>(const Level &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Level &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const Level &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>T &amp;</type>
      <name>theLevel</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::LoopGuard</name>
    <filename>classThePEG_1_1LoopGuard.html</filename>
    <templarg>ExceptionT</templarg>
    <templarg>MessageT</templarg>
    <member kind="function">
      <type></type>
      <name>LoopGuard</name>
      <anchor>a0</anchor>
      <arglist>(const MessageT &amp;mess, long maxc=1000000)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>LoopGuard</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>LoopGuard</name>
      <anchor>d1</anchor>
      <arglist>(const LoopGuard &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>count</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>long</type>
      <name>maxCount</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const MessageT &amp;</type>
      <name>message</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Named</name>
    <filename>classThePEG_1_1Named.html</filename>
    <member kind="function">
      <type></type>
      <name>Named</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Named</name>
      <anchor>a1</anchor>
      <arglist>(const string &amp;newName)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Named</name>
      <anchor>a2</anchor>
      <arglist>(const Named &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Named</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const string &amp;</type>
      <name>name</name>
      <anchor>a4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a5</anchor>
      <arglist>(const Named &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a6</anchor>
      <arglist>(const Named &amp;) const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const Named &amp;</type>
      <name>operator=</name>
      <anchor>b0</anchor>
      <arglist>(const Named &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>const string &amp;</type>
      <name>name</name>
      <anchor>b1</anchor>
      <arglist>(const string &amp;newName)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>theName</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ObjectIndexer</name>
    <filename>classThePEG_1_1ObjectIndexer.html</filename>
    <templarg>IntT</templarg>
    <templarg>ObjT</templarg>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::pointer</type>
      <name>TPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::const_pointer</type>
      <name>cTPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::transient_pointer</type>
      <name>tTPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ObjT &gt;::transient_const_pointer</type>
      <name>tcTPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; IntT, tTPtr &gt;</type>
      <name>IndexObjectMap</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; TPtr, IntT &gt;</type>
      <name>ObjectIndexMap</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>IntT</type>
      <name>operator()</name>
      <anchor>a0</anchor>
      <arglist>(tTPtr o)</arglist>
    </member>
    <member kind="function">
      <type>tTPtr</type>
      <name>operator()</name>
      <anchor>a1</anchor>
      <arglist>(IntT i)</arglist>
    </member>
    <member kind="function">
      <type>tTPtr</type>
      <name>operator()</name>
      <anchor>a2</anchor>
      <arglist>(IntT i) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>operator()</name>
      <anchor>a3</anchor>
      <arglist>(IntT i, tTPtr o)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>included</name>
      <anchor>a4</anchor>
      <arglist>(tTPtr o) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>included</name>
      <anchor>a5</anchor>
      <arglist>(IntT i) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ObjectIndexer &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ObjectIndexer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>IndexObjectMap</type>
      <name>indexObject</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectIndexMap</type>
      <name>objectIndex</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Rebinder</name>
    <filename>classThePEG_1_1Rebinder.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>TPtr</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::const_pointer</type>
      <name>cTPtr</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_pointer</type>
      <name>tTPtr</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; T &gt;::transient_const_pointer</type>
      <name>tcTPtr</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>map&lt; cTPtr, TPtr &gt;</type>
      <name>MapType</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Rebinder</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TPtr &amp;</type>
      <name>operator[]</name>
      <anchor>a1</anchor>
      <arglist>(tcTPtr)</arglist>
    </member>
    <member kind="function">
      <type>R</type>
      <name>translate</name>
      <anchor>a2</anchor>
      <arglist>(const R &amp;r) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>translate</name>
      <anchor>a3</anchor>
      <arglist>(OutputIterator ouptut, InputIterator first, InputIterator last) const</arglist>
    </member>
    <member kind="function">
      <type>R</type>
      <name>alwaysTranslate</name>
      <anchor>a4</anchor>
      <arglist>(const R &amp;r) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>alwaysTranslate</name>
      <anchor>a5</anchor>
      <arglist>(OutputIterator, InputIterator, InputIterator) const</arglist>
    </member>
    <member kind="function">
      <type>const MapType &amp;</type>
      <name>map</name>
      <anchor>a6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Rebinder</name>
      <anchor>d0</anchor>
      <arglist>(const Rebinder &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Rebinder &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const Rebinder &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MapType</type>
      <name>theMap</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Selector</name>
    <filename>classThePEG_1_1Selector.html</filename>
    <templarg>T</templarg>
    <templarg>WeightType</templarg>
    <member kind="typedef">
      <type>map&lt; WeightType, T, less&lt; WeightType &gt;, Allocator&lt; T &gt; &gt;</type>
      <name>MapType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::iterator</type>
      <name>iterator</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>MapType::size_type</type>
      <name>size_type</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Selector</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Selector</name>
      <anchor>a1</anchor>
      <arglist>(const Selector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Selector</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Selector &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const Selector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a4</anchor>
      <arglist>(Selector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>insert</name>
      <anchor>a5</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>reweight</name>
      <anchor>a6</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>erase</name>
      <anchor>a7</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a8</anchor>
      <arglist>(const T &amp;oldObject, const T &amp;newObject)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a9</anchor>
      <arglist>(double rnd, double *remainder=0)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a10</anchor>
      <arglist>(double rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a11</anchor>
      <arglist>(double rnd, double *remainder=0) const</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>operator[]</name>
      <anchor>a12</anchor>
      <arglist>(double rnd) const</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a13</anchor>
      <arglist>(RNDGEN &amp;rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a14</anchor>
      <arglist>(RNDGEN &amp;rnd) const</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>sum</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a20</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a21</anchor>
      <arglist>(OStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a22</anchor>
      <arglist>(IStream &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>MapType</type>
      <name>theMap</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightType</type>
      <name>theSum</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::SimplePhaseSpace</name>
    <filename>structThePEG_1_1SimplePhaseSpace.html</filename>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e0</anchor>
      <arglist>(Energy2 s, PType &amp;p1, PType &amp;p2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e1</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, Energy2 s, double cosTheta, double phi)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e2</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, Energy2 s, Energy2 t, double phi, const PType &amp;p0)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e3</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, Energy2 s)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e4</anchor>
      <arglist>(const PPairType &amp;p, Energy2 s)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e5</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, PType &amp;p3, Energy2 s, double x1, double x3)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMS</name>
      <anchor>e6</anchor>
      <arglist>(PType &amp;p1, PType &amp;p2, PType &amp;p3, Energy2 s, double x1, double x3, double phii=0.0, double theta=0.0, double phi=0.0)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Energy</type>
      <name>getMagnitude</name>
      <anchor>e7</anchor>
      <arglist>(Energy2 s, Energy m1, Energy m2)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>Momentum3</type>
      <name>polar3Vector</name>
      <anchor>e8</anchor>
      <arglist>(Energy p, double costheta, double phi)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>vector&lt; LorentzMomentum &gt;</type>
      <name>CMSn</name>
      <anchor>e9</anchor>
      <arglist>(Energy m0, const vector&lt; Energy &gt; &amp;m)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>CMSn</name>
      <anchor>e10</anchor>
      <arglist>(Container &amp;particles, Energy m0)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::ImpossibleKinematics</name>
    <filename>structThePEG_1_1ImpossibleKinematics.html</filename>
    <member kind="function">
      <type></type>
      <name>ImpossibleKinematics</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::ostringstream</name>
    <filename>classThePEG_1_1ostringstream.html</filename>
    <member kind="function">
      <type></type>
      <name>ostringstream</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ostringstream</name>
      <anchor>a1</anchor>
      <arglist>(const string &amp;)</arglist>
    </member>
    <member kind="function">
      <type>string</type>
      <name>str</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>ostringstream</name>
      <anchor>d0</anchor>
      <arglist>(const ostringstream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ostringstream &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const ostringstream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>operator==</name>
      <anchor>d2</anchor>
      <arglist>(const ostringstream &amp;) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::istringstream</name>
    <filename>classThePEG_1_1istringstream.html</filename>
    <member kind="function">
      <type></type>
      <name>istringstream</name>
      <anchor>a0</anchor>
      <arglist>(const string &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>istringstream</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>istringstream</name>
      <anchor>d1</anchor>
      <arglist>(const istringstream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>istringstream &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const istringstream &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>operator==</name>
      <anchor>d3</anchor>
      <arglist>(const istringstream &amp;) const</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::StringUtils</name>
    <filename>classThePEG_1_1StringUtils.html</filename>
    <member kind="typedef">
      <type>vector&lt; string &gt;</type>
      <name>StringVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>StringVector</type>
      <name>split</name>
      <anchor>e0</anchor>
      <arglist>(string s, string ws=&quot; \t\n&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>car</name>
      <anchor>e1</anchor>
      <arglist>(string s, string ws=&quot; \t\n&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>cdr</name>
      <anchor>e2</anchor>
      <arglist>(string s, string ws=&quot; \t\n&quot;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>string</type>
      <name>stripws</name>
      <anchor>e3</anchor>
      <arglist>(string str)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::SystemUtils</name>
    <filename>classThePEG_1_1SystemUtils.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>getenv</name>
      <anchor>e0</anchor>
      <arglist>(string)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::TimeCounter</name>
    <filename>classThePEG_1_1TimeCounter.html</filename>
    <base>ThePEG::Named</base>
    <member kind="function">
      <type></type>
      <name>TimeCounter</name>
      <anchor>a0</anchor>
      <arglist>(string newName=&quot;&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TimeCounter</name>
      <anchor>a1</anchor>
      <arglist>(const TimeCounter &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TimeCounter</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TimeCounter &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const TimeCounter &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>enter</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>start</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>unsigned int</type>
      <name>nCalls</name>
      <anchor>a7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>timeTot</name>
      <anchor>a8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>timePer</name>
      <anchor>a9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>theNCalls</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>clock_t</type>
      <name>startClock</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned long</type>
      <name>totTime</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>unsigned int</type>
      <name>loop</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::MainTimer</name>
    <filename>classThePEG_1_1MainTimer.html</filename>
    <member kind="function">
      <type></type>
      <name>MainTimer</name>
      <anchor>a0</anchor>
      <arglist>(string file=&quot;.timer&quot;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~MainTimer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>TimeCounter *</type>
      <name>getCounter</name>
      <anchor>e0</anchor>
      <arglist>(unsigned int i, string)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>bool</type>
      <name>running</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>map&lt; unsigned int, TimeCounter &gt;</type>
      <name>CounterMap</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>MainTimer</name>
      <anchor>d0</anchor>
      <arglist>(const MainTimer &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>MainTimer &amp;</type>
      <name>operator=</name>
      <anchor>d1</anchor>
      <arglist>(const MainTimer &amp;)</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>CounterMap &amp;</type>
      <name>counters</name>
      <anchor>h0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private" static="yes">
      <type>void</type>
      <name>statistics</name>
      <anchor>h1</anchor>
      <arglist>(string file)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>string</type>
      <name>filename</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>bool</type>
      <name>isRunning</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>TimeCounter *</type>
      <name>theCounter</name>
      <anchor>v1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Timer</name>
    <filename>classThePEG_1_1Timer.html</filename>
    <templarg>I</templarg>
    <member kind="function">
      <type></type>
      <name>Timer</name>
      <anchor>a0</anchor>
      <arglist>(string name)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~Timer</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>stop</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>start</name>
      <anchor>a3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Timer</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type></type>
      <name>Timer</name>
      <anchor>d1</anchor>
      <arglist>(const Timer &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>Timer &amp;</type>
      <name>operator=</name>
      <anchor>d2</anchor>
      <arglist>(const Timer &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>started</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>TimeCounter *</type>
      <name>theCounter</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Triplet</name>
    <filename>structThePEG_1_1Triplet.html</filename>
    <templarg>T1</templarg>
    <templarg>T2</templarg>
    <templarg>T3</templarg>
    <member kind="typedef">
      <type>T1</type>
      <name>first_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T2</type>
      <name>second_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T3</type>
      <name>third_type</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a1</anchor>
      <arglist>(const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a2</anchor>
      <arglist>(const Triplet&lt; T1, T2, T3 &gt; &amp;t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>Triplet</name>
      <anchor>a3</anchor>
      <arglist>(const Triplet&lt; U1, U2, U3 &gt; &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a4</anchor>
      <arglist>(const Triplet&lt; T1, T2, T3 &gt; &amp;t) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a5</anchor>
      <arglist>(const Triplet&lt; T1, T2, T3 &gt; &amp;t) const</arglist>
    </member>
    <member kind="variable">
      <type>T1</type>
      <name>first</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T2</type>
      <name>second</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>T3</type>
      <name>third</name>
      <anchor>o2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::TypeInfo</name>
    <filename>structThePEG_1_1TypeInfo.html</filename>
    <member kind="function" static="yes">
      <type>string</type>
      <name>name</name>
      <anchor>e0</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>int</type>
      <name>version</name>
      <anchor>e1</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::OUnit</name>
    <filename>structThePEG_1_1OUnit.html</filename>
    <templarg>T</templarg>
    <templarg>UT</templarg>
    <member kind="function">
      <type></type>
      <name>OUnit</name>
      <anchor>a0</anchor>
      <arglist>(const T &amp;t, const UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>OUnit</name>
      <anchor>a1</anchor>
      <arglist>(const OUnit&lt; T, UT &gt; &amp;iu)</arglist>
    </member>
    <member kind="variable">
      <type>const T &amp;</type>
      <name>theX</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const UT &amp;</type>
      <name>theUnit</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::IUnit</name>
    <filename>structThePEG_1_1IUnit.html</filename>
    <templarg>T</templarg>
    <templarg>UT</templarg>
    <member kind="function">
      <type></type>
      <name>IUnit</name>
      <anchor>a0</anchor>
      <arglist>(T &amp;t, const UT &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>IUnit</name>
      <anchor>a1</anchor>
      <arglist>(const IUnit&lt; T, UT &gt; &amp;iu)</arglist>
    </member>
    <member kind="variable">
      <type>T &amp;</type>
      <name>theX</name>
      <anchor>o0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable">
      <type>const UT &amp;</type>
      <name>theUnit</name>
      <anchor>o1</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::UtilityBase</name>
    <filename>structThePEG_1_1UtilityBase.html</filename>
    <member kind="function" static="yes">
      <type>LorentzMomentum</type>
      <name>sumMomentum</name>
      <anchor>e0</anchor>
      <arglist>(const Cont &amp;)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzMomentum</type>
      <name>sumMomentum</name>
      <anchor>e1</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>transform</name>
      <anchor>e2</anchor>
      <arglist>(Iterator first, Iterator last, const LorentzRotation &amp;boost)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e3</anchor>
      <arglist>(const pair&lt; PType, PType &gt; &amp;pp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>getBoostToCM</name>
      <anchor>e4</anchor>
      <arglist>(const pair&lt; PType, PType &gt; &amp;pp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>getBoostFromCM</name>
      <anchor>e5</anchor>
      <arglist>(const pair&lt; PType, PType &gt; &amp;pp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e6</anchor>
      <arglist>(Iterator first, Iterator last)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e7</anchor>
      <arglist>(Iterator first, Iterator last, Iterator zAxis)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>boostToCM</name>
      <anchor>e8</anchor>
      <arglist>(Iterator first, Iterator last, Iterator zAxis, Iterator xzPlane)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>e9</anchor>
      <arglist>(PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentumFromCMS</name>
      <anchor>e10</anchor>
      <arglist>(PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>e11</anchor>
      <arglist>(Iter first, Iter last, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentum</name>
      <anchor>e12</anchor>
      <arglist>(Iter first, Iter last, const Momentum3 &amp;q, double eps)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>setMomentumFromCMS</name>
      <anchor>e13</anchor>
      <arglist>(Iter first, Iter last, Energy2 m2, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToMomentum</name>
      <anchor>e14</anchor>
      <arglist>(const PType &amp;p, const Momentum3 &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToMomentum</name>
      <anchor>e15</anchor>
      <arglist>(const PType &amp;p, const LorentzMomentum &amp;q)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformFromCMS</name>
      <anchor>e16</anchor>
      <arglist>(const LV &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformFromCMS</name>
      <anchor>e17</anchor>
      <arglist>(const LV &amp;sum, LV zAxis)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformFromCMS</name>
      <anchor>e18</anchor>
      <arglist>(const LV &amp;sum, const LV &amp;zAxis, LV xyPlane)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToCMS</name>
      <anchor>e19</anchor>
      <arglist>(const LV &amp;sum, LV zAxis)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToCMS</name>
      <anchor>e20</anchor>
      <arglist>(const LV &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>LorentzRotation</type>
      <name>transformToCMS</name>
      <anchor>e21</anchor>
      <arglist>(const LV &amp;sum, const LV &amp;zAxis, LV xyPlane)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>add</name>
      <anchor>e22</anchor>
      <arglist>(Cont1 &amp;c1, const Cont2 &amp;c2)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Utilities</name>
    <filename>structThePEG_1_1Utilities.html</filename>
    <base>ThePEG::UtilityBase</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::VSelector</name>
    <filename>classThePEG_1_1VSelector.html</filename>
    <templarg>T</templarg>
    <templarg>WeightType</templarg>
    <member kind="typedef">
      <type>vector&lt; WeightType &gt;</type>
      <name>WeightVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>WeightVector::const_iterator</type>
      <name>WIterator</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>vector&lt; T &gt;</type>
      <name>ObjectVector</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ObjectVector::iterator</type>
      <name>iterator</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ObjectVector::const_iterator</type>
      <name>const_iterator</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ObjectVector::size_type</type>
      <name>size_type</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VSelector</name>
      <anchor>a0</anchor>
      <arglist>(size_type reserved=0)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VSelector</name>
      <anchor>a1</anchor>
      <arglist>(const VSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~VSelector</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const VSelector &amp;</type>
      <name>operator=</name>
      <anchor>a3</anchor>
      <arglist>(const VSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a4</anchor>
      <arglist>(VSelector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>insert</name>
      <anchor>a5</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>reweight</name>
      <anchor>a6</anchor>
      <arglist>(WeightType, const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>erase</name>
      <anchor>a7</anchor>
      <arglist>(const T &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>replace</name>
      <anchor>a8</anchor>
      <arglist>(const T &amp;told, const T &amp;tnew)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a9</anchor>
      <arglist>(double rnd, double *remainder=0)</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>operator[]</name>
      <anchor>a10</anchor>
      <arglist>(double rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a11</anchor>
      <arglist>(double rnd, double *remainder=0) const</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>operator[]</name>
      <anchor>a12</anchor>
      <arglist>(double rnd) const</arglist>
    </member>
    <member kind="function">
      <type>T &amp;</type>
      <name>select</name>
      <anchor>a13</anchor>
      <arglist>(RNDGEN &amp;rnd)</arglist>
    </member>
    <member kind="function">
      <type>const T &amp;</type>
      <name>select</name>
      <anchor>a14</anchor>
      <arglist>(RNDGEN &amp;rnd) const</arglist>
    </member>
    <member kind="function">
      <type>WeightType</type>
      <name>sum</name>
      <anchor>a15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>begin</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_iterator</type>
      <name>end</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>empty</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>size_type</type>
      <name>size</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>reserve</name>
      <anchor>a20</anchor>
      <arglist>(size_type reserved)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>clear</name>
      <anchor>a21</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a22</anchor>
      <arglist>(OStream &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>input</name>
      <anchor>a23</anchor>
      <arglist>(IStream &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>size_type</type>
      <name>iselect</name>
      <anchor>b0</anchor>
      <arglist>(double rnd, double *remainder) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightVector</type>
      <name>theSums</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightVector</type>
      <name>theWeights</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>ObjectVector</type>
      <name>theObjects</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>WeightType</type>
      <name>theSum</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Constants</name>
    <filename>namespaceThePEG_1_1Constants.html</filename>
    <member kind="variable" static="yes">
      <type>const Length</type>
      <name>MaxLength</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const Energy</type>
      <name>MaxEnergy</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const Energy2</type>
      <name>MaxEnergy2</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>MaxDouble</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>HugeDouble</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>MaxFloat</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>HugeFloat</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>MaxRapidity</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>pi</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const long</type>
      <name>MaxInt</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>epsilon</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const double</type>
      <name>EulerGamma</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Group</name>
    <filename>namespaceThePEG_1_1Group.html</filename>
    <member kind="enumeration">
      <name>Handler</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>subproc</name>
      <anchor>a8a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cascade</name>
      <anchor>a8a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>multi</name>
      <anchor>a8a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>hadron</name>
      <anchor>a8a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>decay</name>
      <anchor>a8a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>Level</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>before</name>
      <anchor>a9a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>main</name>
      <anchor>a9a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>after</name>
      <anchor>a9a7</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Helicity</name>
    <filename>namespaceThePEG_1_1Helicity.html</filename>
    <class kind="class">ThePEG::Helicity::FermionSpinInfo</class>
    <class kind="class">ThePEG::Helicity::HelicityLogicalError</class>
    <class kind="class">ThePEG::Helicity::HelicityConsistencyError</class>
    <class kind="class">ThePEG::Helicity::HelicityVertex</class>
    <class kind="class">ThePEG::Helicity::LorentzPolarizationVector</class>
    <class kind="class">ThePEG::Helicity::LorentzSpinor</class>
    <class kind="class">ThePEG::Helicity::LorentzSpinorBar</class>
    <class kind="class">ThePEG::Helicity::LorentzTensor</class>
    <class kind="class">ThePEG::Helicity::RhoDMatrix</class>
    <class kind="class">ThePEG::Helicity::ScalarSpinInfo</class>
    <class kind="class">ThePEG::Helicity::SpinInfo</class>
    <class kind="class">ThePEG::Helicity::TensorSpinInfo</class>
    <class kind="class">ThePEG::Helicity::VectorSpinInfo</class>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::pointer</type>
      <name>FermionSpinPtr</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::const_pointer</type>
      <name>cFermionSpinPtr</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::transient_pointer</type>
      <name>tFermionSpinPtr</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; FermionSpinInfo &gt;::transient_const_pointer</type>
      <name>tcFermionSpinPtr</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::pointer</type>
      <name>VertexPtr</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::const_pointer</type>
      <name>cVertexPtr</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::transient_pointer</type>
      <name>tVertexPtr</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; HelicityVertex &gt;::transient_const_pointer</type>
      <name>tcVertexPtr</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::pointer</type>
      <name>ScalarSpinPtr</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::const_pointer</type>
      <name>cScalarSpinPtr</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::transient_pointer</type>
      <name>tScalarSpinPtr</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; ScalarSpinInfo &gt;::transient_const_pointer</type>
      <name>tcScalarSpinPtr</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::pointer</type>
      <name>SpinfoPtr</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::const_pointer</type>
      <name>cSpinfoPtr</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::transient_pointer</type>
      <name>tSpinfoPtr</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; SpinInfo &gt;::transient_const_pointer</type>
      <name>tcSpinfoPtr</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::pointer</type>
      <name>TensorSpinPtr</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::const_pointer</type>
      <name>cTensorSpinPtr</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::transient_pointer</type>
      <name>tTensorSpinPtr</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; TensorSpinInfo &gt;::transient_const_pointer</type>
      <name>tcTensorSpinPtr</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::pointer</type>
      <name>VectorSpinPtr</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::const_pointer</type>
      <name>cVectorSpinPtr</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::transient_pointer</type>
      <name>tVectorSpinPtr</name>
      <anchor>a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Ptr&lt; VectorSpinInfo &gt;::transient_const_pointer</type>
      <name>tcVectorSpinPtr</name>
      <anchor>a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>DiracRep</name>
      <anchor>a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HELASDRep</name>
      <anchor>a41a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>HaberDRep</name>
      <anchor>a41a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>defaultDRep</name>
      <anchor>a41a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumeration">
      <name>SpinorType</name>
      <anchor>a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>u_spinortype</name>
      <anchor>a42a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>v_spinortype</name>
      <anchor>a42a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>unknown_spinortype</name>
      <anchor>a42a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator/</name>
      <anchor>a30</anchor>
      <arglist>(const LorentzPolarizationVector &amp;, Complex a)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a31</anchor>
      <arglist>(Complex a, const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a32</anchor>
      <arglist>(Complex a, const Lorentz5Momentum &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostXOf</name>
      <anchor>a33</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostYOf</name>
      <anchor>a34</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostZOf</name>
      <anchor>a35</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostOf</name>
      <anchor>a36</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, const Hep3Vector &amp;betaVector)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>boostOf</name>
      <anchor>a37</anchor>
      <arglist>(const LorentzPolarizationVector &amp;vec, const Hep3Vector &amp;axis, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator *</name>
      <anchor>a38</anchor>
      <arglist>(Complex a, const LorentzTensor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a39</anchor>
      <arglist>(const LorentzPolarizationVector &amp;, const LorentzTensor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator *</name>
      <anchor>a40</anchor>
      <arglist>(const LorentzTensor &amp;, const LorentzPolarizationVector &amp;)</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::FermionSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1FermionSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FermionSpinInfo</name>
      <anchor>z316_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FermionSpinInfo</name>
      <anchor>z316_1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>FermionSpinInfo</name>
      <anchor>z316_2</anchor>
      <arglist>(const FermionSpinInfo &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~FermionSpinInfo</name>
      <anchor>z316_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z318_0</anchor>
      <arglist>(int hel, LorentzSpinor in) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>getProductionBasisState</name>
      <anchor>z318_1</anchor>
      <arglist>(int hel) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z318_2</anchor>
      <arglist>(int hel, LorentzSpinor in) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>getDecayBasisState</name>
      <anchor>z318_3</anchor>
      <arglist>(int hel) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>FermionSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const FermionSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzSpinor &gt;</type>
      <name>_productionstates</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzSpinor &gt;</type>
      <name>_decaystates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; FermionSpinInfo &gt;</type>
      <name>initFermionSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::HelicityLogicalError</name>
    <filename>classThePEG_1_1Helicity_1_1HelicityLogicalError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::HelicityConsistencyError</name>
    <filename>classThePEG_1_1Helicity_1_1HelicityConsistencyError.html</filename>
    <base>ThePEG::Exception</base>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::HelicityVertex</name>
    <filename>classThePEG_1_1Helicity_1_1HelicityVertex.html</filename>
    <base>ThePEG::EventInfoBase</base>
    <member kind="typedef">
      <type>vector&lt; tcSpinPtr &gt;</type>
      <name>SpinVector</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HelicityVertex</name>
      <anchor>z320_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>HelicityVertex</name>
      <anchor>z320_1</anchor>
      <arglist>(const HelicityVertex &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~HelicityVertex</name>
      <anchor>z320_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinVector</type>
      <name>incoming</name>
      <anchor>z322_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>SpinVector</type>
      <name>outgoing</name>
      <anchor>z322_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addIncoming</name>
      <anchor>z322_2</anchor>
      <arglist>(tcSpinPtr spin, int &amp;loc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>addOutgoing</name>
      <anchor>z322_3</anchor>
      <arglist>(tcSpinPtr spin, int &amp;loc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetIncoming</name>
      <anchor>z322_4</anchor>
      <arglist>(tcSpinPtr spin, int loc)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>resetOutgoing</name>
      <anchor>z322_5</anchor>
      <arglist>(tcSpinPtr spin, int loc)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual RhoDMatrix</type>
      <name>getRhoMatrix</name>
      <anchor>z324_0</anchor>
      <arglist>(int loc)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual RhoDMatrix</type>
      <name>getDMatrix</name>
      <anchor>z324_1</anchor>
      <arglist>(int loc)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>HelicityVertex &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const HelicityVertex &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinVector</type>
      <name>_incoming</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinVector</type>
      <name>_outgoing</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>AbstractNoPIOClassDescription&lt; HelicityVertex &gt;</type>
      <name>initHelicityVertex</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzPolarizationVector</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzPolarizationVector.html</filename>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z326_0</anchor>
      <arglist>(Complex x, Complex y, Complex z, Complex t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z326_1</anchor>
      <arglist>(Complex x, Complex y, Complex z)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z326_2</anchor>
      <arglist>(Complex t)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z326_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z326_4</anchor>
      <arglist>(const LorentzVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzPolarizationVector</name>
      <anchor>z326_5</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LorentzPolarizationVector</name>
      <anchor>z326_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>x</name>
      <anchor>z328_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>y</name>
      <anchor>z328_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>z</name>
      <anchor>z328_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>t</name>
      <anchor>z328_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setX</name>
      <anchor>z328_4</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setY</name>
      <anchor>z328_5</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZ</name>
      <anchor>z328_6</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setT</name>
      <anchor>z328_7</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z328_8</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator[]</name>
      <anchor>z328_9</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z328_10</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator[]</name>
      <anchor>z328_11</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator=</name>
      <anchor>z330_0</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator+</name>
      <anchor>z330_1</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator+=</name>
      <anchor>z330_2</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator-</name>
      <anchor>z330_3</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator-=</name>
      <anchor>z330_4</anchor>
      <arglist>(const LorentzPolarizationVector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>operator-</name>
      <anchor>z330_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator *=</name>
      <anchor>z330_6</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>operator/=</name>
      <anchor>z330_7</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>dot</name>
      <anchor>z330_8</anchor>
      <arglist>(const LorentzVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator *</name>
      <anchor>z330_9</anchor>
      <arglist>(const LorentzVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>dot</name>
      <anchor>z330_10</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator *</name>
      <anchor>z330_11</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>z332_0</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>z332_1</anchor>
      <arglist>(const LorentzPolarizationVector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boostX</name>
      <anchor>z334_0</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boostY</name>
      <anchor>z334_1</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boostZ</name>
      <anchor>z334_2</anchor>
      <arglist>(double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boost</name>
      <anchor>z334_3</anchor>
      <arglist>(double bx, double by, double bz)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boost</name>
      <anchor>z334_4</anchor>
      <arglist>(const Hep3Vector &amp;)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>boost</name>
      <anchor>z334_5</anchor>
      <arglist>(const Hep3Vector &amp;axis, double beta)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateX</name>
      <anchor>z334_6</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateY</name>
      <anchor>z334_7</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateZ</name>
      <anchor>z334_8</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotateUz</name>
      <anchor>z334_9</anchor>
      <arglist>(const Hep3Vector &amp;newUz)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector &amp;</type>
      <name>rotate</name>
      <anchor>z334_10</anchor>
      <arglist>(double, const Hep3Vector &amp;axis)</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>conjugate</name>
      <anchor>z334_11</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_vec</name>
      <anchor>r0</anchor>
      <arglist>[4]</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzSpinor</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzSpinor.html</filename>
    <member kind="function">
      <type>LorentzSpinor &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzSpinor &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z336_0</anchor>
      <arglist>(SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z336_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z336_2</anchor>
      <arglist>(Complex, Complex, Complex, Complex, SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinor</name>
      <anchor>z336_3</anchor>
      <arglist>(Complex, Complex, Complex, Complex, DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator[]</name>
      <anchor>z338_0</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z338_1</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z338_2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator[]</name>
      <anchor>z338_3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1</name>
      <anchor>z338_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2</name>
      <anchor>z338_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3</name>
      <anchor>z338_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4</name>
      <anchor>z338_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS1</name>
      <anchor>z338_8</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS2</name>
      <anchor>z338_9</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS3</name>
      <anchor>z338_10</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS4</name>
      <anchor>z338_11</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>bar</name>
      <anchor>z340_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>boost</name>
      <anchor>z340_1</anchor>
      <arglist>(double, double, double) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>boost</name>
      <anchor>z340_2</anchor>
      <arglist>(const Hep3Vector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>changeRep</name>
      <anchor>z342_0</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>transformRep</name>
      <anchor>z342_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>DiracRep</type>
      <name>Rep</name>
      <anchor>z342_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinorType</type>
      <name>Type</name>
      <anchor>z342_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist>[4]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiracRep</type>
      <name>_dirac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinorType</type>
      <name>_type</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzSpinorBar</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzSpinorBar.html</filename>
    <member kind="function">
      <type>LorentzSpinorBar &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const LorentzSpinorBar &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z344_0</anchor>
      <arglist>(SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z344_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z344_2</anchor>
      <arglist>(Complex, Complex, Complex, Complex, SpinorType t=unknown_spinortype, DiracRep r=defaultDRep)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzSpinorBar</name>
      <anchor>z344_3</anchor>
      <arglist>(Complex, Complex, Complex, Complex, DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator[]</name>
      <anchor>z346_0</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z346_1</anchor>
      <arglist>(int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z346_2</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator[]</name>
      <anchor>z346_3</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s1</name>
      <anchor>z346_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s2</name>
      <anchor>z346_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s3</name>
      <anchor>z346_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>s4</name>
      <anchor>z346_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS1</name>
      <anchor>z346_8</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS2</name>
      <anchor>z346_9</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS3</name>
      <anchor>z346_10</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setS4</name>
      <anchor>z346_11</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinor</type>
      <name>bar</name>
      <anchor>z348_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>boost</name>
      <anchor>z348_1</anchor>
      <arglist>(double, double, double) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>boost</name>
      <anchor>z348_2</anchor>
      <arglist>(const Hep3Vector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>changeRep</name>
      <anchor>z350_0</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>LorentzSpinorBar</type>
      <name>transformRep</name>
      <anchor>z350_1</anchor>
      <arglist>(DiracRep)</arglist>
    </member>
    <member kind="function">
      <type>DiracRep</type>
      <name>Rep</name>
      <anchor>z350_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>SpinorType</type>
      <name>Type</name>
      <anchor>z350_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_spin</name>
      <anchor>r0</anchor>
      <arglist>[4]</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>DiracRep</type>
      <name>_dirac</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>SpinorType</type>
      <name>_type</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::LorentzTensor</name>
    <filename>classThePEG_1_1Helicity_1_1LorentzTensor.html</filename>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z352_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z352_1</anchor>
      <arglist>(Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex, Complex)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z352_2</anchor>
      <arglist>(LorentzPolarizationVector, LorentzPolarizationVector)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>LorentzTensor</name>
      <anchor>z352_3</anchor>
      <arglist>(LorentzVector p, LorentzVector q)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~LorentzTensor</name>
      <anchor>z352_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xx</name>
      <anchor>z354_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yx</name>
      <anchor>z354_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zx</name>
      <anchor>z354_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>tx</name>
      <anchor>z354_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xy</name>
      <anchor>z354_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yy</name>
      <anchor>z354_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zy</name>
      <anchor>z354_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>ty</name>
      <anchor>z354_7</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xz</name>
      <anchor>z354_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yz</name>
      <anchor>z354_9</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zz</name>
      <anchor>z354_10</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>tz</name>
      <anchor>z354_11</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>xt</name>
      <anchor>z354_12</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>yt</name>
      <anchor>z354_13</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>zt</name>
      <anchor>z354_14</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>tt</name>
      <anchor>z354_15</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXX</name>
      <anchor>z354_16</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYX</name>
      <anchor>z354_17</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZX</name>
      <anchor>z354_18</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTX</name>
      <anchor>z354_19</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXY</name>
      <anchor>z354_20</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYY</name>
      <anchor>z354_21</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZY</name>
      <anchor>z354_22</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTY</name>
      <anchor>z354_23</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXZ</name>
      <anchor>z354_24</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYZ</name>
      <anchor>z354_25</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZZ</name>
      <anchor>z354_26</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTZ</name>
      <anchor>z354_27</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setXT</name>
      <anchor>z354_28</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setYT</name>
      <anchor>z354_29</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setZT</name>
      <anchor>z354_30</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setTT</name>
      <anchor>z354_31</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z354_32</anchor>
      <arglist>(int, int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z354_33</anchor>
      <arglist>(int, int)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>boost</name>
      <anchor>z356_0</anchor>
      <arglist>(double, double, double) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>boost</name>
      <anchor>z356_1</anchor>
      <arglist>(const Hep3Vector &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>conjugate</name>
      <anchor>z356_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor &amp;</type>
      <name>operator=</name>
      <anchor>z358_0</anchor>
      <arglist>(const LorentzTensor &amp;)</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator *</name>
      <anchor>z358_1</anchor>
      <arglist>(const LorentzTensor &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator *=</name>
      <anchor>z358_2</anchor>
      <arglist>(Complex)</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator+</name>
      <anchor>z358_3</anchor>
      <arglist>(const LorentzTensor &amp;) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>operator-</name>
      <anchor>z358_4</anchor>
      <arglist>(const LorentzTensor &amp;) const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_tensor</name>
      <anchor>r0</anchor>
      <arglist>[4][4]</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::RhoDMatrix</name>
    <filename>classThePEG_1_1Helicity_1_1RhoDMatrix.html</filename>
    <member kind="function">
      <type>RhoDMatrix &amp;</type>
      <name>operator=</name>
      <anchor>a0</anchor>
      <arglist>(const RhoDMatrix &amp;)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>output</name>
      <anchor>a1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RhoDMatrix</name>
      <anchor>z360_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RhoDMatrix</name>
      <anchor>z360_1</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RhoDMatrix</name>
      <anchor>z360_2</anchor>
      <arglist>(const RhoDMatrix &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~RhoDMatrix</name>
      <anchor>z360_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Complex</type>
      <name>operator()</name>
      <anchor>z362_0</anchor>
      <arglist>(int, int) const</arglist>
    </member>
    <member kind="function">
      <type>Complex &amp;</type>
      <name>operator()</name>
      <anchor>z362_1</anchor>
      <arglist>(int, int)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>average</name>
      <anchor>z362_2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>zero</name>
      <anchor>z362_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>normalize</name>
      <anchor>z362_4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setSpin</name>
      <anchor>z364_0</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>getSpin</name>
      <anchor>z364_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>_ispin</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Complex</type>
      <name>_matrix</name>
      <anchor>r1</anchor>
      <arglist>[5][5]</arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::ScalarSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1ScalarSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a1</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarSpinInfo</name>
      <anchor>z366_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarSpinInfo</name>
      <anchor>z366_1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ScalarSpinInfo</name>
      <anchor>z366_2</anchor>
      <arglist>(const ScalarSpinInfo &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~ScalarSpinInfo</name>
      <anchor>z366_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>ScalarSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const ScalarSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; ScalarSpinInfo &gt;</type>
      <name>initScalarSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::SpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1SpinInfo.html</filename>
    <base>ThePEG::SpinBase</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>update</name>
      <anchor>a2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinInfo</name>
      <anchor>z368_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinInfo</name>
      <anchor>z368_1</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>SpinInfo</name>
      <anchor>z368_2</anchor>
      <arglist>(const SpinInfo &amp;)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~SpinInfo</name>
      <anchor>z368_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setProductionVertex</name>
      <anchor>z370_0</anchor>
      <arglist>(VertexPtr) const</arglist>
    </member>
    <member kind="function">
      <type>tcVertexPtr</type>
      <name>getProductionVertex</name>
      <anchor>z370_1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayVertex</name>
      <anchor>z370_2</anchor>
      <arglist>(VertexPtr) const</arglist>
    </member>
    <member kind="function">
      <type>tcVertexPtr</type>
      <name>getDecayVertex</name>
      <anchor>z370_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>decayed</name>
      <anchor>z372_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>decayed</name>
      <anchor>z372_1</anchor>
      <arglist>(bool) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>developed</name>
      <anchor>z372_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>decay</name>
      <anchor>z372_3</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>develop</name>
      <anchor>z372_4</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDeveloped</name>
      <anchor>z372_5</anchor>
      <arglist>(bool) const</arglist>
    </member>
    <member kind="function">
      <type>int</type>
      <name>Spin</name>
      <anchor>z372_6</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>Particle</name>
      <anchor>z372_7</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>const Lorentz5Momentum &amp;</type>
      <name>productionMomentum</name>
      <anchor>z372_8</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>timelike</name>
      <anchor>z372_9</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix</type>
      <name>rhoMatrix</name>
      <anchor>z374_0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix &amp;</type>
      <name>rhoMatrix</name>
      <anchor>z374_1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix</type>
      <name>DMatrix</name>
      <anchor>z374_2</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>RhoDMatrix &amp;</type>
      <name>DMatrix</name>
      <anchor>z374_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setSpin</name>
      <anchor>b0</anchor>
      <arglist>(int)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setProductionMomentum</name>
      <anchor>b1</anchor>
      <arglist>(const Lorentz5Momentum &amp;in)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>setTimelike</name>
      <anchor>b2</anchor>
      <arglist>(bool)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>SpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const SpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexPtr</type>
      <name>_production</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>VertexPtr</type>
      <name>_decay</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_timelike</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>_prodloc</name>
      <anchor>r3</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>_decayloc</name>
      <anchor>r4</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decayed</name>
      <anchor>r5</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_developed</name>
      <anchor>r6</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RhoDMatrix</type>
      <name>_rhomatrix</name>
      <anchor>r7</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>RhoDMatrix</type>
      <name>_Dmatrix</name>
      <anchor>r8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>int</type>
      <name>_ispin</name>
      <anchor>r9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>Lorentz5Momentum</type>
      <name>_productionmomentum</name>
      <anchor>r10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; SpinInfo &gt;</type>
      <name>initSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::TensorSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1TensorSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>a0</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>a1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TensorSpinInfo</name>
      <anchor>z376_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TensorSpinInfo</name>
      <anchor>z376_1</anchor>
      <arglist>(const TensorSpinInfo &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TensorSpinInfo</name>
      <anchor>z376_2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~TensorSpinInfo</name>
      <anchor>z376_3</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z378_0</anchor>
      <arglist>(int hel, LorentzTensor in) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z378_1</anchor>
      <arglist>(int hel, LorentzTensor in) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>getProductionBasisState</name>
      <anchor>z378_2</anchor>
      <arglist>(int hel) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzTensor</type>
      <name>getDecayBasisState</name>
      <anchor>z378_3</anchor>
      <arglist>(int hel) const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>TensorSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>d0</anchor>
      <arglist>(const TensorSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzTensor &gt;</type>
      <name>_productionstates</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzTensor &gt;</type>
      <name>_decaystates</name>
      <anchor>r1</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>r2</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; TensorSpinInfo &gt;</type>
      <name>initTensorSpinInfo</name>
      <anchor>v0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Helicity::VectorSpinInfo</name>
    <filename>classThePEG_1_1Helicity_1_1VectorSpinInfo.html</filename>
    <base>ThePEG::Helicity::SpinInfo</base>
    <member kind="function">
      <type>void</type>
      <name>setBasisState</name>
      <anchor>z382_0</anchor>
      <arglist>(int hel, LorentzPolarizationVector in) const</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>setDecayState</name>
      <anchor>z382_1</anchor>
      <arglist>(int hel, LorentzPolarizationVector in) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>getProductionBasisState</name>
      <anchor>z382_2</anchor>
      <arglist>(int hel) const</arglist>
    </member>
    <member kind="function">
      <type>LorentzPolarizationVector</type>
      <name>getDecayBasisState</name>
      <anchor>z382_3</anchor>
      <arglist>(int hel) const</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual void</type>
      <name>rebind</name>
      <anchor>z382_4</anchor>
      <arglist>(const EventTranslationMap &amp;trans)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual EIPtr</type>
      <name>clone</name>
      <anchor>z382_5</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>Init</name>
      <anchor>z382_6</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>VectorSpinInfo &amp;</type>
      <name>operator=</name>
      <anchor>z382_7</anchor>
      <arglist>(const VectorSpinInfo &amp;)</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzPolarizationVector &gt;</type>
      <name>_productionstates</name>
      <anchor>z382_8</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>vector&lt; LorentzPolarizationVector &gt;</type>
      <name>_decaystates</name>
      <anchor>z382_9</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private">
      <type>bool</type>
      <name>_decaycalc</name>
      <anchor>z382_10</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" protection="private" static="yes">
      <type>NoPIOClassDescription&lt; VectorSpinInfo &gt;</type>
      <name>initVectorSpinInfo</name>
      <anchor>z382_11</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorSpinInfo</name>
      <anchor>z380_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorSpinInfo</name>
      <anchor>z380_1</anchor>
      <arglist>(const VectorSpinInfo &amp;)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>VectorSpinInfo</name>
      <anchor>z380_2</anchor>
      <arglist>(const Lorentz5Momentum &amp;p, bool time)</arglist>
    </member>
    <member kind="function" virtualness="virtual">
      <type>virtual</type>
      <name>~VectorSpinInfo</name>
      <anchor>z380_3</anchor>
      <arglist>()</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Math</name>
    <filename>namespaceThePEG_1_1Math.html</filename>
    <class kind="struct">ThePEG::Math::MathType</class>
    <class kind="struct">ThePEG::Math::Power</class>
    <member kind="function">
      <type>double</type>
      <name>gamma</name>
      <anchor>a0</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>lngamma</name>
      <anchor>a1</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>exp1m</name>
      <anchor>a2</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>log1m</name>
      <anchor>a3</anchor>
      <arglist>(double)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>powi</name>
      <anchor>a4</anchor>
      <arglist>(double x, int p)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pIntegrate</name>
      <anchor>a5</anchor>
      <arglist>(double p, double xl, double xu)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pIntegrate</name>
      <anchor>a6</anchor>
      <arglist>(int p, double xl, double xu)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pXIntegrate</name>
      <anchor>a7</anchor>
      <arglist>(double e, double xl, double dx)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pGenerate</name>
      <anchor>a8</anchor>
      <arglist>(double p, double xl, double xu, double rnd)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pGenerate</name>
      <anchor>a9</anchor>
      <arglist>(int p, double xl, double xu, double rnd)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>pXGenerate</name>
      <anchor>a10</anchor>
      <arglist>(double e, double xl, double xu, double rnd)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>relativeError</name>
      <anchor>a11</anchor>
      <arglist>(FloatType x, FloatType y)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>absmin</name>
      <anchor>a12</anchor>
      <arglist>(const T &amp;x, const T &amp;y)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>absmax</name>
      <anchor>a13</anchor>
      <arglist>(const T &amp;x, const T &amp;y)</arglist>
    </member>
    <member kind="function">
      <type>T</type>
      <name>sign</name>
      <anchor>a14</anchor>
      <arglist>(T x, U y)</arglist>
    </member>
    <member kind="function">
      <type>double</type>
      <name>Pow</name>
      <anchor>a15</anchor>
      <arglist>(double x)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::MathType</name>
    <filename>structThePEG_1_1Math_1_1MathType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Power</name>
    <filename>structThePEG_1_1Math_1_1Power.html</filename>
    <templarg>N</templarg>
    <templarg>Inv</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>pow</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Math::Functions</name>
    <filename>namespaceThePEG_1_1Math_1_1Functions.html</filename>
    <class kind="struct">ThePEG::Math::Functions::PowX</class>
    <class kind="struct">ThePEG::Math::Functions::Pow1mX</class>
    <class kind="struct">ThePEG::Math::Functions::InvX1mX</class>
    <class kind="struct">ThePEG::Math::Functions::ExpX</class>
    <class kind="struct">ThePEG::Math::Functions::FracPowX</class>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::PowX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1PowX.html</filename>
    <templarg>N</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::Pow1mX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1Pow1mX.html</filename>
    <templarg>N</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::InvX1mX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1InvX1mX.html</filename>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::ExpX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1ExpX.html</filename>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Math::Functions::FracPowX</name>
    <filename>structThePEG_1_1Math_1_1Functions_1_1FracPowX.html</filename>
    <templarg>N</templarg>
    <templarg>D</templarg>
    <base>ThePEG::Math::MathType</base>
    <member kind="function" static="yes">
      <type>double</type>
      <name>primitive</name>
      <anchor>e0</anchor>
      <arglist>(double x)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>integrate</name>
      <anchor>e1</anchor>
      <arglist>(double x0, double x1)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>double</type>
      <name>generate</name>
      <anchor>e2</anchor>
      <arglist>(double x0, double x1, double R)</arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::ParticleID</name>
    <filename>namespaceThePEG_1_1ParticleID.html</filename>
    <member kind="enumeration">
      <name>ParticleCodes</name>
      <anchor>a511</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>d</name>
      <anchor>a511a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dbar</name>
      <anchor>a511a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>u</name>
      <anchor>a511a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ubar</name>
      <anchor>a511a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>s</name>
      <anchor>a511a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sbar</name>
      <anchor>a511a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>c</name>
      <anchor>a511a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cbar</name>
      <anchor>a511a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b</name>
      <anchor>a511a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bbar</name>
      <anchor>a511a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>t</name>
      <anchor>a511a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tbar</name>
      <anchor>a511a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bprime</name>
      <anchor>a511a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bprimebar</name>
      <anchor>a511a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tprime</name>
      <anchor>a511a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tprimebar</name>
      <anchor>a511a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eminus</name>
      <anchor>a511a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eplus</name>
      <anchor>a511a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_e</name>
      <anchor>a511a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_ebar</name>
      <anchor>a511a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>muminus</name>
      <anchor>a511a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>muplus</name>
      <anchor>a511a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_mu</name>
      <anchor>a511a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_mubar</name>
      <anchor>a511a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauminus</name>
      <anchor>a511a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauplus</name>
      <anchor>a511a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_tau</name>
      <anchor>a511a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_taubar</name>
      <anchor>a511a27</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauprimeminus</name>
      <anchor>a511a28</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>tauprimeplus</name>
      <anchor>a511a29</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nuprime_tau</name>
      <anchor>a511a30</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nuprime_taubar</name>
      <anchor>a511a31</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>g</name>
      <anchor>a511a32</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>gamma</name>
      <anchor>a511a33</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Z0</name>
      <anchor>a511a34</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wplus</name>
      <anchor>a511a35</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wminus</name>
      <anchor>a511a36</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h0</name>
      <anchor>a511a37</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Zprime0</name>
      <anchor>a511a38</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Zbis0</name>
      <anchor>a511a39</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wprimeplus</name>
      <anchor>a511a40</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Wprimeminus</name>
      <anchor>a511a41</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H0</name>
      <anchor>a511a42</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>A0</name>
      <anchor>a511a43</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Hplus</name>
      <anchor>a511a44</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Hminus</name>
      <anchor>a511a45</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Graviton</name>
      <anchor>a511a46</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>R0</name>
      <anchor>a511a47</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Rbar0</name>
      <anchor>a511a48</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LQ_ue</name>
      <anchor>a511a49</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>LQ_uebar</name>
      <anchor>a511a50</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>reggeon</name>
      <anchor>a511a51</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi0</name>
      <anchor>a511a52</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho0</name>
      <anchor>a511a53</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_20</name>
      <anchor>a511a54</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_L0</name>
      <anchor>a511a55</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>piplus</name>
      <anchor>a511a56</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>piminus</name>
      <anchor>a511a57</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rhoplus</name>
      <anchor>a511a58</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rhominus</name>
      <anchor>a511a59</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_2plus</name>
      <anchor>a511a60</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_2minus</name>
      <anchor>a511a61</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta</name>
      <anchor>a511a62</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>omega</name>
      <anchor>a511a63</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>f_2</name>
      <anchor>a511a64</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_S0</name>
      <anchor>a511a65</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K0</name>
      <anchor>a511a66</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kbar0</name>
      <anchor>a511a67</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar0</name>
      <anchor>a511a68</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstarbar0</name>
      <anchor>a511a69</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_20</name>
      <anchor>a511a70</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_2bar0</name>
      <anchor>a511a71</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kplus</name>
      <anchor>a511a72</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kminus</name>
      <anchor>a511a73</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstarplus</name>
      <anchor>a511a74</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstarminus</name>
      <anchor>a511a75</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_2plus</name>
      <anchor>a511a76</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_2minus</name>
      <anchor>a511a77</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>etaprime</name>
      <anchor>a511a78</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>phi</name>
      <anchor>a511a79</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>fprime_2</name>
      <anchor>a511a80</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dplus</name>
      <anchor>a511a81</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dminus</name>
      <anchor>a511a82</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstarplus</name>
      <anchor>a511a83</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstarminus</name>
      <anchor>a511a84</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2plus</name>
      <anchor>a511a85</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2minus</name>
      <anchor>a511a86</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D0</name>
      <anchor>a511a87</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dbar0</name>
      <anchor>a511a88</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar0</name>
      <anchor>a511a89</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstarbar0</name>
      <anchor>a511a90</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_20</name>
      <anchor>a511a91</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2bar0</name>
      <anchor>a511a92</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_splus</name>
      <anchor>a511a93</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_sminus</name>
      <anchor>a511a94</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_splus</name>
      <anchor>a511a95</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_sminus</name>
      <anchor>a511a96</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2splus</name>
      <anchor>a511a97</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_2sminus</name>
      <anchor>a511a98</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta_c</name>
      <anchor>a511a99</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Jpsi</name>
      <anchor>a511a100</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_2c</name>
      <anchor>a511a101</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B0</name>
      <anchor>a511a102</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bbar0</name>
      <anchor>a511a103</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar0</name>
      <anchor>a511a104</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstarbar0</name>
      <anchor>a511a105</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_20</name>
      <anchor>a511a106</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2bar0</name>
      <anchor>a511a107</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bplus</name>
      <anchor>a511a108</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bminus</name>
      <anchor>a511a109</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstarplus</name>
      <anchor>a511a110</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstarminus</name>
      <anchor>a511a111</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2plus</name>
      <anchor>a511a112</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2minus</name>
      <anchor>a511a113</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_s0</name>
      <anchor>a511a114</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_sbar0</name>
      <anchor>a511a115</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_s0</name>
      <anchor>a511a116</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_sbar0</name>
      <anchor>a511a117</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2s0</name>
      <anchor>a511a118</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2sbar0</name>
      <anchor>a511a119</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_cplus</name>
      <anchor>a511a120</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_cminus</name>
      <anchor>a511a121</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_cplus</name>
      <anchor>a511a122</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_cminus</name>
      <anchor>a511a123</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2cplus</name>
      <anchor>a511a124</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_2cminus</name>
      <anchor>a511a125</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta_b</name>
      <anchor>a511a126</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Upsilon</name>
      <anchor>a511a127</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_2b</name>
      <anchor>a511a128</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pomeron</name>
      <anchor>a511a129</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dd_1</name>
      <anchor>a511a130</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dd_1bar</name>
      <anchor>a511a131</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltaminus</name>
      <anchor>a511a132</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabarplus</name>
      <anchor>a511a133</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_0</name>
      <anchor>a511a134</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_0bar</name>
      <anchor>a511a135</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_1</name>
      <anchor>a511a136</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ud_1bar</name>
      <anchor>a511a137</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>n0</name>
      <anchor>a511a138</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nbar0</name>
      <anchor>a511a139</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Delta0</name>
      <anchor>a511a140</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabar0</name>
      <anchor>a511a141</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>uu_1</name>
      <anchor>a511a142</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>uu_1bar</name>
      <anchor>a511a143</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pplus</name>
      <anchor>a511a144</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pbarminus</name>
      <anchor>a511a145</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltaplus</name>
      <anchor>a511a146</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabarminus</name>
      <anchor>a511a147</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltaplus2</name>
      <anchor>a511a148</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Deltabarminus2</name>
      <anchor>a511a149</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_0</name>
      <anchor>a511a150</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_0bar</name>
      <anchor>a511a151</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_1</name>
      <anchor>a511a152</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>sd_1bar</name>
      <anchor>a511a153</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmaminus</name>
      <anchor>a511a154</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmabarplus</name>
      <anchor>a511a155</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarminus</name>
      <anchor>a511a156</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarbarplus</name>
      <anchor>a511a157</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda0</name>
      <anchor>a511a158</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambdabar0</name>
      <anchor>a511a159</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_0</name>
      <anchor>a511a160</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_0bar</name>
      <anchor>a511a161</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_1</name>
      <anchor>a511a162</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>su_1bar</name>
      <anchor>a511a163</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma0</name>
      <anchor>a511a164</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmabar0</name>
      <anchor>a511a165</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar0</name>
      <anchor>a511a166</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarbar0</name>
      <anchor>a511a167</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmaplus</name>
      <anchor>a511a168</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmabarminus</name>
      <anchor>a511a169</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarplus</name>
      <anchor>a511a170</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastarbarminus</name>
      <anchor>a511a171</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ss_1</name>
      <anchor>a511a172</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ss_1bar</name>
      <anchor>a511a173</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Ximinus</name>
      <anchor>a511a174</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xibarplus</name>
      <anchor>a511a175</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistarminus</name>
      <anchor>a511a176</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistarbarplus</name>
      <anchor>a511a177</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi0</name>
      <anchor>a511a178</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xibar0</name>
      <anchor>a511a179</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar0</name>
      <anchor>a511a180</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistarbar0</name>
      <anchor>a511a181</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegaminus</name>
      <anchor>a511a182</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegabarplus</name>
      <anchor>a511a183</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_0</name>
      <anchor>a511a184</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_0bar</name>
      <anchor>a511a185</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_1</name>
      <anchor>a511a186</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cd_1bar</name>
      <anchor>a511a187</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_c0</name>
      <anchor>a511a188</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cbar0</name>
      <anchor>a511a189</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_c0</name>
      <anchor>a511a190</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cbar0</name>
      <anchor>a511a191</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_cplus</name>
      <anchor>a511a192</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_cbarminus</name>
      <anchor>a511a193</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_c0</name>
      <anchor>a511a194</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_cbar0</name>
      <anchor>a511a195</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_0</name>
      <anchor>a511a196</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_0bar</name>
      <anchor>a511a197</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_1</name>
      <anchor>a511a198</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cu_1bar</name>
      <anchor>a511a199</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cplus</name>
      <anchor>a511a200</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cbarminus</name>
      <anchor>a511a201</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cplus</name>
      <anchor>a511a202</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cbarminus</name>
      <anchor>a511a203</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cplus2</name>
      <anchor>a511a204</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_cbarminus2</name>
      <anchor>a511a205</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cplus2</name>
      <anchor>a511a206</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_cbarminus2</name>
      <anchor>a511a207</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_cplus</name>
      <anchor>a511a208</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_cbarminus</name>
      <anchor>a511a209</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_0</name>
      <anchor>a511a210</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_0bar</name>
      <anchor>a511a211</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_1</name>
      <anchor>a511a212</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cs_1bar</name>
      <anchor>a511a213</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_c0</name>
      <anchor>a511a214</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_cbar0</name>
      <anchor>a511a215</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_c0</name>
      <anchor>a511a216</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_cbar0</name>
      <anchor>a511a217</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_cplus</name>
      <anchor>a511a218</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_cbarminus</name>
      <anchor>a511a219</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_cplus</name>
      <anchor>a511a220</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_cbarminus</name>
      <anchor>a511a221</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_c0</name>
      <anchor>a511a222</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_cbar0</name>
      <anchor>a511a223</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_c0</name>
      <anchor>a511a224</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_cbar0</name>
      <anchor>a511a225</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cc_1</name>
      <anchor>a511a226</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>cc_1bar</name>
      <anchor>a511a227</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccplus</name>
      <anchor>a511a228</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccbarminus</name>
      <anchor>a511a229</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccplus</name>
      <anchor>a511a230</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccbarminus</name>
      <anchor>a511a231</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccplus2</name>
      <anchor>a511a232</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_ccbarminus2</name>
      <anchor>a511a233</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccplus2</name>
      <anchor>a511a234</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_ccbarminus2</name>
      <anchor>a511a235</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_ccplus</name>
      <anchor>a511a236</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_ccbarminus</name>
      <anchor>a511a237</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_ccplus</name>
      <anchor>a511a238</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_ccbarminus</name>
      <anchor>a511a239</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_cccplus2</name>
      <anchor>a511a240</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_cccbarminus</name>
      <anchor>a511a241</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_0</name>
      <anchor>a511a242</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_0bar</name>
      <anchor>a511a243</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_1</name>
      <anchor>a511a244</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bd_1bar</name>
      <anchor>a511a245</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bminus</name>
      <anchor>a511a246</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bbarplus</name>
      <anchor>a511a247</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bminus</name>
      <anchor>a511a248</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bbarplus</name>
      <anchor>a511a249</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_b0</name>
      <anchor>a511a250</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Lambda_bbar0</name>
      <anchor>a511a251</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bminus</name>
      <anchor>a511a252</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbarplus</name>
      <anchor>a511a253</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bc0</name>
      <anchor>a511a254</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bcbar0</name>
      <anchor>a511a255</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_0</name>
      <anchor>a511a256</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_0bar</name>
      <anchor>a511a257</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_1</name>
      <anchor>a511a258</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bu_1bar</name>
      <anchor>a511a259</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_b0</name>
      <anchor>a511a260</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bbar0</name>
      <anchor>a511a261</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_b0</name>
      <anchor>a511a262</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bbar0</name>
      <anchor>a511a263</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bplus</name>
      <anchor>a511a264</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigma_bbarminus</name>
      <anchor>a511a265</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bplus</name>
      <anchor>a511a266</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Sigmastar_bbarminus</name>
      <anchor>a511a267</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_b0</name>
      <anchor>a511a268</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbar0</name>
      <anchor>a511a269</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bcplus</name>
      <anchor>a511a270</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bcbarminus</name>
      <anchor>a511a271</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_0</name>
      <anchor>a511a272</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_0bar</name>
      <anchor>a511a273</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_1</name>
      <anchor>a511a274</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bs_1bar</name>
      <anchor>a511a275</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bminus</name>
      <anchor>a511a276</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bbarplus</name>
      <anchor>a511a277</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bminus</name>
      <anchor>a511a278</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbarplus</name>
      <anchor>a511a279</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_b0</name>
      <anchor>a511a280</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bbar0</name>
      <anchor>a511a281</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_b0</name>
      <anchor>a511a282</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbar0</name>
      <anchor>a511a283</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bminus</name>
      <anchor>a511a284</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbarplus</name>
      <anchor>a511a285</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bminus</name>
      <anchor>a511a286</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbarplus</name>
      <anchor>a511a287</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bc0</name>
      <anchor>a511a288</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bcbar0</name>
      <anchor>a511a289</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_0</name>
      <anchor>a511a290</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_0bar</name>
      <anchor>a511a291</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_1</name>
      <anchor>a511a292</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bc_1bar</name>
      <anchor>a511a293</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bc0</name>
      <anchor>a511a294</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bcbar0</name>
      <anchor>a511a295</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bc0</name>
      <anchor>a511a296</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bcbar0</name>
      <anchor>a511a297</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bcplus</name>
      <anchor>a511a298</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xiprime_bcbarminus</name>
      <anchor>a511a299</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bcplus</name>
      <anchor>a511a300</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bcbarminus</name>
      <anchor>a511a301</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegaprime_bc0</name>
      <anchor>a511a302</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegaprime_bcba</name>
      <anchor>a511a303</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bc0</name>
      <anchor>a511a304</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bcbar0</name>
      <anchor>a511a305</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bccplus</name>
      <anchor>a511a306</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bccbarminus</name>
      <anchor>a511a307</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bccplus</name>
      <anchor>a511a308</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bccbarminus</name>
      <anchor>a511a309</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bb_1</name>
      <anchor>a511a310</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>bb_1bar</name>
      <anchor>a511a311</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbminus</name>
      <anchor>a511a312</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbbarplus</name>
      <anchor>a511a313</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbminus</name>
      <anchor>a511a314</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbbarplus</name>
      <anchor>a511a315</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bb0</name>
      <anchor>a511a316</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xi_bbbar0</name>
      <anchor>a511a317</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bb0</name>
      <anchor>a511a318</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Xistar_bbbar0</name>
      <anchor>a511a319</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbminus</name>
      <anchor>a511a320</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbbarplus</name>
      <anchor>a511a321</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbminus</name>
      <anchor>a511a322</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbbarplus</name>
      <anchor>a511a323</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbc0</name>
      <anchor>a511a324</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omega_bbcbar0</name>
      <anchor>a511a325</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbc0</name>
      <anchor>a511a326</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbcbar0</name>
      <anchor>a511a327</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbbminus</name>
      <anchor>a511a328</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Omegastar_bbbbarplus</name>
      <anchor>a511a329</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_00</name>
      <anchor>a511a330</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b_10</name>
      <anchor>a511a331</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_0plus</name>
      <anchor>a511a332</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_0minus</name>
      <anchor>a511a333</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b_1plus</name>
      <anchor>a511a334</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>b_1minus</name>
      <anchor>a511a335</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>f_0</name>
      <anchor>a511a336</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h_1</name>
      <anchor>a511a337</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_00</name>
      <anchor>a511a338</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_0bar0</name>
      <anchor>a511a339</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_10</name>
      <anchor>a511a340</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_1bar0</name>
      <anchor>a511a341</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_0plus</name>
      <anchor>a511a342</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_0minus</name>
      <anchor>a511a343</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_1plus</name>
      <anchor>a511a344</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>K_1minus</name>
      <anchor>a511a345</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta1440</name>
      <anchor>a511a346</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>hprime_1</name>
      <anchor>a511a347</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0plus</name>
      <anchor>a511a348</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0minus</name>
      <anchor>a511a349</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1plus</name>
      <anchor>a511a350</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1minus</name>
      <anchor>a511a351</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_00</name>
      <anchor>a511a352</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0bar0</name>
      <anchor>a511a353</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_10</name>
      <anchor>a511a354</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1bar0</name>
      <anchor>a511a355</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0splus</name>
      <anchor>a511a356</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_0sminus</name>
      <anchor>a511a357</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1splus</name>
      <anchor>a511a358</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>D_1sminus</name>
      <anchor>a511a359</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_0c</name>
      <anchor>a511a360</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h_1c</name>
      <anchor>a511a361</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_00</name>
      <anchor>a511a362</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0bar0</name>
      <anchor>a511a363</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_10</name>
      <anchor>a511a364</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1bar0</name>
      <anchor>a511a365</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0plus</name>
      <anchor>a511a366</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0minus</name>
      <anchor>a511a367</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1plus</name>
      <anchor>a511a368</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1minus</name>
      <anchor>a511a369</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0s0</name>
      <anchor>a511a370</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0sbar0</name>
      <anchor>a511a371</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1s0</name>
      <anchor>a511a372</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1sbar0</name>
      <anchor>a511a373</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0cplus</name>
      <anchor>a511a374</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_0cminus</name>
      <anchor>a511a375</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1cplus</name>
      <anchor>a511a376</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>B_1cminus</name>
      <anchor>a511a377</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_0b</name>
      <anchor>a511a378</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>h_1b</name>
      <anchor>a511a379</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_10</name>
      <anchor>a511a380</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_1plus</name>
      <anchor>a511a381</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>a_1minus</name>
      <anchor>a511a382</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>f_1</name>
      <anchor>a511a383</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_10</name>
      <anchor>a511a384</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_1bar0</name>
      <anchor>a511a385</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_1plus</name>
      <anchor>a511a386</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Kstar_1minus</name>
      <anchor>a511a387</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>fprime_1</name>
      <anchor>a511a388</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1plus</name>
      <anchor>a511a389</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1minus</name>
      <anchor>a511a390</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_10</name>
      <anchor>a511a391</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1bar0</name>
      <anchor>a511a392</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1splus</name>
      <anchor>a511a393</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Dstar_1sminus</name>
      <anchor>a511a394</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_1c</name>
      <anchor>a511a395</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_10</name>
      <anchor>a511a396</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1bar0</name>
      <anchor>a511a397</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1plus</name>
      <anchor>a511a398</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1minus</name>
      <anchor>a511a399</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1s0</name>
      <anchor>a511a400</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1sbar0</name>
      <anchor>a511a401</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1cplus</name>
      <anchor>a511a402</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Bstar_1cminus</name>
      <anchor>a511a403</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>chi_1b</name>
      <anchor>a511a404</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>psiprime</name>
      <anchor>a511a405</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Upsilonprime</name>
      <anchor>a511a406</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_L</name>
      <anchor>a511a407</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_Lbar</name>
      <anchor>a511a408</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_L</name>
      <anchor>a511a409</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_Lbar</name>
      <anchor>a511a410</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_L</name>
      <anchor>a511a411</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_Lbar</name>
      <anchor>a511a412</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_L</name>
      <anchor>a511a413</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_Lbar</name>
      <anchor>a511a414</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_1</name>
      <anchor>a511a415</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_1bar</name>
      <anchor>a511a416</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_1</name>
      <anchor>a511a417</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_1bar</name>
      <anchor>a511a418</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Lminus</name>
      <anchor>a511a419</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Lplus</name>
      <anchor>a511a420</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eL</name>
      <anchor>a511a421</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eLbar</name>
      <anchor>a511a422</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Lminus</name>
      <anchor>a511a423</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Lplus</name>
      <anchor>a511a424</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muL</name>
      <anchor>a511a425</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muLbar</name>
      <anchor>a511a426</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_1minus</name>
      <anchor>a511a427</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_1plus</name>
      <anchor>a511a428</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauL</name>
      <anchor>a511a429</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauLbar</name>
      <anchor>a511a430</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_g</name>
      <anchor>a511a431</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_10</name>
      <anchor>a511a432</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_20</name>
      <anchor>a511a433</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_1plus</name>
      <anchor>a511a434</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_1minus</name>
      <anchor>a511a435</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_30</name>
      <anchor>a511a436</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_40</name>
      <anchor>a511a437</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_2plus</name>
      <anchor>a511a438</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_chi_2minus</name>
      <anchor>a511a439</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_Gravitino</name>
      <anchor>a511a440</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_R</name>
      <anchor>a511a441</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_d_Rbar</name>
      <anchor>a511a442</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_R</name>
      <anchor>a511a443</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_u_Rbar</name>
      <anchor>a511a444</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_R</name>
      <anchor>a511a445</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_s_Rbar</name>
      <anchor>a511a446</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_R</name>
      <anchor>a511a447</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_c_Rbar</name>
      <anchor>a511a448</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_2</name>
      <anchor>a511a449</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_b_2bar</name>
      <anchor>a511a450</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_2</name>
      <anchor>a511a451</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_t_2bar</name>
      <anchor>a511a452</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Rminus</name>
      <anchor>a511a453</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_e_Rplus</name>
      <anchor>a511a454</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eR</name>
      <anchor>a511a455</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_eRbar</name>
      <anchor>a511a456</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Rminus</name>
      <anchor>a511a457</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_mu_Rplus</name>
      <anchor>a511a458</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muR</name>
      <anchor>a511a459</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_muRbar</name>
      <anchor>a511a460</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_2minus</name>
      <anchor>a511a461</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_tau_2plus</name>
      <anchor>a511a462</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauR</name>
      <anchor>a511a463</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>SUSY_nu_tauRbar</name>
      <anchor>a511a464</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_tc0</name>
      <anchor>a511a465</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_tcplus</name>
      <anchor>a511a466</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_tcminus</name>
      <anchor>a511a467</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>piprime_tc0</name>
      <anchor>a511a468</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>eta_tc0</name>
      <anchor>a511a469</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_tc0</name>
      <anchor>a511a470</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_tcplus</name>
      <anchor>a511a471</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_tcminus</name>
      <anchor>a511a472</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>omega_tc</name>
      <anchor>a511a473</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>V8_tc</name>
      <anchor>a511a474</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_22_1_tc</name>
      <anchor>a511a475</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_22_8_tc</name>
      <anchor>a511a476</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_11_tc</name>
      <anchor>a511a477</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_12_tc</name>
      <anchor>a511a478</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_21_tc</name>
      <anchor>a511a479</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_22_tc</name>
      <anchor>a511a480</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dstar</name>
      <anchor>a511a481</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>dstarbar</name>
      <anchor>a511a482</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ustar</name>
      <anchor>a511a483</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>ustarbar</name>
      <anchor>a511a484</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>estarminus</name>
      <anchor>a511a485</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>estarbarplus</name>
      <anchor>a511a486</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nustar_e0</name>
      <anchor>a511a487</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nustar_ebar0</name>
      <anchor>a511a488</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Gravitonstar</name>
      <anchor>a511a489</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_Re</name>
      <anchor>a511a490</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_Rmu</name>
      <anchor>a511a491</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>nu_Rtau</name>
      <anchor>a511a492</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Z_R0</name>
      <anchor>a511a493</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>W_Rplus</name>
      <anchor>a511a494</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>W_Rminus</name>
      <anchor>a511a495</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Lplus2</name>
      <anchor>a511a496</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Lminus2</name>
      <anchor>a511a497</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Rplus2</name>
      <anchor>a511a498</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>H_Rminus2</name>
      <anchor>a511a499</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>rho_diff0</name>
      <anchor>a511a500</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_diffrplus</name>
      <anchor>a511a501</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>pi_diffrminus</name>
      <anchor>a511a502</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>omega_di</name>
      <anchor>a511a503</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>phi_diff</name>
      <anchor>a511a504</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>Jpsi_di</name>
      <anchor>a511a505</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>n_diffr0</name>
      <anchor>a511a506</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>n_diffrbar0</name>
      <anchor>a511a507</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>p_diffrplus</name>
      <anchor>a511a508</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>p_diffrbarminus</name>
      <anchor>a511a509</anchor>
      <arglist></arglist>
    </member>
    <member kind="enumvalue">
      <name>undefined</name>
      <anchor>a511a510</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Pointer</name>
    <filename>namespaceThePEG_1_1Pointer.html</filename>
    <class kind="struct">ThePEG::Pointer::Ptr</class>
    <class kind="struct">ThePEG::Pointer::PtrTraitsType</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; T * &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; const T * &gt;</class>
    <class kind="class">ThePEG::Pointer::RCPtrBase</class>
    <class kind="class">ThePEG::Pointer::RCPtr</class>
    <class kind="class">ThePEG::Pointer::ConstRCPtr</class>
    <class kind="class">ThePEG::Pointer::TransientRCPtr</class>
    <class kind="class">ThePEG::Pointer::TransientConstRCPtr</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; RCPtr&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; ConstRCPtr&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; TransientRCPtr&lt; T &gt; &gt;</class>
    <class kind="struct">ThePEG::Pointer::PtrTraits&lt; TransientConstRCPtr&lt; T &gt; &gt;</class>
    <class kind="class">ThePEG::Pointer::ReferenceCounted</class>
    <member kind="function">
      <type>T1</type>
      <name>dynamic_ptr_cast</name>
      <anchor>a0</anchor>
      <arglist>(const T2 &amp;t2)</arglist>
    </member>
    <member kind="function">
      <type>T1</type>
      <name>const_ptr_cast</name>
      <anchor>a1</anchor>
      <arglist>(const T2 &amp;t2)</arglist>
    </member>
    <member kind="function">
      <type>Ptr</type>
      <name>ptr_new</name>
      <anchor>a2</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Ptr</type>
      <name>ptr_new</name>
      <anchor>a3</anchor>
      <arglist>(typename PtrTraits&lt; Ptr &gt;::const_reference t)</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>new_ptr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>Ptr&lt; T &gt;::pointer</type>
      <name>new_ptr</name>
      <anchor>a5</anchor>
      <arglist>(const T &amp;t)</arglist>
    </member>
    <member kind="function">
      <type>TPtr</type>
      <name>ptr_cast</name>
      <anchor>a6</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="function">
      <type>TPtr</type>
      <name>ptr_cast_const</name>
      <anchor>a7</anchor>
      <arglist>(const T *t)</arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::Ptr</name>
    <filename>structThePEG_1_1Pointer_1_1Ptr.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pointer</type>
      <name>ptr</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const_pointer</type>
      <name>cptr</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_pointer</type>
      <name>tptr</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_const_pointer</type>
      <name>tcptr</name>
      <anchor>w7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>pointer</type>
      <name>p</name>
      <anchor>w8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const_pointer</type>
      <name>cp</name>
      <anchor>w9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_pointer</type>
      <name>tp</name>
      <anchor>w10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>transient_const_pointer</type>
      <name>tcp</name>
      <anchor>w11</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraitsType</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraitsType.html</filename>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; T * &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01T_01_5_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(T *p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(R *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; const T * &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01const_01T_01_5_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>const T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const T *p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(const R *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const T *r)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::RCPtrBase</name>
    <filename>classThePEG_1_1Pointer_1_1RCPtrBase.html</filename>
    <member kind="function" protection="protected">
      <type>void</type>
      <name>increment</name>
      <anchor>b0</anchor>
      <arglist>(const ReferenceCounted *)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>bool</type>
      <name>release</name>
      <anchor>b1</anchor>
      <arglist>(const ReferenceCounted *)</arglist>
    </member>
    <member kind="typedef" protection="private">
      <type>ReferenceCounted::CounterType</type>
      <name>CounterType</name>
      <anchor>y0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::RCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1RCPtr.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::RCPtrBase</base>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const RCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>RCPtr</name>
      <anchor>a3</anchor>
      <arglist>(pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~RCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>create</name>
      <anchor>a5</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>create</name>
      <anchor>a6</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a7</anchor>
      <arglist>(const RCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a8</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a9</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>RCPtr &amp;</type>
      <name>assignConst</name>
      <anchor>a10</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>assign</name>
      <anchor>a11</anchor>
      <arglist>(pointer)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a12</anchor>
      <arglist>(RCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a13</anchor>
      <arglist>(const RCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a14</anchor>
      <arglist>(const RCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a15</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a16</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a17</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a18</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a19</anchor>
      <arglist>(const RCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a20</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a21</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator T *</name>
      <anchor>a22</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>operator-&gt;</name>
      <anchor>a23</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator *</name>
      <anchor>a24</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RCPtr</type>
      <name>Create</name>
      <anchor>e0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>RCPtr</type>
      <name>Create</name>
      <anchor>e1</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>increment</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>release</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pointer</type>
      <name>thePointer</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::ConstRCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1ConstRCPtr.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::RCPtrBase</base>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const ConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>ConstRCPtr</name>
      <anchor>a3</anchor>
      <arglist>(const_pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~ConstRCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>ConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const ConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>ConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>ConstRCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a7</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>void</type>
      <name>swap</name>
      <anchor>a8</anchor>
      <arglist>(ConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a9</anchor>
      <arglist>(const ConstRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a10</anchor>
      <arglist>(const ConstRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a11</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a12</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a13</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a14</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a15</anchor>
      <arglist>(const ConstRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a16</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator const T *</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_pointer</type>
      <name>operator-&gt;</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_reference</type>
      <name>operator *</name>
      <anchor>a20</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>increment</name>
      <anchor>d0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>release</name>
      <anchor>d1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const_pointer</type>
      <name>thePointer</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::TransientRCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1TransientRCPtr.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const TransientRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientRCPtr</name>
      <anchor>a3</anchor>
      <arglist>(pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TransientRCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const TransientRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a7</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>TransientRCPtr &amp;</type>
      <name>assignConst</name>
      <anchor>a8</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a9</anchor>
      <arglist>(const TransientRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a10</anchor>
      <arglist>(const TransientRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a11</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a12</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a13</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a14</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a15</anchor>
      <arglist>(const TransientRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a16</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator T *</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>pointer</type>
      <name>operator-&gt;</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>reference</type>
      <name>operator *</name>
      <anchor>a20</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>pointer</type>
      <name>thePointer</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::TransientConstRCPtr</name>
    <filename>classThePEG_1_1Pointer_1_1TransientConstRCPtr.html</filename>
    <templarg>T</templarg>
    <member kind="typedef">
      <type>void</type>
      <name>iterator_category</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>void</type>
      <name>difference_type</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T *</type>
      <name>pointer</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T *</type>
      <name>const_pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T &amp;</type>
      <name>reference</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>const T &amp;</type>
      <name>const_reference</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>T</type>
      <name>value_type</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a1</anchor>
      <arglist>(const TransientConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>TransientConstRCPtr</name>
      <anchor>a3</anchor>
      <arglist>(const_pointer p)</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>~TransientConstRCPtr</name>
      <anchor>a4</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function">
      <type>TransientConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a5</anchor>
      <arglist>(const TransientConstRCPtr &amp;p)</arglist>
    </member>
    <member kind="function">
      <type>TransientConstRCPtr &amp;</type>
      <name>operator=</name>
      <anchor>a6</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>TransientConstRCPtr &amp;</type>
      <name>assignDynamic</name>
      <anchor>a7</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a8</anchor>
      <arglist>(const TransientConstRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a9</anchor>
      <arglist>(const TransientConstRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a10</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a11</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator==</name>
      <anchor>a12</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!=</name>
      <anchor>a13</anchor>
      <arglist>(const UPtr &amp;u) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a14</anchor>
      <arglist>(const TransientConstRCPtr &amp;p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator&lt;</name>
      <anchor>a15</anchor>
      <arglist>(const_pointer p) const</arglist>
    </member>
    <member kind="function">
      <type>bool</type>
      <name>operator!</name>
      <anchor>a16</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type></type>
      <name>operator const T *</name>
      <anchor>a17</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_pointer</type>
      <name>operator-&gt;</name>
      <anchor>a18</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function">
      <type>const_reference</type>
      <name>operator *</name>
      <anchor>a19</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>const_pointer</type>
      <name>thePointer</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; RCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01RCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const RCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; ConstRCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01ConstRCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>const T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const ConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>create</name>
      <anchor>e1</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>create</name>
      <anchor>e2</anchor>
      <arglist>(const_reference t)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e3</anchor>
      <arglist>(const_pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>DynamicCast</name>
      <anchor>e4</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>ConstCast</name>
      <anchor>e5</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>const_pointer</type>
      <name>PtrCast</name>
      <anchor>e6</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; TransientRCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01TransientRCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const TransientRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e1</anchor>
      <arglist>(transient_pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_pointer</type>
      <name>DynamicCast</name>
      <anchor>e2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_pointer</type>
      <name>ConstCast</name>
      <anchor>e3</anchor>
      <arglist>(transient_const_pointer c)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_pointer</type>
      <name>PtrCast</name>
      <anchor>e4</anchor>
      <arglist>(T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="struct">
    <name>ThePEG::Pointer::PtrTraits&lt; TransientConstRCPtr&lt; T &gt; &gt;</name>
    <filename>structThePEG_1_1Pointer_1_1PtrTraits_3_01TransientConstRCPtr_3_01T_01_4_01_4.html</filename>
    <templarg>T</templarg>
    <base>ThePEG::Pointer::PtrTraitsType</base>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;::value_type</type>
      <name>value_type</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;::reference</type>
      <name>reference</name>
      <anchor>w1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;::const_reference</type>
      <name>const_reference</name>
      <anchor>w2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>RCPtr&lt; T &gt;</type>
      <name>pointer</name>
      <anchor>w3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>ConstRCPtr&lt; T &gt;</type>
      <name>const_pointer</name>
      <anchor>w4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientRCPtr&lt; T &gt;</type>
      <name>transient_pointer</name>
      <anchor>w5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>TransientConstRCPtr&lt; T &gt;</type>
      <name>transient_const_pointer</name>
      <anchor>w6</anchor>
      <arglist></arglist>
    </member>
    <member kind="function" static="yes">
      <type>const T *</type>
      <name>barePointer</name>
      <anchor>e0</anchor>
      <arglist>(const TransientConstRCPtr&lt; T &gt; &amp;p)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>void</type>
      <name>destroy</name>
      <anchor>e1</anchor>
      <arglist>(transient_const_pointer tp)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_const_pointer</type>
      <name>DynamicCast</name>
      <anchor>e2</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_const_pointer</type>
      <name>ConstCast</name>
      <anchor>e3</anchor>
      <arglist>(const UPtr &amp;u)</arglist>
    </member>
    <member kind="function" static="yes">
      <type>transient_const_pointer</type>
      <name>PtrCast</name>
      <anchor>e4</anchor>
      <arglist>(const T *t)</arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const bool</type>
      <name>reference_counted</name>
      <anchor>s0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="class">
    <name>ThePEG::Pointer::ReferenceCounted</name>
    <filename>classThePEG_1_1Pointer_1_1ReferenceCounted.html</filename>
    <member kind="typedef">
      <type>unsigned int</type>
      <name>CounterType</name>
      <anchor>w0</anchor>
      <arglist></arglist>
    </member>
    <member kind="function">
      <type>CounterType</type>
      <name>referenceCount</name>
      <anchor>a0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ReferenceCounted</name>
      <anchor>z902_0</anchor>
      <arglist>()</arglist>
    </member>
    <member kind="function" protection="protected">
      <type></type>
      <name>ReferenceCounted</name>
      <anchor>z902_1</anchor>
      <arglist>(const ReferenceCounted &amp;)</arglist>
    </member>
    <member kind="function" protection="protected">
      <type>ReferenceCounted &amp;</type>
      <name>operator=</name>
      <anchor>z902_2</anchor>
      <arglist>(const ReferenceCounted &amp;)</arglist>
    </member>
    <member kind="function" protection="private">
      <type>void</type>
      <name>incrementReferenceCount</name>
      <anchor>d0</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="function" protection="private">
      <type>bool</type>
      <name>decrementReferenceCount</name>
      <anchor>d1</anchor>
      <arglist>() const</arglist>
    </member>
    <member kind="variable" protection="private">
      <type>CounterType</type>
      <name>theReferenceCounter</name>
      <anchor>r0</anchor>
      <arglist></arglist>
    </member>
  </compound>
  <compound kind="namespace">
    <name>ThePEG::Units</name>
    <filename>namespaceThePEG_1_1Units.html</filename>
    <member kind="typedef">
      <type>double</type>
      <name>Mass</name>
      <anchor>a0</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy</name>
      <anchor>a1</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Time</name>
      <anchor>a2</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Length</name>
      <anchor>a3</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Charge</name>
      <anchor>a4</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>AngularMomentum</name>
      <anchor>a5</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Area</name>
      <anchor>a6</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Area</type>
      <name>CrossSection</name>
      <anchor>a7</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy2</name>
      <anchor>a8</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy4</name>
      <anchor>a9</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Energy2XSec</name>
      <anchor>a10</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>DiffXSec</name>
      <anchor>a11</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Diff2XSec</name>
      <anchor>a12</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>Diff3XSec</name>
      <anchor>a13</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>InvEnergy</name>
      <anchor>a14</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>InvEnergy2</name>
      <anchor>a15</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>double</type>
      <name>InvEnergy4</name>
      <anchor>a16</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Energy2</type>
      <name>Scale</name>
      <anchor>a17</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector3</type>
      <name>Point</name>
      <anchor>a18</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector3</type>
      <name>Distance</name>
      <anchor>a19</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Vector3</type>
      <name>Momentum3</name>
      <anchor>a20</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LorentzVector</type>
      <name>LorentzDistance</name>
      <anchor>a21</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Lorentz5Vector&lt; Length &gt;</type>
      <name>Lorentz5Distance</name>
      <anchor>a22</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LorentzVector</type>
      <name>LorentzPoint</name>
      <anchor>a23</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>LorentzVector</type>
      <name>LorentzMomentum</name>
      <anchor>a24</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Lorentz5Vector&lt; Energy &gt;</type>
      <name>Lorentz5Momentum</name>
      <anchor>a25</anchor>
      <arglist></arglist>
    </member>
    <member kind="typedef">
      <type>Transverse&lt; Energy &gt;</type>
      <name>TransverseMomentum</name>
      <anchor>a26</anchor>
      <arglist></arglist>
    </member>
    <member kind="variable" static="yes">
      <type>const Energy2</type>
      <name>GeV2</name>
      <anchor>a27</anchor>
      <arglist></arglist>
    </member>
  </compound>
</tagfile>
