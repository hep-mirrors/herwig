// -*- C++ -*-
//
// MyEventShapes.icc is a part of Herwig - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the MyEventShapes class.
//

namespace Herwig {


inline double MyEventShapes::thrust() {
  checkThrust(); 
  return _thrust[0];
}

inline double MyEventShapes::thrustMajor() {
  checkThrust(); 
  return _thrust[1];
}

inline double MyEventShapes::thrustMinor() {
  checkThrust(); 
  return _thrust[2];
}

inline double MyEventShapes::oblateness() {
  checkThrust(); 
  return _thrust[1]-_thrust[2];
}

inline Axis MyEventShapes::thrustAxis() {
  checkThrust(); 
  return _thrustAxis[0];
}

inline Axis MyEventShapes::majorAxis() {
  checkThrust(); 
  return _thrustAxis[1];
}

inline Axis MyEventShapes::minorAxis() {
  checkThrust(); 
  return _thrustAxis[2];
}

inline void MyEventShapes::reset(const tPVector &part)
{
  _pv.resize(part.size());
  for(unsigned int ix=0;ix<part.size();++ix) _pv[ix]=part[ix]->momentum();
  _thrustDone = false;
  _spherDone  = false;
  _linTenDone = false;
  _hemDone    = false;
  _useCmBoost = false; 
}

inline double MyEventShapes::sphericity() {
  checkSphericity(); 
  return 3./2.*(_spher[1]+_spher[2]); 
}

inline double MyEventShapes::aplanarity() {
  checkSphericity(); 
  return 3./2.*_spher[2];
}

inline double MyEventShapes::planarity() {
  checkSphericity(); 
  return _spher[1]-_spher[2]; 
}

inline Axis MyEventShapes::sphericityAxis() {
  checkSphericity(); 
  return _spherAxis[0]; 
}

inline vector<double> MyEventShapes::sphericityEigenValues() {
  checkSphericity(); 
  return _spher; 
}

inline vector<Axis> MyEventShapes::sphericityEigenVectors() {
  checkSphericity(); 
  return _spherAxis; 
}

inline vector<double> MyEventShapes::linTenEigenValues() {
  checkLinTen(); 
  return _linTen; 
}

inline vector<Axis> MyEventShapes::linTenEigenVectors() {
  checkLinTen(); 
  return _linTenAxis; 
}

inline double MyEventShapes::CParameter() {
  checkLinTen(); 
  return 3.*(_linTen[0]*_linTen[1]+_linTen[1]*_linTen[2]
	     +_linTen[2]*_linTen[0]); 
}

inline double MyEventShapes::DParameter() {
  checkLinTen(); 
  return 27.*(_linTen[0]*_linTen[1]*_linTen[2]); 
}

inline double MyEventShapes::Mhigh2() {
  checkHemispheres();
  return _mPlus; 
} 

inline double MyEventShapes::Mlow2() {
  checkHemispheres();
  return _mMinus; 
} 

inline double MyEventShapes::Mdiff2() {
  checkHemispheres();
  return _mPlus-_mMinus; 
} 

inline double MyEventShapes::Bmax() {
  checkHemispheres(); 
  return _bPlus;
}

inline double MyEventShapes::Bmin() {
  checkHemispheres(); 
  return _bMinus;
}

inline double MyEventShapes::Bsum() {
  checkHemispheres(); 
  return _bPlus+_bMinus;
}

inline double MyEventShapes::Bdiff() {
  checkHemispheres(); 
  return _bPlus-_bMinus;
}

inline void MyEventShapes::checkLinTen() {
  if (!_linTenDone) {
    _linTenDone = true;
    diagonalizeTensors(true, _useCmBoost); 
  }
}

inline void MyEventShapes::checkSphericity() {
  if (!_spherDone) {
    _spherDone = true;
    diagonalizeTensors(false, _useCmBoost); 
  }
}

inline void MyEventShapes::checkThrust() {
  if (!_thrustDone) {
    _thrustDone = true;
    calculateThrust(); 
  }
}

inline void MyEventShapes::checkHemispheres() {
  if (!_hemDone) {
    _hemDone = true;
    calcHemisphereMasses(); 
  }
}

inline void MyEventShapes::calcHemisphereMasses() {
  Lorentz5Momentum pos, neg;
  Energy pden(ZERO),epos(ZERO),eneg(ZERO);
  for(unsigned int ix=0;ix<_pv.size();++ix)
    {
      if(_pv[ix].vect() * thrustAxis() > ZERO)
	{
	  pos  += _pv[ix];
	  epos += _pv[ix].perp(thrustAxis()); 
	}
      else
	{
	  neg  += _pv[ix];
	  eneg += _pv[ix].perp(thrustAxis()); 
	}
      pden += _pv[ix].vect().mag();	 
    }
  // denominator and masses
  Energy2 den(sqr(pos.e()+neg.e()));
  _mPlus = pos.m2()/den;
  _mMinus = neg.m2()/den;
  if (_mPlus < _mMinus) swap(_mPlus, _mMinus);
  // jet broadening
  _bPlus  = 0.5*epos/pden;
  _bMinus = 0.5*eneg/pden;
  if (_bPlus < _bMinus) swap(_bPlus, _bMinus);
}

inline double MyEventShapes::getXi(const Lorentz5Momentum & p, 
				 const Energy & Ebeam) {
  return((Ebeam > ZERO && p.vect().mag() > ZERO) ? 
	 log(Ebeam/p.vect().mag()) : -1.); 
}

inline Energy MyEventShapes::getPt(const Lorentz5Momentum & p) {
  return p.perp(); 
}

inline double MyEventShapes::getRapidity(const Lorentz5Momentum & p) {
  return (p.t() > p.z() ? p.rapidity() : 1e99); 
}

inline Energy MyEventShapes::ptInT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[1]; 
}

inline Energy MyEventShapes::ptOutT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return p.vect()*_thrustAxis[2]; 
}

inline double MyEventShapes::yT(const Lorentz5Momentum & p) {
  checkThrust(); 
  return (p.t() > p.vect()*_thrustAxis[0] ? 
	  p.rapidity(_thrustAxis[0]) : 1e99);
}

inline Energy MyEventShapes::ptInS(const Lorentz5Momentum & p) { 
  checkSphericity(); 
  return p.vect()*_spherAxis[1]; 
}

inline Energy MyEventShapes::ptOutS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return p.vect()*_spherAxis[2]; 
}

inline double MyEventShapes::yS(const Lorentz5Momentum & p) {
  checkSphericity(); 
  return (p.t() > p.vect()*_spherAxis[0] ? 
	  p.rapidity(_spherAxis[0]) : 1e99);
}

inline void MyEventShapes::normalizeEEC(vector<double> & hi, long evts) {
  for (unsigned int bin = 0; bin < hi.size(); bin++) bin /= (hi.size()*evts);
}

inline double MyEventShapes::AEEC(vector<double> & hi, double& coschi) {
  if (coschi > 0. && coschi <= 1.) {
    int i = static_cast<int>( floor((-coschi+1.)/2.*hi.size()) ); 
    int j = static_cast<int>( floor(( coschi+1.)/2.*hi.size()) ); 
    return hi[i]-hi[j];
  } else {
    return 1e99;
  }
}
}
