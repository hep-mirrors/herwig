#include <cstdlib> 
#include <ctime> 
#include <iostream>
#include <fstream>
#include <string>
#include <fstream>
#include <stdio.h>
#include <cmath>
#include <iomanip>
// Set this to path of input file 

#include "PWEPEM_INPUTS.h"


using namespace std;

/******************************************************************************/
// filegen generates interpolation files for numerical integration. These are tables of pt squared vs integral 
 void filegen(double &rintgend1, double &rintgend2, double &rintgend3, double &rintgend4);
// Function used in filegen. This is the integral over x.
 double function(double pt2, double x);
// interp reads files generated by filegen to find solutions to Sudakov form factor. Uses polynomial of order 3.
double interp(int N,double XXX, double Xmax1, double Xmax2, double Xmax3, double Xmax4);
// xmaxmin determines the maximum and minimum value of x for given values of pt2 depending on which y branch it lies.
void xmaxmin (double pt2, double &rxmax, double &rxmin5,double &rxmin6 );
// ME calculates the value of the approximation to the NLO matrix element for given y and x.
double ME (double pt2,double &rx, double &ry1, double &ry2, double xmin5, double &rM1, double &rM2, double &rw);
// Random number generator
double random (int &rseed);
/******************************************************************************/
  Input user;
 double pt2max = 0.0901699441;
 double pt2min = 0.0000048;
 double pi = 3.14152654;
 double b = 23./(12.*pi);
 double bp = 58./(46.*pi);
 double emcm = user.cme();
 double CF = 4./3.;


int main() {
  // Switches
  int nevg = user.nevgen();
  int nit = user.it();
  //  double emcm = user.cme();
  int seed = user.rseed();
  int nf = user.nf();
  double Mz =  user.Mz();   
  double alphasmz = user.alphasmz();
  bool truncate = user.trunc();
  bool massiveME = user.massiveME();
  bool boost = user.bst();
  if (massiveME) {boost=false;}
  int ii=0; //event count


  // Integrals at end of pt2-integral tables

  double end1,end2,end3,end4;

  // Generate integration files

  filegen(end1,end2,end3,end4); 

  
  int mm=0;

  // File for output

  ofstream outdata5;
  outdata5.open("PWEPEM.dat", ios::trunc); 
     outdata5 << "<LesHouchesEvents version =\"1.0\">" << endl; outdata5 << "<!--" << endl;
     outdata5 << "File generated with PWEPEM.cxx" << endl; outdata5 << "-->" << endl;
     outdata5 << "<init>" << endl;
     outdata5 << "\t11\t" << "-11\t";
     outdata5 << user.cme()/2. << "\t" << user.cme()/2.  << "\t" << "0 \t 0 \t 7\t 7 \t 1 \t 1" << endl;
     outdata5 << "\t" << 30590.  << "\t" << 0.000000 << "\t1.00000 \t11" << endl;     outdata5 << "</init>" << endl;
  for (int ixx=1; ixx < nevg+1; ixx++) {
    double x1, x2;
    x1 = 0.; x2 = 0.;
    //iterate = true if solution found and hence hardest emission.

    bool iterate =false;
    double intg=0.;
    
    for (int ia=0; iterate==false; ia++){

      //find solution to log(Delta) = log(random number)

      double logn=fabs(log(random(seed)));
      intg+=logn;
       double pt2=interp(1000,intg,end1,end2,end3,end4);
     
      if (0.*intg !=0) {break;}
      if (intg > end4) {break;}
      if (pt2 < pt2min) {break;}
      double xmax, xmin5, xmin6;
       xmaxmin(pt2, xmax, xmin5, xmin6);
       double x , y1, y2, M, M1, M2, w;
       // find maximum value of ME
        double Mmax=0.;
     	for (int ix=0; ix < 10000 ; ix++) {
       x=(xmax-xmin6)*random(seed)+xmin6;
       M = ME(pt2,x,y1,y2,xmin5,M1,M2,w);
        if (fabs(M) > fabs(Mmax)) {Mmax=M;}
	}
	
	// distribute according to matrix element*delta function

	do {
       x=(xmax-xmin6)*random(seed)+xmin6;
       M = ME(pt2,x,y1,y2,xmin5,M1,M2,w);} while (random(seed) > fabs(M/Mmax));

	//parent parton identifier

	int Jt;
	Jt = 0;
	//  Select parent parton and matrix element upper bound veto 

	if (x > xmin5 && pt2 < 1./12.){
	  if (random(seed) < (fabs(M1)/fabs(M))) {
	    if (random(seed) < (pow(x,2)+pow(y1,2))/2.) {
	       //Kleiss trick
	      if (random(seed) < pow(x,2)/(pow(x,2)+pow(y1,2))) {
		x1=x;
		x2=y1;
		Jt=1;}
	      else{
	        x2=x;
	        x1=y1;
		Jt=2;}
	    
	      
              mm=mm+1;
	     
	      iterate=true;
	     
	    }}
          else{
	    if (random(seed) < (pow(x,2)+pow(y2,2))/2.) {
	       //Kleiss trick
	      if (random(seed) < pow(x,2)/(pow(x,2)+pow(y1,2))) {
		x1=x;
		x2=y2;
		Jt=1;}
	      else{
	        x2=x;
	        x1=y2;
	        Jt=2;}
	    
              mm=mm+1;
	    
	      iterate=true;}}}
	else {
          if (random(seed) < (pow(x,2)+pow(y2,2))/2.) {
	    //Kleiss trick
	    if (random(seed) < pow(x,2)/(pow(x,2)+pow(y1,2))) { 
	         x1=x;
		 x2=y2;
		 Jt=1;}
           else{
	        x2=x;
	        x1=y2;
	        Jt=2;}
	   
              mm=mm+1;
	     
	      iterate=true;  }}
      if (iterate) {
	
	double z1, ptr2, ptsq ,z, q;
	ptr2 =0.;
	bool emit = false;
	ptsq=pow(emcm,2)*pt2;

	// Truncated Shower 

      if (truncate) {
        double Qg=0.75;
	double u=0.75;
	double qc=2.8;
	double alpham=1.;
	double x3=2.-x1-x2;
	//	ptsq=pow(emcm,2)*pt2;

	if (Jt==1) {
	  z=0.5*(x2+sqrt(pow(x2,2)-4.*pt2));
		
	}else {
	  z=0.5*(x1+sqrt(pow(x1,2)-4.*pt2));
		
	}
	double qi=emcm;

	double Pzmax=(1.+pow((1.-Qg/emcm),2))/(Qg/emcm);
	double Pz;
	do{
	z1=random(seed)*(1.-Qg/emcm-u/emcm)+u/emcm;
	Pz=(1.+pow(z1,2))/(1.-z1);} while (random(seed) > Pz/Pzmax);
	if (ptsq/pow(z*(1.-z),2)+pow(u/z,2)+pow(Qg/(1.-z),2)/z < 0.) {emit=false;}
	double qh=sqrt(ptsq/pow(z*(1.-z),2)+pow(u/z,2)+pow(Qg/(1.-z),2)/z);
        double C=CF*alpham*log(Qg/(qi-u))/pi;
	  double D=exp(2.*log(qh/qc)*C);
	  double E=exp(2.*log(qi/qc)*C);
	 if (random(seed) < 1.-E/D) {
	  do {
	  q=sqrt(exp(log(E/random(seed))/C)*pow(qc,2));} while (q < qh); 
	  ptr2 = pow((1.-z1)*z1*q,2)-pow((1-z1)*u,2)-z1*pow(Qg,2);
	  emit = true;
	  //energy fractions
	  double ze=z+pt2/z;
	  double z1e=z1+ptr2/(pow(emcm,2)*z1); 
	  // vetoes: pt, and alphas

	  if (Jt==1) {if ((1.-z1e)*(x2+x3)*emcm/2.< sqrt(ptr2)){emit=false;}
	  if (ze*z1e*(x2+x3)*emcm/2.< sqrt(ptsq))    {emit=false;}}

	  if (Jt==2) {if ((1.-z1e)*(x1+x3)*emcm/2.< sqrt(ptr2)){emit=false;}
	  if (ze*z1e*(x1+x3)*emcm/2.< sqrt(ptsq))    {emit=false;}}
	  double alphas=1./(b*log(ptr2/(pt2min*pow(emcm,2))))*(1.-bp*log(log(ptr2/(pt2min*pow(emcm,2))))/(b*log(ptr2/(pt2min*pow(emcm,2)))));
	  alphas=alphas+pow(alphas,2)*(67./3.-pow(pi,2)-50./9.)/(4.*pi);

	  if (ptr2 < 0 || q > qi || ptr2 > ptsq || random(seed) > alphas/alpham || random(seed) > Pz*(1.-z1)/2.) {emit=false;}
	  //change to energy fraction z1e
          z1=z1e;
	   }
      }
  

      // Assign event properties for LH reader

// Constants 
  double GF = 0.0000116639;
  double Yz = 2.486;
  double alphaem = 0.007297352;
  
  //Lepton charge & coupling constants
  double Che = -1;
  double sin2thw = 0.2312;
  double Ae = -0.5;
  double Ve = Ae-2.*Che*sin2thw;
  double AV2 = pow(Ae,2)+pow(Ve,2);
  double CLe = (Ae+Ve)/2.;
  double CRe = (Ve-Ae)/2.;
  double gz2 = sqrt(32.)*GF*pow(Mz,2);
  double e2 = 4.*pi*alphaem;
  double k = sqrt(2.)*GF*pow(Mz,2)/e2;
  double chi1 = k*pow(emcm,2)*(pow(emcm,2)-pow(Mz,2))/(pow((pow(emcm,2)-pow(Mz,2)),2)+pow(Yz*Mz,2));
  double chi2 = pow(k,2)*pow(emcm,4)/(pow((pow(emcm,2)-pow(Mz,2)),2)+pow(Yz*Mz,2));
  // double alphas=1./(b*log(1./pt2min))*(1.-bp*log(log(1./pt2min))/(b*log(1./pt2min)));
   
  //quark masses ,velocities and couplings. NB:gluon mass[6] =0.75 
    double mq[7],beta[6],Ch[6],Aq[6],Vq[6],cs[6],sigV[6],sigA[6],sigVA[6],css;
  
  mq[1] = 0.325; mq[2] = 0.325; mq[3] = 0.5; mq[4] = 1.6; mq[5] = 5.; mq[6] = 0.75; 
 

    Ch[1]=-1./3.; Ch[2]=2./3.; Ch[3]=Ch[1]; Ch[4]=Ch[2]; Ch[5]=Ch[1];
    Aq[1]=-0.5; Aq[2]=0.5; Aq[3]=Aq[1]; Aq[4]=Aq[2]; Aq[5]=Aq[1];
   //Calculate  Born cross-section
   //initialize cross-sections...
  cs[1]=0.; cs[2]=0.; cs[3]=0.; cs[4]=0.; cs[5]=0.; css=0.;
  for (int ix=1; ix < nf; ix++) {
    Vq[ix] = Aq[ix]-(2.*Ch[ix]*sin2thw);
    beta[ix] = sqrt(1.-4.*pow(mq[ix]/emcm,2));
    sigV[ix] = pow(Ch[ix],2)-2.*Ch[ix]*Ve*Vq[ix]*chi1+AV2*pow(Vq[ix],2)*chi2;
    sigA[ix] = AV2*pow(Aq[ix],2)*chi2;
    sigVA[ix]= -2.*Ch[ix]*Ae*Aq[ix]*chi1+4.*Ae*Ve*Aq[ix]*Vq[ix]*chi2;
    cs[ix] = beta[ix]+0.5*pow(beta[ix],2)+0.5*(1.-pow(beta[ix],2))*beta[ix]*sigV[ix]+pow(beta[ix],3)*sigA[ix];
    css+=cs[ix];
}
  //select flavour of process
  double m, mg, mass[8];
  int ID;
  if (random(seed) < cs[1]/css) {ID = 1; } else {
    if (random(seed) < cs[2]/(css-cs[1])) {ID = 2;} else {
      if (random(seed) < cs[3]/(css-cs[1]-cs[2])) {ID = 3; } else {
	if (random(seed) < cs[4]/(cs[4]+cs[5])) {ID = 4; } else {
	  ID = 5; m = mq[5];}}}} 
  if (massiveME) {m = mq[ID];} else {m = 0.;}  
  mass[1]=0.;
  mass[2]=0.;
  mass[3]=emcm;  
  // Parameters for NLO cross-section calculation.
  double param[8];
  param[0] = pow(m,2)/pow(emcm,2);
  param[1] = 1.+12.*param[0]; // R = 1+param[1]*alphasmz/pi for vector current
  param[2] = 1.-22.*param[0]; // R = 1+param[2]*alphasmz/pi for axial vector current
  param[3] = 2.*param[0];
  param[4] = sqrt(1.-4.*param[0]); // beta
  param[5] = 0.5*(1.+param[4]);
  param[6] = (param[0]*param[5]+0.25*param[4]*pow(1+param[4],2))/(param[5]-param[0]);
  param[7] = 2.*alphasmz/(3.*pi); // colour factor

  // cross-section parameters
  double sigU = param[4]*sigV[ID]+pow(param[4],3)*sigA[ID];
  double sigL = 0.5*(1.-pow(param[4],2))*param[4]*sigV[ID];
  double sigF = pow(param[4],2)*sigVA[ID];
  double CLf = (Aq[ID]+Vq[ID])/2.;
  double CRf = (Vq[ID]-Aq[ID])/2.;
  //*********************************************************************************
  /*Les Houches Accord event parameters:: PUP are the momenta, 
   ICOLUP is the colour code, MOTHUP is the mother information, ISTUP is 
   the status code. ISPINUP signifies spins. IDUP is the particle ID.
    NUP is the number of particles in the event. SCALUP is the scale of 
   the event.AQEDUP and AQCDUP are alphaem and alphasmz resp.XWGTUP is 
   the weight of the event=1 or -1 for unweighted events.*/
  
  double PUP[6][9],AQEDUP,AQCDUP,XWGTUP,SCALUP;
  int ICOLUP[3][8],MOTHUP[3][8],ISTUP[8],ISPINUP[8],IDUP[8],NUP;
  SCALUP = sqrt(ptsq);
  AQEDUP=0.007297352;
  AQCDUP=alphasmz;
  IDUP[1]=11;
  IDUP[2]=-11;
  IDUP[3]=23;
  IDUP[4]=ID;
  IDUP[5]=-ID;
  IDUP[6]=21;
  MOTHUP[1][1]=0;
  MOTHUP[1][2]=0;
  MOTHUP[2][1]=0;
  MOTHUP[2][2]=0;
  MOTHUP[1][3]=1;
  MOTHUP[2][3]=2;
  MOTHUP[1][4]=3;
  MOTHUP[2][4]=3;
  MOTHUP[1][5]=3;
  MOTHUP[2][5]=3;
  MOTHUP[1][6]=3;
  MOTHUP[2][6]=3;
  ICOLUP[1][1]=0;
  ICOLUP[2][1]=0;
  ICOLUP[1][2]=0;
  ICOLUP[2][2]=0;
  ICOLUP[1][3]=0;
  ICOLUP[2][3]=0;
  ISTUP[1]=-1;
  ISTUP[2]=-1;
  ISTUP[3]=2;
  ISTUP[4]=1;
  ISTUP[5]=1;
  ISTUP[6]=1;
    double x3 = 2.-x1-x2;
    double c13=(x1*x3-2.*(1.-x2))/(sqrt(pow(x1,2)-4.*param[0])*x3);
    double c23=(x2*x3-2.*(1.-x1))/(sqrt(pow(x2,2)-4.*param[0])*x3);
    if (isinf(c13) || isinf(c23))
      {x3 = x3 + 0.0000001;
	x1 = x1 - 0.0000001/2.;
	x2 = x2 - 0.0000001/2.;
       c13=(x1*x3-2.*(1.-x2))/(sqrt(pow(x1,2)-4.*param[0])*x3);
       c23=(x2*x3-2.*(1.-x1))/(sqrt(pow(x2,2)-4.*param[0])*x3);}
    double cth,pcm;
    double cofac, maxcofac,cf,ct, ppt;
    double px1 = sqrt(pow(0.5*emcm*x1,2)-pow(m,2));
    double px2 = sqrt(pow(0.5*emcm*x2,2)-pow(m,2));
    double px3 = sqrt(pow(0.5*emcm*x3,2));
    do {cth = 2.*random(seed)-1.;
    cofac = (1.+pow(cth,2))*sigU+2.*sigL*(1.-pow(cth,2))+2.*cth*sigF;  
    maxcofac = 2.*(sigU+sigF);
    if (Jt==1) {
    cf = (px2*c23+px3)/px1; ct = (px1-px3*cf)/px2;}else
      {cf = (px1*c13+px3)/px2; ct = (px2-px3*cf)/px1;}
    if (ct > 1. || cf > 1.) {cofac = 0.;}
    } while (random(seed) > cofac/maxcofac);
    double phi = 2.*pi*random(seed);
    double phi2 = 2.*pi*random(seed);
  
    if (Jt==1) {
      double x=x2+x3;
      pcm = px1;
      PUP[3][4]=px1*cth;
      double pt = sqrt(pow(px1,2)-pow(PUP[3][4],2));
      PUP[1][4]=pt*cos(phi);
      PUP[2][4]=pt*sin(phi);
      double ppl,ppl2,ppe1,ppe2;
      ppl2 = 0.; ppe1 = 0.; ppe2 = 0.;
      if (!emit){
	ppl = px2*ct;
	if (random(seed) < 0.5) {
	 ppt = sqrt (pow(px2,2)-pow(ppl,2));}else {ppt = -sqrt (pow(px2,2)-pow(ppl,2));}
} else { 
	  ppe1=z1*x*emcm/2.;
	  ppe2=(1.-z1)*x*emcm/2.;
	  ppl2=sqrt(pow(ppe2,2)-ptr2);
	  ppl=sqrt(pow(ppe1,2)-ptr2);
	  if (ppe1 < sqrt(ptr2)) {
	    ppl=0.; ppe1=sqrt(ptr2); ppe2=x*emcm/2.-ppe1; ppl2=sqrt(pow(ppe2,2)-ptr2);}
	  if (ppe2 < sqrt(ptr2)) {
	    ppl2=0.; ppe2=sqrt(ptr2); ppe1=x*emcm/2.-ppe2; ppl=sqrt(pow(ppe1,2)-ptr2);}
	  if (random(seed) < 0.5) {
	 ppt = sqrt(ptr2);}else {ppt = -sqrt(ptr2) ;}
}
      
      double ppt1 = ppt*cos(phi2);
      double ppt2 = ppt*sin(phi2);
      PUP[3][5]=-(ppl*cth-ppt1*sin(acos(cth)));
      PUP[1][5]=-((ppl*sin(acos(cth))+ppt1*cth)*cos(phi)-ppt2*sin(phi));
      PUP[2][5]=-((ppl*sin(acos(cth))+ppt1*cth)*sin(phi)+ppt2*cos(phi));
      if (emit){
	PUP[4][4] = x1*emcm/2.;
	PUP[4][5]=ppe1;
	PUP[4][6]=ppe2;
      PUP[3][6]=-(ppl2*cth+ppt1*sin(acos(cth)));
      PUP[1][6]=-((ppl2*sin(acos(cth))-ppt1*cth)*cos(phi)+ppt2*sin(phi));
      PUP[2][6]=-((ppl2*sin(acos(cth))-ppt1*cth)*sin(phi)-ppt2*cos(phi));
      ICOLUP[1][4]=501;
      ICOLUP[2][4]=0;
      ICOLUP[1][5]=0;
      ICOLUP[2][5]=503;
      ICOLUP[1][6]=502;
      ICOLUP[2][6]=501;
      ICOLUP[1][7]=503;
      ICOLUP[2][7]=502;
      }
    }
    else {
      double x=x1+x3;
      pcm = px2;
      PUP[3][5]=px2*cth;
      double pt = sqrt(pow(px2,2)-pow(PUP[3][5],2));
      PUP[1][5]=pt*cos(phi);
      PUP[2][5]=pt*sin(phi);
      double ppl, ppl2, ppe1,ppe2;
      ppl2 = 0.; ppe1 = 0.; ppe2 = 0.;
      if (!emit){
       ppl = px1*ct;
      if (random(seed) < 0.5) {
	ppt = sqrt (pow(px1,2)-pow(ppl,2));}else {ppt = -sqrt (pow(px1,2)-pow(ppl,2));}} else {
	  ppe1=z1*x*emcm/2.;
	  ppe2=(1.-z1)*x*emcm/2.;
	  ppl2=sqrt(pow(ppe2,2)-ptr2);
	  ppl=sqrt(pow(ppe1,2)-ptr2);
	  if (ppe1 < sqrt(ptr2)) {
	    ppl=0.; ppe1=sqrt(ptr2); ppe2=x*emcm/2.-ppe1; ppl2=sqrt(pow(ppe2,2)-ptr2);}
	  if (ppe2 < sqrt(ptr2)) {
	    ppl2=0.; ppe2=sqrt(ptr2); ppe1=x*emcm/2.-ppe2; ppl=sqrt(pow(ppe1,2)-ptr2);}
	  if (random(seed) < 0.5) {
	 ppt = sqrt(ptr2);}else {ppt = -sqrt(ptr2) ;}
	}
      double ppt1 = ppt*cos(phi2);
      double ppt2 = ppt*sin(phi2);
      PUP[3][4]=-(ppl*cth-ppt1*sin(acos(cth)));
      PUP[1][4]=-((ppl*sin(acos(cth))+ppt1*cth)*cos(phi)-ppt2*sin(phi));
      PUP[2][4]=-((ppl*sin(acos(cth))+ppt1*cth)*sin(phi)+ppt2*cos(phi));
      if (emit){
      PUP[4][4]=ppe1;
      PUP[4][5] = x2*emcm/2.;
      PUP[4][6]=ppe2;
      PUP[3][6]=-(ppl2*cth+ppt1*sin(acos(cth)));
      PUP[1][6]=-((ppl2*sin(acos(cth))-ppt1*cth)*cos(phi)+ppt2*sin(phi));
      PUP[2][6]=-((ppl2*sin(acos(cth))-ppt1*cth)*sin(phi)-ppt2*cos(phi));
      ICOLUP[1][4]=501;
      ICOLUP[2][4]=0;
      ICOLUP[1][5]=0;
      ICOLUP[2][5]=503;
      ICOLUP[1][6]=502;
      ICOLUP[2][6]=501;
      ICOLUP[1][7]=503;
      ICOLUP[2][7]=502;
      }}
    if (!emit){
     double ppl2 = px3*cf;
     double ppt3 = -ppt/fabs(ppt)*sqrt(pow(px3,2)-pow(ppl2,2));
     double ppt4 = ppt3*cos(phi2);
     double ppt5 = ppt3*sin(phi2);
      PUP[3][6]=-(ppl2*cth-ppt4*sin(acos(cth)));
      PUP[1][6]=-((ppl2*sin(acos(cth))+ppt4*cth)*cos(phi)-ppt5*sin(phi));
      PUP[2][6]=-((ppl2*sin(acos(cth))+ppt4*cth)*sin(phi)+ppt5*cos(phi));
      PUP[4][4] = x1*emcm/2.;
      PUP[4][5] = x2*emcm/2.;
      PUP[4][6] = x3*emcm/2.;
  
      //colour info
      ICOLUP[1][4] = 501;
      ICOLUP[2][4] = 0;
      ICOLUP[1][5] = 0;
      ICOLUP[2][5] = 502;
      ICOLUP[1][6] = 502;
      ICOLUP[2][6] = 501;
      //Number of particles
      NUP=6;
      double alpha = 1.;
     //boost masses if needed. Need to boost to nominal gluon mass always.
      double mb;
      if (massiveME || (!massiveME && boost)) {mb = mq[ID]; mg = mq[6]; }
      if (!massiveME && !boost) {mb = 0.; mg = 0.;}
     double Eq,Eqb,Eg;
     double pq = sqrt(pow(PUP[1][4],2)+pow(PUP[2][4],2)+pow(PUP[3][4],2));
     double pqb = sqrt(pow(PUP[1][5],2)+pow(PUP[2][5],2)+pow(PUP[3][5],2));
     double pg = sqrt(pow(PUP[1][6],2)+pow(PUP[2][6],2)+pow(PUP[3][6],2));
       for (int ix=1; ix < nit+1; ix++) {
       Eq = sqrt(pow(mb,2)+alpha*pow(pq,2));
       Eqb = sqrt(pow(mb,2)+alpha*pow(pqb,2));
       Eg =  sqrt(pow(mg,2)+alpha*pow(pg,2));
       alpha = alpha+(2.*(emcm-Eq-Eqb-Eg))/(pow(pq,2)/Eq+pow(pqb,2)/Eqb+pow(pg,2)/Eg);
         }
     PUP[1][4] =sqrt(alpha)*PUP[1][4];
     PUP[2][4] =sqrt(alpha)*PUP[2][4];
     PUP[3][4] =sqrt(alpha)*PUP[3][4];
     PUP[4][4] =Eq;
     PUP[1][5] =sqrt(alpha)*PUP[1][5];
     PUP[2][5] =sqrt(alpha)*PUP[2][5];
     PUP[3][5] =sqrt(alpha)*PUP[3][5];
     PUP[4][5] =Eqb;
     PUP[1][6] =sqrt(alpha)*PUP[1][6];
     PUP[2][6] =sqrt(alpha)*PUP[2][6];
     PUP[3][6] =sqrt(alpha)*PUP[3][6];
     PUP[4][6] =Eg;
     if (massiveME || (!massiveME && boost)) {
       mass[4] = mq[ID];
       mass[5] = mq[ID];
       mass[6] = mq[6];}
     if (!massiveME && !boost)
       {mass[4] = 0.;
       mass[5] = 0.;
       mass[6] = 0.;}
      } else {

      //truncated emission

              double phi3=2.*pi*random(seed);
	      double phi4=2.*pi*random(seed);
	      double ph=2.*pi*random(seed);
	      double phh=2.*pi*random(seed);
	      if (Jt==2) {PUP[4][4]=PUP[4][5];}   
	      double ptgg;
	      if (random(seed) < 0.5) {ptgg=sqrt(ptr2);}else{ptgg=-sqrt(ptr2);}
              double btgg=ptr2/(4.*(1.-z1)*pow(emcm-PUP[4][4],2));
              double pegg=(1.-z1)*(emcm-PUP[4][4])+btgg*(emcm-PUP[4][4]);
              double pzgg=(1.-z1)*(emcm-PUP[4][4])-btgg*(emcm-PUP[4][4]);
              double sth=sqrt(ptr2)/(z1*(emcm-PUP[4][4]));
	      double ptq, ptg;
	      if (random(seed) < 0.5) {
	      ptq=sqrt(ptsq)*cos(asin(sth))+z*z1*(emcm-PUP[4][4])*sth;
	      ptg=-sqrt(ptsq)*cos(asin(sth))+(1-z)*z1*(emcm-PUP[4][4])*sth;
              } else {
	      ptq=-sqrt(ptsq)*cos(asin(sth))+z*z1*(emcm-PUP[4][4])*sth;
              ptg=sqrt(ptsq)*cos(asin(sth))+(1.-z)*z1*(emcm-PUP[4][4])*sth;}

	      double btq=pow(ptq,2)/(4.*z1*z*pow(emcm-PUP[4][4],2));
	      double btg=pow(ptg,2)/(4.*(1.-z)*z1*pow(emcm-PUP[4][4],2));
	      double pe=z*z1*(emcm-PUP[4][4])+btq*(emcm-PUP[4][4]);
	      double pzq=z*z1*(emcm-PUP[4][4])-btq*(emcm-PUP[4][4]);
	      double peg=z1*(1.-z)*(emcm-PUP[4][4])+btg*(emcm-PUP[4][4]);
	      double pzg=z1*(1.-z)*(emcm-PUP[4][4])-btg*(emcm-PUP[4][4]);
	      PUP[4][6]=pegg;
	      double p6t1=ptgg*cos(ph);
	      double p6t2=ptgg*sin(ph);
	      PUP[1][6]=-((pzgg*sin(acos(cth))+p6t1*cth)*cos(phh)-p6t2*sin(phh));
	      PUP[2][6]=-((pzgg*sin(acos(cth))+p6t1*cth)*sin(phh)+p6t2*cos(phh));
	      PUP[3][6]=-(pzgg*cth-p6t1*sin(acos(cth)));
	      PUP[4][5]=pe;
	      double p5t1=ptq*cos(phi4);
	      double p5t2=ptq*sin(phi4);
	      PUP[1][5]=-((pzq*sin(acos(cth))+p5t1*cth)*cos(phi3)-p5t2*sin(phi3));
	      PUP[2][5]=-((pzq*sin(acos(cth))+p5t1*cth)*sin(phi3)+p5t2*cos(phi3));
	      PUP[3][5]=-(pzq*cth-p5t1*sin(acos(cth)));
              PUP[4][7]=peg;
	      double p7t1=ptg*cos(phi4);
	      double p7t2=ptg*sin(phi4);
	      PUP[1][7]=-((pzg*sin(acos(cth))+p7t1*cth)*cos(phi3)-p7t2*sin(phi3));
	      PUP[2][7]=-((pzg*sin(acos(cth))+p7t1*cth)*sin(phi3)+p7t2*cos(phi3));
	      PUP[3][7]=-(pzg*cth-p7t1*sin(acos(cth)));
	      PUP[1][4]=-PUP[1][7]-PUP[1][6]-PUP[1][5];
	      PUP[2][4]=-PUP[2][7]-PUP[2][6]-PUP[2][5];
	      PUP[3][4]=-PUP[3][7]-PUP[3][6]-PUP[3][5];
	      if (Jt==2) {
         PUP[1][8]= PUP[1][4]; PUP[2][8]= PUP[2][4]; PUP[3][8]= PUP[3][4];
	 PUP[1][4]= PUP[1][5]; PUP[2][4]= PUP[2][5]; PUP[3][4]= PUP[3][5];
	 PUP[1][5]= PUP[1][8]; PUP[2][5]= PUP[2][8]; PUP[3][5]= PUP[3][8];}
	 double pq = sqrt(pow(PUP[1][4],2)+pow(PUP[2][4],2)+pow(PUP[3][4],2));
	 double pqb = sqrt(pow(PUP[1][5],2)+pow(PUP[2][5],2)+pow(PUP[3][5],2));
	 double pg = sqrt(pow(PUP[1][6],2)+pow(PUP[2][6],2)+pow(PUP[3][6],2));     
	 double pgg = sqrt(pow(PUP[1][7],2)+pow(PUP[2][7],2)+pow(PUP[3][7],2));     
	 double mb;
	 if (massiveME || (!massiveME && boost)) {mb = mq[ID]; mg = mq[6]; }
	 if (!massiveME && !boost) {mb = 0.; mg = 0.;}
         double Eq,Eqb,Eg,Egg;
	 double alpha=1;
	 double nit=5;
	 for (int ixx=1; ixx < nit+1; ixx++) {
       Eq = sqrt(pow(mb,2)+alpha*pow(pq,2));
       Eqb = sqrt(pow(mb,2)+alpha*pow(pqb,2));
       Eg =  sqrt(pow(mg,2)+alpha*pow(pg,2));
       Egg= sqrt(pow(mg,2)+alpha*pow(pgg,2));
       alpha = alpha+(2.*(emcm-Eq-Eqb-Eg-Egg))/(pow(pq,2)/Eq+pow(pqb,2)/Eqb+pow(pg,2)/Eg+pow(pgg,2)/Egg);
         }
     PUP[1][4] =sqrt(alpha)*PUP[1][4];
     PUP[2][4] =sqrt(alpha)*PUP[2][4];
     PUP[3][4] =sqrt(alpha)*PUP[3][4];
     PUP[4][4] =Eq;
     PUP[1][5] =sqrt(alpha)*PUP[1][5];
     PUP[2][5] =sqrt(alpha)*PUP[2][5];
     PUP[3][5] =sqrt(alpha)*PUP[3][5];
     PUP[4][5] =Eqb;
     PUP[1][6] =sqrt(alpha)*PUP[1][6];
     PUP[2][6] =sqrt(alpha)*PUP[2][6];
     PUP[3][6] =sqrt(alpha)*PUP[3][6];
     PUP[4][6] =Eg;
     PUP[1][7] =sqrt(alpha)*PUP[1][7];
     PUP[2][7] =sqrt(alpha)*PUP[2][7];
     PUP[3][7] =sqrt(alpha)*PUP[3][7];
     PUP[4][7] =Egg;
     if (massiveME || (!massiveME && boost)) {
       mass[4] = mq[ID];
       mass[5] = mq[ID];
       mass[6] = mq[6];
       mass[7] = mq[6];  }
     if (!massiveME && !boost)
       {mass[4] = 0.;
       mass[5] = 0.;
       mass[6] = 0.;
       mass[7] = 0.; }
     IDUP[7]=21;
     ISTUP[7]=1;
     MOTHUP[1][7]=3;
     MOTHUP[2][7]=3;
     NUP=7;
     }
    // spin info-redundant

    double C[9], M[9];
     C[1] = pow(CRe,2)*(chi2/(pow((emcm*k),2)))*pow(gz2,2);
     C[2] = pow(CLe,2)*(chi2/(pow((emcm*k),2)))*pow(gz2,2);
     C[3] = CLf*(emcm/2.-pcm)+CRf*(emcm/2.+pcm);
     C[4] = CLf*(emcm/2.+pcm)+CLf*(emcm/2.-pcm);
     C[5] = (CLf+CRf)*m;
     C[6] = 2*e2*Ch[ID]*CRe*chi1*gz2/(k*emcm);
     C[7] = 2*e2*Ch[ID]*CLe*chi1*gz2/(k*emcm);
     C[8] = e2*Ch[ID];
     M[1] = (C[1]*pow(C[3],2)-C[6]*C[3]+pow(C[8],2))*pow(1+cth,2);
     M[5] = (C[2]*pow(C[4],2)-C[7]*C[4]+pow(C[8],2))*pow(1+cth,2);
     M[2] = (C[1]*pow(C[4],2)-C[6]*C[4]+pow(C[8],2))*pow(1+cth,2);
     M[6] = (C[2]*pow(C[3],2)-C[7]*C[3]+pow(C[8],2))*pow(1+cth,2);
     M[3] = (C[1]*pow(C[5],2)-2.*m/emcm*C[6]*C[5]+pow(C[8],2)*4.*param[0])*(1.-pow(cth,2));
     M[7] = (C[2]*pow(C[5],2)-2.*m/emcm*C[7]*C[5]+pow(C[8],2)*4.*param[0])*(1.-pow(cth,2));
     M[4] = M[3]; 
     M[8] = M[7];
     double Mud, Mdu;
     Mud = 0.; Mdu =0.;
     for (int ix=1; ix < 5; ix++) {Mud+=M[ix];}
     for (int ix=5; ix < 9; ix++) {Mud+=M[ix];}
     if (random(seed) < Mud/(Mud+Mdu)) {
       ISPINUP[1]=+1;
       ISPINUP[2]=-1;
       ISPINUP[3]=+1;
     if (random(seed) < (M[1]+M[3])/Mud) {
       ISPINUP[4] = +1;
     if (random(seed) < M[1]/(M[1]+M[3])) {
       ISPINUP[5] = -1;}else {ISPINUP[5] = +1;}} else {
	 ISPINUP[4] = -1;
	 if (random(seed) < M[2]/(M[2]+M[4])) {
	   ISPINUP[5] = +1;} else {ISPINUP[5] = -1;} }} else {
       ISPINUP[1]=-1;
       ISPINUP[2]=+1;
       ISPINUP[3]=-1;
     if (random(seed) < (M[6]+M[7])/Mdu) {
       ISPINUP[4] = +1;
     if (random(seed) < M[6]/(M[6]+M[7])) {
       ISPINUP[5] = -1;}else {ISPINUP[5] = +1;}} else {
	 ISPINUP[4] = -1;
	 if (random(seed) < M[5]/(M[5]+M[8])) {
	   ISPINUP[5] = +1;} else {ISPINUP[5] = -1;} }}
     if (Jt==1) {ISPINUP[6] = ISPINUP[4];} else {ISPINUP[6] = ISPINUP[5];}
      ISPINUP[7]=ISPINUP[6];
     //Momenta of incoming particles and Z boson
   
     PUP[4][1]=emcm/2.;
     PUP[1][1]=0.;
     PUP[2][1]=0.;
     PUP[3][1]=emcm/2;
     PUP[4][2]=emcm/2;
     PUP[1][2]=0.;
     PUP[2][2]=0.;
     PUP[3][2]=-emcm/2;
     PUP[4][3]=emcm;
     PUP[1][3]=0.;
     PUP[2][3]=0.;
     PUP[3][3]=0.;
     //weight info
     XWGTUP = 1;
    double sum1, sum2, sum3, sum4;
     sum1=0.;sum2=0.;sum3=0.;sum4=0.;
     ii+=1;
     outdata5 << "<event>" << endl;
     outdata5 << NUP <<"\t" << "11" <<"\t"<<XWGTUP<<"\t" << SCALUP << "\t" << AQEDUP << "\t" << AQCDUP << endl;
     for (int ja = 1; ja < NUP+1; ja++) {
       outdata5 << IDUP[ja] << "\t" << ISTUP[ja] << "\t" << MOTHUP[1][ja] <<"\t" << MOTHUP[2][ja] << "\t" << ICOLUP[1][ja] << "\t" << ICOLUP[2][ja] <<"\t" <<setprecision (9)<< PUP[1][ja] << "\t" << PUP[2][ja]<<"\t"<<PUP[3][ja]<<"\t"<<PUP[4][ja]<<"\t" << mass[ja] <<"\t"<< "0" << "\t" <<"9" <<endl;
       sum1+=PUP[4][ja];sum2+=PUP[1][ja];sum3+=PUP[2][ja];sum4+=PUP[3][ja];
}
     cout  << "Generated event : " << "\t" << ixx << "\t" << "of" << "\t" << nevg << "\r" << flush; 
       outdata5 << "</event>" << endl;

       // cout << sum1 << "\t" << sum2 << "\t" << sum3 << "\t" << sum4 << endl;
     
      }
    }
     
  }
 outdata5 << "</LesHouchesEvents>" << endl;
   cout << endl;
      return 0; }


/********************************************************************************/
/********************************************************************************/
// filegen generates interpolation files for numerical integration. These are tables of pt squared vs integral 

void filegen (double &rintgend1, double &rintgend2, double &rintgend3, double &rintgend4){
   cout << "Generating interpolation files..." << endl;
  ofstream outdata,outdata1,outdata2,outdata3,outdata4;
  outdata1.open("pwepem1.dat", ios::trunc); 
  outdata2.open("pwepem2.dat", ios::trunc); 
  outdata3.open("pwepem3.dat", ios::trunc); 
  outdata4.open("pwepem4.dat", ios::trunc); 
   double pt2t,pt2b,nit,intg, pt2;
   pt2t = 0.; pt2b =0.;
   intg = 0.;
   nit = 1000;
   
   for (int iy=1; iy < 5; iy++) {
     
     if (iy==1) {pt2t = pt2max; pt2b=0.001;}
     if (iy==2) {pt2t = 0.001; pt2b=0.0001;}
     if (iy==3) {pt2t = 0.0001; pt2b=0.00001;}
     if (iy==4) {pt2t = 0.00001; pt2b=pt2min;}
     double div = (pt2t-pt2b)/nit;  
     pt2 = pt2t+div;
   for (int ix=0; ix<nit; ix++) {
     
   pt2=pt2-div;
   if (pt2 < pt2b) {break;}
   
   double alphas=1./(b*log(pt2/pt2min))*(1.-bp*log(log(pt2/pt2min))/(b*log(pt2/pt2min)));
   alphas=alphas + pow(alphas,2)*(67./3.-pow(pi,2)-50./9.)/(4.*pi);
   double xminr=(39.*pt2-1.+pow(pt2,3)+15.*pow(pt2,2));
   double xmini=(6.*sqrt(-33.*pow(pt2,2)+3.*pt2-3.*pow(pt2,3)));
   if (pt2 > 0.0901698) {xmini = 0.;}
   double xminm=sqrt(pow(xminr,2)+pow(xmini,2));
   double xmint=atan2(xmini,xminr);
   double xmin1=-1./12.*pow(xminm,(1./3.))*cos(xmint/3.);
   double xmin2=(-1./12.-pow(pt2,2)/12.-5.*pt2/6.)*cos(xmint/3.)/(pow(xminm,(1./3.)));
   double xmin3=pt2/6.+5./6.;
   double xmin4=sqrt(3.)/12.*pow(xminm,(1./3.))*sin(xmint/3.)
               -3.*sqrt(3.)*(-1./36.-pow(pt2,2)/36.-5.*pt2/18.)
               /pow(xminm,(1./3.))*sin(xmint/3.);
   double xmin5=xmin1+xmin2+xmin3+xmin4;
   double xmin6=xmin1+xmin2+xmin3-xmin4;
   
    if (pt2 < 1./12.) {
       intg+= 2.*alphas/(3.*pi)*((log(16.*pow(pt2,2))/pt2
	  -function(pt2,xmin6))+(log(16.*pow(pt2,2))/pt2-function(pt2,xmin5)))*div;
       
	 } else {
       intg+= 2.*alphas/(3.*pi)*(function(pt2,xmin5)-function(pt2,xmin6))*div;
       
       }
   
   if (iy==1) {outdata1  << pt2 << "\t" << abs(intg) << endl;}
   if (iy==2) {outdata2  << pt2 << "\t" << abs(intg) << endl;}
   if (iy==3) {outdata3  << pt2 << "\t" << abs(intg) << endl;}
   if (iy==4) {outdata4  << pt2 << "\t" << abs(intg) << endl;}
  }
   //cout << fabs(intg) << endl;
   if (iy==1) {rintgend1=abs(intg);}
   if (iy==2) {rintgend2=abs(intg);}
   if (iy==3) {rintgend3=abs(intg);}
   if (iy==4) {rintgend4=abs(intg);}
   }
  cout << "...Done" << endl;
}

// Function used in filegen. This is the integral over x.

double function (double pt2, double x) {
    double G=log(1.-x)/pt2+2.*log(sqrt(1.-x)+sqrt(1.-4.*pt2-x))/pt2;
   return G;}

// interp reads files generated by filegen to find solutions to Sudakov form factor. Uses polynomial of order 3.

double interp(int N,double XXX, double Xmax1, double Xmax2, double Xmax3, double Xmax4) {
       double FF;
       double AA;
  int IX=0;
  int IY=N+1;
  int MID;
  double aa,bb,cc,dd,ee,ii,gg,hh;
  ifstream indata;

      for (int iy=0;(IY-IX) > 1;iy++) {
	if (XXX < Xmax1 ) {
    indata.open("pwepem1.dat", ios::in); 
  }else if (XXX > Xmax1  && XXX < Xmax2 ) {
    indata.open("pwepem2.dat", ios::in);
  }else if (XXX > Xmax2 && XXX < Xmax3 ) {
    indata.open("pwepem3.dat", ios::in);
  }else if (XXX > Xmax3) {
    indata.open("pwepem4.dat", ios::in);
  }  
        MID=(IX+IY)/2;
        for(int ix=0;ix < MID ;ix++) {
	  indata >> FF >> AA;}

	 indata.close();
	
        if (XXX >= AA) {
        IX=MID;} else {IY=MID;}
	if ((IY-IX) < 1) break;}
          if (IX < 5) {IX=5;}
    if (XXX < Xmax1 ) {
    indata.open("pwepem1.dat", ios::in); 
  }else if (XXX > Xmax1  && XXX < Xmax2 ) {
    indata.open("pwepem2.dat", ios::in);
  }else if (XXX > Xmax2 && XXX < Xmax3 ) {
    indata.open("pwepem3.dat", ios::in);
  }else if (XXX > Xmax3) {
    indata.open("pwepem4.dat", ios::in);
  }  
     for (int ix=0;ix<IX-3;ix++) {
        indata >> FF >> AA;}
        indata >> aa >> bb ;
        indata >> cc >> dd ;
        indata >> ee >> ii ;
        indata >> gg >> hh ;
        indata.close();
       double d1=(cc-aa)/(dd-bb);
       double d2=(ee-cc)/(ii-dd);
       double d3=(gg-ee)/(hh-ii) ;
       double dydx=(gg-aa)/(hh-bb);
       double dydx1=(ee-aa)/(ii-bb);
	 double dydx2=(gg-cc)/(hh-dd);
	 double d2ydx2=(dydx2-dydx1)/((hh+dd-ii-bb)/2.);
	 double d2ydx21=2.*(d2-d1)/(ii-bb);
	 double d2ydx22=2.*(d3-d2)/(hh-dd);
	 double d3ydx3=2*(d2ydx22-d2ydx21)/(hh+dd-ii-bb);
	 double ddd=d3ydx3/6.;
       double ccc=(d2ydx2-6.*ddd*(XXX-bb))/2.;
       double bbb=(dydx-2.*ccc*(XXX-bb)-3.*ddd*pow((XXX-bb),2));
       return bbb*(XXX-bb)+ccc*pow((XXX-bb),2)+ddd*pow((XXX-bb),3)+aa;}

// xmaxmin determines the maximum and minimum value of x for given values of pt2 depending on which y branch it lies.

     void xmaxmin (double pt2, double &rxmax, double &rxmin5,double &rxmin6 ) {
      double xminr=(39.*pt2-1.+pow(pt2,3)+15.*pow(pt2,2));
      double xmini=(6.*sqrt(-33.*pow(pt2,2)+3.*pt2-3.*pow(pt2,3)));
      if (pt2 == 0.0901698) {xmini = 0.;}
      double xminm=sqrt(pow(xminr,2)+pow(xmini,2));
      double xmint=atan2(xmini,xminr);
      double xmin1=-1./12.*pow(xminm,(1./3.))*cos(xmint/3.);
      double xmin2=(-1./12.-pow(pt2,2)/12.-5.*pt2/6.)*cos(xmint/3.)/(pow(xminm,(1./3.)));
      double xmin3=pt2/6.+5./6.;
      double xmin4=sqrt(3.)/12.*pow(xminm,(1./3.))*sin(xmint/3.)
	-3.*sqrt(3.)*(-1./36.-pow(pt2,2)/36.-5.*pt2/18.)
	/pow(xminm,(1./3.))*sin(xmint/3.);
      rxmin5=xmin1+xmin2+xmin3+xmin4;
      rxmin6=xmin1+xmin2+xmin3-xmin4;
      if (pt2 < 1./12.) {
        rxmax=1.-4.*pt2;} else {
        rxmax=rxmin5;
        }
      }

// ME calculates the value of the approximation to the NLO matrix element for given y and x.

  double ME (double pt2,double &rx, double &ry1, double &ry2, double xmin5, double &rM1, double &rM2, double &rw) {
       ry1=(-2.+3.*rx-pow(rx,2)-sqrt(pow(rx,2)-2.*pow(rx,3)+pow(rx,4)-4.*pt2*pow(rx,2)+4.*pt2*pow(rx,3)))/(2.*(rx-1.));
        ry2=(-2.+3.*rx-pow(rx,2)+sqrt(pow(rx,2)-2.*pow(rx,3)+pow(rx,4)-4.*pt2*pow(rx,2)+4.*pt2*pow(rx,3)))/(2.*(rx-1.));

//       Using the pt^2 delta function to eliminate x. w1,w2=d(pt)/dy
       rw=(1.-rx)*(ry1-ry2)/(2.*sqrt(pt2)*pow(rx,2));
       rM1=2./((1.-rx)*(1.-ry1)*rw);
       rM2=2./((1.-rx)*(1.-ry2)*rw);
       if (rx < xmin5 || pt2 > 1./12.){rM1=0;}
       double M=fabs(rM1)+fabs(rM2);
       return M;}

// Random number generator

  double random (int &rseed) {
    int M = 2147483647;
    int A = 16807;
    int Q = 127773;
    int R = 2836;
    double MINV = 0.46566128752458e-09;
    int HI = rseed/Q;
    int LO = rseed % Q;
    rseed = A*LO - R*HI;
      if (rseed <= 0) {rseed = rseed + M;}
    return rseed*MINV;}  
