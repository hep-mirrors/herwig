// -*- C++ -*-
//
// METRP2to2.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the METRP2to2 class.
//

namespace Herwig {
  
  inline METRP2to2::METRP2to2():_maxflavour(5),_process(0),_ndim(6), _planckmass(1500.0) {
    massOption(true ,0);
    massOption(false,0);
  }
  
  inline IBPtr METRP2to2::clone() const {
    return new_ptr(*this);
  }
  
  inline IBPtr METRP2to2::fullclone() const {
    return new_ptr(*this);
  }
  
  
  inline double METRP2to2::ME() const {
    Energy2 t(tHat()),s(sHat());
    double output;
    // cout << "ecm = " << sqrt(s) << " ";
    output = Any(s,t);
    return output;
  }
  
  inline double METRP2to2::bccalc(double s) const {  
    double n = double(_ndim);
    double resultbc = 0;  
    double pifac = 3.1415926536;
    double M_D = _planckmass * 1000;
    resultbc = pow( (pow((4 * pifac),(n/2.0) - 1.0) * s * Math::gamma(n/2.0) / (2 * pow(M_D,n+2.0)) ),1.0/n);  
    return resultbc;
  }
  



 inline double METRP2to2::Any(double s, double t) const {
    double n = double(_ndim);
    double q = sqrt(-t);
    double pifac = 3.1415926536;
    double M_D = _planckmass * 1000;
    double bc = pow(pow((4 * pifac),(n/2.0) - 1.0) * s * Math::gamma(n/2.0) / (2 * pow(M_D,n+2.0)),1.0/n);
    
    //double Anyres = 4 * pifac * s * pow(bc,2) * fny(n,bc,q);
    //std::cout << _ndim << endl;
    //  std::cout << sqrt(s) << endl;
    //std::cout << _maxflavour << endl;
    // std::cout << _planckmass <<endl;
    //    std::cout << Math::gamma(2.0) << endl;
    double Anyres = pow(s * fny(n,bc,q),2) * pow(bc,4);
   return Anyres;
  }



  inline double METRP2to2::fny(double n, double bc, double q) const {
    //cout << "bc = " << bc << " q = " << q << endl; 
    double y = bc * q;
    //cout << "y = " << y << endl;
    double fnyres = 0;
    if(y>20) { fnyres = fnyasympt(n,y); } else {
      //ostringstream ost;
      //ost << "absf" << n << "y.dat";
      // fnyres = ffile(ost.str(), y); 
      fnyres = fpoint(int(n),y);
    }
    return fnyres;
  }

  inline double METRP2to2::fnyasympt(double n, double y) const {
    return (pow(n, 1.0/(n+1.0)) * pow(y, - (n+2.0)/(n+1.0) ) / sqrt(n+1.0));
  }  

  inline double METRP2to2::ffile(string inputf, double x) const {
    ifstream normin;
    string stringin = "";
    double normfac = 1;
    //double stringdoub = 0;
    double y = 0;
    
    // bool next = 0;
    bool filerror = 0;
    bool even = 0;
    normin.open(inputf.c_str());
    double indouble = 0;
    // double indouble1 = 0;
    double indouble2 = 0;
    // bool nexttest = 0;
    
    if(!normin) { cerr << "Error: Failed to open file " << inputf << endl; filerror = 1; normfac = 1.; }
    
    if(!filerror) {
      while(normin) { 
	normin >> stringin;
	indouble = atof(stringin.c_str());
	if(even) { indouble2 = atof(stringin.c_str()); }
	if(!even && indouble >= x) { y = indouble2; break; }
	if(even) { even = 0; } else { even = 1; }
	
	//  if(next && !nexttest) {   normin >> stringdoub; y = stringdoub; nexttest = 1;}
	//	cout << "f(" << x << ") = " << y << endl; 
	//	if(nexttest && indouble >= indouble1) { break; } else { nexttest = 0; }
      }
    }
    return y;
}

  inline double METRP2to2::interp(double y, double f0, double f1, double y0, double y1) const {  
    double result;  
    result = f0 + (y - y0) * (f1 - f0) / (y1 - y0);  
    return result;
  }
  
  inline double METRP2to2::fpoint(int n, double x) const {   
    double fvalue;  
    double nx = 0, y0 = 0, y1 = 0, f1 = 0, f0 = 0;  
    int n1 = 0 , n0 = 0;  
    if(x < 20) {     
      if(n == 2) {       
	double datamatrix[100] = { 2.090560, 1.457590, 1.113050, 0.885216, 0.720795, 0.597404, 0.501483, 0.425543, 0.364668, 0.315299, 0.274983, 0.241792, 0.214466, 0.191698, 0.172689, 0.156841, 0.143329, 0.131919, 0.122174, 0.113656, 0.106339, 0.099869, 0.094101, 0.089013, 0.084378, 0.080185, 0.076376, 0.072856, 0.069622, 0.066624, 0.063844, 0.061242, 0.058820, 0.056561, 0.054417, 0.052433, 0.05055, 0.048772, 0.047129, 0.045546, 0.044056, 0.042673, 0.041328, 0.040078, 0.038895, 0.037749, 0.036688, 0.035666, 0.034687, 0.033771, 0.032883, 0.032041, 0.031239, 0.030467, 0.029731, 0.029025, 0.028350, 0.027698, 0.027075, 0.026479, 0.025896, 0.025347, 0.024812, 0.024291, 0.023804, 0.023318, 0.022854, 0.022416, 0.021974, 0.021561, 0.021160, 0.020761, 0.020390, 0.020021, 0.019662, 0.019325, 0.01898, 0.018662, 0.018351, 0.018041, 0.017747, 0.017459, 0.017177, 0.016906, 0.016641, 0.016384, 0.016132, 0.015889, 0.015651, 0.015418, 0.015196, 0.014973, 0.014759, 0.014553, 0.014345, 0.014149, 0.013956, 0.013762, 0.013582, 0.013399};       
	nx = x / 0.2;       n0 = int(nx);  n1 = int(nx+1);       y0 = n0 * 0.2;       y1 = n1 * 0.2;       f1 = datamatrix[n1];       f0 = datamatrix[n0];    
      }    
      if(n == 3) {       
	double datamatrix[100] = { 1.17491, 1.02696, 0.89463, 0.77688, 0.67270, 0.58105, 0.50095, 0.43143, 0.37156, 0.32046, 0.27726, 0.24113, 0.21126, 0.18684, 0.16707, 0.15118, 0.13843, 0.12815, 0.11974, 0.11271, 0.10670, 0.10141, 0.09663, 0.09224, 0.08814, 0.08427, 0.08061, 0.07715, 0.07387, 0.07077, 0.06785, 0.06511, 0.06254, 0.06014, 0.05790, 0.05582, 0.05388, 0.05207, 0.05038, 0.04879, 0.04731, 0.04591, 0.04459, 0.04334, 0.04216, 0.04103, 0.03996, 0.03894, 0.03796, 0.03702, 0.03612, 0.03526, 0.03443, 0.03363, 0.03287, 0.03214, 0.03143, 0.03075, 0.03010, 0.02947, 0.02887, 0.02829, 0.02773, 0.02719, 0.02666, 0.02616, 0.02567, 0.0250, 0.02475, 0.02431, 0.02388, 0.02347, 0.02306, 0.02267, 0.02230, 0.02193, 0.02157, 0.02123, 0.02089, 0.02056, 0.02025, 0.01994, 0.01964, 0.01934, 0.01906, 0.018, 0.01851, 0.01825, 0.01799, 0.01774, 0.01750, 0.01726, 0.01703, 0.01680, 0.01658, 0.01637, 0.01616, 0.01595, 0.01575, 0.01555};     
	nx = x / 0.2;     n0 = int(nx);  n1 = int(nx+1);     y0 = n0 * 0.2;     y1 = n1 * 0.2;     f1 = datamatrix[n1];     
	f0 = datamatrix[n0];    }    
      if(n == 4) {       
     double datamatrix[100] = { 0.86361, 0.81617, 0.75594, 0.68928, 0.62036, 0.55206, 0.48641, 0.42484, 0.36832, 0.31749, 0.27273, 0.23419, 0.20185, 0.17547, 0.15464, 0.13871, 0.12685, 0.11813, 0.11162, 0.10654, 0.10229, 0.09844, 0.09475, 0.09107, 0.08738, 0.08368, 0.08000, 0.07641, 0.07295, 0.06967, 0.06660, 0.06377, 0.06118, 0.05883, 0.05670, 0.05476, 0.05300, 0.05138, 0.04989, 0.04849, 0.04716, 0.04590, 0.04469, 0.04353, 0.04240, 0.04131, 0.04026, 0.03924, 0.03826, 0.037, 0.03642, 0.03556, 0.03473, 0.03394, 0.03319, 0.03247, 0.03178, 0.03112, 0.03049, 0.02988, 0.02930, 0.02873, 0.02819, 0.02767, 0.02716, 0.02667, 0.02619, 0.02573, 0.02529, 0.02486, 0.02444, 0.02403, 0.02364, 0.02326, 0.02289, 0.02253, 0.02218, 0.02184, 0.02152, 0.02120, 0.02089, 0.02058, 0.02029, 0.02000, 0.01972, 0.01944, 0.01918, 0.01892, 0.01866, 0.01841, 0.01816, 0.01792, 0.01769, 0.01746, 0.01724, 0.01702, 0.01681, 0.01660, 0.01639, 0.01619 };       
     nx = x / 0.2;       n0 = int(nx);  n1 = int(nx+1);       y0 = n0 * 0.2;       y1 = n1 * 0.2;       f1 = datamatrix[n1];       f0 = datamatrix[n0]; 
      }       
      if(n == 5) {       double datamatrix[100] = { 0.73584, 0.71183, 0.67590, 0.63118, 0.58053, 0.52645, 0.47109, 0.41628, 0.36351, 0.31401, 0.26878, 0.22857, 0.19396, 0.16533, 0.14280, 0.12611, 0.11459, 0.10713, 0.10244, 0.09934, 0.09690, 0.09453, 0.09189, 0.08887, 0.08548, 0.08180, 0.07796, 0.07410, 0.07035, 0.06681, 0.06358, 0.06068, 0.05815, 0.05595, 0.05405, 0.05240, 0.05094, 0.04962, 0.04838, 0.04720, 0.04604, 0.04489, 0.04375, 0.04262, 0.04150, 0.04040, 0.03934, 0.03831, 0.03733, 0.03639, 0.03551, 0.03469, 0.03391, 0.03317, 0.03247, 0.03181, 0.03118, 0.03057, 0.02998, 0.02941, 0.02886, 0.02832, 0.02779, 0.02728, 0.02678, 0.02630, 0.02583, 0.02538, 0.02494, 0.02452, 0.02412, 0.02373, 0.02335, 0.02299, 0.02264, 0.02230, 0.02197, 0.02165, 0.02134, 0.02104, 0.02074, 0.02045, 0.02016, 0.01989, 0.01961, 0.01935, 0.01909, 0.01883, 0.01858, 0.01834, 0.01810, 0.01787, 0.01764, 0.01742, 0.01721, 0.01699, 0.01679, 0.01659, 0.01639, 0.01620};        
	nx = x / 0.2;       n0 = int(nx);  n1 = int(nx+1);       y0 = n0 * 0.2;       y1 = n1 * 0.2;       f1 = datamatrix[n1];       f0 = datamatrix[n0];   
      }    
      if(n == 6) {      double datamatrix[100] = { 0.67139, 0.65466, 0.62818, 0.59351, 0.55242, 0.50671, 0.45815, 0.40837, 0.35888, 0.31104, 0.26603, 0.22490, 0.18855, 0.15777, 0.13319, 0.11510, 0.10322, 0.09650, 0.09333, 0.09206, 0.09137, 0.09045, 0.08888, 0.08652, 0.08343, 0.07977, 0.07574, 0.07157, 0.06747, 0.06364, 0.06020, 0.05725, 0.05479, 0.05281, 0.05121, 0.04991, 0.04880, 0.04779, 0.04680, 0.04580, 0.04475, 0.04364, 0.04249, 0.04130, 0.04012, 0.03895, 0.03783, 0.03677, 0.03579, 0.03488, 0.03405, 0.03330, 0.03261, 0.03197, 0.03137, 0.03080, 0.03025, 0.02970, 0.02917, 0.02863, 0.02811, 0.02758, 0.02707, 0.02657, 0.02608, 0.02560, 0.02515, 0.02471, 0.02430, 0.02390, 0.02351, 0.02314, 0.02279, 0.02244, 0.02211, 0.02178, 0.02146, 0.02115, 0.02084, 0.02054, 0.02025, 0.01996, 0.01968, 0.01941, 0.01915, 0.01890, 0.01865, 0.01841, 0.01818, 0.01795, 0.01773, 0.01751, 0.01730, 0.01710, 0.01690, 0.01670, 0.01650, 0.01631, 0.01612, 0.01593 };      
	nx = x / 0.2;      n0 = int(nx);  n1 = int(nx+1);      y0 = n0 * 0.2;      y1 = n1 * 0.2;      f1 = datamatrix[n1];      f0 = datamatrix[n0];         
      }    
      fvalue = interp(x, f0, f1, y0, y1);      
    } else { cout << "y out of range for datafile! " << endl; fvalue = 0; }     
    
    return fvalue; 
  }
  
  
  
}
