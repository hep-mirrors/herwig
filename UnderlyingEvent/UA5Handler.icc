// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ForcedSplitting class.
//

namespace Herwig {

// This returns the mean multiplicity for the energy E amd the given parameters N1,N2,N3
inline double UA5Handler::meanMultiplicity(Energy E) {
  return _n1*pow(E/GeV,2.0*_n2)+_n3;
}

// This returns the randomly generated value for the negative binomial
inline double UA5Handler::negativeBinomial(int N, double mean, double ek) {
  if(N < 0) return 0.0;
  double r = mean/ek;
  double rval = pow(1.+r, -ek);
  r /= (1.+r);
  for(int i = 1; i<=N; i++) rval *=  r*(ek+double(i)-1.)/double(i);
  return rval;
}

// This returns random number from dN/d(x**2)=exp(-B*TM) distribution, where
// TM = SQRT(X**2+AM0**2).  Uses Newton's method to solve F-R=0
inline double UA5Handler::randExt(Energy AM0, InvEnergy B) {
  double r = rnd();
  // Starting value
  Energy am = AM0-log(r)/B;
  for(int i = 1; i<20; ++i) {
    double a = exp(-B*(am-AM0))/(1.+B*AM0);
    double f = (1.+B*am)*a-r;
    double df = -B*B*am*a;
    double dam = -f/df;
    am += dam;
    if(am<AM0) am=AM0+.001;
    if(abs(dam) < .001) break;
  }
  return am;
}

inline double UA5Handler::gaussDistribution(double mean, double stdev) {
   double x = rnd();
   x = sqrt(-2.*log(x));
   double y;
   randAzm(x,x,y);
   return mean + stdev*x;
}

// This returns a random number with a flat distribution [-A,A] plus gaussian
// tail with stdev B
inline double UA5Handler::randUng(double A, double B) {
  double prun;
  if(A == 0.) prun = 0.;
  else prun = 1./(1.+B*1.2533/A);
  if(rnd() < prun) return 2.*(rnd()-0.5)*A;
  else {
    double temp = gaussDistribution(0.,B);
    if(temp < 0) return temp - abs(A);
    else return temp + abs(A);
  }
}

// Generates a random azimuthal angle and creates a 2 vector of length x with angle phi
inline void UA5Handler::randAzm(double x, double &px, double &py) {
   double c,s,cs;
   while(true) {
      c = 2.*rnd()-1.;
      s = 2.*rnd()-1.;
      cs = c*c+s*s;
      if(cs <= 1.&&cs!=0.) break;
   }
   double qt = x/cs;
   px = (c*c-s*s)*qt;
   py = 2.*c*s*qt;
}

}
