// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the TopDecayMECorrection class.
//

namespace Herwig {

inline TopDecayMECorrection::TopDecayMECorrection() : _xg_sampling(1.5),
						      _initialenhance(700.), 
						      _finalenhance(1.2),
						      _use_me_for_t2(false)
{}

inline TopDecayMECorrection::TopDecayMECorrection(const TopDecayMECorrection & x)
    : MECorrectionBase(x), _ma(x._ma), _mc(x._mc), _mt(x._mt), _mg(x._mg), _a(x._a), _c(x._c), _g(x._g),
      _initialenhance(x._initialenhance),_finalenhance(x._finalenhance),
      _use_me_for_t2(x._use_me_for_t2)
{}

inline IBPtr TopDecayMECorrection::clone() const {
  return new_ptr(*this);
}

inline IBPtr TopDecayMECorrection::fullclone() const {
  return new_ptr(*this);
}

inline void TopDecayMECorrection::doinitrun() throw(InitException) {
  Interfaced::doinit();
  _output[0].open("TopDecayMECorrectionRaw.top");
  _output[0] << "SET FONT DUPLEX\n";
  _output[0] << "SET LIMITS X 0 1 Y 0.9 1.3\n";
  _output[0] << "TITLE BOTTOM \"X011\"\n";
  _output[0] << "CASE         \" X X\"\n";
  _output[0] << "TITLE LEFT \"X021\"\n";
  _output[0] << "CASE       \" X X\"\n";
  _output[1].open("TopDecayMECorrectionReconstructed.top");
  _output[1] << "SET FONT DUPLEX\n";
  _output[1] << "SET LIMITS X 0 1 Y 0.9 1.3\n";
  _output[1] << "TITLE BOTTOM \"X011\"\n";
  _output[1] << "CASE         \" X X\"\n";
  _output[1] << "TITLE LEFT \"X021\"\n";
  _output[1] << "CASE       \" X X\"\n";
}

inline void TopDecayMECorrection::dofinish() {
  Interfaced::dofinish();
  _output[0] << "PLOT\n";
  _output[1] << "PLOT\n";
  // Here we calculate the full phase space boundary to be sent 
  // to the file and joined with a red line.
  for(double xg=2*sqrt(_g);xg<=1.+_g-sqr(sqrt(_a)+sqrt(_c));xg+=0.0005)
    { double xa = XAB(_a,_c,_g,xg,(2.*xg-2.*_g)/(xg+sqrt(xg*xg-4.*_g)),0);
      KPRINTER(xg,xa); }
  _output[0] << "JOIN BLACK" << endl;
  _output[1] << "JOIN BLACK" << endl;
  for(double xg=1.+_g-sqr(sqrt(_a)+sqrt(_c));xg>=2*sqrt(_g);xg-=0.0005)
    { double xa = XAB(_a,_c,_g,xg,(2.*xg-2.*_g)/(xg-sqrt(xg*xg-4.*_g)),0);
      KPRINTER(xg,xa); }
  _output[0] << "JOIN BLACK" << endl;
  _output[1] << "JOIN BLACK" << endl;
  for(double xa=2*sqrt(_a);xa<=1.+_a-sqr(sqrt(_c)+sqrt(_g));xa+=0.0005)
    { double xg = XGC(_a,_c,_g,xa,1.2,-1,1);
      KPRINTER(xg,xa); }
  _output[0] << "JOIN BLACK" << endl;
  _output[1] << "JOIN BLACK" << endl;
  for(double xa=1.+_a-sqr(sqrt(_c)+sqrt(_g));xa>=2*sqrt(_a);xa-=0.0005)
  { double xg = XGC(_a,_c,_g,xa,1.2, 1,1); 
    KPRINTER(xg,xa); }
  _output[0] << "JOIN BLACK" << endl;
  _output[1] << "JOIN BLACK" << endl;
  // Here we calculate the approximate dead region boundary, 
  // to be joined in green:
  for(double xg=2*sqrt(_g);xg<=(1.+_g-sqr(sqrt(_a)+sqrt(_c)));xg+=0.0001)
  { double xamin = APPROXDEADMINXA(xg,_ktb,_ktc);
    if(xamin!=9999999.) { 
       _output[0] << xg << " " << xamin << "\n"; 
       _output[1] << xg << " " << xamin << "\n"; } }
  _output[0] << "JOIN GREEN" << endl;
  _output[1] << "JOIN GREEN" << endl;
  for(double xg=2*sqrt(_g);xg<=(1.+_g-sqr(sqrt(_a)+sqrt(_c)));xg+=0.0001)
  { double xamax = APPROXDEADMAXXA(xg,_ktb,_ktc);
    if(xamax!=-9999999.) {
       _output[0] << xg << " " << xamax << "\n"; 
       _output[1] << xg << " " << xamax << "\n"; } }
  _output[0] << "JOIN GREEN" << endl;
  _output[1] << "JOIN GREEN" << endl;
  // Here we calculate the exact dead region boundary, 
  // to be joined in green:
  for(double xa=XACCUT(_a,_c,_ktc);
             xa<1.+_a-sqr(sqrt(_c)+sqrt(_g));xa+=0.0005)
    { double xg = XGC(_a,_c,0.,xa,_ktc, 1,0);
      KPRINTER(xg,xa); }
  _output[0] << "JOIN RED" << endl;
  _output[1] << "JOIN RED" << endl;
  for(double xa=XACCUT(_a,_c,_ktc);
             xa<1.+_a-sqr(sqrt(_c)+sqrt(_g));xa+=0.0005)
    { double xg = XGC(_a,_c,0.,xa,_ktc,-1,0); 
      KPRINTER(xg,xa); }
  _output[0] << "JOIN RED" << endl;
  _output[1] << "JOIN RED" << endl;
  
// close the file units...
  _output[0].close();
  _output[1].close();
}

inline int TopDecayMECorrection::KPRINTER(double XG,double XA) {
    if(!isnan(XG)&&!isnan(XA)
       &&XG>=2.*sqrt(_g)-1.0E-7
       &&XG<=1.+_g-sqr(sqrt(_a)+sqrt(_c))+1.0E-7
      ) 
    {
      _output[0] << XG << " " << XA << "\n"; 
      _output[1] << XG << " " << XA << "\n"; 
    }
    return 0;
}

inline double TopDecayMECorrection::XGBR1(double A, double C, double G,
                                          int TOGGLE) 
{ 
  return 1.-sqr(sqrt(A)+TOGGLE*sqrt(C-G));
}
inline double TopDecayMECorrection::XGBR2(double A, double C, double G,
                                          int TOGGLE) 
{ 
  return ((1.-A)*(1.+TOGGLE*sqrt(A))-(C-G)*(1.-TOGGLE*sqrt(A)))/(1.-A);
}

inline double TopDecayMECorrection::KTR(double A, double C, double G,
                                        double XGB, int TOGGLE) 
{ 
  return 2.*(XGB-G)/
    (XGB+TOGGLE*sqrt((1.-1./A)*(XGB-XGBR2(A,C,G, 1))
		     *(XGB-XGBR2(A,C,G,-1))));
}

inline double TopDecayMECorrection::XAB(double A, double C, double G,
                                        double XGB, double KT, int TOGGLE) 
{ 
    complex<double> LAMBDA;
    complex<double> XAB;
    complex<double> KTMKTRPKTMKTRM;
    if(TOGGLE==2) {
        // This applies for G==0.&&KT==KTR(A,C,0.,XGB,1).
	XAB = complex<double>(-2.*A*(XGB-2.)/(1.+A-C-XGB),0.);
    } else if(TOGGLE==1) {
        // This applies for KT==1&&G==0.
	LAMBDA = sqrt((XGB-XGBR1(A,C,0., 1))*(XGB-XGBR1(A,C,0.,-1)));
	XAB = (0.5/(KT-XGB+G))*(KT*(1.+A-C+G-XGB)-LAMBDA)
	    + (0.5/(KT+XGB*(1.-KT)-G))*(KT*(1.+A-C+G-XGB)+LAMBDA);
    } else {
        // This is the general form of XAB.
	KTMKTRPKTMKTRM = ( sqr(XGB*KT-2.*(XGB-G))
			  -KT*KT*(1.-1./A)*(XGB-XGBR2(A,C,G, 1))
			                  *(XGB-XGBR2(A,C,G,-1))
	                 )/
                         (XGB*XGB-(1.-1./A)*(XGB-XGBR2(A,C,G, 1))
                                           *(XGB-XGBR2(A,C,G,-1))
      	                 );
	LAMBDA = sqrt((XGB-XGBR1(A,C,G, 1))*(XGB-XGBR1(A,C,G,-1))*
                      KTMKTRPKTMKTRM);
	XAB = (0.5/(KT-XGB+G))*(KT*(1.+A-C+G-XGB)-LAMBDA)
	    + (0.5/(KT+XGB*(1.-KT)-G))*(KT*(1.+A-C+G-XGB)+LAMBDA);
    }
    double PHI = atan(imag(XAB)/real(XAB));
    if(tan(PHI)>=1.0E-9) {
	cout << "TopMECorrection::XAB: Warning complex x_a value tan(phi)="
	     << tan(PHI) 
	     << "   XGB="    << XGB 
	     << "   XAB="    << XAB <<endl;
    }
    return  real(XAB);
}
inline double TopDecayMECorrection::XGBCUT(double A, double C, double KT) 
{ 
    double lambda2 = 1.+A*A+C*C-2.*A-2.*C-2.*A*C; 
    double NUM1    = KT*KT*(1.-A-C);
    double NUM2    = 2.*KT*sqrt(A*(KT*KT*C+lambda2*(KT-1.)));
    return (NUM1-NUM2)/(KT*KT-4.*A*(KT-1.));
}
inline double TopDecayMECorrection::XACCUT(double A, double C, double KT) 
{ 
    return 1.+A-C-0.25*KT;
}
inline double TopDecayMECorrection::Z(double A ,double C , double G, 
                                      double XAC, double KT, 
                                      int TOGGLE1, int TOGGLE2) 
{ 
    double z;
    if(TOGGLE2<1) { 
      z = (KT+TOGGLE1*sqrt(KT*(KT-4.*(1.+A-C-XAC))))/(2.*KT); 
    } else {
      z = ((1.+A+C-G-XAC)+TOGGLE1*sqrt(sqr(1.+A-C-G-XAC)-4.*G*C))
         /(2.*(1.+A-XAC));
    }
    return z;
}
inline double TopDecayMECorrection::XGC(double A ,double C , double G, 
                                        double XAC, double KT, 
                                        int TOGGLE1, int TOGGLE2) 
{ 
    return (2.-XAC)*(1.-0.5*(1.+(C-G)/(1.+A-XAC)))
          -(Z(A,C,G,XAC,KT,TOGGLE1,TOGGLE2)-0.5*(1.+(C-G)/(1.+A-XAC)))
          *sqrt(XAC*XAC-4.*A);
}
inline double TopDecayMECorrection::XGINVC0(double A ,double G, double XG , double KT) 
{ 
  double U,V,output;
  U = 2.*A*A*A-66.*A*A
     +9.*XG*KT*A+18.*KT*A
     -66.*A+27.*XG*XG*KT
     -45.*XG*KT+18.*KT+2.;
  V = -A*A-14.*A-3.*XG*KT+3.*KT-1.;
  if(U>0.&&(-4.*V*V*V-U*U)>0.) {
      output = (1./3.)*( 1.+A
		        +2.*sqrt(-V)
                           *cos((1./3.)*(atan(sqrt(-4.*V*V*V-U*U)/U)))
                       );
  } else if(U>0.&&(-4.*V*V*V-U*U)<0.) {
      output = (1./3.)*( 1.+A
		        +2.*sqrt(-V)
                           *cosh((1./3.)*(atanh(sqrt(4.*V*V*V+U*U)/U)))
                       );
  } else {
      output = (1./3.)*( 1.+A
		        +2.*sqrt(-V)
                           *cos((1./3.)*(atan(sqrt(-4.*V*V*V-U*U)/U)+pi))
                       );
  }
  return output;
}

inline double TopDecayMECorrection::APPROXDEADMAXXA(double XG,double KTB,double KTC) 
{
  double maxxa(0.);
  double X  = min(XGINVC0(_a,_g,XG,KTC),
		  XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG-sqrt(XG*XG-4.*_g)),0));
  double Y(-9999999999.);
  if(XG>2.*sqrt(_g)&&XG<=XGBCUT(_a,_c,KTB)) {
      Y = max(XAB(_a,_c,0.,XG,KTB,0),
		  XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG+sqrt(XG*XG-4.*_g)),0));
  } else if(XG>=XGBCUT(_a,_c,KTB)&&XG<=1.+_g-sqr(sqrt(_a)+sqrt(_c))) {
      Y = max(XAB(_a,_c,0.,XG,KTR(_a,_c,0.,XG,1),2),
		  XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG+sqrt(XG*XG-4.*_g)),0));
  }
  if(XG>2.*sqrt(_g)&&XG<=1.+_g-sqr(sqrt(_a)+sqrt(_c))) {
    if(X>=Y) { maxxa =  X       ; }
    else     { maxxa = -9999999.; }
  } else {
    maxxa = -9999999.;
  }
  return maxxa;
}

inline double TopDecayMECorrection::APPROXDEADMINXA(double XG,double KTB,double KTC) 
{
  double MINXA(0.);
  double X  = min(XGINVC0(_a,_g,XG,KTC),
		  XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG-sqrt(XG*XG-4.*_g)),0));
  double Y(-9999999999.);
  if(XG>2.*sqrt(_g)&&XG<=XGBCUT(_a,_c,KTB)) {
      Y = max(XAB(_a,_c,0.,XG,KTB,0),
		  XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG+sqrt(XG*XG-4.*_g)),0));
  } else if(XG>=XGBCUT(_a,_c,KTB)&&XG<=1.+_g-sqr(sqrt(_a)+sqrt(_c))) {
      if(_use_me_for_t2) {
	  Y = XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG+sqrt(XG*XG-4.*_g)),0);
      } else {
	  Y = max(XAB(_a,_c,0.,XG,KTR(_a,_c,0.,XG,1),2),
		  XAB(_a,_c,_g,XG,(2.*XG-2.*_g)/(XG+sqrt(XG*XG-4.*_g)),0));
      }
  }
  if(XG>2.*sqrt(_g)&&XG<=1.+_g-sqr(sqrt(_a)+sqrt(_c))) {
      if(X>=Y) { MINXA =  Y  ; }
      else     { MINXA = 9999999.; }
  } else {
      MINXA = 9999999.;
  }
  return MINXA;
}

inline bool TopDecayMECorrection::INTHEALLOWEDREGION(double A  , double C, 
                                                     double G  , 
                                                     double XG , double XA)
{
    bool output(true);
    if(XG<2.*sqrt(G)||XG>1.+G-sqr(sqrt(A)+sqrt(C)))           output = false;
    if(XA<XAB(A,C,G,XG,(2.*XG-2.*G)/(XG+sqrt(XG*XG-4.*G)),0)) output = false;
    if(XA>XAB(A,C,G,XG,(2.*XG-2.*G)/(XG-sqrt(XG*XG-4.*G)),0)) output = false;
    return output;
}

inline bool TopDecayMECorrection::INTHEAPPROXDEADREGION(double A  , double C, 
                                                        double G  ,  
                                                        double XG , double XA,
                                                        double KTB, double KTC)
{
    bool output(true);
    if(!INTHEALLOWEDREGION(A,C,G,XG,XA))      output = false;
    if(XA<APPROXDEADMINXA(XG,KTB,KTC))        output = false;
    if(XA>APPROXDEADMAXXA(XG,KTB,KTC))        output = false;
    return output;
}

inline bool TopDecayMECorrection::INTHEDEADREGION(double A  , double C, 
                                                  double G  ,  
                                                  double XG , double XA,
                                                  double KTB, double KTC)
{
    bool output(true);
    if(!INTHEAPPROXDEADREGION(A,C,G,XG,XA,KTB,KTC)) output = false;
    if(XA>XACCUT(A,C,KTC)) {
	if(XG<XGC(A,C,0.,XACCUT(A,C,KTC),KTC, 1,0)&&
           XG>XGC(A,C,0.,XA,KTC, 1,0)) { output = false; } 
	if(XG>XGC(A,C,0.,XACCUT(A,C,KTC),KTC,-1,0)&&
           XG<XGC(A,C,0.,XA,KTC,-1,0)) { output = false; } 
    } 

    return output;
}

inline double TopDecayMECorrection::BRACES(double XG,double XA)
{return (1.+_a-_c-XA)*me(XA,XG);}

inline double TopDecayMECorrection::DEADREGIONXGXA(double KTB,double KTC)
{
  _xg=0.;
  _xa=0.;
  // Here we set limits on xg and generate a value inside the bounds.
  double xgmin(2.*sqrt(_g)),xgmax(1.+_g-sqr(sqrt(_a)+sqrt(_c)));
  // Generate _xg.
  if(_xg_sampling==2.) {
      _xg=xgmin*xgmax/(xgmin+UseRandom::rnd()*(xgmax-xgmin));
  } else {
      _xg=xgmin*xgmax/pow((  pow(xgmin,_xg_sampling-1.)
                           + UseRandom::rnd()*(pow(xgmax,_xg_sampling-1.) 
                                              -pow(xgmin,_xg_sampling-1.))
                          ),1./(_xg_sampling-1.));
  }
  // Here we set the bounds on _xa for given _xg.
  double xamin(APPROXDEADMINXA(_xg,KTB,KTC));
  double xamax(APPROXDEADMAXXA(_xg,KTB,KTC));
  // Are the bounds sensible? If not return.
  if(xamax<=xamin) return -1.;
  _xa=1.+_a-(1.+_a-xamax)*pow((1.+_a-xamin)/(1.+_a-xamax),UseRandom::rnd());
  // If outside the allowed region return -1.
  if(!INTHEDEADREGION(_a,_c,_g,_xg,_xa,KTB,KTC)) return -1.;
  // The integration volume for the weight
  double xg_vol,xa_vol; 
  if(_xg_sampling==2.) {
      xg_vol = (xgmax-xgmin)
             / (xgmax*xgmin);
  } else {
      xg_vol = (pow(xgmax,_xg_sampling-1.)-pow(xgmin,_xg_sampling-1.))
	     / ((_xg_sampling-1.)*pow(xgmax*xgmin,_xg_sampling-1.));
  }
  xa_vol = log((1.+_a-xamin)/(1.+_a-xamax));
  // Here we return the integral volume factor multiplied by the part of the 
  // weight left over which is not included in the BRACES function, i.e.
  // the part of _xg^-2 which is not absorbed in the integration measure.
  return xg_vol*xa_vol*pow(_xg,_xg_sampling-2.);
}

inline HepLorentzRotation TopDecayMECorrection::HWUROT(Lorentz5Momentum V) {
// This routine returns a rotation matrix. The rotation is generated 
// from A such that when applied to V it moves V to point in the 
// +Z direction.
   double V2,VT2,VT,CT,ST,CF,SF;
   VT2=V.x()*V.x()+V.y()*V.y();
   V2 =V.z()*V.z()+VT2;

   V2=sqrt( V2);
   VT=sqrt(VT2);
   CT=V.z()/V2;
   ST=VT/V2;
   CF=V.x()/VT;
   SF=V.y()/VT;

   HepLorentzVector   C1( CF*CT,   -SF, CF*ST,    0.);
   HepLorentzVector   C2( SF*CT,    CF, SF*ST,    0.);
   HepLorentzVector   C3(   -ST,    0.,    CT,    0.);
   HepLorentzVector   C0(    0.,    0.,    0.,    1.);
   HepLorentzRotation  R(    C1,    C2,    C3,    C0);
   Lorentz5Momentum NewV = R*V;
   if(fabs(NewV.x())>=1.0E-10||fabs(NewV.y())>=1.0E-10||NewV.z()<0.0) { 
       cout << "TopDecayMECorrection::HWUROT: Rotation didn't work!" 
            << endl;
       cout << "Old Vector: " << V    << endl;
       cout << "New Vector: " << NewV << endl;
   }
   return R;
}

inline HepLorentzRotation TopDecayMECorrection::RANDOMZROTATION() {
// This routine returns a random rotation matrix, where the rotation
// is random about the z-axis.
   double C  = 2.*UseRandom::rnd()-1.; //* cos flat between -1 & 1 *//
   double S  = 2.*UseRandom::rnd()-1.; //* sin flat between -1 & 1 *//
   double CS = C*C+S*S;
   while(CS>1.||CS==0.) {
       C  = 2.*UseRandom::rnd()-1.;
       S  = 2.*UseRandom::rnd()-1.;
       CS = C*C+S*S;
   }
   double COSINE = (C*C-S*S)/CS;
   double SINE   = 2.*C*S/CS; 
   HepLorentzVector   C1(COSINE,  SINE,    0.,    0.);
   HepLorentzVector   C2( -SINE,COSINE,    0.,    0.);
   HepLorentzVector   C3(    0.,    0.,    1.,    0.);
   HepLorentzVector   C0(    0.,    0.,    0.,    1.);
   HepLorentzRotation  R(    C1,    C2,    C3,    C0);
   return R;
}

inline double TopDecayMECorrection::HWUSQR(double X) {
// This routine returns a double
  double SIGN(1.);
  if(X/fabs(X)<0.) SIGN = -1.;
  return sqrt(fabs(X))*SIGN;
}

}
