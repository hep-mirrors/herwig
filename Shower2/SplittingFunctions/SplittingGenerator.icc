// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the SplittingGenerator class.
//

namespace Herwig {

inline SplittingGenerator::SplittingGenerator()
  : _qcdinteractionMode(1), _qedinteractionMode(0), _ewkinteractionMode(0),
    _isr_Mode(1), _isr_qcdMode(1), _isr_qedMode(1), _isr_ewkMode(1),
    _fsr_Mode(1), _fsr_qcdMode(1), _fsr_qedMode(1), _fsr_ewkMode(1)
  //    _output(3), _nout(3,0)
{}

inline IBPtr SplittingGenerator::clone() const {
  return new_ptr(*this);
}

inline IBPtr SplittingGenerator::fullclone() const {
  return new_ptr(*this);
}

// // KMH - 18/05/06 - adding some histogramming code...
// inline void SplittingGenerator::book_histo(double xmin,double xmax,
//                                            int bins,
//                                            vector<double> & bin_edges,
// 					   vector<double> & bin_conts)
// {  bin_edges.reserve(bins+1);
//    for(int i=1;i<=bins+1;i++) {
//        bin_edges.push_back((xmin+(i-1)*(xmax-xmin)/bins));
//    }
//    bin_conts.resize(bins);
// }
// inline void SplittingGenerator::add_point(double datapt, double wgt,
//                                           const vector<double> & bin_edges,
//                                           vector<double> & bin_conts) const
// {  for(unsigned int i=1;i<=bin_edges.size()-1;i++) {
//      if(datapt>bin_edges[i-1]&&datapt<bin_edges[i]) {
//        bin_conts[i-1] += wgt;
//      }
//    }
// }
// inline void SplittingGenerator::topdraw_file(
//      string titletop   , string topcase   ,string titleleft , string leftcase,
//      string titlebottom, string bottomcase,
//      const vector<double> & bins, 
//      vector<double> & conts, ofstream & out,bool append, bool norm)
// const
// {
//   unsigned int nbins;
//   nbins = bins.size()-1;

//   if(norm) {
//     double integral = 0.0;
//     for(unsigned int i=1;i<=nbins;i++) {
//       integral += conts[i-1]*(bins[i]-bins[i-1]);
//     }
//     for(unsigned int i=1;i<=nbins;i++) {
//       if(integral!=0.) conts[i-1]=conts[i-1]/integral;
//     }
//   }
//   if(!append) {
//     out << "NEW FRAME\n";
//     out << "SET FONT DUPLEX\n";
//     out << "TITLE TOP    \"" << titletop    << "\"\n";
//     out << "CASE         \"" << topcase     << "\"\n";
//     out << "TITLE LEFT   \"" << titleleft   << "\"\n";
//     out << "CASE         \"" << leftcase    << "\"\n";
//     out << "TITLE BOTTOM \"" << titlebottom << "\"\n";
//     out << "CASE         \"" << bottomcase  << "\"\n";
//   }
//   for(unsigned int i=1;i<=nbins;i++) {
//     out << 0.5*(bins[i]-bins[i-1])+bins[i-1] 
//                << " " 
//                << conts[i-1] 
//                << "\n";  
//   }
//   out << "HIST " << "BLUE" << endl; 

// }
// // KMH - 18/05/06 - end of modification...

inline void SplittingGenerator::doinitrun() throw(InitException) {
  Interfaced::doinitrun();
  BranchingList::const_iterator cit=_fbranchings.begin();
  for( ;cit!=_fbranchings.end();++cit)
    {cit->second.first->setShowerVariables(_showerVariables);} 
  cit=_bbranchings.begin();
  for( ;cit!=_bbranchings.end();++cit)
    {cit->second.first->setShowerVariables(_showerVariables);}

//   _output[0].open("TopDalitzSplittingGenerator.top");
//   _output[0] << "SET FONT DUPLEX\n";
//   _output[0] << "SET LIMITS X 0 1 Y 0.9 1.3\n";
//   _output[0] << "TITLE BOTTOM \"X011\"\n";
//   _output[0] << "CASE         \" X X\"\n";
//   _output[0] << "TITLE LEFT \"X021\"\n";
//   _output[0] << "CASE       \" X X\"\n";
//   _nout[0]=0;
//   _output[1].open("Topkappatilde_z.top");
//   _output[1] << "SET FONT DUPLEX\n";
//   _output[1] << "SET LIMITS X 0 1 Y 0.9 1.9\n";
//   _output[1] << "TITLE BOTTOM \"z\"\n";
//   _output[1] << "CASE         \" \"\n";
//   _output[1] << "TITLE LEFT \"ktilde\"\n";
//   _output[1] << "CASE       \"      \"\n";
//   _nout[1]=0;

//   _output[2].open("Topkappa_z.top");
//   _output[2] << "SET FONT DUPLEX\n";
//   _output[2] << "SET LIMITS X 0 1 Y 0.0 0.1\n";
//   _output[2] << "TITLE BOTTOM \"z\"\n";
//   _output[2] << "CASE         \" \"\n";
//   _output[2] << "TITLE LEFT \"k\"\n";
//   _output[2] << "CASE       \" \"\n";
//   _nout[2]=0;
//   // book histogram for gluon's cosine w.r.t. b-quark
//   book_histo(-1.,1.,20,glucos_bins,glucos_evts);
//   // ... same but theoretical distribution...
//   book_histo(-1.,0.9,19,glucos_bins_th,glucos_evts_th);
}

inline void SplittingGenerator::rebind(const TranslationMap & trans)
  throw(RebindException) {
  BranchingList::iterator cit;
  for(cit=_fbranchings.begin();cit!=_fbranchings.end();++cit)
    {(cit->second).first=trans.translate((cit->second).first);}
  for(cit=_bbranchings.begin();cit!=_bbranchings.end();++cit)
    {(cit->second).first=trans.translate((cit->second).first);}
  Interfaced::rebind(trans);
}

inline IVector SplittingGenerator::getReferences() {
  IVector ret = Interfaced::getReferences();
  BranchingList::iterator cit;
  for(cit=_fbranchings.begin();cit!=_fbranchings.end();++cit)
    {ret.push_back((cit->second).first);}
  for(cit=_bbranchings.begin();cit!=_bbranchings.end();++cit)
    {ret.push_back((cit->second).first);}
  return ret;
}

inline const ShowerVarsPtr & SplittingGenerator::showerVariables() const {
  return _showerVariables;
}

inline bool SplittingGenerator::isISRadiationON() const {
  return _isr_Mode && (_isr_qcdMode||_isr_qedMode||_isr_ewkMode);
}  

inline bool SplittingGenerator::isFSRadiationON() const {
  return _fsr_Mode && (_fsr_qcdMode||_fsr_qedMode||_fsr_ewkMode);
}

inline bool SplittingGenerator::
isInteractionON(const ShowerIndex::InteractionType interaction) const {
  bool mode(false);
  switch ( interaction ) {
  case ShowerIndex::QCD : 
    mode = _qcdinteractionMode && ((_isr_qcdMode&&_isr_Mode)||
				  (_fsr_qcdMode&&_fsr_Mode)); break; 
  case ShowerIndex::QED :  
    mode = _qedinteractionMode && ((_isr_qedMode&&_isr_Mode)||
				  (_fsr_qedMode&&_fsr_Mode)); break; 
  case ShowerIndex::EWK : 
    mode = _ewkinteractionMode && ((_isr_ewkMode&&_isr_Mode)||
				  (_fsr_ewkMode&&_fsr_Mode)); break; 
  default: break;
  }
  return mode;
}

inline bool SplittingGenerator::
isISRadiationON(const ShowerIndex::InteractionType interaction) const {
  bool mode(false);
  if ( isInteractionON(interaction) && isISRadiationON() ) { 
    switch ( interaction ) {
    case ShowerIndex::QCD : mode = _isr_qcdMode; break; 
    case ShowerIndex::QED : mode = _isr_qedMode; break; 
    case ShowerIndex::EWK : mode = _isr_ewkMode; break; 
    default: break;
    }
  }
  return mode;
}

inline bool SplittingGenerator::
isFSRadiationON(const ShowerIndex::InteractionType interaction) const {
  bool mode = false;
  if ( isInteractionON(interaction) && isFSRadiationON() ) { 
    switch ( interaction ) {
    case ShowerIndex::QCD : mode = _fsr_qcdMode; break; 
    case ShowerIndex::QED : mode = _fsr_qedMode; break; 
    case ShowerIndex::EWK : mode = _fsr_ewkMode; break; 
    default: break;
    }
  }
  return mode;
}

inline string SplittingGenerator::addFinalSplitting(string arg) {
  return addSplitting(arg,true);
}
inline string SplittingGenerator::addInitialSplitting(string arg) {
  return addSplitting(arg,false);
}

inline void SplittingGenerator::setShowerVariables(ShowerVarsPtr in) {
  _showerVariables=in;
}

}
