// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the Reweighter class.
//

namespace Herwig {

inline Reweighter::Reweighter()
  : Interfaced(),
    _vetoHighest(true),
    _MEalpha(1.)
{}

#ifdef HERWIG_DEBUG_CKKW_REWEIGHTING

inline Reweighter::Reweighter(const Reweighter& x)
  : Interfaced(x), _resolution(x._resolution), _reconstructor(x._reconstructor),
    _vetoHighest(x._vetoHighest), _MEalpha(x._MEalpha),
    _showerAlpha(x._showerAlpha), _stats(x._stats) { }
  
#endif

inline tJetMeasurePtr Reweighter::resolution () const {
  return _resolution;
}

inline bool Reweighter::vetoHighest () const {
  return _vetoHighest;
}

inline void Reweighter::MEalpha (double a) {
  _MEalpha = a;
}

inline double Reweighter::MEalpha () const {
  return _MEalpha;
}

inline tShowerAlphaPtr Reweighter::showerAlpha () const {
  return _showerAlpha;
}

inline CascadeReconstructorPtr Reweighter::reconstructor () const {
  return _reconstructor;
}

inline void Reweighter::rebind(const TranslationMap & trans)
  throw(RebindException) {
  _reconstructor = trans.translate(_reconstructor);
  Interfaced::rebind(trans);
}

inline IVector Reweighter::getReferences() {
  IVector ret = Interfaced::getReferences();
  ret.push_back(_reconstructor);
  return ret;
}

#ifdef HERWIG_DEBUG_CKKW_REWEIGHTING

inline void Reweighter::doinitrun() {
  Interfaced::doinitrun();
  event_internals().open("event_internals.dat");
  event_internals() << "# multiplicity\t CKKW weight\t (scale/GeV2 of clustering, z of clustering)" << endl;
}

inline void Reweighter::dofinish() {
  Interfaced::dofinish();

  generator()->log() << "CKKW statistics" << endl
		     << "================================================================================"
		     << endl
		     << "mult\t accepted\t avg weight"
		     << endl
		     << "--------------------------------------------------------------------------------"
		     << endl;
  for (map<unsigned int, pair<unsigned long, double> >::iterator s = _stats.begin();
       s != _stats.end(); ++s)
    generator()->log() << s->first << "\t" << s->second.first << "\t"
		       << s->second.second/s->second.first << endl;
  generator()->log() << "================================================================================"
		     << endl;
}

#endif

}
