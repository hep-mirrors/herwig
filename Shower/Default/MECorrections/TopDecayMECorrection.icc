// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the TopDecayMECorrection class.
//

namespace Herwig {

inline TopDecayMECorrection::TopDecayMECorrection() : _xg_sampling(1.5),
						      _initialenhance(1.), 
						      _finalenhance(1.8),
						      _useMEforT2(true)
{}

inline IBPtr TopDecayMECorrection::clone() const {
  return new_ptr(*this);
}

inline IBPtr TopDecayMECorrection::fullclone() const {
  return new_ptr(*this);
}

inline double TopDecayMECorrection::xgbr(int toggle) 
{ 
  return 1.+toggle*sqrt(_a)-_c*(1.-toggle*sqrt(_a))/(1.-_a);
}

inline double TopDecayMECorrection::ktr(double xgb, int toggle) 
{ 
  return 2.*xgb/
    (xgb+toggle*sqrt((1.-1./_a)
		     *(xgb-xgbr( 1))
		     *(xgb-xgbr(-1))));
}

inline double TopDecayMECorrection::xab(double xgb,
                                        double kt, int toggle) 
{ 
  double xab;
  if(toggle==2) {
    // This applies for g==0.&&kt==ktr(a,c,0.,xgb,1).
    xab = -2.*_a*(xgb-2.)/(1.+_a-_c-xgb);
  } else if(toggle==1) {
    // This applies for kt==1&&g==0.
    double lambda = sqrt(sqr(xgb-1.+_a+_c)-4.*_a*_c);
    xab = (0.5/(kt-xgb))*(kt*(1.+_a-_c-xgb)-lambda)
      + (0.5/(kt+xgb*(1.-kt)))*(kt*(1.+_a-_c-xgb)+lambda);
  } else {
    // This is the general form of xab.
    double ktmktrpktmktrm = ( sqr(xgb*kt-2.*xgb)
			      -kt*kt*(1.-1./_a)*(xgb-xgbr( 1))
			      *(xgb-xgbr(-1))
			      )/
      (xgb*xgb-(1.-1./_a)*(xgb-xgbr( 1))
       *(xgb-xgbr(-1))
       );
    double lambda = sqrt((sqr(1.-_a-_c-xgb)-4.*_a*_c)*
			 ktmktrpktmktrm);
    xab = (0.5/(kt-xgb))*(kt*(1.+_a-_c-xgb)-lambda)
      + (0.5/(kt+xgb*(1.-kt)))*(kt*(1.+_a-_c-xgb)+lambda);
  }
  if(isnan(xab)) {
    double ktmktrpktmktrm = ( sqr(xgb*kt-2.*(xgb-_g))
			      -kt*kt*(1.-1./_a)*(xgb-xgbr( 1)-_g/(1.+sqrt(_a)))
			      *(xgb-xgbr(-1)-_g/(1.-sqrt(_a)))
			      )/
      (xgb*xgb-(1.-1./_a)*(xgb-xgbr( 1)-_g/(1.+sqrt(_a)))
       *(xgb-xgbr(-1)-_g/(1.-sqrt(_a)))
       );
    double lambda = sqrt((xgb-1.+sqr(sqrt(_a)+sqrt(_c-_g)))
			 *(xgb-1.+sqr(sqrt(_a)-sqrt(_c-_g)))*
			 ktmktrpktmktrm);
    xab = (0.5/(kt-xgb+_g))*(kt*(1.+_a-_c+_g-xgb)-lambda)
      + (0.5/(kt+xgb*(1.-kt)-_g))*(kt*(1.+_a-_c+_g-xgb)+lambda);
    if(isnan(xab)) {
      cout << "TopMECorrection::xab: Warning complex x_a value tan(phi)="
	   << "  xgb    = " << xgb 
	   << "  xab    = " << xab    <<endl
	   << "  toggle = " << toggle <<endl
	   << "  ktmktrpktmktrm = "   << ktmktrpktmktrm <<endl;
    }
  }
  return xab;
}

inline double TopDecayMECorrection::xgbcut(double kt) 
{ 
  double lambda2 = 1.+_a*_a+_c*_c-2.*_a-2.*_c-2.*_a*_c; 
  double num1    = kt*kt*(1.-_a-_c);
  double num2    = 2.*kt*sqrt(_a*(kt*kt*_c+lambda2*(kt-1.)));
  return (num1-num2)/(kt*kt-4.*_a*(kt-1.));
}

inline double TopDecayMECorrection::xaccut(double kt) 
{ 
    return 1.+_a-_c-0.25*kt;
}

inline double TopDecayMECorrection::z(double xac, double kt, 
                                      int toggle1, int toggle2) 
{ 
  double z = -1.0;
  if(toggle2==0) { 
    z = (kt+toggle1*sqrt(kt*(kt-4.*(1.+_a-_c-xac))))/(2.*kt); 
  } else if(toggle2==1) {
    z = ((1.+_a+_c-xac)+toggle1*(1.+_a-_c-xac))
      /(2.*(1.+_a-xac));
  } else if(toggle2==2) {
    z = 0.5;
  } else {
    throw Exception() << "Cannot determine z in TopDecayMECorrection::z()"
		      << Exception::eventerror;
  }
  return z;
}

inline double TopDecayMECorrection::xgc(double xac, double kt, 
                                        int toggle1, int toggle2) 
{ 
    return (2.-xac)*(1.-0.5*(1.+_c/(1.+_a-xac)))
          -(z(xac,kt,toggle1,toggle2)-0.5*(1.+_c/(1.+_a-xac)))
          *sqrt(xac*xac-4.*_a);
}

inline double TopDecayMECorrection::xginvc0(double xg , double kt) 
{ 
  double u,v,output;
  u = 2.*_a*_a*_a-66.*_a*_a
     +9.*xg*kt*_a+18.*kt*_a
     -66.*_a+27.*xg*xg*kt
     -45.*xg*kt+18.*kt+2.;
  v = -_a*_a-14.*_a-3.*xg*kt+3.*kt-1.;
  double u2=u*u,v3=v*v*v;
  if(u>0.&&(-4.*v3-u2)>0.)      output = cos(  atan(sqrt(-4.*v3-u2)/u)/3.);
  else if(u>0.&&(-4.*v3-u2)<0.) output = cosh(atanh(sqrt( 4.*v3+u2)/u)/3.);
  else                          output = cos(( atan(sqrt(-4.*v3-u2)/u)+pi)/3.);
  return ( 1.+_a +2.*sqrt(-v)*output)/3.;
}

inline double TopDecayMECorrection::approxDeadMaxxa(double xg,double ktb,double ktc) 
{
  double maxxa(0.);
  double x  = min(xginvc0(xg,ktc),
		  xab(xg,(2.*xg-2.*_g)/(xg-sqrt(xg*xg-4.*_g)),0));
  double y(-9999999999.);
  if(xg>2.*sqrt(_g)&&xg<=xgbcut(ktb)) {
      y = max(xab(xg,ktb,0),xab(xg,1.,1));
  } else if(xg>=xgbcut(ktb)&&xg<=1.-sqr(sqrt(_a)+sqrt(_c))) {
      y = max(xab(xg,ktr(xg,1),2),xab(xg,1.,1));
  }
  if(xg>2.*sqrt(_g)&&xg<=1.-sqr(sqrt(_a)+sqrt(_c))) {
    if(x>=y) { maxxa =  x       ; }
    else     { maxxa = -9999999.; }
  } else {
    maxxa = -9999999.;
  }
  return maxxa;
}

inline double TopDecayMECorrection::approxDeadMinxa(double xg,double ktb,double ktc) 
{
  double minxa(0.);
  double x  = min(xginvc0(xg,ktc),
		  xab(xg,(2.*xg-2.*_g)/(xg-sqrt(xg*xg-4.*_g)),0));
  double y(-9999999999.);
  if(xg>2.*sqrt(_g)&&xg<=xgbcut(ktb)) {
      y = max(xab(xg,ktb,0),xab(xg,1.,1));
  } else if(xg>=xgbcut(ktb)&&xg<=1.-sqr(sqrt(_a)+sqrt(_c))) {
      if(_useMEforT2) y = xab(xg,1.,1);
      else            y = max(xab(xg,ktr(xg,1),2),xab(xg,1.,1));
  }
  if(xg>2.*sqrt(_g)&&xg<=1.-sqr(sqrt(_a)+sqrt(_c))) {
      if(x>=y) { minxa =  y  ; }
      else     { minxa = 9999999.; }
  } else {
      minxa = 9999999.;
  }
  return minxa;
}

inline bool TopDecayMECorrection::inTheAllowedRegion(double xg , double xa)
{
    bool output(true);
    if(xg<2.*sqrt(_g)||xg>1.-sqr(sqrt(_a)+sqrt(_c)))      output = false;
    if(xa<xab(xg,1.,1))                                   output = false;
    if(xa>xab(xg,(2.*xg-2.*_g)/(xg-sqrt(xg*xg-4.*_g)),0)) output = false;
    return output;
}

inline bool TopDecayMECorrection::inTheApproxDeadRegion(double xg , double xa,
                                                        double ktb, double ktc)
{
    bool output(true);
    if(!inTheAllowedRegion(xg,xa))       output = false;
    if(xa<approxDeadMinxa(xg,ktb,ktc))   output = false;
    if(xa>approxDeadMaxxa(xg,ktb,ktc))   output = false;
    return output;
}

inline bool TopDecayMECorrection::inTheDeadRegion(double xg , double xa,
                                                  double ktb, double ktc)
{
    bool output(true);
    if(!inTheApproxDeadRegion(xg,xa,ktb,ktc)) output = false;
    if(xa>xaccut(ktc)) {
	if(xg<xgc(xaccut(ktc),ktc, 1,2)&&
           xg>xgc(xa,ktc, 1,0)) { output = false; } 
	if(xg>xgc(xaccut(ktc),ktc,-1,2)&&
           xg<xgc(xa,ktc,-1,0)) { output = false; } 
    } 
    return output;
}

inline double TopDecayMECorrection::deadRegionxgxa(double ktb,double ktc)
{
  _xg=0.;
  _xa=0.;
  // Here we set limits on xg and generate a value inside the bounds.
  double xgmin(2.*sqrt(_g)),xgmax(1.-sqr(sqrt(_a)+sqrt(_c)));
  // Generate _xg.
  if(_xg_sampling==2.) {
      _xg=xgmin*xgmax/(xgmin+UseRandom::rnd()*(xgmax-xgmin));
  } else {
      _xg=xgmin*xgmax/pow((  pow(xgmin,_xg_sampling-1.)
                           + UseRandom::rnd()*(pow(xgmax,_xg_sampling-1.) 
                                              -pow(xgmin,_xg_sampling-1.))
                          ),1./(_xg_sampling-1.));
  }
  // Here we set the bounds on _xa for given _xg.
  double xamin(approxDeadMinxa(_xg,ktb,ktc));
  double xamax(approxDeadMaxxa(_xg,ktb,ktc));
  // Are the bounds sensible? If not return.
  if(xamax<=xamin) return -1.;
  _xa=1.+_a-(1.+_a-xamax)*pow((1.+_a-xamin)/(1.+_a-xamax),UseRandom::rnd());
  // If outside the allowed region return -1.
  if(!inTheDeadRegion(_xg,_xa,ktb,ktc)) return -1.;
  // The integration volume for the weight
  double xg_vol,xa_vol; 
  if(_xg_sampling==2.) {
      xg_vol = (xgmax-xgmin)
             / (xgmax*xgmin);
  } else {
      xg_vol = (pow(xgmax,_xg_sampling-1.)-pow(xgmin,_xg_sampling-1.))
	     / ((_xg_sampling-1.)*pow(xgmax*xgmin,_xg_sampling-1.));
  }
  xa_vol = log((1.+_a-xamin)/(1.+_a-xamax));
  // Here we return the integral volume factor multiplied by the part of the 
  // weight left over which is not included in the BRACES function, i.e.
  // the part of _xg^-2 which is not absorbed in the integration measure.
  return xg_vol*xa_vol*pow(_xg,_xg_sampling-2.);
}

inline LorentzRotation TopDecayMECorrection::rotateToZ(Lorentz5Momentum v) {
  // compute the rotation matrix
  LorentzRotation trans;
  // rotate so in z-y plane
  trans.rotateZ(-atan2(v.y(),v.x()));
  // rotate so along Z
  trans.rotateY(-acos(v.z()/v.vect().mag()));
  // generate random rotation
  double c,s,cs;
  do
    {
      c = 2.*UseRandom::rnd()-1.;
      s = 2.*UseRandom::rnd()-1.;
      cs = c*c+s*s;
    }
  while(cs>1.||cs==0.);
  double cost=(c*c-s*s)/cs,sint=2.*c*s/cs;
  // apply random azimuthal rotation
  trans.rotateZ(atan2(sint,cost));
  return trans;
}

}
