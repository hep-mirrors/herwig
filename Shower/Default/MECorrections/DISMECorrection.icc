// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the DISMECorrection class.
//

namespace Herwig {

  inline DISMECorrection::DISMECorrection() : _meopt(true), _initial(6.), _final(3.),
					    _procprob(0.35),
					    _comptonint(0.), _bgfint(0.),
					    _sinW(0.), _cosW(0.), _mz2(0.*GeV2),
					    _nover(0), _ntry(0), _ngen(0),
					    _maxwgt(make_pair(0.,0.)) {
}

inline IBPtr DISMECorrection::clone() const {
  return new_ptr(*this);
}

inline IBPtr DISMECorrection::fullclone() const {
  return new_ptr(*this);
}

inline double DISMECorrection::generateComptonPoint(double &xp, double & zp) {
  static const double maxwgt = 50.;
  double wgt;
  do {
    xp  = UseRandom::rnd();
    double zpmin = xp, zpmax = 1./(1.+xp*(1.-xp));
    zp = 1.-pow((1.-zpmin)/(1.-zpmax),UseRandom::rnd())*(1.-zpmax);
    wgt = log((1.-zpmin)/(1.-zpmax))*(1.-zp);
    if(UseRandom::rndbool()) swap(xp,zp);
    double xperp2 = 4.*(1.-xp)*(1.-zp)*zp/xp,x2=1.-(1.-zp)/xp;
    wgt *= 2.*(1.+sqr(xp)*(sqr(x2)+1.5*xperp2))/(1.-xp)/(1.-zp);
    if(wgt>maxwgt) cerr << "testing violates compton max " << wgt << "\n";
  }
  while(wgt<UseRandom::rnd()*maxwgt);
  return _comptonint;
}

inline double DISMECorrection::generateBGFPoint(double &xp, double & zp) {
  static const double maxwgt = 2.,npow=0.34,ac=1.0;
  double wgt;
  do {
    double rho = UseRandom::rnd();
    xp = 1.-pow(rho,1./(1.-npow));
    wgt = (sqr(xp)+ac+sqr(1.-xp));
    if(wgt>1.+ac) cerr << "testing violates BGF maxA " << wgt << "\n";
  }
  while(wgt<UseRandom::rnd()*(1.+ac));
  double xpwgt = -((6.-5.*npow+sqr(npow))*ac-3.*npow+sqr(npow)+4) 
    /(sqr(npow)*(npow-6.)+11.*npow-6.);
  xpwgt *= pow(1.-xp,npow)/wgt;
  double xp2(sqr(xp)),lxp(log(xp)),xp4(sqr(xp2)),lxp1(log(1.-xp));
  double zpwgt = (2.*xp4*(lxp+lxp1-3.)+4.*xp*xp2*(3.-lxp-lxp1)
		  +xp2*(-13.+lxp+lxp1)+xp*(+7.+lxp+lxp1)-lxp-lxp1-1.)/(1.+xp-xp2);
  do {
    double zpmax = 1./(1.+xp*(1.-xp)), zpmin = 1.-zpmax;
    zp = 1.-pow((1.-zpmin)/(1.-zpmax),UseRandom::rnd())*(1.-zpmax);
    wgt = log((1.-zpmin)/(1.-zpmax))*(1.-zp);
    double x1 = -1./xp;
    double x2 = 1.-(1.-zp)/xp;
    double x3 = 2.+x1-x2;
    double xperp2 = 4.*(1.-xp)*(1.-zp)*zp/xp;
    wgt *= sqr(xp)/(1.-zp)*(sqr(x3)+sqr(x2)+3.*xperp2);
    if(wgt>maxwgt*zpwgt) cerr << "testing violates BGF maxB " << wgt/xpwgt << "\n";
  }
  while(wgt<UseRandom::rnd()*maxwgt);
  return zpwgt*xpwgt;
}
  
inline double DISMECorrection::A(tcPDPtr qin, tcPDPtr,
				 tcPDPtr lin, tcPDPtr lout) {
  double output;
  // charged current
  if(lin->id()!=lout->id()) {
    output = 2;
  }
  // neutral current
  else {
    double fact = 0.25*_q2/(_q2+_mz2)/_sinW/_cosW;
    double cvl,cal,cvq,caq;
    if(abs(lin->id())%2==0) {
      cvl = generator()->standardModel()->vnu()*fact+generator()->standardModel()->enu();
      cal = generator()->standardModel()->anu()*fact;
    }
    else {
      cvl = generator()->standardModel()->ve()*fact+generator()->standardModel()->ee();
      cal = generator()->standardModel()->ae()*fact;
    }
    if(abs(qin->id())%2==0) {
      cvq = generator()->standardModel()->vu()*fact+generator()->standardModel()->eu();
      caq = generator()->standardModel()->au()*fact;
    }
    else {
      cvq = generator()->standardModel()->vd()*fact+generator()->standardModel()->ed();
      caq = generator()->standardModel()->ad()*fact;
    }
    output = 8.*cvl*cal*cvq*caq/(sqr(cvl)+sqr(cal))/(sqr(cvq)+sqr(caq));
  }
  if(qin->id()<0) output *= -1.;
  if(lin->id()<0) output *= -1;
  return output;
}

inline vector<double> DISMECorrection::ComptonME(double xp, double x2, double xperp,
						 double A, double l, bool norm) {
  vector<double> output(3,0.);
  double cos2 =   x2 /sqrt(sqr(x2)+sqr(xperp));
  double sin2 = xperp/sqrt(sqr(x2)+sqr(xperp));
  if(_meopt) {
    double root = sqrt(sqr(l)-1.);
    output[0] = sqr(cos2)-A*cos2*l+sqr(l);
    output[1] = A*cos2*root*sin2-2.*l*root*sin2;
    output[2] = sqr(root)*sqr(sin2);
    double lo(1+A*l+sqr(l));
    for(unsigned int ix=0;ix<output.size();++ix) output[ix] /= lo;
  }
  else {
    output[0] = 1.;
    output[1] = -2.*sin2;
    output[2] = sqr(sin2);
  }
  double denom = norm ? 1.+sqr(xp)*(sqr(x2)+1.5*sqr(xperp)) : 1.;
  double fact  = sqr(xp)*(sqr(x2)+sqr(xperp));
  for(unsigned int ix=0;ix<output.size();++ix) 
    output[ix] = ((ix==0 ? 1. : 0.) +fact*output[ix])/denom;
  return output;
}

inline vector<double> DISMECorrection::BGFME(double xp, double x2, double x3, 
					     double xperp, double A, double l,
					     bool norm) {
  vector<double> output(3,0.);
  double cos2  =   x2 /sqrt(sqr(x2)+sqr(xperp));
  double sin2  = xperp/sqrt(sqr(x2)+sqr(xperp));
  double fact2 = sqr(xp)*(sqr(x2)+sqr(xperp));
  double cos3  =   x3 /sqrt(sqr(x3)+sqr(xperp));
  double sin3  = xperp/sqrt(sqr(x3)+sqr(xperp));
  double fact3 = sqr(xp)*(sqr(x3)+sqr(xperp));
  if(_meopt) {
    double root = sqrt(sqr(l)-1.);
    output[0] = fact3*(sqr(cos3)-A*cos3*l+sqr(l))+
                fact2*(sqr(cos2)-A*cos2*l+sqr(l));
    output[1] =-fact3*(A*cos3*root*sin3-2.*l*root*sin3)+
                fact2*(A*cos2*root*sin2-2.*l*root*sin2);
    output[2] = fact3*(sqr(root)*sqr(sin3))+
                fact2*(sqr(root)*sqr(sin2));
    double lo(1+A*l+sqr(l));
    for(unsigned int ix=0;ix<output.size();++ix) output[ix] /=lo;
  }
  else {
    output[0] = fact3+fact2;
    output[1] = -2.*sin2*fact2+2.*sin3*fact3;
    output[2] = sqr(sin2)*fact2+sqr(sin3)*fact3;
  }
  double denom = norm ? sqr(xp)*(sqr(x3)+sqr(x2)+3.*sqr(xperp)) : 1.;
  for(unsigned int ix=0;ix<output.size();++ix) output[ix] /=denom;
  return output;
}

}
