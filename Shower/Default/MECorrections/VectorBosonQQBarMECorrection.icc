// -*- C++ -*-
//
// VectorBosonQQBarMECorrection.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the VectorBosonQQBarMECorrection class.
//

namespace Herwig {

inline VectorBosonQQBarMECorrection::VectorBosonQQBarMECorrection() {}

inline IBPtr VectorBosonQQBarMECorrection::clone() const {
  return new_ptr(*this);
}

inline IBPtr VectorBosonQQBarMECorrection::fullclone() const {
  return new_ptr(*this);
}

inline void VectorBosonQQBarMECorrection::setRho(double r) 
{ 
  d_rho = r;
  d_v = sqrt(1.-4.*d_rho);
}

inline void VectorBosonQQBarMECorrection::setKtildeSymm() { 
  d_kt1 = (1. + sqrt(1. - 4.*d_rho))/2.;
  setKtilde2();
}

inline void VectorBosonQQBarMECorrection::setKtilde2() { 
   double num = d_rho * d_kt1 + 0.25 * d_v *(1.+d_v)*(1.+d_v);
   double den = d_kt1 - d_rho;
   d_kt2 = num/den;
}

inline double VectorBosonQQBarMECorrection::getZfromX(double x1, double x2) {
  double uval = u(x2);
  double num = x1 - (2. - x2)*uval;
  double den = sqrt(x2*x2 - 4.*d_rho);
  return uval + num/den;
}

inline double VectorBosonQQBarMECorrection::getKfromX(double x1, double x2) {
   double zval = getZfromX(x1, x2);
   return (1.-x2)/(zval*(1.-zval));
}

inline double VectorBosonQQBarMECorrection::MEV(double x1, double x2) {
  // Vector part
  double num = (x1+2.*d_rho)*(x1+2.*d_rho) + (x2+2.*d_rho)*(x2+2.*d_rho) 
    - 8.*d_rho*(1.+2.*d_rho);
  double den = (1.+2.*d_rho)*(1.-x1)*(1.-x2);
  return (num/den - 2.*d_rho/((1.-x1)*(1.-x1)) 
	  - 2*d_rho/((1.-x2)*(1.-x2)))/d_v;
}

inline double VectorBosonQQBarMECorrection::MEA(double x1, double x2) {
  // Axial part
  double num = (x1+2.*d_rho)*(x1+2.*d_rho) + (x2+2.*d_rho)*(x2+2.*d_rho) 
    + 2.*d_rho*((5.-x1-x2)*(5.-x1-x2) - 19.0 + 4*d_rho);
  double den = d_v*d_v*(1.-x1)*(1.-x2);
  return (num/den - 2.*d_rho/((1.-x1)*(1.-x1)) 
	  - 2*d_rho/((1.-x2)*(1.-x2)))/d_v;
}

inline double VectorBosonQQBarMECorrection::u(double x2) {
  return 0.5*(1. + d_rho/(1.-x2+d_rho));
}

inline void VectorBosonQQBarMECorrection::
getXXbar(double kti, double z, double &x, double &xbar) {
  x = (1. + sqr(d_v)*(-1. + z) + sqr(kti*(-1. + z))*z*z*z 
       + z*sqrt(sqr(d_v) + kti*(-1. + z)*z*(2. + kti*(-1. + z)*z))
       - kti*(-1. + z)*z*(2. + z*(-2 
       + sqrt(sqr(d_v)+ kti*(-1. + z)*z*(2. + kti*(-1. + z)*z))
				  )))
    /(1. - kti*(-1. + z)*z 
      + sqrt(sqr(d_v) + kti*(-1. + z)*z*(2. + kti*(-1. + z)*z)));
  xbar = 1. + kti*(-1. + z)*z;
}

inline double VectorBosonQQBarMECorrection::qWeight(double x, double xbar) {
  double rval; 
  double xg = 2. - xbar - x;
  // always return one in the soft gluon region
  if(xg < EPS) return 1.0;
  // check it is in the phase space
  if((1.-x)*(1.-xbar)*(1.-xg) < d_rho*xg*xg) return 0.0;
  double k1 = getKfromX(x, xbar);
  double k2 = getKfromX(xbar, x);
  // Is it in the quark emission zone?
  if(k1 < d_kt1) {
    rval = MEV(x, xbar)/PS(x, xbar);
    // is it also in the anti-quark emission zone?
    if(k2 < d_kt2) rval *= 0.5;
    return rval;
  }
  return 1.0;
}

inline double VectorBosonQQBarMECorrection::qbarWeight(double x, double xbar) {
  double rval; 
  double xg = 2. - xbar - x;
  // always return one in the soft gluon region
  if(xg < EPS) return 1.0;
  // check it is in the phase space
  if((1.-x)*(1.-xbar)*(1.-xg) < d_rho*xg*xg) return 0.0;
  double k1 = getKfromX(xbar, x);
  double k2 = getKfromX(x, xbar);
  // Is it in the antiquark emission zone?
  if(k2 < d_kt2) {
    rval = MEV(x, xbar)/PS(xbar, x);
    // is it also in the quark emission zone?
    if(k1 < d_kt1) rval *= 0.5;
    return rval;
  }
  return 1.0;
}

inline double VectorBosonQQBarMECorrection::qWeightX(Energy qtilde, double z) {
  double x, xb;
  getXXbar(sqr(qtilde/d_Q), z, x, xb);
  return qWeight(x, xb); 
}

inline double VectorBosonQQBarMECorrection::qbarWeightX(Energy qtilde, double z) {
  double x, xb;
  getXXbar(sqr(qtilde/d_Q), z, x, xb);
  return qbarWeight(x, xb); 
}

inline double VectorBosonQQBarMECorrection::PS(double x, double xbar) {
  double u = 0.5*(1. + d_rho / (1.-xbar+d_rho));
  double z = u + (x - (2.-xbar)*u)/sqrt(xbar*xbar - 4.*d_rho);
  double brack = (1.+z*z)/(1.-z)- 2.*d_rho/(1-xbar);
  // interesting: the splitting function without the subtraction
  // term. Actually gives a much worse approximation in the collinear
  // limit.  double brack = (1.+z*z)/(1.-z);
  double den = (1.-xbar)*sqrt(xbar*xbar - 4.*d_rho);
  return brack/den;
}

}
