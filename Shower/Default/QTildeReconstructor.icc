// -*- C++ -*-
//
// QTildeReconstructor.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the QTildeReconstructor class.?
//

namespace Herwig {
using namespace ThePEG;

inline QTildeReconstructor::QTildeReconstructor() 
  : _reconopt(0)
{}

inline IBPtr QTildeReconstructor::clone() const {
  return new_ptr(*this);
}

inline IBPtr QTildeReconstructor::fullclone() const {
  return new_ptr(*this);
}

inline Energy QTildeReconstructor::momConsEq(const double & k, 
					  const Energy & root_s, 
					  const JetKinVect & jets) const {
  static Energy2 eps=1e-9*GeV2;
  Energy dum = Energy();
  Energy2 dum2;
  for(JetKinVect::const_iterator it = jets.begin(); it != jets.end(); ++it) {
    dum2 = (it->q).m2() + sqr(k)*(it->p).vect().mag2();
    if(dum2 < Energy2())
      {
	if(dum2 < -eps) throw KinematicsReconstructionVeto();
	else dum2 = Energy2();
      }
    dum += sqrt(dum2);
  }
  return( dum - root_s ); 
}

inline LorentzRotation QTildeReconstructor::
solveBoost(const double k, const Lorentz5Momentum & newq, 
	   const Lorentz5Momentum & oldp ) const {
  Energy q = newq.vect().mag(); 
  Energy2 qs = sqr(q); 
  Energy2 Q2 = newq.mass2(); 
  Energy kp = k*(oldp.vect().mag()); 
  Energy2 kps = sqr(kp);
  double betam = (q*newq.e() - kp*sqrt(kps + Q2))/(kps + qs + Q2); 
  Boost beta = -betam*(k/kp)*oldp.vect();
  // note that (k/kp)*oldp.vect() = oldp.vect()/oldp.vect().mag() but cheaper. 
  Vector3<Energy2> ax = newq.vect().cross( oldp.vect() ); 
  double delta = newq.vect().angle( oldp.vect() );
  LorentzRotation R;
  using Constants::pi;
  if ( ax.mag2()/GeV2/MeV2 > 1e-16 ) {
    R.rotate( delta, unitVector(ax) ).boost( beta );
  } 
  else if(abs(delta-pi)/pi < 0.001) {
    double phi=2.*pi*UseRandom::rnd();
    Axis axis(cos(phi),sin(phi),0.);
    axis.rotateUz(newq.vect().unit());
    R.rotate(delta,axis).boost( beta );
  }
  else {
    R.boost( beta );
  } 
  return R;
}

inline void QTildeReconstructor::boostChain(tPPtr p, const LorentzRotation &bv,
					    tPPtr & parent) const {
  if(!p->parents().empty()) boostChain(p->parents()[0], bv,parent);
  else parent=p;
  p->transform(bv);
  if(p->children().size()==2) {
    if(dynamic_ptr_cast<ShowerParticlePtr>(p->children()[1]))
      p->children()[1]->deepTransform(bv);
  }
}

inline double QTildeReconstructor::getBeta(const double E, const double q, 
					   const double Ep, const double qp) const {
  return (q*E-qp*Ep)/(sqr(qp)+sqr(E));
}

}
