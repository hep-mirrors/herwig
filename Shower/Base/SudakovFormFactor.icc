// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the SudakovFormFactor class.
//

namespace Herwig {

inline SudakovFormFactor::SudakovFormFactor() : _pdfmax(35.0), _z( 0.0 ), 
						_phi(0.0), _pT(0.),
						_a(0.3), _b(2.3), _c(0.3*GeV),
						_kinCutoffScale( .75*GeV )
{}

inline tSplittingFnPtr SudakovFormFactor::splittingFn() const { 
  return _splittingFn; 
}

inline tShowerAlphaPtr SudakovFormFactor::alpha() const { 
  return _alpha; 
}

inline ShowerIndex::InteractionType  SudakovFormFactor::interactionType() const {
  return _splittingFn->interactionType();
}

inline double SudakovFormFactor::z() const { 
  return _z; 
}

inline double SudakovFormFactor::phi() const {
  return _phi; 
}

inline Energy SudakovFormFactor::pT() const {
  return _pT;
}

inline void SudakovFormFactor::z(double in) {
  _z=in;
}
				        
inline void SudakovFormFactor::phi(double in) {
  _phi=in;
}

inline void SudakovFormFactor::pT(Energy in) {
  _pT=in;
}

inline pair<double,double> SudakovFormFactor::zLimits() const {
  return _zlimits;
}

inline void SudakovFormFactor::zLimits(pair<double,double> in) {
  _zlimits=in;
}

inline double SudakovFormFactor::guessz () const {
  double lower = _splittingFn->integOverP(_zlimits.first);
  return _splittingFn->invIntegOverP
    (lower + UseRandom::rnd()*(_splittingFn->integOverP(_zlimits.second) - lower));
}
 
inline bool SudakovFormFactor::SplittingFnVeto(const Energy2 t, 
					       const IdList &ids,
					       const bool mass) const {
  return UseRandom::rnd()>_splittingFn->ratioP(_z, t, ids,mass);
}

inline bool SudakovFormFactor::alphaSVeto(const Energy2 pt2) const {
  return UseRandom::rnd() > _alpha->ratio(pt2);
}

inline Energy2 SudakovFormFactor::guesst(Energy2 t1,unsigned int iopt,
					 double enhance,bool ident) const {
  double c = 1./((_splittingFn->integOverP(_zlimits.second) -
		  _splittingFn->integOverP(_zlimits.first))* 
		 _alpha->overestimateValue()/(2.*pi)*enhance);
  assert(iopt<=2);
  if(iopt==0)      return t1*pow(UseRandom::rnd(),c);
  else if(iopt==1) {
    if(ident) c*=2;
    return t1*pow(UseRandom::rnd(),c/_pdfmax);
  }
  else             return t1/pow(UseRandom::rnd(),c);
}

inline vector<IdList> SudakovFormFactor::particles() const {
  return _particles;
}

inline void SudakovFormFactor::splittingFn(tSplittingFnPtr in) {
  _splittingFn=in;
}

inline void SudakovFormFactor::alpha(tShowerAlphaPtr in) {
  _alpha=in;
}

inline void SudakovFormFactor::pdfMax(double in) {
  _pdfmax=in;
}

inline double SudakovFormFactor::pdfMax() const {
  return _pdfmax;
}

inline Energy SudakovFormFactor::kinematicCutOff(Energy scale,Energy mq) const {
  return max((scale -_a*mq)/_b,_c);
}

inline Energy SudakovFormFactor::kinScale() const {
  return _kinCutoffScale;
}
}
