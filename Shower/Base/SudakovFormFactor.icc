// -*- C++ -*-
//
// SudakovFormFactor.icc is a part of Herwig++ - A multi-purpose Monte Carlo event generator
// Copyright (C) 2002-2007 The Herwig Collaboration
//
// Herwig++ is licenced under version 2 of the GPL, see COPYING for details.
// Please respect the MCnet academic guidelines, see GUIDELINES for details.
//
//
// This is the implementation of the inlined member functions of
// the SudakovFormFactor class.
//

namespace Herwig {

inline SudakovFormFactor::SudakovFormFactor() : _pdfmax(35.0), _z( 0.0 ), 
						_phi(0.0), _pT(0.*MeV),
						_a(0.3), _b(2.3), _c(0.3*GeV),
						_kinCutoffScale( 2.3*GeV )
{}

inline tSplittingFnPtr SudakovFormFactor::splittingFn() const { 
  return _splittingFn; 
}

inline tShowerAlphaPtr SudakovFormFactor::alpha() const { 
  return _alpha; 
}

inline ShowerIndex::InteractionType  SudakovFormFactor::interactionType() const {
  return _splittingFn->interactionType();
}

inline double SudakovFormFactor::z() const { 
  return _z; 
}

inline double SudakovFormFactor::phi() const {
  return _phi; 
}

inline Energy SudakovFormFactor::pT() const {
  return _pT;
}

inline void SudakovFormFactor::z(double in) {
  _z=in;
}
				        
inline void SudakovFormFactor::phi(double in) {
  _phi=in;
}

inline void SudakovFormFactor::pT(Energy in) {
  _pT=in;
}

inline pair<double,double> SudakovFormFactor::zLimits() const {
  return _zlimits;
}

inline void SudakovFormFactor::zLimits(pair<double,double> in) {
  _zlimits=in;
}

inline double SudakovFormFactor::guessz (unsigned int iopt, const IdList &ids) const {
  unsigned int pdfopt = iopt!=1 ? 0 : _pdffactor;
  double lower = _splittingFn->integOverP(_zlimits.first,ids,pdfopt);
  return _splittingFn->invIntegOverP
    (lower + UseRandom::rnd()*(_splittingFn->integOverP(_zlimits.second,ids,pdfopt) - lower),ids,pdfopt);
}
 
inline bool SudakovFormFactor::SplittingFnVeto(const Energy2 t, 
					       const IdList &ids,
					       const bool mass) const {
  return UseRandom::rnd()>_splittingFn->ratioP(_z, t, ids,mass);
}

inline bool SudakovFormFactor::alphaSVeto(const Energy2 pt2) const {
  return UseRandom::rnd() > Math::powi(_alpha->ratio(pt2),
				       _splittingFn->interactionOrder());
}

inline Energy2 SudakovFormFactor::guesst(Energy2 t1,unsigned int iopt,
					 const IdList &ids,
					 double enhance,bool ident) const {
  unsigned int pdfopt = iopt!=1 ? 0 : _pdffactor;
  double c =
    1./((_splittingFn->integOverP(_zlimits.second,ids,pdfopt) -
	 _splittingFn->integOverP(_zlimits.first ,ids,pdfopt))* 
	_alpha->overestimateValue()/Constants::twopi*enhance);
  assert(iopt<=2);
  if(iopt==1) {
    c/=_pdfmax;
    if(ident) c*=0.5;
  }
  else if(iopt==2) c*=-1.;
  if(_splittingFn->interactionOrder()==1) {
    return t1*pow(UseRandom::rnd(),c);
  }
  else {
    assert(false && "Units are dubious here.");
    int nm(splittingFn()->interactionOrder()-1);
    c/=Math::powi(_alpha->overestimateValue()/Constants::twopi,nm);
    return t1 /       pow (1. - nm*c*log(UseRandom::rnd()) 
			   * Math::powi(t1*UnitRemoval::InvE2,nm)
			   ,1./double(nm));
  }
}

inline vector<IdList> SudakovFormFactor::particles() const {
  return _particles;
}

inline void SudakovFormFactor::splittingFn(tSplittingFnPtr in) {
  _splittingFn=in;
}

inline unsigned int SudakovFormFactor::PDFFactor() const {
  return _pdffactor;
}

inline void SudakovFormFactor::alpha(tShowerAlphaPtr in) {
  _alpha=in;
}

inline void SudakovFormFactor::pdfMax(double in) {
  _pdfmax=in;
}

inline double SudakovFormFactor::pdfMax() const {
  return _pdfmax;
}

inline Energy SudakovFormFactor::kinematicCutOff(Energy scale,Energy mq) const {
  return max((scale -_a*mq)/_b,_c);
}

inline Energy SudakovFormFactor::kinScale() const {
  return _kinCutoffScale;
}
}
