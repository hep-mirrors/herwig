// -*- C++ -*-
#ifndef HERWIG_SudakovFormFactor_H
#define HERWIG_SudakovFormFactor_H
//
// This is the declaration of the <!id>SudakovFormFactor<!!id> class.
//
// CLASSDOC SUBSECTION Description:
//
// This is the definition of the Sudakov form factor.
//
// CLASSDOC SUBSECTION See also:
//
// <a href="http:SplittingFunction.html">SplittingFunction.h</a>, <BR>
// <a href="http:ShowerAlpha.html">ShowerAlpha.h</a>. <BR>
// <a href="http:SplittingGenerator.html">SplittingGenerator.h</a>, <BR>

// 

#include "ShowerConfig.h"
#include "ThePEG/Interface/Interfaced.h"
#include "Herwig++/Utilities/GlobalParameters.h"
#include "SplittingFunction.h"
#include "ShowerAlpha.h"
#include "ShowerIndex.h"
#include "ShowerVariables.h"

namespace Herwig {

using namespace ThePEG;


class SudakovFormFactor: public Interfaced {

public:

  SudakovFormFactor();
  SudakovFormFactor(const SudakovFormFactor &);
  virtual ~SudakovFormFactor();
  // Standard ctors and dtor.

  virtual Energy generateNextBranching(const Energy startingScale,
				       const IdList &ids,
				       const bool reverseAngularOrder = false);
  // Pure virtual method, to be defined in concrete derived classes.
  // It returns the scale of the next branching; if there is no 
  // branching then it returns Energy().
  // The <!id>ch<!!id> argument is used only for Initial State branching,
  // to get access to the PDFs; the <!id>reverseOrdering<!!id> is used 
  // (when it is not equal to the default, false, value) only for 
  // Final State branching of a decaying on-shell particle. 

  virtual void setupLookupTables();
  // This virtual method is defined as empty, and it should be
  // overriden only for those derived Sudakov form factor classes
  // that use lookup tables for numerical evaluations, rather
  // than using the Monte Carlo rejection (veto) method.
  // This method is called once, during initialization, by
  // the <!class>SplittingGenerator<!!class>. 
  // General methods, usable for any type of Sudakov form factor
  // that override this method, should be provided in this
  // class in the protected session.

  inline tSplittingFnPtr splittingFn() const { return _splittingFn; }
  // It returns the pointer to the <!class>SplitFun<!!class> object.

  inline tShowerAlphaPtr alpha() const { return _alpha; }
  // It returns the pointer to the <!class>ShowerAlpha<!!class> object.
  inline ShowerIndex::InteractionType interactionType() {
	  return _splittingFn->interactionType();
  }
  inline double z() const { return _z; }
  inline double phi() const { return _phi; }
  inline Energy qtilde() const { return _q; }
  inline Energy resScale() const { 
    return _variables->cutoffQScale(_splittingFn->interactionType());
  }
  inline Energy kinScale() const { return _variables->kinScale(); }
  // These methods returns other shower kinematics variables, kept
  // internally to this class, that have being generated by a call
  // to <!id>generateNextBranching<!!id> together with the energy
  // scale (which is the returned value of such method).
  // Notice that these variables cannot be set directly from the extern 
  // (outside this class) but only via a call to the method
  // <!id>generateNextBranching<!!id>, whose first action is
  // to reset them, to clear the values they got in the previous
  // call to the same method. In other words, the lifetime
  // of the values of these kinematics variables is between
  // to successive call to <!id>generateNextBranching<!!id>.
  // Finally, notice that at the moment these variables are meaninful
  // only for a 1->2 splitting, but in future other variables
  // could be added as well for describing also a 1->3 splitting.
 
protected:

  Energy _q;
  double _z;
  double _phi;
  // Internal variables to keep shower kinematics information
  // generated by a call to <!id>generateNextBranching<!!id>.

  // toy model: returns q according to powerlike (q^p) distribution
  // with cutoff q0, qmin < q0 < qmax.  qmin is chosen such that the
  // probability for a first branching is 1-R.  z is chosen from
  // 1/(1-z) with z0 = m/q and z0 < z < 1-z0; or (if znorm==false)
  // flatter, as z^2+(1-z)^2 with z0 < z < 1.
  void get_qz (bool znorm, double p, double R, Energy q0, Energy qmax, 
	       Energy &q, double &z);

  // three utility methods, very similar to those of the test
  // programs.  They do what their name says and are adopted to the
  // abstract nature of SplitFun as well.
  double guessz (double z0, double z1);
  Energy2 guesst (Energy2 t0, Energy2 t1, double z0, double z1);
  void gettz (Energy2 tmax, Energy2 &t, double &z, const IdList &);

private:

  SudakovFormFactor & operator=(const SudakovFormFactor &);
  //  Private and non-existent assignment operator.

  SplittingFnPtr _splittingFn;
  ShowerAlphaPtr _alpha;
  ShowerVarsPtr _variables;

  // Now lets put all the interfaced stuff in
public:
  void persistentOutput(PersistentOStream &) const;
  void persistentInput(PersistentIStream &, int);

  static void Init();
protected:
  inline virtual IBPtr 
        clone() const { return new_ptr(*this); }
  inline virtual IBPtr fullclone() const { return clone(); }

  inline virtual void 
        doupdate() throw(UpdateException) { Interfaced::doupdate(); }
  inline virtual void doinit() throw(InitException) { Interfaced::doinit(); }
  inline virtual void dofinish() { Interfaced::dofinish(); }
  inline virtual void rebind(const TranslationMap & trans)
    throw(RebindException) { Interfaced::rebind(trans); }
  inline virtual IVector getReferences() {return Interfaced::getReferences();}
private:
  static ClassDescription<SudakovFormFactor> initSudakovFormFactor;
};

}

namespace ThePEG {

// The following template specialization informs ThePEG about the
// base class of ShowerHandler.
template <>
struct BaseClassTrait<Herwig::SudakovFormFactor,1> {
  typedef ThePEG::Interfaced NthBase;
};

// The following template specialization informs ThePEG about the
// name of this class and the shared object where it is defined.
template <>
struct ClassTraits<Herwig::SudakovFormFactor>
  : public ClassTraitsBase<Herwig::SudakovFormFactor>
{
  static string className() { return "/Herwig++/SudakovFormFactor"; }
  // Return the class name.
  static string library() { return "libHwShower.so"; }
  // Return the name of the shared library to be loaded to get
  // access to this class and every other class it uses
  // (except the base class).
};

}

#endif /* HERWIG_SudakovFormFactor_H */
