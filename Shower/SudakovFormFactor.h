// -*- C++ -*-
#ifndef HERWIG_SudakovFormFactor_H
#define HERWIG_SudakovFormFactor_H
//
// This is the declaration of the SudakovFormFactor class.

#include "ShowerConfig.h"
#include "ThePEG/Interface/Interfaced.h"
#include "Herwig++/Utilities/GlobalParameters.h"
#include "SplittingFunction.h"
#include "ShowerAlpha.h"
#include "ShowerIndex.h"
#include "ShowerVariables.h"

namespace Herwig {

using namespace ThePEG;

/** \ingroup Shower
 *
 *  This is the definition of the Sudakov form factor.
 *
 *  @see SplittingFunction
 *  @see ShowerAlpha
 *  @see SplittingGenerator
 */
class SudakovFormFactor: public Interfaced {

public:

  /**
   * Standard ctors and dtor.
   */
  SudakovFormFactor();
  SudakovFormFactor(const SudakovFormFactor &);
  virtual ~SudakovFormFactor();

  /**
   * It returns the scale of the next branching; if there is no 
   * branching then it returns Energy().
   * The ch argument is used only for Initial State branching,
   * to get access to the PDFs; the revOrd is used 
   * (when it is not equal to the default, false, value) only for 
   * Final State branching of a decaying on-shell particle. 
   */
  virtual Energy generateNextTimeBranching(const Energy startingScale,
				           const IdList &ids,
				           const bool revOrd = false);

  /**
   * Same as above but for a space like branching, needs PDF of object. 
   * If none is given then the veto algorithm isn't used for pdf.
   */
  virtual Energy generateNextSpaceBranching(const Energy startingScale,
		                            const IdList &ids,
					    tcPDPtr beam,
					    const tcPDFPtr &pdf,
					    double x,
					    const bool revOrd = false);

  /**
   * This virtual method is defined as empty, and it should be
   * overriden only for those derived Sudakov form factor classes
   * that use lookup tables for numerical evaluations, rather
   * than using the Monte Carlo rejection (veto) method.
   * This method is called once, during initialization, by
   * the SplittingGenerator. 
   * General methods, usable for any type of Sudakov form factor
   * that override this method, should be provided in this
   * class in the protected session.
   */
  virtual void setupLookupTables();

  /** 
   * It returns the pointer to the SplitFun object.
   */
  inline tSplittingFnPtr splittingFn() const { return _splittingFn; }

  /**
   * It returns the pointer to the ShowerAlpha object.
   */
  inline tShowerAlphaPtr alpha() const { return _alpha; }

  /**
   * These methods returns other shower kinematics variables, kept
   * internally to this class, that have being generated by a call
   * to generateNextBranching together with the energy
   * scale (which is the returned value of such method).
   * Notice that these variables cannot be set directly from the extern 
   * (outside this class) but only via a call to the method
   * generateNextBranching, whose first action is
   * to reset them, to clear the values they got in the previous
   * call to the same method. In other words, the lifetime
   * of the values of these kinematics variables is between
   * to successive call to generateNextBranching.
   * Finally, notice that at the moment these variables are meaninful
   * only for a 1->2 splitting, but in future other variables
   * could be added as well for describing also a 1->3 splitting.
   */
  inline ShowerIndex::InteractionType interactionType() {
	  return _splittingFn->interactionType();
  }
  inline double z() const { return _z; }
  inline double phi() const { return _phi; }
  inline Energy qtilde() const { return _q; }
  inline Energy resScale() const { 
    return _variables->cutoffQScale(_splittingFn->interactionType());
  }
  inline Energy kinScale() const { return _variables->kinScale(); }
 
protected:

  /**
   * Internal variables to keep shower kinematics information
   * generated by a call to generateNextBranching.
   */
  Energy _q;
  double _z;
  double _phi;

  /**
   * Toy model: returns q according to powerlike (q^p) distribution
   * with cutoff q0, qmin < q0 < qmax.  qmin is chosen such that the
   * probability for a first branching is 1-R.  z is chosen from
   * 1/(1-z) with z0 = m/q and z0 < z < 1-z0; or (if znorm==false)
   * flatter, as z^2+(1-z)^2 with z0 < z < 1.
   */
  void get_qz (bool znorm, double p, double R, Energy q0, Energy qmax, 
	       Energy &q, double &z);

  /**
   * Three utility methods, very similar to those of the test
   * programs.  They do what their name says and are adopted to the
   * abstract nature of SplitFun as well.
   */
  double guessz (double z0, double z1);
  Energy2 guesst (Energy2 t0, Energy2 t1, double z0, double z1);
  //void gettz (Energy2 tmax, Energy2 &t, double &z, const IdList &);
  void initialize(Energy2 &t0, Energy2 &tmin, Energy2 &tmax, 
		  Energy &kinCutoff, Energy &m);
  void guessTimeLike(double &z, double &z0, double &z1,
	     Energy2 &t, Energy2 &tmax, Energy2 &tmin, Energy2 &t0,
	     Energy &kinCutoff, bool glueEmits);
  void guessSpaceLike(double &z, double &z0, double &z1,
	     Energy2 &t, Energy2 &tmax, Energy2 &tmin, Energy2 &t0,
	     Energy &kinCutoff, bool glueEmits, const double &x);

  /**
   * The different veto algorithms.
   */
  bool PSVeto(const double &z, const double &z0, const double &z1,
	      const Energy2 &t, const Energy2 &tmin, const Energy2 &t0,
	      const Energy &kinCutoff, bool glueEmits);
  bool SplittingFnVeto(const double &z, const Energy2 &t, const IdList &ids);
  bool alphaSVeto(Energy2 pt2);
  bool tVeto(Energy2 &t, const Energy2 &tmin);
  bool PDFVeto(const double &z, const Energy2 &t, const double &x,
	       const tcPDFPtr &pdf, const tcPDPtr &parton, 
	       const tcPDPtr &beam);
private:

  /**
   * Private and non-existent assignment operator.
   */
  SudakovFormFactor & operator=(const SudakovFormFactor &);

  SplittingFnPtr _splittingFn;
  ShowerAlphaPtr _alpha;
  ShowerVarsPtr _variables;

public:

  void persistentOutput(PersistentOStream &) const;
  void persistentInput(PersistentIStream &, int);

  static void Init();

protected:

  inline virtual IBPtr 
        clone() const { return new_ptr(*this); }
  inline virtual IBPtr fullclone() const { return clone(); }

  inline virtual void 
        doupdate() throw(UpdateException) { Interfaced::doupdate(); }
  inline virtual void doinit() throw(InitException) { Interfaced::doinit(); }
  inline virtual void dofinish() { Interfaced::dofinish(); }
  inline virtual void rebind(const TranslationMap & trans)
    throw(RebindException) { Interfaced::rebind(trans); }
  inline virtual IVector getReferences() {return Interfaced::getReferences();}

private:

  static ClassDescription<SudakovFormFactor> initSudakovFormFactor;

};

}

namespace ThePEG {

/**
 * The following template specialization informs ThePEG about the
 * base class of ShowerHandler.
 */
template <>
struct BaseClassTrait<Herwig::SudakovFormFactor,1> {
  typedef ThePEG::Interfaced NthBase;
};

/**
 * The following template specialization informs ThePEG about the
 * name of this class and the shared object where it is defined.
 */
template <>
struct ClassTraits<Herwig::SudakovFormFactor>
  : public ClassTraitsBase<Herwig::SudakovFormFactor>
{

  /**
   * Return the class name.
   */
  static string className() { return "/Herwig++/SudakovFormFactor"; }

  /**
   * Return the name of the shared library to be loaded to get
   * access to this class and every other class it uses
   * (except the base class).
   */
  static string library() { return "HwShower.so"; }

};

}

#endif /* HERWIG_SudakovFormFactor_H */
