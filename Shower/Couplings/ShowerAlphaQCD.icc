// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the ShowerAlphaQCD class.
//

namespace Herwig {
using namespace ThePEG;
using ThePEG::Constants::pi;

inline ShowerAlphaQCD::ShowerAlphaQCD() 
  : ShowerAlpha(), 
    _qmin(0.630882*GeV), _asType(1), 
    _thresholds(4,0.0), _lambda(4,0.0),
    _nloop(3),_lambdaopt(false),_thresopt(false),
    _lambdain(0.208364*GeV),_alphain(0.118),_inopt(true),_tolerance(1e-10),
    _maxtry(100),_alphamin(0.)
{}

inline IBPtr ShowerAlphaQCD::clone() const {
  return new_ptr(*this);
}

inline IBPtr ShowerAlphaQCD::fullclone() const {
  return new_ptr(*this);
}

inline pair<short, Energy> ShowerAlphaQCD::getLamNfTwoLoop(Energy q) const {
  short nf = 3;
  // get lambda and nf according to the thresholds
  if(q < _thresholds[1]) nf = 3;
  else if(q < _thresholds[2]) nf=4;
  else if(q < _thresholds[3]) nf=5;
  else nf = 6;
  return pair<short,Energy>(nf, _lambda[nf-3]);
}

inline Energy 
ShowerAlphaQCD::computeLambda(Energy match,double alpha,unsigned int nflav) const
{
  Energy lamtest=200.0*MeV;
  double xtest;
  unsigned int ntry=0;
  do
    {
      ++ntry;
      xtest=log(sqr(match/lamtest));
      xtest+= (alpha-alphaS(match,lamtest,nflav))/derivativealphaS(match,lamtest,nflav);
      lamtest=match/exp(0.5*xtest);
    }
  while(abs(alpha-alphaS(match,lamtest,nflav))>_tolerance&&ntry<_maxtry);
  return lamtest;
}

inline double 
ShowerAlphaQCD::derivativealphaS(Energy q, Energy lam, short nf) const
{
  double lx(log(sqr(q/lam)));
  double b0 = 11. - 2./3.*nf;
  double b1 = 51. - 19./3.*nf;
  double b2 = 2857. - 5033./9.*nf + 325./27.*sqr(nf);
  // one loop
  if(_nloop==1)
    {return -4.*pi/(b0*sqr(lx));}
  // two loop
  else if(_nloop==2)
    {return -4.*pi/(b0*sqr(lx))*(1.-2.*b1/sqr(b0)/lx*(1.-2.*log(lx)));}
  // three loop
  else
    {return -4.*pi/(b0*sqr(lx))*(1.-2.*b1/sqr(b0)/lx*(1.-2.*log(lx))
				 +4.*sqr(b1)/(sqr(sqr(b0))*sqr(lx))*
				 (1.-2.*log(lx)+
				  3.*(sqr(log(lx) - 0.5)+b2*b0/(8.*sqr(b1))-1.25)));}
}

inline double ShowerAlphaQCD::alphaS(Energy q, Energy lam, short nf) const {
  double lx(log(sqr(q/lam)));
  double b0 = 11. - 2./3.*nf;
  double b1 = 51. - 19./3.*nf;
  double b2 = 2857. - 5033./9.*nf + 325./27.*sqr(nf);
  // one loop
  if(_nloop==1)
    {return 4.*pi/(b0*lx);}
  // two loop
  else if(_nloop==2) {
    return 4.*pi/(b0*lx)*(1.-2.*b1/sqr(b0)*log(lx)/lx);
  }
  // three loop
  else
    {return 4.*pi/(b0*lx)*(1.-2.*b1/sqr(b0)*log(lx)/lx + 
			   4.*sqr(b1)/(sqr(sqr(b0))*sqr(lx))*
			   (sqr(log(lx) - 0.5) + b2*b0/(8.*sqr(b1)) - 5./4.));}
}
  
inline Energy ShowerAlphaQCD::lambdaQCD(unsigned int nf) {
  if(nf<3) return _lambda[0];
  else if(nf>=3&&nf<=6) return _lambda[nf-3];
  else return _lambda[6];
}
}

