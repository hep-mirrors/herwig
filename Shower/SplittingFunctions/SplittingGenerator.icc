// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the SplittingGenerator class.
//

namespace Herwig {

inline SplittingGenerator::SplittingGenerator()
  : _qcdinteractionMode(1), _qedinteractionMode(0), _ewkinteractionMode(0),
    _isr_Mode(1), _isr_qcdMode(1), _isr_qedMode(1), _isr_ewkMode(1),
    _fsr_Mode(1), _fsr_qcdMode(1), _fsr_qedMode(1), _fsr_ewkMode(1)
  //    _output(3), _nout(3,0)
{}

inline IBPtr SplittingGenerator::clone() const {
  return new_ptr(*this);
}

inline IBPtr SplittingGenerator::fullclone() const {
  return new_ptr(*this);
}

inline void SplittingGenerator::rebind(const TranslationMap & trans)
  throw(RebindException) {
  BranchingList::iterator cit;
  for(cit=_fbranchings.begin();cit!=_fbranchings.end();++cit)
    {(cit->second).first=trans.translate((cit->second).first);}
  for(cit=_bbranchings.begin();cit!=_bbranchings.end();++cit)
    {(cit->second).first=trans.translate((cit->second).first);}
  Interfaced::rebind(trans);
}

inline IVector SplittingGenerator::getReferences() {
  IVector ret = Interfaced::getReferences();
  BranchingList::iterator cit;
  for(cit=_fbranchings.begin();cit!=_fbranchings.end();++cit)
    {ret.push_back((cit->second).first);}
  for(cit=_bbranchings.begin();cit!=_bbranchings.end();++cit)
    {ret.push_back((cit->second).first);}
  return ret;
}

  inline const BranchingList & SplittingGenerator::fbList () const {
    return _fbranchings;
  }

  inline const BranchingList & SplittingGenerator::bbList () const {
    return _bbranchings;
  }

inline bool SplittingGenerator::isISRadiationON() const {
  return _isr_Mode && (_isr_qcdMode||_isr_qedMode||_isr_ewkMode);
}  

inline bool SplittingGenerator::isFSRadiationON() const {
  return _fsr_Mode && (_fsr_qcdMode||_fsr_qedMode||_fsr_ewkMode);
}

inline bool SplittingGenerator::
isInteractionON(const ShowerIndex::InteractionType interaction) const {
  bool mode(false);
  switch ( interaction ) {
  case ShowerIndex::QCD : 
    mode = _qcdinteractionMode && ((_isr_qcdMode&&_isr_Mode)||
				  (_fsr_qcdMode&&_fsr_Mode)); break; 
  case ShowerIndex::QED :  
    mode = _qedinteractionMode && ((_isr_qedMode&&_isr_Mode)||
				  (_fsr_qedMode&&_fsr_Mode)); break; 
  case ShowerIndex::EWK : 
    mode = _ewkinteractionMode && ((_isr_ewkMode&&_isr_Mode)||
				  (_fsr_ewkMode&&_fsr_Mode)); break; 
  default: break;
  }
  return mode;
}

inline bool SplittingGenerator::
isISRadiationON(const ShowerIndex::InteractionType interaction) const {
  bool mode(false);
  if ( isInteractionON(interaction) && isISRadiationON() ) { 
    switch ( interaction ) {
    case ShowerIndex::QCD : mode = _isr_qcdMode; break; 
    case ShowerIndex::QED : mode = _isr_qedMode; break; 
    case ShowerIndex::EWK : mode = _isr_ewkMode; break; 
    default: break;
    }
  }
  return mode;
}

inline bool SplittingGenerator::
isFSRadiationON(const ShowerIndex::InteractionType interaction) const {
  bool mode = false;
  if ( isInteractionON(interaction) && isFSRadiationON() ) { 
    switch ( interaction ) {
    case ShowerIndex::QCD : mode = _fsr_qcdMode; break; 
    case ShowerIndex::QED : mode = _fsr_qedMode; break; 
    case ShowerIndex::EWK : mode = _fsr_ewkMode; break; 
    default: break;
    }
  }
  return mode;
}

inline string SplittingGenerator::addFinalSplitting(string arg) {
  return addSplitting(arg,true);
}
inline string SplittingGenerator::addInitialSplitting(string arg) {
  return addSplitting(arg,false);
}

}
