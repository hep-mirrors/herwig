// -*- C++ -*-
//
// This is the implementation of the inlined member functions of
// the EvtGen class.
//

namespace Herwig {

inline EvtGen::EvtGen() : _decayname("./DECAY.DEC"), _pdtname("./evt.pdl"), 
			  _maxtry(1000), _maxunwgt(10000), _checkconv(false) 
{}

inline IBPtr EvtGen::clone() const {
  return new_ptr(*this);
}

inline IBPtr EvtGen::fullclone() const {
  return new_ptr(*this);
}

inline EvtVector4R  EvtGen::EvtGenMomentum(const Lorentz5Momentum & mom) const {
  return EvtVector4R(mom.t()/GeV,mom.x()/GeV,mom.y()/GeV,mom.z()/GeV);
}

inline Lorentz5Momentum EvtGen::ThePEGMomentum(const EvtVector4R & mom,
					       double mass) const {
  return Lorentz5Momentum(mom.get(1)*GeV,mom.get(2)*GeV,
			  mom.get(3)*GeV,mom.get(0)*GeV,mass*GeV);
}

inline EvtSpinDensity EvtGen::EvtGenSpinDensity(const RhoDMatrix & rho) const {
  EvtSpinDensity rhoout;
  unsigned int ix,iy,ispin(rho.iSpin());
  rhoout.SetDim(ispin);
  for(ix=0;ix<ispin;++ix) {
    for(iy=0;iy<ispin;++iy)
      rhoout.Set(ix,iy,EvtGenComplex(rho(ix,iy)));
  }
  return rhoout;
}

inline EvtComplex EvtGen::EvtGenComplex(Complex c) const {
  return EvtComplex(c.real(),c.imag());
}

inline Complex EvtGen::ThePEGComplex(EvtComplex c) const {
  return Complex(real(c),imag(c));
}

inline EvtDiracSpinor EvtGen::EvtGenSpinor(const LorentzSpinor<SqrtEnergy> & sp) const {
  LorentzSpinor<SqrtEnergy> temp(sp.transformRep(Helicity::HaberDRep));
  InvSqrtEnergy norm(1./sqrt(GeV));
  EvtDiracSpinor output;
  output.set(EvtGenComplex(norm*temp.s1()),EvtGenComplex(norm*temp.s2()),
	     EvtGenComplex(norm*temp.s3()),EvtGenComplex(norm*temp.s4()));
  return output;
}

inline LorentzSpinor<SqrtEnergy> EvtGen::ThePEGSpinor(const EvtDiracSpinor & sp) const {
  SqrtEnergy norm(sqrt(GeV));
  LorentzSpinor<SqrtEnergy> output(norm*ThePEGComplex(sp.get_spinor(0)),
				   norm*ThePEGComplex(sp.get_spinor(1)),
				   norm*ThePEGComplex(sp.get_spinor(2)),
				   norm*ThePEGComplex(sp.get_spinor(3)),
				   Helicity::HaberDRep);
  output.changeRep(Helicity::defaultDRep);
  return output;
}

inline EvtVector4C 
EvtGen::EvtGenPolarization(const LorentzPolarizationVector & eps) const {
  return EvtVector4C(EvtGenComplex(eps.t()),EvtGenComplex(eps.x()),
		     EvtGenComplex(eps.y()),EvtGenComplex(eps.z()));
}

inline LorentzPolarizationVector 
EvtGen::ThePEGPolarization(const EvtVector4C & eps) const {
  return LorentzPolarizationVector(conj(ThePEGComplex(eps.get(1))),
				   conj(ThePEGComplex(eps.get(2))),
				   conj(ThePEGComplex(eps.get(3))),
				   conj(ThePEGComplex(eps.get(0))));
}

inline EvtRaritaSchwinger 
EvtGen::EvtGenRSSpinor(const LorentzRSSpinor<SqrtEnergy> & sp) const {
  LorentzRSSpinor<SqrtEnergy> temp(sp.transformRep(Helicity::HaberDRep));
  EvtRaritaSchwinger output;
  unsigned int ix,iy;
  InvSqrtEnergy norm(1./sqrt(GeV));
  // remember we have vec,spin and evtgen spin,vec
  for(ix=0;ix<4;++ix) {
    for(iy=0;iy<4;++iy) output.set(ix,iy,EvtGenComplex(norm*temp(iy,ix)));
  }
  return output;
}

inline LorentzRSSpinor<SqrtEnergy> 
EvtGen::ThePEGRSSpinor(const EvtRaritaSchwinger & sp) const {
  LorentzRSSpinor<SqrtEnergy> output(Helicity::HaberDRep);
  unsigned int ix,iy;
  SqrtEnergy norm(sqrt(GeV));
  // remember we have vec,spin and evtgen spin,vec
  for(ix=0;ix<4;++ix) {
    for(iy=0;iy<4;++iy) output(ix,iy)=norm*ThePEGComplex(sp.get(iy,ix));
  }
  output.changeRep(Helicity::defaultDRep);
  return output;
}

inline EvtTensor4C EvtGen::EvtGenTensor(const LorentzTensor<double> & ten) const {
  EvtTensor4C output;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix){
    for(iy=0;iy<4;++iy) output.set(ix,iy,EvtGenComplex(ten(ix,iy)));
  }
  return output;
}

inline LorentzTensor<double> EvtGen::ThePEGTensor(const EvtTensor4C & ten) const {
  LorentzTensor<double> output;
  unsigned int ix,iy;
  for(ix=0;ix<4;++ix) {
    for(iy=0;iy<4;++iy)output(ix,iy)=conj(ThePEGComplex(ten.get(ix,iy)));
  }
  return output;
}

// convert particle from EvtGen to ThePEG
inline PPtr EvtGen::ThePEGParticle(EvtParticle *part,tcPDPtr pd, bool spin) const {
  PPtr output(new_ptr(Particle(pd)));
  output->set5Momentum(ThePEGMomentum(part->getP4(),part->mass()));
  if(spin) ThePEGSpin(output,part);
  // make the daughters 
  ParticleVector daug(decayProducts(part,spin));
  for(unsigned int ix=0;ix<daug.size();++ix) output->addChild(daug[ix]);
  return output;
}

inline tSpinfoPtr EvtGen::getSpinInfo(const Particle & part) const {
  // return spin info if exists
  if(part.spinInfo()) {
    return dynamic_ptr_cast<tSpinfoPtr>(const_ptr_cast<tPPtr>(&part)->spinInfo());
  }
  // otherwise make it
  tPPtr ptemp(const_ptr_cast<tPPtr>(&part));
  PDT::Spin spin(part.dataPtr()->iSpin());
  SpinfoPtr pspin;
  if(spin==PDT::Spin0)          pspin=new_ptr(ScalarSpinInfo(part.momentum(),true));
  else if(spin==PDT::Spin1Half) pspin=new_ptr(FermionSpinInfo(part.momentum(),true));
  else if(spin==PDT::Spin1)     pspin=new_ptr(VectorSpinInfo(part.momentum(),true));
  else if(spin==PDT::Spin3Half) pspin=new_ptr(RSFermionSpinInfo(part.momentum(),true));
  else if(spin==PDT::Spin2)     pspin=new_ptr(TensorSpinInfo(part.momentum(),true));
  else throw Exception() << "Can't create spinInfo for decaying particle in "
			 << "EvtGen::checkSpinInfo for spin " << spin << "particle " 
			 << Exception::eventerror;
  ptemp->spinInfo(pspin);
  return pspin;
}
}
